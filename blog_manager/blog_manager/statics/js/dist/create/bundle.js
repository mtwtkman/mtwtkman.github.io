/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

;(function () {
	"use strict";

	function Vnode(tag, key, attrs0, children, text, dom) {
		return { tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false };
	}
	Vnode.normalize = function (node) {
		if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined);
		if (node != null && (typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined);
		return node;
	};
	Vnode.normalizeChildren = function normalizeChildren(children) {
		for (var i = 0; i < children.length; i++) {
			children[i] = Vnode.normalize(children[i]);
		}
		return children;
	};
	var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
	var selectorCache = {};
	var hasOwn = {}.hasOwnProperty;
	function compileSelector(selector) {
		var match,
		    tag = "div",
		    classes = [],
		    attrs = {};
		while (match = selectorParser.exec(selector)) {
			var type = match[1],
			    value = match[2];
			if (type === "" && value !== "") tag = value;else if (type === "#") attrs.id = value;else if (type === ".") classes.push(value);else if (match[3][0] === "[") {
				var attrValue = match[6];
				if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
				if (match[4] === "class") classes.push(attrValue);else attrs[match[4]] = attrValue || true;
			}
		}
		if (classes.length > 0) attrs.className = classes.join(" ");
		return selectorCache[selector] = { tag: tag, attrs: attrs };
	}
	function execSelector(state, attrs, children) {
		var hasAttrs = false,
		    childList,
		    text;
		var className = attrs.className || attrs.class;
		for (var key in state.attrs) {
			if (hasOwn.call(state.attrs, key)) {
				attrs[key] = state.attrs[key];
			}
		}
		if (className !== undefined) {
			if (attrs.class !== undefined) {
				attrs.class = undefined;
				attrs.className = className;
			}
			if (state.attrs.className != null) {
				attrs.className = state.attrs.className + " " + className;
			}
		}
		for (var key in attrs) {
			if (hasOwn.call(attrs, key) && key !== "key") {
				hasAttrs = true;
				break;
			}
		}
		if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
			text = children[0].children;
		} else {
			childList = children;
		}
		return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text);
	}
	function hyperscript(selector) {
		// Because sloppy mode sucks
		var attrs = arguments[1],
		    start = 2,
		    children;
		if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
			throw Error("The selector must be either a string or a component.");
		}
		if (typeof selector === "string") {
			var cached = selectorCache[selector] || compileSelector(selector);
		}
		if (attrs == null) {
			attrs = {};
		} else if ((typeof attrs === "undefined" ? "undefined" : _typeof(attrs)) !== "object" || attrs.tag != null || Array.isArray(attrs)) {
			attrs = {};
			start = 1;
		}
		if (arguments.length === start + 1) {
			children = arguments[start];
			if (!Array.isArray(children)) children = [children];
		} else {
			children = [];
			while (start < arguments.length) {
				children.push(arguments[start++]);
			}
		}
		var normalized = Vnode.normalizeChildren(children);
		if (typeof selector === "string") {
			return execSelector(cached, attrs, normalized);
		} else {
			return Vnode(selector, attrs.key, attrs, normalized);
		}
	}
	hyperscript.trust = function (html) {
		if (html == null) html = "";
		return Vnode("<", undefined, undefined, html, undefined, undefined);
	};
	hyperscript.fragment = function (attrs1, children) {
		return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined);
	};
	var m = hyperscript;
	/** @constructor */
	var PromisePolyfill = function PromisePolyfill(executor) {
		if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`");
		if (typeof executor !== "function") throw new TypeError("executor must be a function");
		var self = this,
		    resolvers = [],
		    rejectors = [],
		    resolveCurrent = handler(resolvers, true),
		    rejectCurrent = handler(rejectors, false);
		var instance = self._instance = { resolvers: resolvers, rejectors: rejectors };
		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function handler(list, shouldAbsorb) {
			return function execute(value) {
				var then;
				try {
					if (shouldAbsorb && value != null && ((typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
						if (value === self) throw new TypeError("Promise can't be resolved w/ itself");
						executeOnce(then.bind(value));
					} else {
						callAsync(function () {
							if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value);
							for (var i = 0; i < list.length; i++) {
								list[i](value);
							}resolvers.length = 0, rejectors.length = 0;
							instance.state = shouldAbsorb;
							instance.retry = function () {
								execute(value);
							};
						});
					}
				} catch (e) {
					rejectCurrent(e);
				}
			};
		}
		function executeOnce(then) {
			var runs = 0;
			function run(fn) {
				return function (value) {
					if (runs++ > 0) return;
					fn(value);
				};
			}
			var onerror = run(rejectCurrent);
			try {
				then(run(resolveCurrent), onerror);
			} catch (e) {
				onerror(e);
			}
		}
		executeOnce(executor);
	};
	PromisePolyfill.prototype.then = function (onFulfilled, onRejection) {
		var self = this,
		    instance = self._instance;
		function handle(callback, list, next, state) {
			list.push(function (value) {
				if (typeof callback !== "function") next(value);else try {
					resolveNext(callback(value));
				} catch (e) {
					if (rejectNext) rejectNext(e);
				}
			});
			if (typeof instance.retry === "function" && state === instance.state) instance.retry();
		}
		var resolveNext, rejectNext;
		var promise = new PromisePolyfill(function (resolve, reject) {
			resolveNext = resolve, rejectNext = reject;
		});
		handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
		return promise;
	};
	PromisePolyfill.prototype.catch = function (onRejection) {
		return this.then(null, onRejection);
	};
	PromisePolyfill.resolve = function (value) {
		if (value instanceof PromisePolyfill) return value;
		return new PromisePolyfill(function (resolve) {
			resolve(value);
		});
	};
	PromisePolyfill.reject = function (value) {
		return new PromisePolyfill(function (resolve, reject) {
			reject(value);
		});
	};
	PromisePolyfill.all = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			var total = list.length,
			    count = 0,
			    values = [];
			if (list.length === 0) resolve([]);else for (var i = 0; i < list.length; i++) {
				(function (i) {
					function consume(value) {
						count++;
						values[i] = value;
						if (count === total) resolve(values);
					}
					if (list[i] != null && (_typeof(list[i]) === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
						list[i].then(consume, reject);
					} else consume(list[i]);
				})(i);
			}
		});
	};
	PromisePolyfill.race = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			for (var i = 0; i < list.length; i++) {
				list[i].then(resolve, reject);
			}
		});
	};
	if (typeof window !== "undefined") {
		if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill;
		var PromisePolyfill = window.Promise;
	} else if (typeof global !== "undefined") {
		if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill;
		var PromisePolyfill = global.Promise;
	} else {}
	var buildQueryString = function buildQueryString(object) {
		if (Object.prototype.toString.call(object) !== "[object Object]") return "";
		var args = [];
		for (var key0 in object) {
			destructure(key0, object[key0]);
		}
		return args.join("&");
		function destructure(key0, value) {
			if (Array.isArray(value)) {
				for (var i = 0; i < value.length; i++) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else if (Object.prototype.toString.call(value) === "[object Object]") {
				for (var i in value) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
		}
	};
	var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i");
	var _8 = function _8($window, Promise) {
		var callbackCount = 0;
		var oncompletion;
		function setCompletionCallback(callback) {
			oncompletion = callback;
		}
		function finalizer() {
			var count = 0;
			function complete() {
				if (--count === 0 && typeof oncompletion === "function") oncompletion();
			}
			return function finalize(promise0) {
				var then0 = promise0.then;
				promise0.then = function () {
					count++;
					var next = then0.apply(promise0, arguments);
					next.then(complete, function (e) {
						complete();
						if (count === 0) throw e;
					});
					return finalize(next);
				};
				return promise0;
			};
		}
		function normalize(args, extra) {
			if (typeof args === "string") {
				var url = args;
				args = extra || {};
				if (args.url == null) args.url = url;
			}
			return args;
		}
		function request(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				if (args.method == null) args.method = "GET";
				args.method = args.method.toUpperCase();
				var useBody = args.method === "GET" || args.method === "TRACE" ? false : typeof args.useBody === "boolean" ? args.useBody : true;
				if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function (value) {
					return value;
				} : JSON.stringify;
				if (typeof args.deserialize !== "function") args.deserialize = deserialize;
				if (typeof args.extract !== "function") args.extract = extract;
				args.url = interpolate(args.url, args.data);
				if (useBody) args.data = args.serialize(args.data);else args.url = assemble(args.url, args.data);
				var xhr = new $window.XMLHttpRequest(),
				    aborted = false,
				    _abort = xhr.abort;
				xhr.abort = function abort() {
					aborted = true;
					_abort.call(xhr);
				};
				xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);
				if (args.serialize === JSON.stringify && useBody) {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
				}
				if (args.deserialize === deserialize) {
					xhr.setRequestHeader("Accept", "application/json, text/*");
				}
				if (args.withCredentials) xhr.withCredentials = args.withCredentials;
				for (var key in args.headers) {
					if ({}.hasOwnProperty.call(args.headers, key)) {
						xhr.setRequestHeader(key, args.headers[key]);
					}
				}if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr;
				xhr.onreadystatechange = function () {
					// Don't throw errors on xhr.abort().
					if (aborted) return;
					if (xhr.readyState === 4) {
						try {
							var response = args.extract !== extract ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args));
							if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
								resolve(cast(args.type, response));
							} else {
								var error = new Error(xhr.responseText);
								for (var key in response) {
									error[key] = response[key];
								}reject(error);
							}
						} catch (e) {
							reject(e);
						}
					}
				};
				if (useBody && args.data != null) xhr.send(args.data);else xhr.send();
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function jsonp(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
				var script = $window.document.createElement("script");
				$window[callbackName] = function (data) {
					script.parentNode.removeChild(script);
					resolve(cast(args.type, data));
					delete $window[callbackName];
				};
				script.onerror = function () {
					script.parentNode.removeChild(script);
					reject(new Error("JSONP request failed"));
					delete $window[callbackName];
				};
				if (args.data == null) args.data = {};
				args.url = interpolate(args.url, args.data);
				args.data[args.callbackKey || "callback"] = callbackName;
				script.src = assemble(args.url, args.data);
				$window.document.documentElement.appendChild(script);
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function interpolate(url, data) {
			if (data == null) return url;
			var tokens = url.match(/:[^\/]+/gi) || [];
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1);
				if (data[key] != null) {
					url = url.replace(tokens[i], data[key]);
				}
			}
			return url;
		}
		function assemble(url, data) {
			var querystring = buildQueryString(data);
			if (querystring !== "") {
				var prefix = url.indexOf("?") < 0 ? "?" : "&";
				url += prefix + querystring;
			}
			return url;
		}
		function deserialize(data) {
			try {
				return data !== "" ? JSON.parse(data) : null;
			} catch (e) {
				throw new Error(data);
			}
		}
		function extract(xhr) {
			return xhr.responseText;
		}
		function cast(type0, data) {
			if (typeof type0 === "function") {
				if (Array.isArray(data)) {
					for (var i = 0; i < data.length; i++) {
						data[i] = new type0(data[i]);
					}
				} else return new type0(data);
			}
			return data;
		}
		return { request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback };
	};
	var requestService = _8(window, PromisePolyfill);
	var coreRenderer = function coreRenderer($window) {
		var $doc = $window.document;
		var $emptyFragment = $doc.createDocumentFragment();
		var onevent;
		function setEventCallback(callback) {
			return onevent = callback;
		}
		//create
		function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					createNode(parent, vnode, hooks, ns, nextSibling);
				}
			}
		}
		function createNode(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			if (typeof tag === "string") {
				vnode.state = {};
				if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
				switch (tag) {
					case "#":
						return createText(parent, vnode, nextSibling);
					case "<":
						return createHTML(parent, vnode, nextSibling);
					case "[":
						return createFragment(parent, vnode, hooks, ns, nextSibling);
					default:
						return createElement(parent, vnode, hooks, ns, nextSibling);
				}
			} else return createComponent(parent, vnode, hooks, ns, nextSibling);
		}
		function createText(parent, vnode, nextSibling) {
			vnode.dom = $doc.createTextNode(vnode.children);
			insertNode(parent, vnode.dom, nextSibling);
			return vnode.dom;
		}
		function createHTML(parent, vnode, nextSibling) {
			var match1 = vnode.children.match(/^\s*?<(\w+)/im) || [];
			var parent1 = { caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup" }[match1[1]] || "div";
			var temp = $doc.createElement(parent1);
			temp.innerHTML = vnode.children;
			vnode.dom = temp.firstChild;
			vnode.domSize = temp.childNodes.length;
			var fragment = $doc.createDocumentFragment();
			var child;
			while (child = temp.firstChild) {
				fragment.appendChild(child);
			}
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createFragment(parent, vnode, hooks, ns, nextSibling) {
			var fragment = $doc.createDocumentFragment();
			if (vnode.children != null) {
				var children = vnode.children;
				createNodes(fragment, children, 0, children.length, hooks, null, ns);
			}
			vnode.dom = fragment.firstChild;
			vnode.domSize = fragment.childNodes.length;
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createElement(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			var attrs2 = vnode.attrs;
			var is = attrs2 && attrs2.is;
			var element = ns ? is ? $doc.createElementNS(ns, tag, { is: is }) : $doc.createElementNS(ns, tag) : is ? $doc.createElement(tag, { is: is }) : $doc.createElement(tag);
			vnode.dom = element;
			if (attrs2 != null) {
				setAttrs(vnode, attrs2, ns);
			}
			insertNode(parent, element, nextSibling);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else {
				if (vnode.text != null) {
					if (vnode.text !== "") element.textContent = vnode.text;else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				}
				if (vnode.children != null) {
					var children = vnode.children;
					createNodes(element, children, 0, children.length, hooks, null, ns);
					setLateAttrs(vnode);
				}
			}
			return element;
		}
		function initComponent(vnode, hooks) {
			var sentinel;
			if (typeof vnode.tag.view === "function") {
				vnode.state = Object.create(vnode.tag);
				sentinel = vnode.state.view;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
			} else {
				vnode.state = void 0;
				sentinel = vnode.tag;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
				vnode.state = vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function" ? new vnode.tag(vnode) : vnode.tag(vnode);
			}
			vnode._state = vnode.state;
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
			initLifecycle(vnode._state, vnode, hooks);
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
			sentinel.$$reentrantLock$$ = null;
		}
		function createComponent(parent, vnode, hooks, ns, nextSibling) {
			initComponent(vnode, hooks);
			if (vnode.instance != null) {
				var element = createNode(parent, vnode.instance, hooks, ns, nextSibling);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
				insertNode(parent, element, nextSibling);
				return element;
			} else {
				vnode.domSize = 0;
				return $emptyFragment;
			}
		}
		//update
		function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
			if (old === vnodes || old == null && vnodes == null) return;else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined);else if (vnodes == null) removeNodes(old, 0, old.length, vnodes);else {
				if (old.length === vnodes.length) {
					var isUnkeyed = false;
					for (var i = 0; i < vnodes.length; i++) {
						if (vnodes[i] != null && old[i] != null) {
							isUnkeyed = vnodes[i].key == null && old[i].key == null;
							break;
						}
					}
					if (isUnkeyed) {
						for (var i = 0; i < old.length; i++) {
							if (old[i] === vnodes[i]) continue;else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling));else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes);else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns);
						}
						return;
					}
				}
				recycling = recycling || isRecyclable(old, vnodes);
				if (recycling) {
					var pool = old.pool;
					old = old.concat(old.pool);
				}
				var oldStart = 0,
				    start = 0,
				    oldEnd = old.length - 1,
				    end = vnodes.length - 1,
				    map;
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldStart],
					    v = vnodes[start];
					if (o === v && !recycling) oldStart++, start++;else if (o == null) oldStart++;else if (v == null) start++;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldStart >= old.length - pool.length || pool == null && recycling;
						oldStart++, start++;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
					} else {
						var o = old[oldEnd];
						if (o === v && !recycling) oldEnd--, start++;else if (o == null) oldEnd--;else if (v == null) start++;else if (o.key === v.key) {
							var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
							updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
							if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling));
							oldEnd--, start++;
						} else break;
					}
				}
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldEnd],
					    v = vnodes[end];
					if (o === v && !recycling) oldEnd--, end--;else if (o == null) oldEnd--;else if (v == null) end--;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
						if (o.dom != null) nextSibling = o.dom;
						oldEnd--, end--;
					} else {
						if (!map) map = getKeyMap(old, oldEnd);
						if (v != null) {
							var oldIndex = map[v.key];
							if (oldIndex != null) {
								var movable = old[oldIndex];
								var shouldRecycle = pool != null && oldIndex >= old.length - pool.length || pool == null && recycling;
								updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns);
								insertNode(parent, toFragment(movable), nextSibling);
								old[oldIndex].skip = true;
								if (movable.dom != null) nextSibling = movable.dom;
							} else {
								var dom = createNode(parent, v, hooks, undefined, nextSibling);
								nextSibling = dom;
							}
						}
						end--;
					}
					if (end < start) break;
				}
				createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
				removeNodes(old, oldStart, oldEnd + 1, vnodes);
			}
		}
		function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			var oldTag = old.tag,
			    tag = vnode.tag;
			if (oldTag === tag) {
				vnode.state = old.state;
				vnode._state = old._state;
				vnode.events = old.events;
				if (!recycling && shouldNotUpdate(vnode, old)) return;
				if (typeof oldTag === "string") {
					if (vnode.attrs != null) {
						if (recycling) {
							vnode.state = {};
							initLifecycle(vnode.attrs, vnode, hooks);
						} else updateLifecycle(vnode.attrs, vnode, hooks);
					}
					switch (oldTag) {
						case "#":
							updateText(old, vnode);break;
						case "<":
							updateHTML(parent, old, vnode, nextSibling);break;
						case "[":
							updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns);break;
						default:
							updateElement(old, vnode, recycling, hooks, ns);
					}
				} else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns);
			} else {
				removeNode(old, null);
				createNode(parent, vnode, hooks, ns, nextSibling);
			}
		}
		function updateText(old, vnode) {
			if (old.children.toString() !== vnode.children.toString()) {
				old.dom.nodeValue = vnode.children;
			}
			vnode.dom = old.dom;
		}
		function updateHTML(parent, old, vnode, nextSibling) {
			if (old.children !== vnode.children) {
				toFragment(old);
				createHTML(parent, vnode, nextSibling);
			} else vnode.dom = old.dom, vnode.domSize = old.domSize;
		}
		function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
			updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns);
			var domSize = 0,
			    children = vnode.children;
			vnode.dom = null;
			if (children != null) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i];
					if (child != null && child.dom != null) {
						if (vnode.dom == null) vnode.dom = child.dom;
						domSize += child.domSize || 1;
					}
				}
				if (domSize !== 1) vnode.domSize = domSize;
			}
		}
		function updateElement(old, vnode, recycling, hooks, ns) {
			var element = vnode.dom = old.dom;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			if (vnode.tag === "textarea") {
				if (vnode.attrs == null) vnode.attrs = {};
				if (vnode.text != null) {
					vnode.attrs.value = vnode.text; //FIXME handle0 multiple children
					vnode.text = undefined;
				}
			}
			updateAttrs(vnode, old.attrs, vnode.attrs, ns);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else if (old.text != null && vnode.text != null && vnode.text !== "") {
				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text;
			} else {
				if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)];
				if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns);
			}
		}
		function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			if (recycling) {
				initComponent(vnode, hooks);
			} else {
				vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
				if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
				if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);
				updateLifecycle(vnode._state, vnode, hooks);
			}
			if (vnode.instance != null) {
				if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.instance.domSize;
			} else if (old.instance != null) {
				removeNode(old.instance, null);
				vnode.dom = undefined;
				vnode.domSize = 0;
			} else {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
			}
		}
		function isRecyclable(old, vnodes) {
			if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
				var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0;
				var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0;
				var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0;
				if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
					return true;
				}
			}
			return false;
		}
		function getKeyMap(vnodes, end) {
			var map = {},
			    i = 0;
			for (var i = 0; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					var key2 = vnode.key;
					if (key2 != null) map[key2] = i;
				}
			}
			return map;
		}
		function toFragment(vnode) {
			var count0 = vnode.domSize;
			if (count0 != null || vnode.dom == null) {
				var fragment = $doc.createDocumentFragment();
				if (count0 > 0) {
					var dom = vnode.dom;
					while (--count0) {
						fragment.appendChild(dom.nextSibling);
					}fragment.insertBefore(dom, fragment.firstChild);
				}
				return fragment;
			} else return vnode.dom;
		}
		function getNextSibling(vnodes, i, nextSibling) {
			for (; i < vnodes.length; i++) {
				if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom;
			}
			return nextSibling;
		}
		function insertNode(parent, dom, nextSibling) {
			if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling);else parent.appendChild(dom);
		}
		function setContentEditable(vnode) {
			var children = vnode.children;
			if (children != null && children.length === 1 && children[0].tag === "<") {
				var content = children[0].children;
				if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;
			} else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted");
		}
		//remove
		function removeNodes(vnodes, start, end, context) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					if (vnode.skip) vnode.skip = false;else removeNode(vnode, context);
				}
			}
		}
		function removeNode(vnode, context) {
			var expected = 1,
			    called = 0;
			if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
				var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
				var result = vnode._state.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			continuation();
			function continuation() {
				if (++called === expected) {
					onremove(vnode);
					if (vnode.dom) {
						var count0 = vnode.domSize || 1;
						if (count0 > 1) {
							var dom = vnode.dom;
							while (--count0) {
								removeNodeFromDOM(dom.nextSibling);
							}
						}
						removeNodeFromDOM(vnode.dom);
						if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") {
							//TODO test custom elements
							if (!context.pool) context.pool = [vnode];else context.pool.push(vnode);
						}
					}
				}
			}
		}
		function removeNodeFromDOM(node) {
			var parent = node.parentNode;
			if (parent != null) parent.removeChild(node);
		}
		function onremove(vnode) {
			if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode);
			if (vnode.instance != null) onremove(vnode.instance);else {
				var children = vnode.children;
				if (Array.isArray(children)) {
					for (var i = 0; i < children.length; i++) {
						var child = children[i];
						if (child != null) onremove(child);
					}
				}
			}
		}
		//attrs2
		function setAttrs(vnode, attrs2, ns) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, null, attrs2[key2], ns);
			}
		}
		function setAttr(vnode, key2, old, value, ns) {
			var element = vnode.dom;
			if (key2 === "key" || key2 === "is" || old === value && !isFormAttribute(vnode, key2) && (typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return;
			var nsLastIndex = key2.indexOf(":");
			if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
				element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value);
			} else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value);else if (key2 === "style") updateStyle(element, old, value);else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if (vnode.tag === "input" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && key2 === "value" && vnode.dom.value == value) return;
				// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
				if (vnode.tag === "input" && key2 === "type") {
					element.setAttribute(key2, value);
					return;
				}
				element[key2] = value;
			} else {
				if (typeof value === "boolean") {
					if (value) element.setAttribute(key2, "");else element.removeAttribute(key2);
				} else element.setAttribute(key2 === "className" ? "class" : key2, value);
			}
		}
		function setLateAttrs(vnode) {
			var attrs2 = vnode.attrs;
			if (vnode.tag === "select" && attrs2 != null) {
				if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined);
				if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined);
			}
		}
		function updateAttrs(vnode, old, attrs2, ns) {
			if (attrs2 != null) {
				for (var key2 in attrs2) {
					setAttr(vnode, key2, old && old[key2], attrs2[key2], ns);
				}
			}
			if (old != null) {
				for (var key2 in old) {
					if (attrs2 == null || !(key2 in attrs2)) {
						if (key2 === "className") key2 = "class";
						if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined);else if (key2 !== "key") vnode.dom.removeAttribute(key2);
					}
				}
			}
		}
		function isFormAttribute(vnode, attr) {
			return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement;
		}
		function isLifecycleMethod(attr) {
			return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate";
		}
		function isAttribute(attr) {
			return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"; // || attr === "type"
		}
		function isCustomElement(vnode) {
			return vnode.attrs.is || vnode.tag.indexOf("-") > -1;
		}
		function hasIntegrationMethods(source) {
			return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove);
		}
		//style
		function updateStyle(element, old, style) {
			if (old === style) element.style.cssText = "", old = null;
			if (style == null) element.style.cssText = "";else if (typeof style === "string") element.style.cssText = style;else {
				if (typeof old === "string") element.style.cssText = "";
				for (var key2 in style) {
					element.style[key2] = style[key2];
				}
				if (old != null && typeof old !== "string") {
					for (var key2 in old) {
						if (!(key2 in style)) element.style[key2] = "";
					}
				}
			}
		}
		//event
		function updateEvent(vnode, key2, value) {
			var element = vnode.dom;
			var callback = typeof onevent !== "function" ? value : function (e) {
				var result = value.call(element, e);
				onevent.call(element, e);
				return result;
			};
			if (key2 in element) element[key2] = typeof value === "function" ? callback : null;else {
				var eventName = key2.slice(2);
				if (vnode.events === undefined) vnode.events = {};
				if (vnode.events[key2] === callback) return;
				if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false);
				if (typeof value === "function") {
					vnode.events[key2] = callback;
					element.addEventListener(eventName, vnode.events[key2], false);
				}
			}
		}
		//lifecycle
		function initLifecycle(source, vnode, hooks) {
			if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode);
			if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode));
		}
		function updateLifecycle(source, vnode, hooks) {
			if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode));
		}
		function shouldNotUpdate(vnode, old) {
			var forceVnodeUpdate, forceComponentUpdate;
			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old);
			if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
				vnode.instance = old.instance;
				return true;
			}
			return false;
		}
		function render(dom, vnodes) {
			if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");
			var hooks = [];
			var active = $doc.activeElement;
			// First time0 rendering into a node clears it out
			if (dom.vnodes == null) dom.textContent = "";
			if (!Array.isArray(vnodes)) vnodes = [vnodes];
			updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined);
			dom.vnodes = vnodes;
			for (var i = 0; i < hooks.length; i++) {
				hooks[i]();
			}if ($doc.activeElement !== active) active.focus();
		}
		return { render: render, setEventCallback: setEventCallback };
	};
	function throttle(callback) {
		//60fps translates to 16.6ms, round it down since setTimeout requires int
		var time = 16;
		var last = 0,
		    pending = null;
		var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout;
		return function () {
			var now = Date.now();
			if (last === 0 || now - last >= time) {
				last = now;
				callback();
			} else if (pending === null) {
				pending = timeout(function () {
					pending = null;
					callback();
					last = Date.now();
				}, time - (now - last));
			}
		};
	}
	var _11 = function _11($window) {
		var renderService = coreRenderer($window);
		renderService.setEventCallback(function (e) {
			if (e.redraw !== false) redraw();
		});
		var callbacks = [];
		function subscribe(key1, callback) {
			unsubscribe(key1);
			callbacks.push(key1, throttle(callback));
		}
		function unsubscribe(key1) {
			var index = callbacks.indexOf(key1);
			if (index > -1) callbacks.splice(index, 2);
		}
		function redraw() {
			for (var i = 1; i < callbacks.length; i += 2) {
				callbacks[i]();
			}
		}
		return { subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render };
	};
	var redrawService = _11(window);
	requestService.setCompletionCallback(redrawService.redraw);
	var _16 = function _16(redrawService0) {
		return function (root, component) {
			if (component === null) {
				redrawService0.render(root, []);
				redrawService0.unsubscribe(root);
				return;
			}

			if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode");

			var run0 = function run0() {
				redrawService0.render(root, Vnode(component));
			};
			redrawService0.subscribe(root, run0);
			redrawService0.redraw();
		};
	};
	m.mount = _16(redrawService);
	var Promise = PromisePolyfill;
	var parseQueryString = function parseQueryString(string) {
		if (string === "" || string == null) return {};
		if (string.charAt(0) === "?") string = string.slice(1);
		var entries = string.split("&"),
		    data0 = {},
		    counters = {};
		for (var i = 0; i < entries.length; i++) {
			var entry = entries[i].split("=");
			var key5 = decodeURIComponent(entry[0]);
			var value = entry.length === 2 ? decodeURIComponent(entry[1]) : "";
			if (value === "true") value = true;else if (value === "false") value = false;
			var levels = key5.split(/\]\[?|\[/);
			var cursor = data0;
			if (key5.indexOf("[") > -1) levels.pop();
			for (var j = 0; j < levels.length; j++) {
				var level = levels[j],
				    nextLevel = levels[j + 1];
				var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
				var isValue = j === levels.length - 1;
				if (level === "") {
					var key5 = levels.slice(0, j).join();
					if (counters[key5] == null) counters[key5] = 0;
					level = counters[key5]++;
				}
				if (cursor[level] == null) {
					cursor[level] = isValue ? value : isNumber ? [] : {};
				}
				cursor = cursor[level];
			}
		}
		return data0;
	};
	var coreRouter = function coreRouter($window) {
		var supportsPushState = typeof $window.history.pushState === "function";
		var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function normalize1(fragment0) {
			var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent);
			if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data;
			return data;
		}
		var asyncId;
		function debounceAsync(callback0) {
			return function () {
				if (asyncId != null) return;
				asyncId = callAsync0(function () {
					asyncId = null;
					callback0();
				});
			};
		}
		function parsePath(path, queryData, hashData) {
			var queryIndex = path.indexOf("?");
			var hashIndex = path.indexOf("#");
			var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length;
			if (queryIndex > -1) {
				var queryEnd = hashIndex > -1 ? hashIndex : path.length;
				var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd));
				for (var key4 in queryParams) {
					queryData[key4] = queryParams[key4];
				}
			}
			if (hashIndex > -1) {
				var hashParams = parseQueryString(path.slice(hashIndex + 1));
				for (var key4 in hashParams) {
					hashData[key4] = hashParams[key4];
				}
			}
			return path.slice(0, pathEnd);
		}
		var router = { prefix: "#!" };
		router.getPath = function () {
			var type2 = router.prefix.charAt(0);
			switch (type2) {
				case "#":
					return normalize1("hash").slice(router.prefix.length);
				case "?":
					return normalize1("search").slice(router.prefix.length) + normalize1("hash");
				default:
					return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash");
			}
		};
		router.setPath = function (path, data, options) {
			var queryData = {},
			    hashData = {};
			path = parsePath(path, queryData, hashData);
			if (data != null) {
				for (var key4 in data) {
					queryData[key4] = data[key4];
				}path = path.replace(/:([^\/]+)/g, function (match2, token) {
					delete queryData[token];
					return data[token];
				});
			}
			var query = buildQueryString(queryData);
			if (query) path += "?" + query;
			var hash = buildQueryString(hashData);
			if (hash) path += "#" + hash;
			if (supportsPushState) {
				var state = options ? options.state : null;
				var title = options ? options.title : null;
				$window.onpopstate();
				if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path);else $window.history.pushState(state, title, router.prefix + path);
			} else $window.location.href = router.prefix + path;
		};
		router.defineRoutes = function (routes, resolve, reject) {
			function resolveRoute() {
				var path = router.getPath();
				var params = {};
				var pathname = parsePath(path, params, params);
				var state = $window.history.state;
				if (state != null) {
					for (var k in state) {
						params[k] = state[k];
					}
				}
				for (var route0 in routes) {
					var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");
					if (matcher.test(pathname)) {
						pathname.replace(matcher, function () {
							var keys = route0.match(/:[^\/]+/g) || [];
							var values = [].slice.call(arguments, 1, -2);
							for (var i = 0; i < keys.length; i++) {
								params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i]);
							}
							resolve(routes[route0], params, path, route0);
						});
						return;
					}
				}
				reject(path, params);
			}
			if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute);else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute;
			resolveRoute();
		};
		return router;
	};
	var _20 = function _20($window, redrawService0) {
		var routeService = coreRouter($window);
		var identity = function identity(v) {
			return v;
		};
		var render1, component, attrs3, currentPath, _lastUpdate;
		var route = function route(root, defaultRoute, routes) {
			if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined");
			var run1 = function run1() {
				if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)));
			};
			var bail = function bail(path) {
				if (path !== defaultRoute) routeService.setPath(defaultRoute, null, { replace: true });else throw new Error("Could not resolve default route " + defaultRoute);
			};
			routeService.defineRoutes(routes, function (payload, params, path) {
				var update = _lastUpdate = function lastUpdate(routeResolver, comp) {
					if (update !== _lastUpdate) return;
					component = comp != null && (typeof comp.view === "function" || typeof comp === "function") ? comp : "div";
					attrs3 = params, currentPath = path, _lastUpdate = null;
					render1 = (routeResolver.render || identity).bind(routeResolver);
					run1();
				};
				if (payload.view || typeof payload === "function") update({}, payload);else {
					if (payload.onmatch) {
						Promise.resolve(payload.onmatch(params, path)).then(function (resolved) {
							update(payload, resolved);
						}, bail);
					} else update(payload, "div");
				}
			}, bail);
			redrawService0.subscribe(root, run1);
		};
		route.set = function (path, data, options) {
			if (_lastUpdate != null) options = { replace: true };
			_lastUpdate = null;
			routeService.setPath(path, data, options);
		};
		route.get = function () {
			return currentPath;
		};
		route.prefix = function (prefix0) {
			routeService.prefix = prefix0;
		};
		route.link = function (vnode1) {
			vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href);
			vnode1.dom.onclick = function (e) {
				if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return;
				e.preventDefault();
				e.redraw = false;
				var href = this.getAttribute("href");
				if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length);
				route.set(href, undefined, undefined);
			};
		};
		route.param = function (key3) {
			if (typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3];
			return attrs3;
		};
		return route;
	};
	m.route = _20(window, redrawService);
	m.withAttr = function (attrName, callback1, context) {
		return function (e) {
			callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName));
		};
	};
	var _28 = coreRenderer(window);
	m.render = _28.render;
	m.redraw = redrawService.redraw;
	m.request = requestService.request;
	m.jsonp = requestService.jsonp;
	m.parseQueryString = parseQueryString;
	m.buildQueryString = buildQueryString;
	m.version = "1.1.1";
	m.vnode = Vnode;
	if (true) module["exports"] = m;else window.m = m;
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _component = __webpack_require__(19);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_mithril2.default.mount(document.getElementById('main'), _component2.default);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(3)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(4);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Utilities
//


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(10);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(9);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(14);
exports.lib.ucmicro = __webpack_require__(75);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/


/**
 * new Ruler()
 **/

function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typorgapher replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Token class



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/

function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML5 entities map: { name -> utf16string }
//


/*eslint quotes:0*/

module.exports = __webpack_require__(77);

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = '';
      state.tokens[delimiters[startDelim.end - 1].token].content = '';
      i++;
    }
  }
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ~~strike through~~
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports.encode = __webpack_require__(70);
module.exports.decode = __webpack_require__(69);
module.exports.format = __webpack_require__(71);
module.exports.parse = __webpack_require__(72);

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(94);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(78);

var _cell2 = _interopRequireDefault(_cell);

var _title = __webpack_require__(84);

var _title2 = _interopRequireDefault(_title);

var _tags = __webpack_require__(83);

var _tags2 = _interopRequireDefault(_tags);

var _editor = __webpack_require__(80);

var _editor2 = _interopRequireDefault(_editor);

var _preview = __webpack_require__(81);

var _preview2 = _interopRequireDefault(_preview);

var _save = __webpack_require__(82);

var _save2 = _interopRequireDefault(_save);

var _article = __webpack_require__(20);

var _article2 = _interopRequireDefault(_article);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var model = new _article2.default();

exports.default = {
  view: function view(vnode) {
    return (0, _mithril2.default)(
      'div',
      { className: 'mdl-grid' },
      (0, _mithril2.default)(_title2.default, { model: model }),
      (0, _mithril2.default)(_tags2.default, { model: model }),
      (0, _mithril2.default)(
        'div',
        { className: _styles2.default.editorWrap },
        (0, _mithril2.default)(_editor2.default, { key: 'editor', model: model }),
        (0, _mithril2.default)(_preview2.default, { key: 'preview', body: model.mdBody() })
      ),
      (0, _mithril2.default)(_save2.default, { model: model })
    );
  }
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _request = __webpack_require__(21);

var _request2 = _interopRequireDefault(_request);

var _markdownIt = __webpack_require__(24);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var md = new _markdownIt2.default();

var Model = function () {
  function Model(data) {
    _classCallCheck(this, Model);

    this.data = data || {
      title: '',
      body: '',
      slug: '',
      publish: false,
      tags: [],
      date: null
    };
    this.fetched = false;
    this.resourcesUrl = '/api/articles';
    this.resourceUrl = this.resourcesUrl + '/' + location.href.split('/').slice(4).join('/');
  }

  _createClass(Model, [{
    key: 'fetch',
    value: function fetch() {
      var _this = this;

      return (0, _request2.default)('GET', this.resourceUrl).then(function (response) {
        _this.fetched = true;
        _this.data = response;
      });
    }
  }, {
    key: 'create',
    value: function create() {
      var _this2 = this;

      return (0, _request2.default)('POST', this.resourcesUrl, this.data).then(function (response) {
        _this2.data = response;
      });
    }
  }, {
    key: 'update',
    value: function update() {
      var _this3 = this;

      return (0, _request2.default)('PUT', this.resourceUrl, this.data).then(function (response) {
        _this3.data = response;
      });
    }
  }, {
    key: 'delete',
    value: function _delete() {
      var _this4 = this;

      return (0, _request2.default)('DELETE', this.resourceUrl).then(function (response) {
        _this4.data = null;
      });
    }
  }, {
    key: 'mdBody',
    value: function mdBody() {
      return md.render(this.data.body);
    }
  }]);

  return Model;
}();

exports.default = Model;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (method, url, data) {
  return _mithril2.default.request({ method: method, url: url, data: data, deserialize: JSON.parse });
};

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//

function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(23)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(17).source;
  re.src_Cc = __webpack_require__(15).source;
  re.src_Z = __webpack_require__(16).source;
  re.src_P = __webpack_require__(9).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(30);

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Just a shortcut for bulk export


exports.parseLinkLabel = __webpack_require__(28);
exports.parseLinkDestination = __webpack_require__(27);
exports.parseLinkTitle = __webpack_require__(29);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link destination
//


var isSpace = __webpack_require__(6).isSpace;
var unescapeAll = __webpack_require__(6).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
        if (level > 1) {
          break;
        }
      }

    if (code === 0x29 /* ) */) {
        level--;
        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//


module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link title
//


var unescapeAll = __webpack_require__(6).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Main parser class



var utils = __webpack_require__(6);
var helpers = __webpack_require__(26);
var Renderer = __webpack_require__(37);
var ParserCore = __webpack_require__(32);
var ParserBlock = __webpack_require__(31);
var ParserInline = __webpack_require__(33);
var LinkifyIt = __webpack_require__(22);
var mdurl = __webpack_require__(14);
var punycode = __webpack_require__(73);

var config = {
  'default': __webpack_require__(35),
  zero: __webpack_require__(36),
  commonmark: __webpack_require__(34)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/


var Ruler = __webpack_require__(7);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(49), ['paragraph', 'reference']], ['code', __webpack_require__(39)], ['fence', __webpack_require__(40), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(38), ['paragraph', 'reference', 'list']], ['hr', __webpack_require__(42), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(45), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(47)], ['heading', __webpack_require__(41), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(44)], ['html_block', __webpack_require__(43), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(46)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(48);

module.exports = ParserBlock;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/


var Ruler = __webpack_require__(7);

var _rules = [['normalize', __webpack_require__(53)], ['block', __webpack_require__(50)], ['inline', __webpack_require__(51)], ['linkify', __webpack_require__(52)], ['replacements', __webpack_require__(54)], ['smartquotes', __webpack_require__(55)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(56);

module.exports = Core;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/


var Ruler = __webpack_require__(7);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(67)], ['newline', __webpack_require__(65)], ['escape', __webpack_require__(61)], ['backticks', __webpack_require__(58)], ['strikethrough', __webpack_require__(13).tokenize], ['emphasis', __webpack_require__(12).tokenize], ['link', __webpack_require__(64)], ['image', __webpack_require__(63)], ['autolink', __webpack_require__(57)], ['html_inline', __webpack_require__(62)], ['entity', __webpack_require__(60)]];

var _rules2 = [['balance_pairs', __webpack_require__(59)], ['strikethrough', __webpack_require__(13).postProcess], ['emphasis', __webpack_require__(12).postProcess], ['text_collapse', __webpack_require__(68)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(66);

module.exports = ParserInline;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// markdown-it default options



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign = __webpack_require__(6).assign;
var unescapeAll = __webpack_require__(6).unescapeAll;
var escapeHtml = __webpack_require__(6).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without mudofying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes



var isSpace = __webpack_require__(6).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      isOutdented,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    if (isOutdented) break;

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)



var isSpace = __webpack_require__(6).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule



var isSpace = __webpack_require__(6).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block



var block_names = __webpack_require__(25);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(11).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists



var isSpace = __webpack_require__(6).isSpace;

// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finilize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var normalizeReference = __webpack_require__(6).normalizeReference;
var isSpace = __webpack_require__(6).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class



var Token = __webpack_require__(8);
var isSpace = __webpack_require__(6).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard



var isSpace = __webpack_require__(6).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//


var arrayReplaceAt = __webpack_require__(6).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Normalize input string



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographyc replacements
//
// (c) (C) → ©
// (tm) (TM) → ™
// (r) (R) → ®
// +- → ±
// (p) (P) -> §
// ... → … (also ?.... → ?.., !.... → !..)
// ???????? → ???, !!!!! → !!!, `,,` → `,`
// -- → &ndash;, --- → &mdash;
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//


var isWhiteSpace = __webpack_require__(6).isWhiteSpace;
var isPunctChar = __webpack_require__(6).isPunctChar;
var isMdAsciiPunct = __webpack_require__(6).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Core state object
//


var Token = __webpack_require__(8);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'



/*eslint max-len:0*/

var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// For each opening emphasis-like marker find a matching closing one
//


module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities = __webpack_require__(10);
var has = __webpack_require__(6).has;
var isValidEntityCode = __webpack_require__(6).isValidEntityCode;
var fromCodePoint = __webpack_require__(6).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess escaped chars and hardbreaks



var isSpace = __webpack_require__(6).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags



var HTML_TAG_RE = __webpack_require__(11).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ![image](<src> "title")



var normalizeReference = __webpack_require__(6).normalizeReference;
var isSpace = __webpack_require__(6).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [link](<to> "stuff")



var normalizeReference = __webpack_require__(6).normalizeReference;
var isSpace = __webpack_require__(6).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'



var isSpace = __webpack_require__(6).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state



var Token = __webpack_require__(8);
var isWhiteSpace = __webpack_require__(6).isWhiteSpace;
var isPunctChar = __webpack_require__(6).isPunctChar;
var isMdAsciiPunct = __webpack_require__(6).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Merge adjacent text nodes into one, and re-calculate all token levels
//


module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(18)) == 'object' && __webpack_require__(18)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(76)(module), __webpack_require__(0)))

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Any = __webpack_require__(17);
exports.Cc = __webpack_require__(15);
exports.Cf = __webpack_require__(74);
exports.P = __webpack_require__(9);
exports.Z = __webpack_require__(16);

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = {
	"Aacute": "Á",
	"aacute": "á",
	"Abreve": "Ă",
	"abreve": "ă",
	"ac": "∾",
	"acd": "∿",
	"acE": "∾̳",
	"Acirc": "Â",
	"acirc": "â",
	"acute": "´",
	"Acy": "А",
	"acy": "а",
	"AElig": "Æ",
	"aelig": "æ",
	"af": "⁡",
	"Afr": "𝔄",
	"afr": "𝔞",
	"Agrave": "À",
	"agrave": "à",
	"alefsym": "ℵ",
	"aleph": "ℵ",
	"Alpha": "Α",
	"alpha": "α",
	"Amacr": "Ā",
	"amacr": "ā",
	"amalg": "⨿",
	"amp": "&",
	"AMP": "&",
	"andand": "⩕",
	"And": "⩓",
	"and": "∧",
	"andd": "⩜",
	"andslope": "⩘",
	"andv": "⩚",
	"ang": "∠",
	"ange": "⦤",
	"angle": "∠",
	"angmsdaa": "⦨",
	"angmsdab": "⦩",
	"angmsdac": "⦪",
	"angmsdad": "⦫",
	"angmsdae": "⦬",
	"angmsdaf": "⦭",
	"angmsdag": "⦮",
	"angmsdah": "⦯",
	"angmsd": "∡",
	"angrt": "∟",
	"angrtvb": "⊾",
	"angrtvbd": "⦝",
	"angsph": "∢",
	"angst": "Å",
	"angzarr": "⍼",
	"Aogon": "Ą",
	"aogon": "ą",
	"Aopf": "𝔸",
	"aopf": "𝕒",
	"apacir": "⩯",
	"ap": "≈",
	"apE": "⩰",
	"ape": "≊",
	"apid": "≋",
	"apos": "'",
	"ApplyFunction": "⁡",
	"approx": "≈",
	"approxeq": "≊",
	"Aring": "Å",
	"aring": "å",
	"Ascr": "𝒜",
	"ascr": "𝒶",
	"Assign": "≔",
	"ast": "*",
	"asymp": "≈",
	"asympeq": "≍",
	"Atilde": "Ã",
	"atilde": "ã",
	"Auml": "Ä",
	"auml": "ä",
	"awconint": "∳",
	"awint": "⨑",
	"backcong": "≌",
	"backepsilon": "϶",
	"backprime": "‵",
	"backsim": "∽",
	"backsimeq": "⋍",
	"Backslash": "∖",
	"Barv": "⫧",
	"barvee": "⊽",
	"barwed": "⌅",
	"Barwed": "⌆",
	"barwedge": "⌅",
	"bbrk": "⎵",
	"bbrktbrk": "⎶",
	"bcong": "≌",
	"Bcy": "Б",
	"bcy": "б",
	"bdquo": "„",
	"becaus": "∵",
	"because": "∵",
	"Because": "∵",
	"bemptyv": "⦰",
	"bepsi": "϶",
	"bernou": "ℬ",
	"Bernoullis": "ℬ",
	"Beta": "Β",
	"beta": "β",
	"beth": "ℶ",
	"between": "≬",
	"Bfr": "𝔅",
	"bfr": "𝔟",
	"bigcap": "⋂",
	"bigcirc": "◯",
	"bigcup": "⋃",
	"bigodot": "⨀",
	"bigoplus": "⨁",
	"bigotimes": "⨂",
	"bigsqcup": "⨆",
	"bigstar": "★",
	"bigtriangledown": "▽",
	"bigtriangleup": "△",
	"biguplus": "⨄",
	"bigvee": "⋁",
	"bigwedge": "⋀",
	"bkarow": "⤍",
	"blacklozenge": "⧫",
	"blacksquare": "▪",
	"blacktriangle": "▴",
	"blacktriangledown": "▾",
	"blacktriangleleft": "◂",
	"blacktriangleright": "▸",
	"blank": "␣",
	"blk12": "▒",
	"blk14": "░",
	"blk34": "▓",
	"block": "█",
	"bne": "=⃥",
	"bnequiv": "≡⃥",
	"bNot": "⫭",
	"bnot": "⌐",
	"Bopf": "𝔹",
	"bopf": "𝕓",
	"bot": "⊥",
	"bottom": "⊥",
	"bowtie": "⋈",
	"boxbox": "⧉",
	"boxdl": "┐",
	"boxdL": "╕",
	"boxDl": "╖",
	"boxDL": "╗",
	"boxdr": "┌",
	"boxdR": "╒",
	"boxDr": "╓",
	"boxDR": "╔",
	"boxh": "─",
	"boxH": "═",
	"boxhd": "┬",
	"boxHd": "╤",
	"boxhD": "╥",
	"boxHD": "╦",
	"boxhu": "┴",
	"boxHu": "╧",
	"boxhU": "╨",
	"boxHU": "╩",
	"boxminus": "⊟",
	"boxplus": "⊞",
	"boxtimes": "⊠",
	"boxul": "┘",
	"boxuL": "╛",
	"boxUl": "╜",
	"boxUL": "╝",
	"boxur": "└",
	"boxuR": "╘",
	"boxUr": "╙",
	"boxUR": "╚",
	"boxv": "│",
	"boxV": "║",
	"boxvh": "┼",
	"boxvH": "╪",
	"boxVh": "╫",
	"boxVH": "╬",
	"boxvl": "┤",
	"boxvL": "╡",
	"boxVl": "╢",
	"boxVL": "╣",
	"boxvr": "├",
	"boxvR": "╞",
	"boxVr": "╟",
	"boxVR": "╠",
	"bprime": "‵",
	"breve": "˘",
	"Breve": "˘",
	"brvbar": "¦",
	"bscr": "𝒷",
	"Bscr": "ℬ",
	"bsemi": "⁏",
	"bsim": "∽",
	"bsime": "⋍",
	"bsolb": "⧅",
	"bsol": "\\",
	"bsolhsub": "⟈",
	"bull": "•",
	"bullet": "•",
	"bump": "≎",
	"bumpE": "⪮",
	"bumpe": "≏",
	"Bumpeq": "≎",
	"bumpeq": "≏",
	"Cacute": "Ć",
	"cacute": "ć",
	"capand": "⩄",
	"capbrcup": "⩉",
	"capcap": "⩋",
	"cap": "∩",
	"Cap": "⋒",
	"capcup": "⩇",
	"capdot": "⩀",
	"CapitalDifferentialD": "ⅅ",
	"caps": "∩︀",
	"caret": "⁁",
	"caron": "ˇ",
	"Cayleys": "ℭ",
	"ccaps": "⩍",
	"Ccaron": "Č",
	"ccaron": "č",
	"Ccedil": "Ç",
	"ccedil": "ç",
	"Ccirc": "Ĉ",
	"ccirc": "ĉ",
	"Cconint": "∰",
	"ccups": "⩌",
	"ccupssm": "⩐",
	"Cdot": "Ċ",
	"cdot": "ċ",
	"cedil": "¸",
	"Cedilla": "¸",
	"cemptyv": "⦲",
	"cent": "¢",
	"centerdot": "·",
	"CenterDot": "·",
	"cfr": "𝔠",
	"Cfr": "ℭ",
	"CHcy": "Ч",
	"chcy": "ч",
	"check": "✓",
	"checkmark": "✓",
	"Chi": "Χ",
	"chi": "χ",
	"circ": "ˆ",
	"circeq": "≗",
	"circlearrowleft": "↺",
	"circlearrowright": "↻",
	"circledast": "⊛",
	"circledcirc": "⊚",
	"circleddash": "⊝",
	"CircleDot": "⊙",
	"circledR": "®",
	"circledS": "Ⓢ",
	"CircleMinus": "⊖",
	"CirclePlus": "⊕",
	"CircleTimes": "⊗",
	"cir": "○",
	"cirE": "⧃",
	"cire": "≗",
	"cirfnint": "⨐",
	"cirmid": "⫯",
	"cirscir": "⧂",
	"ClockwiseContourIntegral": "∲",
	"CloseCurlyDoubleQuote": "”",
	"CloseCurlyQuote": "’",
	"clubs": "♣",
	"clubsuit": "♣",
	"colon": ":",
	"Colon": "∷",
	"Colone": "⩴",
	"colone": "≔",
	"coloneq": "≔",
	"comma": ",",
	"commat": "@",
	"comp": "∁",
	"compfn": "∘",
	"complement": "∁",
	"complexes": "ℂ",
	"cong": "≅",
	"congdot": "⩭",
	"Congruent": "≡",
	"conint": "∮",
	"Conint": "∯",
	"ContourIntegral": "∮",
	"copf": "𝕔",
	"Copf": "ℂ",
	"coprod": "∐",
	"Coproduct": "∐",
	"copy": "©",
	"COPY": "©",
	"copysr": "℗",
	"CounterClockwiseContourIntegral": "∳",
	"crarr": "↵",
	"cross": "✗",
	"Cross": "⨯",
	"Cscr": "𝒞",
	"cscr": "𝒸",
	"csub": "⫏",
	"csube": "⫑",
	"csup": "⫐",
	"csupe": "⫒",
	"ctdot": "⋯",
	"cudarrl": "⤸",
	"cudarrr": "⤵",
	"cuepr": "⋞",
	"cuesc": "⋟",
	"cularr": "↶",
	"cularrp": "⤽",
	"cupbrcap": "⩈",
	"cupcap": "⩆",
	"CupCap": "≍",
	"cup": "∪",
	"Cup": "⋓",
	"cupcup": "⩊",
	"cupdot": "⊍",
	"cupor": "⩅",
	"cups": "∪︀",
	"curarr": "↷",
	"curarrm": "⤼",
	"curlyeqprec": "⋞",
	"curlyeqsucc": "⋟",
	"curlyvee": "⋎",
	"curlywedge": "⋏",
	"curren": "¤",
	"curvearrowleft": "↶",
	"curvearrowright": "↷",
	"cuvee": "⋎",
	"cuwed": "⋏",
	"cwconint": "∲",
	"cwint": "∱",
	"cylcty": "⌭",
	"dagger": "†",
	"Dagger": "‡",
	"daleth": "ℸ",
	"darr": "↓",
	"Darr": "↡",
	"dArr": "⇓",
	"dash": "‐",
	"Dashv": "⫤",
	"dashv": "⊣",
	"dbkarow": "⤏",
	"dblac": "˝",
	"Dcaron": "Ď",
	"dcaron": "ď",
	"Dcy": "Д",
	"dcy": "д",
	"ddagger": "‡",
	"ddarr": "⇊",
	"DD": "ⅅ",
	"dd": "ⅆ",
	"DDotrahd": "⤑",
	"ddotseq": "⩷",
	"deg": "°",
	"Del": "∇",
	"Delta": "Δ",
	"delta": "δ",
	"demptyv": "⦱",
	"dfisht": "⥿",
	"Dfr": "𝔇",
	"dfr": "𝔡",
	"dHar": "⥥",
	"dharl": "⇃",
	"dharr": "⇂",
	"DiacriticalAcute": "´",
	"DiacriticalDot": "˙",
	"DiacriticalDoubleAcute": "˝",
	"DiacriticalGrave": "`",
	"DiacriticalTilde": "˜",
	"diam": "⋄",
	"diamond": "⋄",
	"Diamond": "⋄",
	"diamondsuit": "♦",
	"diams": "♦",
	"die": "¨",
	"DifferentialD": "ⅆ",
	"digamma": "ϝ",
	"disin": "⋲",
	"div": "÷",
	"divide": "÷",
	"divideontimes": "⋇",
	"divonx": "⋇",
	"DJcy": "Ђ",
	"djcy": "ђ",
	"dlcorn": "⌞",
	"dlcrop": "⌍",
	"dollar": "$",
	"Dopf": "𝔻",
	"dopf": "𝕕",
	"Dot": "¨",
	"dot": "˙",
	"DotDot": "⃜",
	"doteq": "≐",
	"doteqdot": "≑",
	"DotEqual": "≐",
	"dotminus": "∸",
	"dotplus": "∔",
	"dotsquare": "⊡",
	"doublebarwedge": "⌆",
	"DoubleContourIntegral": "∯",
	"DoubleDot": "¨",
	"DoubleDownArrow": "⇓",
	"DoubleLeftArrow": "⇐",
	"DoubleLeftRightArrow": "⇔",
	"DoubleLeftTee": "⫤",
	"DoubleLongLeftArrow": "⟸",
	"DoubleLongLeftRightArrow": "⟺",
	"DoubleLongRightArrow": "⟹",
	"DoubleRightArrow": "⇒",
	"DoubleRightTee": "⊨",
	"DoubleUpArrow": "⇑",
	"DoubleUpDownArrow": "⇕",
	"DoubleVerticalBar": "∥",
	"DownArrowBar": "⤓",
	"downarrow": "↓",
	"DownArrow": "↓",
	"Downarrow": "⇓",
	"DownArrowUpArrow": "⇵",
	"DownBreve": "̑",
	"downdownarrows": "⇊",
	"downharpoonleft": "⇃",
	"downharpoonright": "⇂",
	"DownLeftRightVector": "⥐",
	"DownLeftTeeVector": "⥞",
	"DownLeftVectorBar": "⥖",
	"DownLeftVector": "↽",
	"DownRightTeeVector": "⥟",
	"DownRightVectorBar": "⥗",
	"DownRightVector": "⇁",
	"DownTeeArrow": "↧",
	"DownTee": "⊤",
	"drbkarow": "⤐",
	"drcorn": "⌟",
	"drcrop": "⌌",
	"Dscr": "𝒟",
	"dscr": "𝒹",
	"DScy": "Ѕ",
	"dscy": "ѕ",
	"dsol": "⧶",
	"Dstrok": "Đ",
	"dstrok": "đ",
	"dtdot": "⋱",
	"dtri": "▿",
	"dtrif": "▾",
	"duarr": "⇵",
	"duhar": "⥯",
	"dwangle": "⦦",
	"DZcy": "Џ",
	"dzcy": "џ",
	"dzigrarr": "⟿",
	"Eacute": "É",
	"eacute": "é",
	"easter": "⩮",
	"Ecaron": "Ě",
	"ecaron": "ě",
	"Ecirc": "Ê",
	"ecirc": "ê",
	"ecir": "≖",
	"ecolon": "≕",
	"Ecy": "Э",
	"ecy": "э",
	"eDDot": "⩷",
	"Edot": "Ė",
	"edot": "ė",
	"eDot": "≑",
	"ee": "ⅇ",
	"efDot": "≒",
	"Efr": "𝔈",
	"efr": "𝔢",
	"eg": "⪚",
	"Egrave": "È",
	"egrave": "è",
	"egs": "⪖",
	"egsdot": "⪘",
	"el": "⪙",
	"Element": "∈",
	"elinters": "⏧",
	"ell": "ℓ",
	"els": "⪕",
	"elsdot": "⪗",
	"Emacr": "Ē",
	"emacr": "ē",
	"empty": "∅",
	"emptyset": "∅",
	"EmptySmallSquare": "◻",
	"emptyv": "∅",
	"EmptyVerySmallSquare": "▫",
	"emsp13": " ",
	"emsp14": " ",
	"emsp": " ",
	"ENG": "Ŋ",
	"eng": "ŋ",
	"ensp": " ",
	"Eogon": "Ę",
	"eogon": "ę",
	"Eopf": "𝔼",
	"eopf": "𝕖",
	"epar": "⋕",
	"eparsl": "⧣",
	"eplus": "⩱",
	"epsi": "ε",
	"Epsilon": "Ε",
	"epsilon": "ε",
	"epsiv": "ϵ",
	"eqcirc": "≖",
	"eqcolon": "≕",
	"eqsim": "≂",
	"eqslantgtr": "⪖",
	"eqslantless": "⪕",
	"Equal": "⩵",
	"equals": "=",
	"EqualTilde": "≂",
	"equest": "≟",
	"Equilibrium": "⇌",
	"equiv": "≡",
	"equivDD": "⩸",
	"eqvparsl": "⧥",
	"erarr": "⥱",
	"erDot": "≓",
	"escr": "ℯ",
	"Escr": "ℰ",
	"esdot": "≐",
	"Esim": "⩳",
	"esim": "≂",
	"Eta": "Η",
	"eta": "η",
	"ETH": "Ð",
	"eth": "ð",
	"Euml": "Ë",
	"euml": "ë",
	"euro": "€",
	"excl": "!",
	"exist": "∃",
	"Exists": "∃",
	"expectation": "ℰ",
	"exponentiale": "ⅇ",
	"ExponentialE": "ⅇ",
	"fallingdotseq": "≒",
	"Fcy": "Ф",
	"fcy": "ф",
	"female": "♀",
	"ffilig": "ﬃ",
	"fflig": "ﬀ",
	"ffllig": "ﬄ",
	"Ffr": "𝔉",
	"ffr": "𝔣",
	"filig": "ﬁ",
	"FilledSmallSquare": "◼",
	"FilledVerySmallSquare": "▪",
	"fjlig": "fj",
	"flat": "♭",
	"fllig": "ﬂ",
	"fltns": "▱",
	"fnof": "ƒ",
	"Fopf": "𝔽",
	"fopf": "𝕗",
	"forall": "∀",
	"ForAll": "∀",
	"fork": "⋔",
	"forkv": "⫙",
	"Fouriertrf": "ℱ",
	"fpartint": "⨍",
	"frac12": "½",
	"frac13": "⅓",
	"frac14": "¼",
	"frac15": "⅕",
	"frac16": "⅙",
	"frac18": "⅛",
	"frac23": "⅔",
	"frac25": "⅖",
	"frac34": "¾",
	"frac35": "⅗",
	"frac38": "⅜",
	"frac45": "⅘",
	"frac56": "⅚",
	"frac58": "⅝",
	"frac78": "⅞",
	"frasl": "⁄",
	"frown": "⌢",
	"fscr": "𝒻",
	"Fscr": "ℱ",
	"gacute": "ǵ",
	"Gamma": "Γ",
	"gamma": "γ",
	"Gammad": "Ϝ",
	"gammad": "ϝ",
	"gap": "⪆",
	"Gbreve": "Ğ",
	"gbreve": "ğ",
	"Gcedil": "Ģ",
	"Gcirc": "Ĝ",
	"gcirc": "ĝ",
	"Gcy": "Г",
	"gcy": "г",
	"Gdot": "Ġ",
	"gdot": "ġ",
	"ge": "≥",
	"gE": "≧",
	"gEl": "⪌",
	"gel": "⋛",
	"geq": "≥",
	"geqq": "≧",
	"geqslant": "⩾",
	"gescc": "⪩",
	"ges": "⩾",
	"gesdot": "⪀",
	"gesdoto": "⪂",
	"gesdotol": "⪄",
	"gesl": "⋛︀",
	"gesles": "⪔",
	"Gfr": "𝔊",
	"gfr": "𝔤",
	"gg": "≫",
	"Gg": "⋙",
	"ggg": "⋙",
	"gimel": "ℷ",
	"GJcy": "Ѓ",
	"gjcy": "ѓ",
	"gla": "⪥",
	"gl": "≷",
	"glE": "⪒",
	"glj": "⪤",
	"gnap": "⪊",
	"gnapprox": "⪊",
	"gne": "⪈",
	"gnE": "≩",
	"gneq": "⪈",
	"gneqq": "≩",
	"gnsim": "⋧",
	"Gopf": "𝔾",
	"gopf": "𝕘",
	"grave": "`",
	"GreaterEqual": "≥",
	"GreaterEqualLess": "⋛",
	"GreaterFullEqual": "≧",
	"GreaterGreater": "⪢",
	"GreaterLess": "≷",
	"GreaterSlantEqual": "⩾",
	"GreaterTilde": "≳",
	"Gscr": "𝒢",
	"gscr": "ℊ",
	"gsim": "≳",
	"gsime": "⪎",
	"gsiml": "⪐",
	"gtcc": "⪧",
	"gtcir": "⩺",
	"gt": ">",
	"GT": ">",
	"Gt": "≫",
	"gtdot": "⋗",
	"gtlPar": "⦕",
	"gtquest": "⩼",
	"gtrapprox": "⪆",
	"gtrarr": "⥸",
	"gtrdot": "⋗",
	"gtreqless": "⋛",
	"gtreqqless": "⪌",
	"gtrless": "≷",
	"gtrsim": "≳",
	"gvertneqq": "≩︀",
	"gvnE": "≩︀",
	"Hacek": "ˇ",
	"hairsp": " ",
	"half": "½",
	"hamilt": "ℋ",
	"HARDcy": "Ъ",
	"hardcy": "ъ",
	"harrcir": "⥈",
	"harr": "↔",
	"hArr": "⇔",
	"harrw": "↭",
	"Hat": "^",
	"hbar": "ℏ",
	"Hcirc": "Ĥ",
	"hcirc": "ĥ",
	"hearts": "♥",
	"heartsuit": "♥",
	"hellip": "…",
	"hercon": "⊹",
	"hfr": "𝔥",
	"Hfr": "ℌ",
	"HilbertSpace": "ℋ",
	"hksearow": "⤥",
	"hkswarow": "⤦",
	"hoarr": "⇿",
	"homtht": "∻",
	"hookleftarrow": "↩",
	"hookrightarrow": "↪",
	"hopf": "𝕙",
	"Hopf": "ℍ",
	"horbar": "―",
	"HorizontalLine": "─",
	"hscr": "𝒽",
	"Hscr": "ℋ",
	"hslash": "ℏ",
	"Hstrok": "Ħ",
	"hstrok": "ħ",
	"HumpDownHump": "≎",
	"HumpEqual": "≏",
	"hybull": "⁃",
	"hyphen": "‐",
	"Iacute": "Í",
	"iacute": "í",
	"ic": "⁣",
	"Icirc": "Î",
	"icirc": "î",
	"Icy": "И",
	"icy": "и",
	"Idot": "İ",
	"IEcy": "Е",
	"iecy": "е",
	"iexcl": "¡",
	"iff": "⇔",
	"ifr": "𝔦",
	"Ifr": "ℑ",
	"Igrave": "Ì",
	"igrave": "ì",
	"ii": "ⅈ",
	"iiiint": "⨌",
	"iiint": "∭",
	"iinfin": "⧜",
	"iiota": "℩",
	"IJlig": "Ĳ",
	"ijlig": "ĳ",
	"Imacr": "Ī",
	"imacr": "ī",
	"image": "ℑ",
	"ImaginaryI": "ⅈ",
	"imagline": "ℐ",
	"imagpart": "ℑ",
	"imath": "ı",
	"Im": "ℑ",
	"imof": "⊷",
	"imped": "Ƶ",
	"Implies": "⇒",
	"incare": "℅",
	"in": "∈",
	"infin": "∞",
	"infintie": "⧝",
	"inodot": "ı",
	"intcal": "⊺",
	"int": "∫",
	"Int": "∬",
	"integers": "ℤ",
	"Integral": "∫",
	"intercal": "⊺",
	"Intersection": "⋂",
	"intlarhk": "⨗",
	"intprod": "⨼",
	"InvisibleComma": "⁣",
	"InvisibleTimes": "⁢",
	"IOcy": "Ё",
	"iocy": "ё",
	"Iogon": "Į",
	"iogon": "į",
	"Iopf": "𝕀",
	"iopf": "𝕚",
	"Iota": "Ι",
	"iota": "ι",
	"iprod": "⨼",
	"iquest": "¿",
	"iscr": "𝒾",
	"Iscr": "ℐ",
	"isin": "∈",
	"isindot": "⋵",
	"isinE": "⋹",
	"isins": "⋴",
	"isinsv": "⋳",
	"isinv": "∈",
	"it": "⁢",
	"Itilde": "Ĩ",
	"itilde": "ĩ",
	"Iukcy": "І",
	"iukcy": "і",
	"Iuml": "Ï",
	"iuml": "ï",
	"Jcirc": "Ĵ",
	"jcirc": "ĵ",
	"Jcy": "Й",
	"jcy": "й",
	"Jfr": "𝔍",
	"jfr": "𝔧",
	"jmath": "ȷ",
	"Jopf": "𝕁",
	"jopf": "𝕛",
	"Jscr": "𝒥",
	"jscr": "𝒿",
	"Jsercy": "Ј",
	"jsercy": "ј",
	"Jukcy": "Є",
	"jukcy": "є",
	"Kappa": "Κ",
	"kappa": "κ",
	"kappav": "ϰ",
	"Kcedil": "Ķ",
	"kcedil": "ķ",
	"Kcy": "К",
	"kcy": "к",
	"Kfr": "𝔎",
	"kfr": "𝔨",
	"kgreen": "ĸ",
	"KHcy": "Х",
	"khcy": "х",
	"KJcy": "Ќ",
	"kjcy": "ќ",
	"Kopf": "𝕂",
	"kopf": "𝕜",
	"Kscr": "𝒦",
	"kscr": "𝓀",
	"lAarr": "⇚",
	"Lacute": "Ĺ",
	"lacute": "ĺ",
	"laemptyv": "⦴",
	"lagran": "ℒ",
	"Lambda": "Λ",
	"lambda": "λ",
	"lang": "⟨",
	"Lang": "⟪",
	"langd": "⦑",
	"langle": "⟨",
	"lap": "⪅",
	"Laplacetrf": "ℒ",
	"laquo": "«",
	"larrb": "⇤",
	"larrbfs": "⤟",
	"larr": "←",
	"Larr": "↞",
	"lArr": "⇐",
	"larrfs": "⤝",
	"larrhk": "↩",
	"larrlp": "↫",
	"larrpl": "⤹",
	"larrsim": "⥳",
	"larrtl": "↢",
	"latail": "⤙",
	"lAtail": "⤛",
	"lat": "⪫",
	"late": "⪭",
	"lates": "⪭︀",
	"lbarr": "⤌",
	"lBarr": "⤎",
	"lbbrk": "❲",
	"lbrace": "{",
	"lbrack": "[",
	"lbrke": "⦋",
	"lbrksld": "⦏",
	"lbrkslu": "⦍",
	"Lcaron": "Ľ",
	"lcaron": "ľ",
	"Lcedil": "Ļ",
	"lcedil": "ļ",
	"lceil": "⌈",
	"lcub": "{",
	"Lcy": "Л",
	"lcy": "л",
	"ldca": "⤶",
	"ldquo": "“",
	"ldquor": "„",
	"ldrdhar": "⥧",
	"ldrushar": "⥋",
	"ldsh": "↲",
	"le": "≤",
	"lE": "≦",
	"LeftAngleBracket": "⟨",
	"LeftArrowBar": "⇤",
	"leftarrow": "←",
	"LeftArrow": "←",
	"Leftarrow": "⇐",
	"LeftArrowRightArrow": "⇆",
	"leftarrowtail": "↢",
	"LeftCeiling": "⌈",
	"LeftDoubleBracket": "⟦",
	"LeftDownTeeVector": "⥡",
	"LeftDownVectorBar": "⥙",
	"LeftDownVector": "⇃",
	"LeftFloor": "⌊",
	"leftharpoondown": "↽",
	"leftharpoonup": "↼",
	"leftleftarrows": "⇇",
	"leftrightarrow": "↔",
	"LeftRightArrow": "↔",
	"Leftrightarrow": "⇔",
	"leftrightarrows": "⇆",
	"leftrightharpoons": "⇋",
	"leftrightsquigarrow": "↭",
	"LeftRightVector": "⥎",
	"LeftTeeArrow": "↤",
	"LeftTee": "⊣",
	"LeftTeeVector": "⥚",
	"leftthreetimes": "⋋",
	"LeftTriangleBar": "⧏",
	"LeftTriangle": "⊲",
	"LeftTriangleEqual": "⊴",
	"LeftUpDownVector": "⥑",
	"LeftUpTeeVector": "⥠",
	"LeftUpVectorBar": "⥘",
	"LeftUpVector": "↿",
	"LeftVectorBar": "⥒",
	"LeftVector": "↼",
	"lEg": "⪋",
	"leg": "⋚",
	"leq": "≤",
	"leqq": "≦",
	"leqslant": "⩽",
	"lescc": "⪨",
	"les": "⩽",
	"lesdot": "⩿",
	"lesdoto": "⪁",
	"lesdotor": "⪃",
	"lesg": "⋚︀",
	"lesges": "⪓",
	"lessapprox": "⪅",
	"lessdot": "⋖",
	"lesseqgtr": "⋚",
	"lesseqqgtr": "⪋",
	"LessEqualGreater": "⋚",
	"LessFullEqual": "≦",
	"LessGreater": "≶",
	"lessgtr": "≶",
	"LessLess": "⪡",
	"lesssim": "≲",
	"LessSlantEqual": "⩽",
	"LessTilde": "≲",
	"lfisht": "⥼",
	"lfloor": "⌊",
	"Lfr": "𝔏",
	"lfr": "𝔩",
	"lg": "≶",
	"lgE": "⪑",
	"lHar": "⥢",
	"lhard": "↽",
	"lharu": "↼",
	"lharul": "⥪",
	"lhblk": "▄",
	"LJcy": "Љ",
	"ljcy": "љ",
	"llarr": "⇇",
	"ll": "≪",
	"Ll": "⋘",
	"llcorner": "⌞",
	"Lleftarrow": "⇚",
	"llhard": "⥫",
	"lltri": "◺",
	"Lmidot": "Ŀ",
	"lmidot": "ŀ",
	"lmoustache": "⎰",
	"lmoust": "⎰",
	"lnap": "⪉",
	"lnapprox": "⪉",
	"lne": "⪇",
	"lnE": "≨",
	"lneq": "⪇",
	"lneqq": "≨",
	"lnsim": "⋦",
	"loang": "⟬",
	"loarr": "⇽",
	"lobrk": "⟦",
	"longleftarrow": "⟵",
	"LongLeftArrow": "⟵",
	"Longleftarrow": "⟸",
	"longleftrightarrow": "⟷",
	"LongLeftRightArrow": "⟷",
	"Longleftrightarrow": "⟺",
	"longmapsto": "⟼",
	"longrightarrow": "⟶",
	"LongRightArrow": "⟶",
	"Longrightarrow": "⟹",
	"looparrowleft": "↫",
	"looparrowright": "↬",
	"lopar": "⦅",
	"Lopf": "𝕃",
	"lopf": "𝕝",
	"loplus": "⨭",
	"lotimes": "⨴",
	"lowast": "∗",
	"lowbar": "_",
	"LowerLeftArrow": "↙",
	"LowerRightArrow": "↘",
	"loz": "◊",
	"lozenge": "◊",
	"lozf": "⧫",
	"lpar": "(",
	"lparlt": "⦓",
	"lrarr": "⇆",
	"lrcorner": "⌟",
	"lrhar": "⇋",
	"lrhard": "⥭",
	"lrm": "‎",
	"lrtri": "⊿",
	"lsaquo": "‹",
	"lscr": "𝓁",
	"Lscr": "ℒ",
	"lsh": "↰",
	"Lsh": "↰",
	"lsim": "≲",
	"lsime": "⪍",
	"lsimg": "⪏",
	"lsqb": "[",
	"lsquo": "‘",
	"lsquor": "‚",
	"Lstrok": "Ł",
	"lstrok": "ł",
	"ltcc": "⪦",
	"ltcir": "⩹",
	"lt": "<",
	"LT": "<",
	"Lt": "≪",
	"ltdot": "⋖",
	"lthree": "⋋",
	"ltimes": "⋉",
	"ltlarr": "⥶",
	"ltquest": "⩻",
	"ltri": "◃",
	"ltrie": "⊴",
	"ltrif": "◂",
	"ltrPar": "⦖",
	"lurdshar": "⥊",
	"luruhar": "⥦",
	"lvertneqq": "≨︀",
	"lvnE": "≨︀",
	"macr": "¯",
	"male": "♂",
	"malt": "✠",
	"maltese": "✠",
	"Map": "⤅",
	"map": "↦",
	"mapsto": "↦",
	"mapstodown": "↧",
	"mapstoleft": "↤",
	"mapstoup": "↥",
	"marker": "▮",
	"mcomma": "⨩",
	"Mcy": "М",
	"mcy": "м",
	"mdash": "—",
	"mDDot": "∺",
	"measuredangle": "∡",
	"MediumSpace": " ",
	"Mellintrf": "ℳ",
	"Mfr": "𝔐",
	"mfr": "𝔪",
	"mho": "℧",
	"micro": "µ",
	"midast": "*",
	"midcir": "⫰",
	"mid": "∣",
	"middot": "·",
	"minusb": "⊟",
	"minus": "−",
	"minusd": "∸",
	"minusdu": "⨪",
	"MinusPlus": "∓",
	"mlcp": "⫛",
	"mldr": "…",
	"mnplus": "∓",
	"models": "⊧",
	"Mopf": "𝕄",
	"mopf": "𝕞",
	"mp": "∓",
	"mscr": "𝓂",
	"Mscr": "ℳ",
	"mstpos": "∾",
	"Mu": "Μ",
	"mu": "μ",
	"multimap": "⊸",
	"mumap": "⊸",
	"nabla": "∇",
	"Nacute": "Ń",
	"nacute": "ń",
	"nang": "∠⃒",
	"nap": "≉",
	"napE": "⩰̸",
	"napid": "≋̸",
	"napos": "ŉ",
	"napprox": "≉",
	"natural": "♮",
	"naturals": "ℕ",
	"natur": "♮",
	"nbsp": " ",
	"nbump": "≎̸",
	"nbumpe": "≏̸",
	"ncap": "⩃",
	"Ncaron": "Ň",
	"ncaron": "ň",
	"Ncedil": "Ņ",
	"ncedil": "ņ",
	"ncong": "≇",
	"ncongdot": "⩭̸",
	"ncup": "⩂",
	"Ncy": "Н",
	"ncy": "н",
	"ndash": "–",
	"nearhk": "⤤",
	"nearr": "↗",
	"neArr": "⇗",
	"nearrow": "↗",
	"ne": "≠",
	"nedot": "≐̸",
	"NegativeMediumSpace": "​",
	"NegativeThickSpace": "​",
	"NegativeThinSpace": "​",
	"NegativeVeryThinSpace": "​",
	"nequiv": "≢",
	"nesear": "⤨",
	"nesim": "≂̸",
	"NestedGreaterGreater": "≫",
	"NestedLessLess": "≪",
	"NewLine": "\n",
	"nexist": "∄",
	"nexists": "∄",
	"Nfr": "𝔑",
	"nfr": "𝔫",
	"ngE": "≧̸",
	"nge": "≱",
	"ngeq": "≱",
	"ngeqq": "≧̸",
	"ngeqslant": "⩾̸",
	"nges": "⩾̸",
	"nGg": "⋙̸",
	"ngsim": "≵",
	"nGt": "≫⃒",
	"ngt": "≯",
	"ngtr": "≯",
	"nGtv": "≫̸",
	"nharr": "↮",
	"nhArr": "⇎",
	"nhpar": "⫲",
	"ni": "∋",
	"nis": "⋼",
	"nisd": "⋺",
	"niv": "∋",
	"NJcy": "Њ",
	"njcy": "њ",
	"nlarr": "↚",
	"nlArr": "⇍",
	"nldr": "‥",
	"nlE": "≦̸",
	"nle": "≰",
	"nleftarrow": "↚",
	"nLeftarrow": "⇍",
	"nleftrightarrow": "↮",
	"nLeftrightarrow": "⇎",
	"nleq": "≰",
	"nleqq": "≦̸",
	"nleqslant": "⩽̸",
	"nles": "⩽̸",
	"nless": "≮",
	"nLl": "⋘̸",
	"nlsim": "≴",
	"nLt": "≪⃒",
	"nlt": "≮",
	"nltri": "⋪",
	"nltrie": "⋬",
	"nLtv": "≪̸",
	"nmid": "∤",
	"NoBreak": "⁠",
	"NonBreakingSpace": " ",
	"nopf": "𝕟",
	"Nopf": "ℕ",
	"Not": "⫬",
	"not": "¬",
	"NotCongruent": "≢",
	"NotCupCap": "≭",
	"NotDoubleVerticalBar": "∦",
	"NotElement": "∉",
	"NotEqual": "≠",
	"NotEqualTilde": "≂̸",
	"NotExists": "∄",
	"NotGreater": "≯",
	"NotGreaterEqual": "≱",
	"NotGreaterFullEqual": "≧̸",
	"NotGreaterGreater": "≫̸",
	"NotGreaterLess": "≹",
	"NotGreaterSlantEqual": "⩾̸",
	"NotGreaterTilde": "≵",
	"NotHumpDownHump": "≎̸",
	"NotHumpEqual": "≏̸",
	"notin": "∉",
	"notindot": "⋵̸",
	"notinE": "⋹̸",
	"notinva": "∉",
	"notinvb": "⋷",
	"notinvc": "⋶",
	"NotLeftTriangleBar": "⧏̸",
	"NotLeftTriangle": "⋪",
	"NotLeftTriangleEqual": "⋬",
	"NotLess": "≮",
	"NotLessEqual": "≰",
	"NotLessGreater": "≸",
	"NotLessLess": "≪̸",
	"NotLessSlantEqual": "⩽̸",
	"NotLessTilde": "≴",
	"NotNestedGreaterGreater": "⪢̸",
	"NotNestedLessLess": "⪡̸",
	"notni": "∌",
	"notniva": "∌",
	"notnivb": "⋾",
	"notnivc": "⋽",
	"NotPrecedes": "⊀",
	"NotPrecedesEqual": "⪯̸",
	"NotPrecedesSlantEqual": "⋠",
	"NotReverseElement": "∌",
	"NotRightTriangleBar": "⧐̸",
	"NotRightTriangle": "⋫",
	"NotRightTriangleEqual": "⋭",
	"NotSquareSubset": "⊏̸",
	"NotSquareSubsetEqual": "⋢",
	"NotSquareSuperset": "⊐̸",
	"NotSquareSupersetEqual": "⋣",
	"NotSubset": "⊂⃒",
	"NotSubsetEqual": "⊈",
	"NotSucceeds": "⊁",
	"NotSucceedsEqual": "⪰̸",
	"NotSucceedsSlantEqual": "⋡",
	"NotSucceedsTilde": "≿̸",
	"NotSuperset": "⊃⃒",
	"NotSupersetEqual": "⊉",
	"NotTilde": "≁",
	"NotTildeEqual": "≄",
	"NotTildeFullEqual": "≇",
	"NotTildeTilde": "≉",
	"NotVerticalBar": "∤",
	"nparallel": "∦",
	"npar": "∦",
	"nparsl": "⫽⃥",
	"npart": "∂̸",
	"npolint": "⨔",
	"npr": "⊀",
	"nprcue": "⋠",
	"nprec": "⊀",
	"npreceq": "⪯̸",
	"npre": "⪯̸",
	"nrarrc": "⤳̸",
	"nrarr": "↛",
	"nrArr": "⇏",
	"nrarrw": "↝̸",
	"nrightarrow": "↛",
	"nRightarrow": "⇏",
	"nrtri": "⋫",
	"nrtrie": "⋭",
	"nsc": "⊁",
	"nsccue": "⋡",
	"nsce": "⪰̸",
	"Nscr": "𝒩",
	"nscr": "𝓃",
	"nshortmid": "∤",
	"nshortparallel": "∦",
	"nsim": "≁",
	"nsime": "≄",
	"nsimeq": "≄",
	"nsmid": "∤",
	"nspar": "∦",
	"nsqsube": "⋢",
	"nsqsupe": "⋣",
	"nsub": "⊄",
	"nsubE": "⫅̸",
	"nsube": "⊈",
	"nsubset": "⊂⃒",
	"nsubseteq": "⊈",
	"nsubseteqq": "⫅̸",
	"nsucc": "⊁",
	"nsucceq": "⪰̸",
	"nsup": "⊅",
	"nsupE": "⫆̸",
	"nsupe": "⊉",
	"nsupset": "⊃⃒",
	"nsupseteq": "⊉",
	"nsupseteqq": "⫆̸",
	"ntgl": "≹",
	"Ntilde": "Ñ",
	"ntilde": "ñ",
	"ntlg": "≸",
	"ntriangleleft": "⋪",
	"ntrianglelefteq": "⋬",
	"ntriangleright": "⋫",
	"ntrianglerighteq": "⋭",
	"Nu": "Ν",
	"nu": "ν",
	"num": "#",
	"numero": "№",
	"numsp": " ",
	"nvap": "≍⃒",
	"nvdash": "⊬",
	"nvDash": "⊭",
	"nVdash": "⊮",
	"nVDash": "⊯",
	"nvge": "≥⃒",
	"nvgt": ">⃒",
	"nvHarr": "⤄",
	"nvinfin": "⧞",
	"nvlArr": "⤂",
	"nvle": "≤⃒",
	"nvlt": "<⃒",
	"nvltrie": "⊴⃒",
	"nvrArr": "⤃",
	"nvrtrie": "⊵⃒",
	"nvsim": "∼⃒",
	"nwarhk": "⤣",
	"nwarr": "↖",
	"nwArr": "⇖",
	"nwarrow": "↖",
	"nwnear": "⤧",
	"Oacute": "Ó",
	"oacute": "ó",
	"oast": "⊛",
	"Ocirc": "Ô",
	"ocirc": "ô",
	"ocir": "⊚",
	"Ocy": "О",
	"ocy": "о",
	"odash": "⊝",
	"Odblac": "Ő",
	"odblac": "ő",
	"odiv": "⨸",
	"odot": "⊙",
	"odsold": "⦼",
	"OElig": "Œ",
	"oelig": "œ",
	"ofcir": "⦿",
	"Ofr": "𝔒",
	"ofr": "𝔬",
	"ogon": "˛",
	"Ograve": "Ò",
	"ograve": "ò",
	"ogt": "⧁",
	"ohbar": "⦵",
	"ohm": "Ω",
	"oint": "∮",
	"olarr": "↺",
	"olcir": "⦾",
	"olcross": "⦻",
	"oline": "‾",
	"olt": "⧀",
	"Omacr": "Ō",
	"omacr": "ō",
	"Omega": "Ω",
	"omega": "ω",
	"Omicron": "Ο",
	"omicron": "ο",
	"omid": "⦶",
	"ominus": "⊖",
	"Oopf": "𝕆",
	"oopf": "𝕠",
	"opar": "⦷",
	"OpenCurlyDoubleQuote": "“",
	"OpenCurlyQuote": "‘",
	"operp": "⦹",
	"oplus": "⊕",
	"orarr": "↻",
	"Or": "⩔",
	"or": "∨",
	"ord": "⩝",
	"order": "ℴ",
	"orderof": "ℴ",
	"ordf": "ª",
	"ordm": "º",
	"origof": "⊶",
	"oror": "⩖",
	"orslope": "⩗",
	"orv": "⩛",
	"oS": "Ⓢ",
	"Oscr": "𝒪",
	"oscr": "ℴ",
	"Oslash": "Ø",
	"oslash": "ø",
	"osol": "⊘",
	"Otilde": "Õ",
	"otilde": "õ",
	"otimesas": "⨶",
	"Otimes": "⨷",
	"otimes": "⊗",
	"Ouml": "Ö",
	"ouml": "ö",
	"ovbar": "⌽",
	"OverBar": "‾",
	"OverBrace": "⏞",
	"OverBracket": "⎴",
	"OverParenthesis": "⏜",
	"para": "¶",
	"parallel": "∥",
	"par": "∥",
	"parsim": "⫳",
	"parsl": "⫽",
	"part": "∂",
	"PartialD": "∂",
	"Pcy": "П",
	"pcy": "п",
	"percnt": "%",
	"period": ".",
	"permil": "‰",
	"perp": "⊥",
	"pertenk": "‱",
	"Pfr": "𝔓",
	"pfr": "𝔭",
	"Phi": "Φ",
	"phi": "φ",
	"phiv": "ϕ",
	"phmmat": "ℳ",
	"phone": "☎",
	"Pi": "Π",
	"pi": "π",
	"pitchfork": "⋔",
	"piv": "ϖ",
	"planck": "ℏ",
	"planckh": "ℎ",
	"plankv": "ℏ",
	"plusacir": "⨣",
	"plusb": "⊞",
	"pluscir": "⨢",
	"plus": "+",
	"plusdo": "∔",
	"plusdu": "⨥",
	"pluse": "⩲",
	"PlusMinus": "±",
	"plusmn": "±",
	"plussim": "⨦",
	"plustwo": "⨧",
	"pm": "±",
	"Poincareplane": "ℌ",
	"pointint": "⨕",
	"popf": "𝕡",
	"Popf": "ℙ",
	"pound": "£",
	"prap": "⪷",
	"Pr": "⪻",
	"pr": "≺",
	"prcue": "≼",
	"precapprox": "⪷",
	"prec": "≺",
	"preccurlyeq": "≼",
	"Precedes": "≺",
	"PrecedesEqual": "⪯",
	"PrecedesSlantEqual": "≼",
	"PrecedesTilde": "≾",
	"preceq": "⪯",
	"precnapprox": "⪹",
	"precneqq": "⪵",
	"precnsim": "⋨",
	"pre": "⪯",
	"prE": "⪳",
	"precsim": "≾",
	"prime": "′",
	"Prime": "″",
	"primes": "ℙ",
	"prnap": "⪹",
	"prnE": "⪵",
	"prnsim": "⋨",
	"prod": "∏",
	"Product": "∏",
	"profalar": "⌮",
	"profline": "⌒",
	"profsurf": "⌓",
	"prop": "∝",
	"Proportional": "∝",
	"Proportion": "∷",
	"propto": "∝",
	"prsim": "≾",
	"prurel": "⊰",
	"Pscr": "𝒫",
	"pscr": "𝓅",
	"Psi": "Ψ",
	"psi": "ψ",
	"puncsp": " ",
	"Qfr": "𝔔",
	"qfr": "𝔮",
	"qint": "⨌",
	"qopf": "𝕢",
	"Qopf": "ℚ",
	"qprime": "⁗",
	"Qscr": "𝒬",
	"qscr": "𝓆",
	"quaternions": "ℍ",
	"quatint": "⨖",
	"quest": "?",
	"questeq": "≟",
	"quot": "\"",
	"QUOT": "\"",
	"rAarr": "⇛",
	"race": "∽̱",
	"Racute": "Ŕ",
	"racute": "ŕ",
	"radic": "√",
	"raemptyv": "⦳",
	"rang": "⟩",
	"Rang": "⟫",
	"rangd": "⦒",
	"range": "⦥",
	"rangle": "⟩",
	"raquo": "»",
	"rarrap": "⥵",
	"rarrb": "⇥",
	"rarrbfs": "⤠",
	"rarrc": "⤳",
	"rarr": "→",
	"Rarr": "↠",
	"rArr": "⇒",
	"rarrfs": "⤞",
	"rarrhk": "↪",
	"rarrlp": "↬",
	"rarrpl": "⥅",
	"rarrsim": "⥴",
	"Rarrtl": "⤖",
	"rarrtl": "↣",
	"rarrw": "↝",
	"ratail": "⤚",
	"rAtail": "⤜",
	"ratio": "∶",
	"rationals": "ℚ",
	"rbarr": "⤍",
	"rBarr": "⤏",
	"RBarr": "⤐",
	"rbbrk": "❳",
	"rbrace": "}",
	"rbrack": "]",
	"rbrke": "⦌",
	"rbrksld": "⦎",
	"rbrkslu": "⦐",
	"Rcaron": "Ř",
	"rcaron": "ř",
	"Rcedil": "Ŗ",
	"rcedil": "ŗ",
	"rceil": "⌉",
	"rcub": "}",
	"Rcy": "Р",
	"rcy": "р",
	"rdca": "⤷",
	"rdldhar": "⥩",
	"rdquo": "”",
	"rdquor": "”",
	"rdsh": "↳",
	"real": "ℜ",
	"realine": "ℛ",
	"realpart": "ℜ",
	"reals": "ℝ",
	"Re": "ℜ",
	"rect": "▭",
	"reg": "®",
	"REG": "®",
	"ReverseElement": "∋",
	"ReverseEquilibrium": "⇋",
	"ReverseUpEquilibrium": "⥯",
	"rfisht": "⥽",
	"rfloor": "⌋",
	"rfr": "𝔯",
	"Rfr": "ℜ",
	"rHar": "⥤",
	"rhard": "⇁",
	"rharu": "⇀",
	"rharul": "⥬",
	"Rho": "Ρ",
	"rho": "ρ",
	"rhov": "ϱ",
	"RightAngleBracket": "⟩",
	"RightArrowBar": "⇥",
	"rightarrow": "→",
	"RightArrow": "→",
	"Rightarrow": "⇒",
	"RightArrowLeftArrow": "⇄",
	"rightarrowtail": "↣",
	"RightCeiling": "⌉",
	"RightDoubleBracket": "⟧",
	"RightDownTeeVector": "⥝",
	"RightDownVectorBar": "⥕",
	"RightDownVector": "⇂",
	"RightFloor": "⌋",
	"rightharpoondown": "⇁",
	"rightharpoonup": "⇀",
	"rightleftarrows": "⇄",
	"rightleftharpoons": "⇌",
	"rightrightarrows": "⇉",
	"rightsquigarrow": "↝",
	"RightTeeArrow": "↦",
	"RightTee": "⊢",
	"RightTeeVector": "⥛",
	"rightthreetimes": "⋌",
	"RightTriangleBar": "⧐",
	"RightTriangle": "⊳",
	"RightTriangleEqual": "⊵",
	"RightUpDownVector": "⥏",
	"RightUpTeeVector": "⥜",
	"RightUpVectorBar": "⥔",
	"RightUpVector": "↾",
	"RightVectorBar": "⥓",
	"RightVector": "⇀",
	"ring": "˚",
	"risingdotseq": "≓",
	"rlarr": "⇄",
	"rlhar": "⇌",
	"rlm": "‏",
	"rmoustache": "⎱",
	"rmoust": "⎱",
	"rnmid": "⫮",
	"roang": "⟭",
	"roarr": "⇾",
	"robrk": "⟧",
	"ropar": "⦆",
	"ropf": "𝕣",
	"Ropf": "ℝ",
	"roplus": "⨮",
	"rotimes": "⨵",
	"RoundImplies": "⥰",
	"rpar": ")",
	"rpargt": "⦔",
	"rppolint": "⨒",
	"rrarr": "⇉",
	"Rrightarrow": "⇛",
	"rsaquo": "›",
	"rscr": "𝓇",
	"Rscr": "ℛ",
	"rsh": "↱",
	"Rsh": "↱",
	"rsqb": "]",
	"rsquo": "’",
	"rsquor": "’",
	"rthree": "⋌",
	"rtimes": "⋊",
	"rtri": "▹",
	"rtrie": "⊵",
	"rtrif": "▸",
	"rtriltri": "⧎",
	"RuleDelayed": "⧴",
	"ruluhar": "⥨",
	"rx": "℞",
	"Sacute": "Ś",
	"sacute": "ś",
	"sbquo": "‚",
	"scap": "⪸",
	"Scaron": "Š",
	"scaron": "š",
	"Sc": "⪼",
	"sc": "≻",
	"sccue": "≽",
	"sce": "⪰",
	"scE": "⪴",
	"Scedil": "Ş",
	"scedil": "ş",
	"Scirc": "Ŝ",
	"scirc": "ŝ",
	"scnap": "⪺",
	"scnE": "⪶",
	"scnsim": "⋩",
	"scpolint": "⨓",
	"scsim": "≿",
	"Scy": "С",
	"scy": "с",
	"sdotb": "⊡",
	"sdot": "⋅",
	"sdote": "⩦",
	"searhk": "⤥",
	"searr": "↘",
	"seArr": "⇘",
	"searrow": "↘",
	"sect": "§",
	"semi": ";",
	"seswar": "⤩",
	"setminus": "∖",
	"setmn": "∖",
	"sext": "✶",
	"Sfr": "𝔖",
	"sfr": "𝔰",
	"sfrown": "⌢",
	"sharp": "♯",
	"SHCHcy": "Щ",
	"shchcy": "щ",
	"SHcy": "Ш",
	"shcy": "ш",
	"ShortDownArrow": "↓",
	"ShortLeftArrow": "←",
	"shortmid": "∣",
	"shortparallel": "∥",
	"ShortRightArrow": "→",
	"ShortUpArrow": "↑",
	"shy": "­",
	"Sigma": "Σ",
	"sigma": "σ",
	"sigmaf": "ς",
	"sigmav": "ς",
	"sim": "∼",
	"simdot": "⩪",
	"sime": "≃",
	"simeq": "≃",
	"simg": "⪞",
	"simgE": "⪠",
	"siml": "⪝",
	"simlE": "⪟",
	"simne": "≆",
	"simplus": "⨤",
	"simrarr": "⥲",
	"slarr": "←",
	"SmallCircle": "∘",
	"smallsetminus": "∖",
	"smashp": "⨳",
	"smeparsl": "⧤",
	"smid": "∣",
	"smile": "⌣",
	"smt": "⪪",
	"smte": "⪬",
	"smtes": "⪬︀",
	"SOFTcy": "Ь",
	"softcy": "ь",
	"solbar": "⌿",
	"solb": "⧄",
	"sol": "/",
	"Sopf": "𝕊",
	"sopf": "𝕤",
	"spades": "♠",
	"spadesuit": "♠",
	"spar": "∥",
	"sqcap": "⊓",
	"sqcaps": "⊓︀",
	"sqcup": "⊔",
	"sqcups": "⊔︀",
	"Sqrt": "√",
	"sqsub": "⊏",
	"sqsube": "⊑",
	"sqsubset": "⊏",
	"sqsubseteq": "⊑",
	"sqsup": "⊐",
	"sqsupe": "⊒",
	"sqsupset": "⊐",
	"sqsupseteq": "⊒",
	"square": "□",
	"Square": "□",
	"SquareIntersection": "⊓",
	"SquareSubset": "⊏",
	"SquareSubsetEqual": "⊑",
	"SquareSuperset": "⊐",
	"SquareSupersetEqual": "⊒",
	"SquareUnion": "⊔",
	"squarf": "▪",
	"squ": "□",
	"squf": "▪",
	"srarr": "→",
	"Sscr": "𝒮",
	"sscr": "𝓈",
	"ssetmn": "∖",
	"ssmile": "⌣",
	"sstarf": "⋆",
	"Star": "⋆",
	"star": "☆",
	"starf": "★",
	"straightepsilon": "ϵ",
	"straightphi": "ϕ",
	"strns": "¯",
	"sub": "⊂",
	"Sub": "⋐",
	"subdot": "⪽",
	"subE": "⫅",
	"sube": "⊆",
	"subedot": "⫃",
	"submult": "⫁",
	"subnE": "⫋",
	"subne": "⊊",
	"subplus": "⪿",
	"subrarr": "⥹",
	"subset": "⊂",
	"Subset": "⋐",
	"subseteq": "⊆",
	"subseteqq": "⫅",
	"SubsetEqual": "⊆",
	"subsetneq": "⊊",
	"subsetneqq": "⫋",
	"subsim": "⫇",
	"subsub": "⫕",
	"subsup": "⫓",
	"succapprox": "⪸",
	"succ": "≻",
	"succcurlyeq": "≽",
	"Succeeds": "≻",
	"SucceedsEqual": "⪰",
	"SucceedsSlantEqual": "≽",
	"SucceedsTilde": "≿",
	"succeq": "⪰",
	"succnapprox": "⪺",
	"succneqq": "⪶",
	"succnsim": "⋩",
	"succsim": "≿",
	"SuchThat": "∋",
	"sum": "∑",
	"Sum": "∑",
	"sung": "♪",
	"sup1": "¹",
	"sup2": "²",
	"sup3": "³",
	"sup": "⊃",
	"Sup": "⋑",
	"supdot": "⪾",
	"supdsub": "⫘",
	"supE": "⫆",
	"supe": "⊇",
	"supedot": "⫄",
	"Superset": "⊃",
	"SupersetEqual": "⊇",
	"suphsol": "⟉",
	"suphsub": "⫗",
	"suplarr": "⥻",
	"supmult": "⫂",
	"supnE": "⫌",
	"supne": "⊋",
	"supplus": "⫀",
	"supset": "⊃",
	"Supset": "⋑",
	"supseteq": "⊇",
	"supseteqq": "⫆",
	"supsetneq": "⊋",
	"supsetneqq": "⫌",
	"supsim": "⫈",
	"supsub": "⫔",
	"supsup": "⫖",
	"swarhk": "⤦",
	"swarr": "↙",
	"swArr": "⇙",
	"swarrow": "↙",
	"swnwar": "⤪",
	"szlig": "ß",
	"Tab": "\t",
	"target": "⌖",
	"Tau": "Τ",
	"tau": "τ",
	"tbrk": "⎴",
	"Tcaron": "Ť",
	"tcaron": "ť",
	"Tcedil": "Ţ",
	"tcedil": "ţ",
	"Tcy": "Т",
	"tcy": "т",
	"tdot": "⃛",
	"telrec": "⌕",
	"Tfr": "𝔗",
	"tfr": "𝔱",
	"there4": "∴",
	"therefore": "∴",
	"Therefore": "∴",
	"Theta": "Θ",
	"theta": "θ",
	"thetasym": "ϑ",
	"thetav": "ϑ",
	"thickapprox": "≈",
	"thicksim": "∼",
	"ThickSpace": "  ",
	"ThinSpace": " ",
	"thinsp": " ",
	"thkap": "≈",
	"thksim": "∼",
	"THORN": "Þ",
	"thorn": "þ",
	"tilde": "˜",
	"Tilde": "∼",
	"TildeEqual": "≃",
	"TildeFullEqual": "≅",
	"TildeTilde": "≈",
	"timesbar": "⨱",
	"timesb": "⊠",
	"times": "×",
	"timesd": "⨰",
	"tint": "∭",
	"toea": "⤨",
	"topbot": "⌶",
	"topcir": "⫱",
	"top": "⊤",
	"Topf": "𝕋",
	"topf": "𝕥",
	"topfork": "⫚",
	"tosa": "⤩",
	"tprime": "‴",
	"trade": "™",
	"TRADE": "™",
	"triangle": "▵",
	"triangledown": "▿",
	"triangleleft": "◃",
	"trianglelefteq": "⊴",
	"triangleq": "≜",
	"triangleright": "▹",
	"trianglerighteq": "⊵",
	"tridot": "◬",
	"trie": "≜",
	"triminus": "⨺",
	"TripleDot": "⃛",
	"triplus": "⨹",
	"trisb": "⧍",
	"tritime": "⨻",
	"trpezium": "⏢",
	"Tscr": "𝒯",
	"tscr": "𝓉",
	"TScy": "Ц",
	"tscy": "ц",
	"TSHcy": "Ћ",
	"tshcy": "ћ",
	"Tstrok": "Ŧ",
	"tstrok": "ŧ",
	"twixt": "≬",
	"twoheadleftarrow": "↞",
	"twoheadrightarrow": "↠",
	"Uacute": "Ú",
	"uacute": "ú",
	"uarr": "↑",
	"Uarr": "↟",
	"uArr": "⇑",
	"Uarrocir": "⥉",
	"Ubrcy": "Ў",
	"ubrcy": "ў",
	"Ubreve": "Ŭ",
	"ubreve": "ŭ",
	"Ucirc": "Û",
	"ucirc": "û",
	"Ucy": "У",
	"ucy": "у",
	"udarr": "⇅",
	"Udblac": "Ű",
	"udblac": "ű",
	"udhar": "⥮",
	"ufisht": "⥾",
	"Ufr": "𝔘",
	"ufr": "𝔲",
	"Ugrave": "Ù",
	"ugrave": "ù",
	"uHar": "⥣",
	"uharl": "↿",
	"uharr": "↾",
	"uhblk": "▀",
	"ulcorn": "⌜",
	"ulcorner": "⌜",
	"ulcrop": "⌏",
	"ultri": "◸",
	"Umacr": "Ū",
	"umacr": "ū",
	"uml": "¨",
	"UnderBar": "_",
	"UnderBrace": "⏟",
	"UnderBracket": "⎵",
	"UnderParenthesis": "⏝",
	"Union": "⋃",
	"UnionPlus": "⊎",
	"Uogon": "Ų",
	"uogon": "ų",
	"Uopf": "𝕌",
	"uopf": "𝕦",
	"UpArrowBar": "⤒",
	"uparrow": "↑",
	"UpArrow": "↑",
	"Uparrow": "⇑",
	"UpArrowDownArrow": "⇅",
	"updownarrow": "↕",
	"UpDownArrow": "↕",
	"Updownarrow": "⇕",
	"UpEquilibrium": "⥮",
	"upharpoonleft": "↿",
	"upharpoonright": "↾",
	"uplus": "⊎",
	"UpperLeftArrow": "↖",
	"UpperRightArrow": "↗",
	"upsi": "υ",
	"Upsi": "ϒ",
	"upsih": "ϒ",
	"Upsilon": "Υ",
	"upsilon": "υ",
	"UpTeeArrow": "↥",
	"UpTee": "⊥",
	"upuparrows": "⇈",
	"urcorn": "⌝",
	"urcorner": "⌝",
	"urcrop": "⌎",
	"Uring": "Ů",
	"uring": "ů",
	"urtri": "◹",
	"Uscr": "𝒰",
	"uscr": "𝓊",
	"utdot": "⋰",
	"Utilde": "Ũ",
	"utilde": "ũ",
	"utri": "▵",
	"utrif": "▴",
	"uuarr": "⇈",
	"Uuml": "Ü",
	"uuml": "ü",
	"uwangle": "⦧",
	"vangrt": "⦜",
	"varepsilon": "ϵ",
	"varkappa": "ϰ",
	"varnothing": "∅",
	"varphi": "ϕ",
	"varpi": "ϖ",
	"varpropto": "∝",
	"varr": "↕",
	"vArr": "⇕",
	"varrho": "ϱ",
	"varsigma": "ς",
	"varsubsetneq": "⊊︀",
	"varsubsetneqq": "⫋︀",
	"varsupsetneq": "⊋︀",
	"varsupsetneqq": "⫌︀",
	"vartheta": "ϑ",
	"vartriangleleft": "⊲",
	"vartriangleright": "⊳",
	"vBar": "⫨",
	"Vbar": "⫫",
	"vBarv": "⫩",
	"Vcy": "В",
	"vcy": "в",
	"vdash": "⊢",
	"vDash": "⊨",
	"Vdash": "⊩",
	"VDash": "⊫",
	"Vdashl": "⫦",
	"veebar": "⊻",
	"vee": "∨",
	"Vee": "⋁",
	"veeeq": "≚",
	"vellip": "⋮",
	"verbar": "|",
	"Verbar": "‖",
	"vert": "|",
	"Vert": "‖",
	"VerticalBar": "∣",
	"VerticalLine": "|",
	"VerticalSeparator": "❘",
	"VerticalTilde": "≀",
	"VeryThinSpace": " ",
	"Vfr": "𝔙",
	"vfr": "𝔳",
	"vltri": "⊲",
	"vnsub": "⊂⃒",
	"vnsup": "⊃⃒",
	"Vopf": "𝕍",
	"vopf": "𝕧",
	"vprop": "∝",
	"vrtri": "⊳",
	"Vscr": "𝒱",
	"vscr": "𝓋",
	"vsubnE": "⫋︀",
	"vsubne": "⊊︀",
	"vsupnE": "⫌︀",
	"vsupne": "⊋︀",
	"Vvdash": "⊪",
	"vzigzag": "⦚",
	"Wcirc": "Ŵ",
	"wcirc": "ŵ",
	"wedbar": "⩟",
	"wedge": "∧",
	"Wedge": "⋀",
	"wedgeq": "≙",
	"weierp": "℘",
	"Wfr": "𝔚",
	"wfr": "𝔴",
	"Wopf": "𝕎",
	"wopf": "𝕨",
	"wp": "℘",
	"wr": "≀",
	"wreath": "≀",
	"Wscr": "𝒲",
	"wscr": "𝓌",
	"xcap": "⋂",
	"xcirc": "◯",
	"xcup": "⋃",
	"xdtri": "▽",
	"Xfr": "𝔛",
	"xfr": "𝔵",
	"xharr": "⟷",
	"xhArr": "⟺",
	"Xi": "Ξ",
	"xi": "ξ",
	"xlarr": "⟵",
	"xlArr": "⟸",
	"xmap": "⟼",
	"xnis": "⋻",
	"xodot": "⨀",
	"Xopf": "𝕏",
	"xopf": "𝕩",
	"xoplus": "⨁",
	"xotime": "⨂",
	"xrarr": "⟶",
	"xrArr": "⟹",
	"Xscr": "𝒳",
	"xscr": "𝓍",
	"xsqcup": "⨆",
	"xuplus": "⨄",
	"xutri": "△",
	"xvee": "⋁",
	"xwedge": "⋀",
	"Yacute": "Ý",
	"yacute": "ý",
	"YAcy": "Я",
	"yacy": "я",
	"Ycirc": "Ŷ",
	"ycirc": "ŷ",
	"Ycy": "Ы",
	"ycy": "ы",
	"yen": "¥",
	"Yfr": "𝔜",
	"yfr": "𝔶",
	"YIcy": "Ї",
	"yicy": "ї",
	"Yopf": "𝕐",
	"yopf": "𝕪",
	"Yscr": "𝒴",
	"yscr": "𝓎",
	"YUcy": "Ю",
	"yucy": "ю",
	"yuml": "ÿ",
	"Yuml": "Ÿ",
	"Zacute": "Ź",
	"zacute": "ź",
	"Zcaron": "Ž",
	"zcaron": "ž",
	"Zcy": "З",
	"zcy": "з",
	"Zdot": "Ż",
	"zdot": "ż",
	"zeetrf": "ℨ",
	"ZeroWidthSpace": "​",
	"Zeta": "Ζ",
	"zeta": "ζ",
	"zfr": "𝔷",
	"Zfr": "ℨ",
	"ZHcy": "Ж",
	"zhcy": "ж",
	"zigrarr": "⇝",
	"zopf": "𝕫",
	"Zopf": "ℤ",
	"Zscr": "𝒵",
	"zscr": "𝓏",
	"zwj": "‍",
	"zwnj": "‌"
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.span = vnode.attrs.span;
    vnode.state.cls = vnode.attrs.cls;
  },
  view: function view(vnode) {
    return (0, _mithril2.default)(
      'div',
      { className: 'mdl-cell mdl-cell--' + vnode.state.span + '-col ' + vnode.state.cls },
      vnode.attrs.inner
    );
  }
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(91);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(92)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(79);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(78);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.oninput = function (v) {
      vnode.state.model.data.body = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'textarea',
      {
        className: _styles2.default.textarea,
        oninput: _mithril2.default.withAttr('value', vnode.state.oninput) },
      vnode.state.model.data.body
    );
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorLeftSide, inner: inner });
  }
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(79);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(78);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(vnode) {
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorRightSide,
      inner: _mithril2.default.trust(vnode.attrs.body) });
  }
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(79);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(78);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'button',
      {
        className: 'mdl-button mdl-js-button mdl-button--raised mdl-button--colored',
        onclick: vnode.state.model.save },
      'save'
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, cls: _styles2.default.saveButton, inner: inner });
  }
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(79);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(78);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.tags = v.split(',');
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.tags,
      onchange: _mithril2.default.withAttr('value', vnode.state.onchanage),
      value: vnode.state.model.data.tags.join(',')
    });
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _cell = __webpack_require__(78);

var _cell2 = _interopRequireDefault(_cell);

var _styles = __webpack_require__(79);

var _styles2 = _interopRequireDefault(_styles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.title = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.title,
      onchange: _mithril2.default.withAttr('value', vnode.state.onchange),
      value: vnode.state.model.data.title
    });
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(85);
var ieee754 = __webpack_require__(88);
var isArray = __webpack_require__(89);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(86).Buffer))

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(87)(undefined);
// imports


// module
exports.push([module.i, ".ZeW3HIwa_BWIGW0yZJi5G{width:100%;font-size:24pt;padding-left:10px}.ZcsaZvcof0txWdeqikCGZ{width:100%;font-size:18pt;padding-left:10px}._1ouasj646M7i9oKw-0Q_55{position:relative;width:100%;height:calc(100% - 230px)}._2MLWR8W_pHfNBkBmp0ni08{position:absolute;top:0;background:#fcfcfc;padding:10px;overflow:auto;height:100%}.GJYonSHLOXZJhPSUwZdvb{left:0}.u_RSyvBLD7b0Z12hpK8D4{left:50%;background-color:#fff}._2gAtgm9oADOrZYt1udmcJR{text-align:right;margin-top:15px}._3NBbIr4WlHyUQc29YW6bSX{width:100%;height:100%;resize:none;background-color:#fcfcfc;border:none;font-size:10pt}", ""]);

// exports
exports.locals = {
	"title": "ZeW3HIwa_BWIGW0yZJi5G",
	"tags": "ZcsaZvcof0txWdeqikCGZ",
	"editorWrap": "_1ouasj646M7i9oKw-0Q_55",
	"editor": "_2MLWR8W_pHfNBkBmp0ni08",
	"editorLeftSide": "GJYonSHLOXZJhPSUwZdvb",
	"editorRightSide": "u_RSyvBLD7b0Z12hpK8D4",
	"saveButton": "_2gAtgm9oADOrZYt1udmcJR",
	"textarea": "_3NBbIr4WlHyUQc29YW6bSX"
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(90);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(87)(undefined);
// imports


// module
exports.push([module.i, "._2YrKEmruSXq-LY8HT9gjcA{position:relative;width:100%;height:calc(100% - 230px)}._3L5NEB84KxPflxBZveysdd{text-align:right;margin-top:15px}", ""]);

// exports
exports.locals = {
	"editorWrap": "_2YrKEmruSXq-LY8HT9gjcA",
	"saveButton": "_3L5NEB84KxPflxBZveysdd"
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(93);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(92)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMTZmODhlN2U5OTVhNWNmZDY2NWUiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9taXRocmlsL21pdGhyaWwuanMiLCJ3ZWJwYWNrOi8vLy4vZW50cnkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvdG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvbW9kZWxzL2FydGljbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2xpbmtpZnktaXQvbGliL3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2xhYmVsLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9odG1sX2lubGluZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZW5jb2RlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvY2VsbC5qcyIsIndlYnBhY2s6Ly8vLi4vbGlicy9jb21wb25lbnRzL3N0eWxlcy5jc3M/MTRjOSIsIndlYnBhY2s6Ly8vLi4vbGlicy9jb21wb25lbnRzL2VkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbGlicy9jb21wb25lbnRzL3ByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvY29tcG9uZW50cy9zYXZlLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvdGFncy5qcyIsIndlYnBhY2s6Ly8vLi4vbGlicy9jb21wb25lbnRzL3RpdGxlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3N0eWxlLWxvYWRlci9maXhVcmxzLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvc3R5bGVzLmNzcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzLmNzcz8yMjNhIl0sIm5hbWVzIjpbImciLCJGdW5jdGlvbiIsImV2YWwiLCJlIiwid2luZG93IiwibW9kdWxlIiwiZXhwb3J0cyIsIlZub2RlIiwidGFnIiwia2V5IiwiYXR0cnMwIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZG9tIiwiYXR0cnMiLCJkb21TaXplIiwidW5kZWZpbmVkIiwic3RhdGUiLCJfc3RhdGUiLCJldmVudHMiLCJpbnN0YW5jZSIsInNraXAiLCJub3JtYWxpemUiLCJub2RlIiwiQXJyYXkiLCJpc0FycmF5Iiwibm9ybWFsaXplQ2hpbGRyZW4iLCJpIiwibGVuZ3RoIiwic2VsZWN0b3JQYXJzZXIiLCJzZWxlY3RvckNhY2hlIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJjb21waWxlU2VsZWN0b3IiLCJzZWxlY3RvciIsIm1hdGNoIiwiY2xhc3NlcyIsImV4ZWMiLCJ0eXBlIiwidmFsdWUiLCJpZCIsInB1c2giLCJhdHRyVmFsdWUiLCJyZXBsYWNlIiwiY2xhc3NOYW1lIiwiam9pbiIsImV4ZWNTZWxlY3RvciIsImhhc0F0dHJzIiwiY2hpbGRMaXN0IiwiY2xhc3MiLCJjYWxsIiwiaHlwZXJzY3JpcHQiLCJhcmd1bWVudHMiLCJzdGFydCIsInZpZXciLCJFcnJvciIsImNhY2hlZCIsIm5vcm1hbGl6ZWQiLCJ0cnVzdCIsImh0bWwiLCJmcmFnbWVudCIsImF0dHJzMSIsIm0iLCJQcm9taXNlUG9seWZpbGwiLCJleGVjdXRvciIsIlR5cGVFcnJvciIsInNlbGYiLCJyZXNvbHZlcnMiLCJyZWplY3RvcnMiLCJyZXNvbHZlQ3VycmVudCIsImhhbmRsZXIiLCJyZWplY3RDdXJyZW50IiwiX2luc3RhbmNlIiwiY2FsbEFzeW5jIiwic2V0SW1tZWRpYXRlIiwic2V0VGltZW91dCIsImxpc3QiLCJzaG91bGRBYnNvcmIiLCJleGVjdXRlIiwidGhlbiIsImV4ZWN1dGVPbmNlIiwiYmluZCIsImNvbnNvbGUiLCJlcnJvciIsInJldHJ5IiwicnVucyIsInJ1biIsImZuIiwib25lcnJvciIsInByb3RvdHlwZSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3Rpb24iLCJoYW5kbGUiLCJjYWxsYmFjayIsIm5leHQiLCJyZXNvbHZlTmV4dCIsInJlamVjdE5leHQiLCJwcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhdGNoIiwiYWxsIiwidG90YWwiLCJjb3VudCIsInZhbHVlcyIsImNvbnN1bWUiLCJyYWNlIiwiUHJvbWlzZSIsImdsb2JhbCIsImJ1aWxkUXVlcnlTdHJpbmciLCJvYmplY3QiLCJPYmplY3QiLCJ0b1N0cmluZyIsImFyZ3MiLCJrZXkwIiwiZGVzdHJ1Y3R1cmUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJGSUxFX1BST1RPQ09MX1JFR0VYIiwiUmVnRXhwIiwiXzgiLCIkd2luZG93IiwiY2FsbGJhY2tDb3VudCIsIm9uY29tcGxldGlvbiIsInNldENvbXBsZXRpb25DYWxsYmFjayIsImZpbmFsaXplciIsImNvbXBsZXRlIiwiZmluYWxpemUiLCJwcm9taXNlMCIsInRoZW4wIiwiYXBwbHkiLCJleHRyYSIsInVybCIsInJlcXVlc3QiLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInVzZUJvZHkiLCJzZXJpYWxpemUiLCJGb3JtRGF0YSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzZXJpYWxpemUiLCJleHRyYWN0IiwiaW50ZXJwb2xhdGUiLCJhc3NlbWJsZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiYWJvcnRlZCIsIl9hYm9ydCIsImFib3J0Iiwib3BlbiIsImFzeW5jIiwidXNlciIsInBhc3N3b3JkIiwic2V0UmVxdWVzdEhlYWRlciIsIndpdGhDcmVkZW50aWFscyIsImhlYWRlcnMiLCJjb25maWciLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJ0ZXN0IiwiY2FzdCIsInJlc3BvbnNlVGV4dCIsInNlbmQiLCJiYWNrZ3JvdW5kIiwianNvbnAiLCJjYWxsYmFja05hbWUiLCJNYXRoIiwicm91bmQiLCJyYW5kb20iLCJzY3JpcHQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjYWxsYmFja0tleSIsInNyYyIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwidG9rZW5zIiwic2xpY2UiLCJxdWVyeXN0cmluZyIsInByZWZpeCIsImluZGV4T2YiLCJwYXJzZSIsInR5cGUwIiwicmVxdWVzdFNlcnZpY2UiLCJjb3JlUmVuZGVyZXIiLCIkZG9jIiwiJGVtcHR5RnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50Iiwib25ldmVudCIsInNldEV2ZW50Q2FsbGJhY2siLCJjcmVhdGVOb2RlcyIsInBhcmVudCIsInZub2RlcyIsImVuZCIsImhvb2tzIiwibmV4dFNpYmxpbmciLCJucyIsInZub2RlIiwiY3JlYXRlTm9kZSIsImluaXRMaWZlY3ljbGUiLCJjcmVhdGVUZXh0IiwiY3JlYXRlSFRNTCIsImNyZWF0ZUZyYWdtZW50IiwiY3JlYXRlQ29tcG9uZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJpbnNlcnROb2RlIiwibWF0Y2gxIiwicGFyZW50MSIsImNhcHRpb24iLCJ0aGVhZCIsInRib2R5IiwidGZvb3QiLCJ0ciIsInRoIiwidGQiLCJjb2xncm91cCIsImNvbCIsInRlbXAiLCJpbm5lckhUTUwiLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImNoaWxkIiwiYXR0cnMyIiwiaXMiLCJlbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwic2V0QXR0cnMiLCJjb250ZW50ZWRpdGFibGUiLCJzZXRDb250ZW50RWRpdGFibGUiLCJ0ZXh0Q29udGVudCIsInNldExhdGVBdHRycyIsImluaXRDb21wb25lbnQiLCJzZW50aW5lbCIsImNyZWF0ZSIsIiQkcmVlbnRyYW50TG9jayQkIiwidXBkYXRlTm9kZXMiLCJvbGQiLCJyZWN5Y2xpbmciLCJyZW1vdmVOb2RlcyIsImlzVW5rZXllZCIsImdldE5leHRTaWJsaW5nIiwidXBkYXRlTm9kZSIsImlzUmVjeWNsYWJsZSIsInBvb2wiLCJjb25jYXQiLCJvbGRTdGFydCIsIm9sZEVuZCIsIm1hcCIsIm8iLCJ2Iiwic2hvdWxkUmVjeWNsZSIsInRvRnJhZ21lbnQiLCJnZXRLZXlNYXAiLCJvbGRJbmRleCIsIm1vdmFibGUiLCJvbGRUYWciLCJzaG91bGROb3RVcGRhdGUiLCJ1cGRhdGVMaWZlY3ljbGUiLCJ1cGRhdGVUZXh0IiwidXBkYXRlSFRNTCIsInVwZGF0ZUZyYWdtZW50IiwidXBkYXRlRWxlbWVudCIsInVwZGF0ZUNvbXBvbmVudCIsInJlbW92ZU5vZGUiLCJub2RlVmFsdWUiLCJ1cGRhdGVBdHRycyIsImFicyIsIm9sZENoaWxkcmVuTGVuZ3RoIiwicG9vbENoaWxkcmVuTGVuZ3RoIiwidm5vZGVzQ2hpbGRyZW5MZW5ndGgiLCJrZXkyIiwiY291bnQwIiwiaW5zZXJ0QmVmb3JlIiwiY29udGVudCIsImNvbnRleHQiLCJleHBlY3RlZCIsImNhbGxlZCIsIm9uYmVmb3JlcmVtb3ZlIiwicmVzdWx0IiwiY29udGludWF0aW9uIiwib25yZW1vdmUiLCJyZW1vdmVOb2RlRnJvbURPTSIsImhhc0ludGVncmF0aW9uTWV0aG9kcyIsInNldEF0dHIiLCJpc0Zvcm1BdHRyaWJ1dGUiLCJpc0xpZmVjeWNsZU1ldGhvZCIsIm5zTGFzdEluZGV4Iiwic3Vic3RyIiwic2V0QXR0cmlidXRlTlMiLCJ1cGRhdGVFdmVudCIsInVwZGF0ZVN0eWxlIiwiaXNBdHRyaWJ1dGUiLCJpc0N1c3RvbUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwic2VsZWN0ZWRJbmRleCIsImF0dHIiLCJzb3VyY2UiLCJvbmNyZWF0ZSIsIm9udXBkYXRlIiwic3R5bGUiLCJjc3NUZXh0IiwiZXZlbnROYW1lIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmluaXQiLCJmb3JjZVZub2RlVXBkYXRlIiwiZm9yY2VDb21wb25lbnRVcGRhdGUiLCJvbmJlZm9yZXVwZGF0ZSIsInJlbmRlciIsImFjdGl2ZSIsImZvY3VzIiwidGhyb3R0bGUiLCJ0aW1lIiwibGFzdCIsInBlbmRpbmciLCJ0aW1lb3V0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibm93IiwiRGF0ZSIsIl8xMSIsInJlbmRlclNlcnZpY2UiLCJyZWRyYXciLCJjYWxsYmFja3MiLCJzdWJzY3JpYmUiLCJrZXkxIiwidW5zdWJzY3JpYmUiLCJpbmRleCIsInNwbGljZSIsInJlZHJhd1NlcnZpY2UiLCJfMTYiLCJyZWRyYXdTZXJ2aWNlMCIsInJvb3QiLCJjb21wb25lbnQiLCJydW4wIiwibW91bnQiLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic3RyaW5nIiwiY2hhckF0IiwiZW50cmllcyIsInNwbGl0IiwiZGF0YTAiLCJjb3VudGVycyIsImVudHJ5Iiwia2V5NSIsImRlY29kZVVSSUNvbXBvbmVudCIsImxldmVscyIsImN1cnNvciIsInBvcCIsImoiLCJsZXZlbCIsIm5leHRMZXZlbCIsImlzTnVtYmVyIiwiaXNOYU4iLCJwYXJzZUludCIsImlzVmFsdWUiLCJjb3JlUm91dGVyIiwic3VwcG9ydHNQdXNoU3RhdGUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiY2FsbEFzeW5jMCIsIm5vcm1hbGl6ZTEiLCJmcmFnbWVudDAiLCJsb2NhdGlvbiIsImFzeW5jSWQiLCJkZWJvdW5jZUFzeW5jIiwiY2FsbGJhY2swIiwicGFyc2VQYXRoIiwicGF0aCIsInF1ZXJ5RGF0YSIsImhhc2hEYXRhIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsInBhdGhFbmQiLCJxdWVyeUVuZCIsInF1ZXJ5UGFyYW1zIiwia2V5NCIsImhhc2hQYXJhbXMiLCJyb3V0ZXIiLCJnZXRQYXRoIiwidHlwZTIiLCJzZXRQYXRoIiwib3B0aW9ucyIsIm1hdGNoMiIsInRva2VuIiwicXVlcnkiLCJoYXNoIiwidGl0bGUiLCJvbnBvcHN0YXRlIiwicmVwbGFjZVN0YXRlIiwiaHJlZiIsImRlZmluZVJvdXRlcyIsInJvdXRlcyIsInJlc29sdmVSb3V0ZSIsInBhcmFtcyIsInBhdGhuYW1lIiwiayIsInJvdXRlMCIsIm1hdGNoZXIiLCJrZXlzIiwib25oYXNoY2hhbmdlIiwiXzIwIiwicm91dGVTZXJ2aWNlIiwiaWRlbnRpdHkiLCJyZW5kZXIxIiwiYXR0cnMzIiwiY3VycmVudFBhdGgiLCJsYXN0VXBkYXRlIiwicm91dGUiLCJkZWZhdWx0Um91dGUiLCJydW4xIiwiYmFpbCIsInBheWxvYWQiLCJ1cGRhdGUiLCJyb3V0ZVJlc29sdmVyIiwiY29tcCIsIm9ubWF0Y2giLCJyZXNvbHZlZCIsInNldCIsImdldCIsInByZWZpeDAiLCJsaW5rIiwidm5vZGUxIiwib25jbGljayIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ3aGljaCIsInByZXZlbnREZWZhdWx0IiwiZ2V0QXR0cmlidXRlIiwicGFyYW0iLCJrZXkzIiwid2l0aEF0dHIiLCJhdHRyTmFtZSIsImNhbGxiYWNrMSIsImN1cnJlbnRUYXJnZXQiLCJfMjgiLCJ2ZXJzaW9uIiwiZ2V0RWxlbWVudEJ5SWQiLCJwcm9jZXNzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsImxlbiIsIm5leHRUaWNrIiwiSXRlbSIsImFycmF5IiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJuYW1lIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJ0YXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJydW5JZlByZXNlbnQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsImNhblVzZVBvc3RNZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsIm9ubWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsIm9uR2xvYmFsTWVzc2FnZSIsImV2ZW50IiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwiZ2V0UHJvdG90eXBlT2YiLCJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2xvc2UiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIml0ZW0iLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwicmVxdWlyZSIsIl9jbGFzcyIsIm9iaiIsImlzU3RyaW5nIiwiX2hhc093blByb3BlcnR5IiwiaGFzIiwiYXNzaWduIiwic291cmNlcyIsImZvckVhY2giLCJhcnJheVJlcGxhY2VBdCIsInBvcyIsIm5ld0VsZW1lbnRzIiwiaXNWYWxpZEVudGl0eUNvZGUiLCJjIiwiZnJvbUNvZGVQb2ludCIsInN1cnJvZ2F0ZTEiLCJzdXJyb2dhdGUyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiVU5FU0NBUEVfTURfUkUiLCJFTlRJVFlfUkUiLCJVTkVTQ0FQRV9BTExfUkUiLCJESUdJVEFMX0VOVElUWV9URVNUX1JFIiwiZW50aXRpZXMiLCJyZXBsYWNlRW50aXR5UGF0dGVybiIsImNvZGUiLCJjaGFyQ29kZUF0IiwidG9Mb3dlckNhc2UiLCJ1bmVzY2FwZU1kIiwic3RyIiwidW5lc2NhcGVBbGwiLCJlc2NhcGVkIiwiZW50aXR5IiwiSFRNTF9FU0NBUEVfVEVTVF9SRSIsIkhUTUxfRVNDQVBFX1JFUExBQ0VfUkUiLCJIVE1MX1JFUExBQ0VNRU5UUyIsInJlcGxhY2VVbnNhZmVDaGFyIiwiY2giLCJlc2NhcGVIdG1sIiwiUkVHRVhQX0VTQ0FQRV9SRSIsImVzY2FwZVJFIiwiaXNTcGFjZSIsImlzV2hpdGVTcGFjZSIsIlVOSUNPREVfUFVOQ1RfUkUiLCJpc1B1bmN0Q2hhciIsImlzTWRBc2NpaVB1bmN0Iiwibm9ybWFsaXplUmVmZXJlbmNlIiwidHJpbSIsImxpYiIsIm1kdXJsIiwidWNtaWNybyIsIlJ1bGVyIiwiX19ydWxlc19fIiwiX19jYWNoZV9fIiwiX19maW5kX18iLCJfX2NvbXBpbGVfXyIsImNoYWlucyIsInJ1bGUiLCJlbmFibGVkIiwiYWx0IiwiYWx0TmFtZSIsImNoYWluIiwiYXQiLCJvcHQiLCJiZWZvcmUiLCJiZWZvcmVOYW1lIiwicnVsZU5hbWUiLCJhZnRlciIsImFmdGVyTmFtZSIsImVuYWJsZSIsImlnbm9yZUludmFsaWQiLCJpZHgiLCJlbmFibGVPbmx5IiwiZGlzYWJsZSIsImdldFJ1bGVzIiwiY2hhaW5OYW1lIiwiVG9rZW4iLCJuZXN0aW5nIiwibWFya3VwIiwiaW5mbyIsIm1ldGEiLCJibG9jayIsImhpZGRlbiIsImF0dHJJbmRleCIsImF0dHJQdXNoIiwiYXR0ckRhdGEiLCJhdHRyU2V0IiwiYXR0ckdldCIsImF0dHJKb2luIiwiYXR0cl9uYW1lIiwidW5xdW90ZWQiLCJzaW5nbGVfcXVvdGVkIiwiZG91YmxlX3F1b3RlZCIsImF0dHJfdmFsdWUiLCJhdHRyaWJ1dGUiLCJvcGVuX3RhZyIsImNsb3NlX3RhZyIsImNvbW1lbnQiLCJwcm9jZXNzaW5nIiwiZGVjbGFyYXRpb24iLCJjZGF0YSIsIkhUTUxfVEFHX1JFIiwiSFRNTF9PUEVOX0NMT1NFX1RBR19SRSIsInRva2VuaXplIiwiZW1waGFzaXMiLCJzaWxlbnQiLCJzY2FubmVkIiwic2NhbkRlbGltcyIsImRlbGltaXRlcnMiLCJqdW1wIiwiY2FuX29wZW4iLCJjYW5fY2xvc2UiLCJwb3N0UHJvY2VzcyIsInN0YXJ0RGVsaW0iLCJlbmREZWxpbSIsImlzU3Ryb25nIiwibWF4Iiwic3RyaWtldGhyb3VnaCIsImxvbmVNYXJrZXJzIiwiZW5jb2RlIiwiZGVjb2RlIiwiZm9ybWF0IiwibW9kZWwiLCJlZGl0b3JXcmFwIiwibWRCb2R5IiwibWQiLCJNb2RlbCIsImJvZHkiLCJzbHVnIiwicHVibGlzaCIsInRhZ3MiLCJkYXRlIiwiZmV0Y2hlZCIsInJlc291cmNlc1VybCIsInJlc291cmNlVXJsIiwiaXNPYmplY3QiLCJpc1JlZ0V4cCIsImlzRnVuY3Rpb24iLCJkZWZhdWx0T3B0aW9ucyIsImZ1enp5TGluayIsImZ1enp5RW1haWwiLCJmdXp6eUlQIiwiaXNPcHRpb25zT2JqIiwicmVkdWNlIiwiYWNjIiwiZGVmYXVsdFNjaGVtYXMiLCJ2YWxpZGF0ZSIsInRhaWwiLCJyZSIsImh0dHAiLCJzcmNfYXV0aCIsInNyY19ob3N0X3BvcnRfc3RyaWN0Iiwic3JjX3BhdGgiLCJub19odHRwIiwic3JjX2RvbWFpbiIsInNyY19kb21haW5fcm9vdCIsInNyY19wb3J0Iiwic3JjX2hvc3RfdGVybWluYXRvciIsIm1haWx0byIsInNyY19lbWFpbF9uYW1lIiwic3JjX2hvc3Rfc3RyaWN0IiwidGxkc18yY2hfc3JjX3JlIiwidGxkc19kZWZhdWx0IiwicmVzZXRTY2FuQ2FjaGUiLCJfX2luZGV4X18iLCJfX3RleHRfY2FjaGVfXyIsImNyZWF0ZVZhbGlkYXRvciIsImNyZWF0ZU5vcm1hbGl6ZXIiLCJjb21waWxlIiwiX19vcHRzX18iLCJ0bGRzIiwiX190bGRzX18iLCJvbkNvbXBpbGUiLCJfX3RsZHNfcmVwbGFjZWRfXyIsInNyY194biIsInNyY190bGRzIiwidW50cGwiLCJ0cGwiLCJlbWFpbF9mdXp6eSIsInRwbF9lbWFpbF9mdXp6eSIsImxpbmtfZnV6enkiLCJ0cGxfbGlua19mdXp6eSIsImxpbmtfbm9faXBfZnV6enkiLCJ0cGxfbGlua19ub19pcF9mdXp6eSIsImhvc3RfZnV6enlfdGVzdCIsInRwbF9ob3N0X2Z1enp5X3Rlc3QiLCJhbGlhc2VzIiwiX19jb21waWxlZF9fIiwic2NoZW1hRXJyb3IiLCJ2YWwiLCJfX3NjaGVtYXNfXyIsImNvbXBpbGVkIiwiYWxpYXMiLCJzbGlzdCIsImZpbHRlciIsInNjaGVtYV90ZXN0Iiwic3JjX1pQQ2MiLCJzY2hlbWFfc2VhcmNoIiwicHJldGVzdCIsIk1hdGNoIiwic2hpZnQiLCJfX2xhc3RfaW5kZXhfXyIsInNjaGVtYSIsIl9fc2NoZW1hX18iLCJsYXN0SW5kZXgiLCJyYXciLCJjcmVhdGVNYXRjaCIsIkxpbmtpZnlJdCIsInNjaGVtYXMiLCJhZGQiLCJkZWZpbml0aW9uIiwibWwiLCJtZSIsInRsZF9wb3MiLCJhdF9wb3MiLCJ0ZXN0U2NoZW1hQXQiLCJzZWFyY2giLCJrZWVwT2xkIiwic29ydCIsImVsIiwiYXJyIiwicmV2ZXJzZSIsIm9wdHMiLCJzcmNfQW55Iiwic3JjX0NjIiwic3JjX1oiLCJzcmNfUCIsInNyY19aQ2MiLCJ0ZXh0X3NlcGFyYXRvcnMiLCJzcmNfcHNldWRvX2xldHRlciIsInNyY19pcDQiLCJzcmNfaG9zdCIsInRwbF9ob3N0X2Z1enp5IiwidHBsX2hvc3Rfbm9faXBfZnV6enkiLCJ0cGxfaG9zdF9mdXp6eV9zdHJpY3QiLCJ0cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0IiwicGFyc2VMaW5rTGFiZWwiLCJwYXJzZUxpbmtEZXN0aW5hdGlvbiIsInBhcnNlTGlua1RpdGxlIiwibGluZXMiLCJvayIsImRpc2FibGVOZXN0ZWQiLCJmb3VuZCIsInByZXZQb3MiLCJsYWJlbEVuZCIsInBvc01heCIsIm9sZFBvcyIsImlubGluZSIsInNraXBUb2tlbiIsInV0aWxzIiwiaGVscGVycyIsIlJlbmRlcmVyIiwiUGFyc2VyQ29yZSIsIlBhcnNlckJsb2NrIiwiUGFyc2VySW5saW5lIiwicHVueWNvZGUiLCJ6ZXJvIiwiY29tbW9ubWFyayIsIkJBRF9QUk9UT19SRSIsIkdPT0RfREFUQV9SRSIsInZhbGlkYXRlTGluayIsIlJFQ09ERV9IT1NUTkFNRV9GT1IiLCJub3JtYWxpemVMaW5rIiwicGFyc2VkIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInRvQVNDSUkiLCJlciIsIm5vcm1hbGl6ZUxpbmtUZXh0IiwidG9Vbmljb2RlIiwiTWFya2Rvd25JdCIsInByZXNldE5hbWUiLCJjb3JlIiwicmVuZGVyZXIiLCJsaW5raWZ5IiwiY29uZmlndXJlIiwicHJlc2V0cyIsImNvbXBvbmVudHMiLCJydWxlcyIsInJ1bGVyIiwicnVsZXMyIiwicnVsZXIyIiwibWlzc2VkIiwidXNlIiwicGx1Z2luIiwiU3RhdGUiLCJwYXJzZUlubGluZSIsImlubGluZU1vZGUiLCJyZW5kZXJJbmxpbmUiLCJfcnVsZXMiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibGluZSIsImhhc0VtcHR5TGluZXMiLCJtYXhOZXN0aW5nIiwic2tpcEVtcHR5TGluZXMiLCJzQ291bnQiLCJibGtJbmRlbnQiLCJ0aWdodCIsImlzRW1wdHkiLCJvdXRUb2tlbnMiLCJsaW5lTWF4IiwiQ29yZSIsImwiLCJfcnVsZXMyIiwiY2FjaGUiLCJwdXNoUGVuZGluZyIsInhodG1sT3V0IiwiYnJlYWtzIiwibGFuZ1ByZWZpeCIsInR5cG9ncmFwaGVyIiwicXVvdGVzIiwiaGlnaGxpZ2h0IiwiZGVmYXVsdF9ydWxlcyIsImNvZGVfaW5saW5lIiwic2xmIiwicmVuZGVyQXR0cnMiLCJjb2RlX2Jsb2NrIiwiZmVuY2UiLCJsYW5nTmFtZSIsImhpZ2hsaWdodGVkIiwidG1wQXR0cnMiLCJ0bXBUb2tlbiIsImltYWdlIiwicmVuZGVySW5saW5lQXNUZXh0IiwicmVuZGVyVG9rZW4iLCJoYXJkYnJlYWsiLCJzb2Z0YnJlYWsiLCJodG1sX2Jsb2NrIiwiaHRtbF9pbmxpbmUiLCJuZXh0VG9rZW4iLCJuZWVkTGYiLCJibG9ja3F1b3RlIiwiYWRqdXN0VGFiIiwiaW5pdGlhbCIsImlzT3V0ZGVudGVkIiwibGFzdExpbmVFbXB0eSIsIm5leHRMaW5lIiwib2Zmc2V0Iiwib2xkQk1hcmtzIiwib2xkQlNDb3VudCIsIm9sZEluZGVudCIsIm9sZFBhcmVudFR5cGUiLCJvbGRTQ291bnQiLCJvbGRUU2hpZnQiLCJzcGFjZUFmdGVyTWFya2VyIiwidGVybWluYXRlIiwidGVybWluYXRvclJ1bGVzIiwib2xkTGluZU1heCIsImJNYXJrcyIsInRTaGlmdCIsImVNYXJrcyIsImJzQ291bnQiLCJwYXJlbnRUeXBlIiwiZ2V0TGluZXMiLCJtZW0iLCJoYXZlRW5kTWFya2VyIiwic2tpcENoYXJzIiwic2tpcFNwYWNlcyIsImhlYWRpbmciLCJ0bXAiLCJza2lwU3BhY2VzQmFjayIsInNraXBDaGFyc0JhY2siLCJociIsImNudCIsImJsb2NrX25hbWVzIiwiSFRNTF9TRVFVRU5DRVMiLCJsaW5lVGV4dCIsImxoZWFkaW5nIiwic2tpcEJ1bGxldExpc3RNYXJrZXIiLCJza2lwT3JkZXJlZExpc3RNYXJrZXIiLCJtYXJrVGlnaHRQYXJhZ3JhcGhzIiwiY29udGVudFN0YXJ0IiwiaW5kZW50IiwiaW5kZW50QWZ0ZXJNYXJrZXIiLCJpc09yZGVyZWQiLCJpdGVtTGluZXMiLCJsaXN0TGluZXMiLCJsaXN0VG9rSWR4IiwibWFya2VyQ2hhckNvZGUiLCJtYXJrZXJWYWx1ZSIsIm9sZExJbmRlbnQiLCJvbGRUaWdodCIsInBvc0FmdGVyTWFya2VyIiwicHJldkVtcHR5RW5kIiwiaXNUZXJtaW5hdGluZ1BhcmFncmFwaCIsIk51bWJlciIsIm1pbiIsInBhcmFncmFwaCIsInJlZmVyZW5jZSIsIl9lbmRMaW5lIiwiZGVzdEVuZFBvcyIsImRlc3RFbmRMaW5lTm8iLCJsYWJlbCIsInJlcyIsInJlZmVyZW5jZXMiLCJTdGF0ZUJsb2NrIiwicyIsImluZGVudF9mb3VuZCIsImRkSW5kZW50IiwiZnJvbSIsImJlZ2luIiwia2VlcExhc3RMRiIsImxpbmVJbmRlbnQiLCJmaXJzdCIsImxpbmVTdGFydCIsImdldExpbmUiLCJlc2NhcGVkU3BsaXQiLCJlc2NhcGVzIiwibGFzdFBvcyIsImJhY2tUaWNrZWQiLCJsYXN0QmFja1RpY2siLCJzdWJzdHJpbmciLCJ0YWJsZSIsImNvbHVtbnMiLCJjb2x1bW5Db3VudCIsImFsaWducyIsInQiLCJ0YWJsZUxpbmVzIiwidGJvZHlMaW5lcyIsInRvayIsImlzTGlua09wZW4iLCJpc0xpbmtDbG9zZSIsImN1cnJlbnRUb2tlbiIsIm5vZGVzIiwibG4iLCJodG1sTGlua0xldmVsIiwiZnVsbFVybCIsInVybFRleHQiLCJibG9ja1Rva2VucyIsImxpbmtzIiwiTkVXTElORVNfUkUiLCJOVUxMX1JFIiwiUkFSRV9SRSIsIlNDT1BFRF9BQkJSX1RFU1RfUkUiLCJTQ09QRURfQUJCUl9SRSIsIlNDT1BFRF9BQkJSIiwiciIsInAiLCJ0bSIsInJlcGxhY2VGbiIsInJlcGxhY2Vfc2NvcGVkIiwiaW5saW5lVG9rZW5zIiwiaW5zaWRlX2F1dG9saW5rIiwicmVwbGFjZV9yYXJlIiwiYmxrSWR4IiwiUVVPVEVfVEVTVF9SRSIsIlFVT1RFX1JFIiwiQVBPU1RST1BIRSIsInJlcGxhY2VBdCIsInByb2Nlc3NfaW5saW5lcyIsInRoaXNMZXZlbCIsImxhc3RDaGFyIiwibmV4dENoYXIiLCJpc0xhc3RQdW5jdENoYXIiLCJpc05leHRQdW5jdENoYXIiLCJpc0xhc3RXaGl0ZVNwYWNlIiwiaXNOZXh0V2hpdGVTcGFjZSIsImNhbk9wZW4iLCJjYW5DbG9zZSIsImlzU2luZ2xlIiwic3RhY2siLCJvcGVuUXVvdGUiLCJjbG9zZVF1b3RlIiwiT1VURVIiLCJzaW5nbGUiLCJzbWFydHF1b3RlcyIsIlN0YXRlQ29yZSIsIkVNQUlMX1JFIiwiQVVUT0xJTktfUkUiLCJhdXRvbGluayIsImxpbmtNYXRjaCIsImVtYWlsTWF0Y2giLCJiYWNrdGljayIsIm1hdGNoU3RhcnQiLCJtYXRjaEVuZCIsImxpbmtfcGFpcnMiLCJsYXN0RGVsaW0iLCJjdXJyRGVsaW0iLCJvZGRfbWF0Y2giLCJESUdJVEFMX1JFIiwiTkFNRURfUkUiLCJFU0NBUEVEIiwiZXNjYXBlIiwiaXNMZXR0ZXIiLCJsYyIsImxhYmVsU3RhcnQiLCJwYXJzZVJlZmVyZW5jZSIsIm5ld2xpbmUiLCJwbWF4IiwiU3RhdGVJbmxpbmUiLCJwZW5kaW5nTGV2ZWwiLCJjYW5TcGxpdFdvcmQiLCJsZWZ0X2ZsYW5raW5nIiwicmlnaHRfZmxhbmtpbmciLCJpc1Rlcm1pbmF0b3JDaGFyIiwidGV4dF9jb2xsYXBzZSIsImN1cnIiLCJkZWNvZGVDYWNoZSIsImdldERlY29kZUNhY2hlIiwiZXhjbHVkZSIsImRlZmF1bHRDaGFycyIsInNlcSIsImIxIiwiYjIiLCJiMyIsImI0IiwiY2hyIiwiY29tcG9uZW50Q2hhcnMiLCJlbmNvZGVDYWNoZSIsImdldEVuY29kZUNhY2hlIiwia2VlcEVzY2FwZWQiLCJuZXh0Q29kZSIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsIlVybCIsInByb3RvY29sUGF0dGVybiIsInBvcnRQYXR0ZXJuIiwic2ltcGxlUGF0aFBhdHRlcm4iLCJkZWxpbXMiLCJ1bndpc2UiLCJhdXRvRXNjYXBlIiwibm9uSG9zdENoYXJzIiwiaG9zdEVuZGluZ0NoYXJzIiwiaG9zdG5hbWVNYXhMZW4iLCJob3N0bmFtZVBhcnRQYXR0ZXJuIiwiaG9zdG5hbWVQYXJ0U3RhcnQiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwidXJsUGFyc2UiLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJsb3dlclByb3RvIiwiaGVjIiwicmVzdCIsInNpbXBsZVBhdGgiLCJwcm90byIsImhvc3RFbmQiLCJhdFNpZ24iLCJsYXN0SW5kZXhPZiIsImhvc3QiLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwidW5zaGlmdCIsInFtIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlR2xvYmFsIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZGVsaW1pdGVyIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJlcnJvcnMiLCJiYXNlTWludXNUTWluIiwiZmxvb3IiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJSYW5nZUVycm9yIiwibWFwRG9tYWluIiwicGFydHMiLCJsYWJlbHMiLCJlbmNvZGVkIiwidWNzMmRlY29kZSIsIm91dHB1dCIsImNvdW50ZXIiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiY29kZVBvaW50IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJvdXQiLCJuIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsInciLCJiYXNlTWludXNUIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwiZGVmaW5lIiwiQW55IiwiQ2MiLCJDZiIsIlAiLCJaIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJzcGFuIiwiY2xzIiwiaW5uZXIiLCJvbmlucHV0IiwidGV4dGFyZWEiLCJlZGl0b3IiLCJlZGl0b3JMZWZ0U2lkZSIsImVkaXRvclJpZ2h0U2lkZSIsInNhdmUiLCJzYXZlQnV0dG9uIiwib25jaGFuZ2UiLCJvbmNoYW5hZ2UiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsInBsYWNlSG9sZGVyc0NvdW50IiwiYjY0IiwicGxhY2VIb2xkZXJzIiwiTCIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJleHRyYUJ5dGVzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiYmFzZTY0IiwiaWVlZTc1NCIsIkJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImtNYXhMZW5ndGgiLCJfX3Byb3RvX18iLCJmb28iLCJzdWJhcnJheSIsImNyZWF0ZUJ1ZmZlciIsInRoYXQiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsIlN5bWJvbCIsInNwZWNpZXMiLCJjb25maWd1cmFibGUiLCJhc3NlcnRTaXplIiwic2l6ZSIsImFsbG9jIiwiZmlsbCIsImVuY29kaW5nIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJ3cml0ZSIsImZyb21BcnJheUxpa2UiLCJieXRlT2Zmc2V0IiwiaXNCdWZmZXIiLCJjb3B5IiwiYnVmZmVyIiwiaXNuYW4iLCJiIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsImEiLCJ4IiwieSIsImJ1ZiIsImlzVmlldyIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJlcXVhbHMiLCJpbnNwZWN0IiwidGFyZ2V0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiYXJyYXlJbmRleE9mIiwiaW5kZXhTaXplIiwiYXJyTGVuZ3RoIiwidmFsTGVuZ3RoIiwicmVhZCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwicmVtYWluaW5nIiwic3RyTGVuIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIl9hcnIiLCJmaXJzdEJ5dGUiLCJieXRlc1BlclNlcXVlbmNlIiwic2Vjb25kQnl0ZSIsInRoaXJkQnl0ZSIsImZvdXJ0aEJ5dGUiLCJ0ZW1wQ29kZVBvaW50IiwiZGVjb2RlQ29kZVBvaW50c0FycmF5IiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJjb2RlUG9pbnRzIiwicmV0IiwidG9IZXgiLCJieXRlcyIsIm5ld0J1ZiIsInNsaWNlTGVuIiwiY2hlY2tPZmZzZXQiLCJleHQiLCJyZWFkVUludExFIiwibm9Bc3NlcnQiLCJtdWwiLCJyZWFkVUludEJFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludExFIiwicG93IiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJkc3QiLCJ1c2VTb3VyY2VNYXAiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwiY3NzTWFwcGluZyIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlUm9vdCIsInNvdXJjZU1hcCIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiZCIsIk5hTiIsInJ0IiwibG9nIiwiTE4yIiwiY3NzIiwiYmFzZVVybCIsImN1cnJlbnREaXIiLCJmaXhlZENzcyIsImZ1bGxNYXRjaCIsIm9yaWdVcmwiLCJ1bnF1b3RlZE9yaWdVcmwiLCIkMSIsIm5ld1VybCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hFQSxJQUFJQSxDQUFKOztBQUVBO0FBQ0FBLElBQUssWUFBVztBQUNmLFFBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsS0FBSUEsS0FBS0MsU0FBUyxhQUFULEdBQUwsSUFBa0MsQ0FBQyxHQUFFQyxJQUFILEVBQVMsTUFBVCxDQUF0QztBQUNBLENBSEQsQ0FHRSxPQUFNQyxDQUFOLEVBQVM7QUFDVjtBQUNBLEtBQUcsUUFBT0MsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFyQixFQUNDSixJQUFJSSxNQUFKO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBOztBQUVBQyxPQUFPQyxPQUFQLEdBQWlCTixDQUFqQixDOzs7Ozs7Ozs7OztBQ3BCQSxDQUFFLGFBQVc7QUFDYjs7QUFDQSxVQUFTTyxLQUFULENBQWVDLEdBQWYsRUFBb0JDLEdBQXBCLEVBQXlCQyxNQUF6QixFQUFpQ0MsUUFBakMsRUFBMkNDLElBQTNDLEVBQWlEQyxHQUFqRCxFQUFzRDtBQUNy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QixDQUFzQnFaLEVBQXRCLENBQVA7QUFDRDs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNRLGNBQVQsQ0FBd0JSLEVBQXhCLEVBQTRCO0FBQzFCLFVBQVFBLEVBQVI7QUFDRSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJ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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7OztBQzlrRUE7Ozs7OztrQkFFZTtBQUNia1QsVUFBUSx1QkFBUztBQUNmN0csVUFBTXpMLEtBQU4sQ0FBWTBtQyxJQUFaLEdBQW1CajdCLE1BQU01TCxLQUFOLENBQVk2bUMsSUFBL0I7QUFDQWo3QixVQUFNekwsS0FBTixDQUFZMm1DLEdBQVosR0FBa0JsN0IsTUFBTTVMLEtBQU4sQ0FBWThtQyxHQUE5QjtBQUNELEdBSlk7QUFLYnRrQyxRQUFNLHFCQUFTO0FBQ2IsV0FBTztBQUFBO0FBQUEsUUFBSyxtQ0FBaUNvSixNQUFNekwsS0FBTixDQUFZMG1DLElBQTdDLGFBQXlEajdCLE1BQU16TCxLQUFOLENBQVkybUMsR0FBMUU7QUFDSmw3QixZQUFNNUwsS0FBTixDQUFZK21DO0FBRFIsS0FBUDtBQUdEO0FBVFksQzs7Ozs7O0FDRmY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7Ozs7Ozs7QUNwQkE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7a0JBRWU7QUFDYnQwQixVQUFRLHVCQUFTO0FBQ2Y3RyxVQUFNekwsS0FBTixDQUFZMm5CLEtBQVosR0FBb0JsYyxNQUFNNUwsS0FBTixDQUFZOG5CLEtBQWhDO0FBQ0FsYyxVQUFNekwsS0FBTixDQUFZNm1DLE9BQVosR0FBc0IsYUFBSztBQUN6QnA3QixZQUFNekwsS0FBTixDQUFZMm5CLEtBQVosQ0FBa0JsZ0IsSUFBbEIsQ0FBdUJ1Z0IsSUFBdkIsR0FBOEJuWixDQUE5QjtBQUNELEtBRkQ7QUFHRCxHQU5ZO0FBT2J4TSxRQUFNLHFCQUFTO0FBQ2IsUUFBTXVrQyxRQUFRO0FBQUE7QUFBQTtBQUNaLG1CQUFXLGlCQUFPRSxRQUROO0FBRVosaUJBQVMsa0JBQUV6c0IsUUFBRixDQUFXLE9BQVgsRUFBb0I1TyxNQUFNekwsS0FBTixDQUFZNm1DLE9BQWhDLENBRkc7QUFHVHA3QixZQUFNekwsS0FBTixDQUFZMm5CLEtBQVosQ0FBa0JsZ0IsSUFBbEIsQ0FBdUJ1Z0I7QUFIZCxLQUFkO0FBS0EsV0FBTyx5Q0FBTSxNQUFNLENBQVosRUFBZSxLQUFRLGlCQUFPK2UsTUFBZixTQUF5QixpQkFBT0MsY0FBL0MsRUFBaUUsT0FBT0osS0FBeEUsR0FBUDtBQUNEO0FBZFksQzs7Ozs7Ozs7Ozs7OztBQ0pmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O2tCQUVlO0FBQ2J2a0MsUUFBTSxxQkFBUztBQUNiLFdBQU8seUNBQU0sTUFBTSxDQUFaLEVBQWUsS0FBUSxpQkFBTzBrQyxNQUFmLFNBQXlCLGlCQUFPRSxlQUEvQztBQUNNLGFBQU8sa0JBQUV4a0MsS0FBRixDQUFRZ0osTUFBTTVMLEtBQU4sQ0FBWW1vQixJQUFwQixDQURiLEdBQVA7QUFFRDtBQUpZLEM7Ozs7Ozs7Ozs7Ozs7QUNKZjs7OztBQUNBOzs7O0FBQ0E7Ozs7OztrQkFFZTtBQUNiMVYsVUFBUSx1QkFBUztBQUNmN0csVUFBTXpMLEtBQU4sQ0FBWTJuQixLQUFaLEdBQW9CbGMsTUFBTTVMLEtBQU4sQ0FBWThuQixLQUFoQztBQUNELEdBSFk7QUFJYnRsQixRQUFNLHFCQUFTO0FBQ2IsUUFBTXVrQyxRQUFRO0FBQUE7QUFBQTtBQUNaLG1CQUFVLGlFQURFO0FBRVosaUJBQVNuN0IsTUFBTXpMLEtBQU4sQ0FBWTJuQixLQUFaLENBQWtCdWYsSUFGZjtBQUFBO0FBQUEsS0FBZDtBQUtBLFdBQU8seUNBQU0sTUFBTSxFQUFaLEVBQWdCLEtBQUssaUJBQU9DLFVBQTVCLEVBQXdDLE9BQU9QLEtBQS9DLEdBQVA7QUFDRDtBQVhZLEM7Ozs7Ozs7Ozs7Ozs7QUNKZjs7OztBQUNBOzs7O0FBQ0E7Ozs7OztrQkFFZTtBQUNidDBCLFVBQVEsdUJBQVM7QUFDZjdHLFVBQU16TCxLQUFOLENBQVkybkIsS0FBWixHQUFvQmxjLE1BQU01TCxLQUFOLENBQVk4bkIsS0FBaEM7QUFDQWxjLFVBQU16TCxLQUFOLENBQVlvbkMsUUFBWixHQUF1QixhQUFLO0FBQzFCMzdCLFlBQU16TCxLQUFOLENBQVkybkIsS0FBWixDQUFrQmxnQixJQUFsQixDQUF1QjBnQixJQUF2QixHQUE4QnRaLEVBQUU0RixLQUFGLENBQVEsR0FBUixDQUE5QjtBQUNELEtBRkQ7QUFHRCxHQU5ZO0FBT2JwUyxRQUFNLHFCQUFTO0FBQ2IsUUFBTXVrQyxRQUFRLGtDQUFPLE1BQUssTUFBWixFQUFtQixXQUFXLGlCQUFPemUsSUFBckM7QUFDWixnQkFBVSxrQkFBRTlOLFFBQUYsQ0FBVyxPQUFYLEVBQW9CNU8sTUFBTXpMLEtBQU4sQ0FBWXFuQyxTQUFoQyxDQURFO0FBRVosYUFBTzU3QixNQUFNekwsS0FBTixDQUFZMm5CLEtBQVosQ0FBa0JsZ0IsSUFBbEIsQ0FBdUIwZ0IsSUFBdkIsQ0FBNEJ2bUIsSUFBNUIsQ0FBaUMsR0FBakM7QUFGSyxNQUFkO0FBSUEsV0FBTyx5Q0FBTSxNQUFNLEVBQVosRUFBZ0IsT0FBT2dsQyxLQUF2QixHQUFQO0FBQ0Q7QUFiWSxDOzs7Ozs7Ozs7Ozs7O0FDSmY7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7a0JBRWU7QUFDYnQwQixVQUFRLHVCQUFTO0FBQ2Y3RyxVQUFNekwsS0FBTixDQUFZMm5CLEtBQVosR0FBb0JsYyxNQUFNNUwsS0FBTixDQUFZOG5CLEtBQWhDO0FBQ0FsYyxVQUFNekwsS0FBTixDQUFZb25DLFFBQVosR0FBdUIsYUFBSztBQUMxQjM3QixZQUFNekwsS0FBTixDQUFZMm5CLEtBQVosQ0FBa0JsZ0IsSUFBbEIsQ0FBdUIrUCxLQUF2QixHQUErQjNJLENBQS9CO0FBQ0QsS0FGRDtBQUdELEdBTlk7QUFPYnhNLFFBQU0scUJBQVM7QUFDYixRQUFNdWtDLFFBQVEsa0NBQU8sTUFBSyxNQUFaLEVBQW1CLFdBQVcsaUJBQU9wdkIsS0FBckM7QUFDWixnQkFBVSxrQkFBRTZDLFFBQUYsQ0FBVyxPQUFYLEVBQW9CNU8sTUFBTXpMLEtBQU4sQ0FBWW9uQyxRQUFoQyxDQURFO0FBRVosYUFBTzM3QixNQUFNekwsS0FBTixDQUFZMm5CLEtBQVosQ0FBa0JsZ0IsSUFBbEIsQ0FBdUIrUDtBQUZsQixNQUFkO0FBSUEsV0FBTyx5Q0FBTSxNQUFNLEVBQVosRUFBZ0IsT0FBT292QixLQUF2QixHQUFQO0FBQ0Q7QUFiWSxDOzs7Ozs7O0FDSmY7O0FBRUF2bkMsUUFBUWlvQyxVQUFSLEdBQXFCQSxVQUFyQjtBQUNBam9DLFFBQVFrb0MsV0FBUixHQUFzQkEsV0FBdEI7QUFDQWxvQyxRQUFRbW9DLGFBQVIsR0FBd0JBLGFBQXhCOztBQUVBLElBQUlDLFNBQVMsRUFBYjtBQUNBLElBQUlDLFlBQVksRUFBaEI7QUFDQSxJQUFJQyxNQUFNLE9BQU9DLFVBQVAsS0FBc0IsV0FBdEIsR0FBb0NBLFVBQXBDLEdBQWlEcm5DLEtBQTNEOztBQUVBLElBQUltaEIsT0FBTyxrRUFBWDtBQUNBLEtBQUssSUFBSWhoQixJQUFJLENBQVIsRUFBV2tiLE1BQU04RixLQUFLL2dCLE1BQTNCLEVBQW1DRCxJQUFJa2IsR0FBdkMsRUFBNEMsRUFBRWxiLENBQTlDLEVBQWlEO0FBQy9DK21DLFNBQU8vbUMsQ0FBUCxJQUFZZ2hCLEtBQUtoaEIsQ0FBTCxDQUFaO0FBQ0FnbkMsWUFBVWhtQixLQUFLQyxVQUFMLENBQWdCamhCLENBQWhCLENBQVYsSUFBZ0NBLENBQWhDO0FBQ0Q7O0FBRURnbkMsVUFBVSxJQUFJL2xCLFVBQUosQ0FBZSxDQUFmLENBQVYsSUFBK0IsRUFBL0I7QUFDQStsQixVQUFVLElBQUkvbEIsVUFBSixDQUFlLENBQWYsQ0FBVixJQUErQixFQUEvQjs7QUFFQSxTQUFTa21CLGlCQUFULENBQTRCQyxHQUE1QixFQUFpQztBQUMvQixNQUFJbHNCLE1BQU1rc0IsSUFBSW5uQyxNQUFkO0FBQ0EsTUFBSWliLE1BQU0sQ0FBTixHQUFVLENBQWQsRUFBaUI7QUFDZixVQUFNLElBQUl0WixLQUFKLENBQVUsZ0RBQVYsQ0FBTjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPd2xDLElBQUlsc0IsTUFBTSxDQUFWLE1BQWlCLEdBQWpCLEdBQXVCLENBQXZCLEdBQTJCa3NCLElBQUlsc0IsTUFBTSxDQUFWLE1BQWlCLEdBQWpCLEdBQXVCLENBQXZCLEdBQTJCLENBQTdEO0FBQ0Q7O0FBRUQsU0FBUzByQixVQUFULENBQXFCUSxHQUFyQixFQUEwQjtBQUN4QjtBQUNBLFNBQU9BLElBQUlubkMsTUFBSixHQUFhLENBQWIsR0FBaUIsQ0FBakIsR0FBcUJrbkMsa0JBQWtCQyxHQUFsQixDQUE1QjtBQUNEOztBQUVELFNBQVNQLFdBQVQsQ0FBc0JPLEdBQXRCLEVBQTJCO0FBQ3pCLE1BQUlwbkMsQ0FBSixFQUFPd1UsQ0FBUCxFQUFVK2QsQ0FBVixFQUFheUQsR0FBYixFQUFrQnFSLFlBQWxCLEVBQWdDbGEsR0FBaEM7QUFDQSxNQUFJalMsTUFBTWtzQixJQUFJbm5DLE1BQWQ7QUFDQW9uQyxpQkFBZUYsa0JBQWtCQyxHQUFsQixDQUFmOztBQUVBamEsUUFBTSxJQUFJOFosR0FBSixDQUFRL3JCLE1BQU0sQ0FBTixHQUFVLENBQVYsR0FBY21zQixZQUF0QixDQUFOOztBQUVBO0FBQ0E5VSxNQUFJOFUsZUFBZSxDQUFmLEdBQW1CbnNCLE1BQU0sQ0FBekIsR0FBNkJBLEdBQWpDOztBQUVBLE1BQUlvc0IsSUFBSSxDQUFSOztBQUVBLE9BQUt0bkMsSUFBSSxDQUFKLEVBQU93VSxJQUFJLENBQWhCLEVBQW1CeFUsSUFBSXV5QixDQUF2QixFQUEwQnZ5QixLQUFLLENBQUwsRUFBUXdVLEtBQUssQ0FBdkMsRUFBMEM7QUFDeEN3aEIsVUFBT2dSLFVBQVVJLElBQUlubUIsVUFBSixDQUFlamhCLENBQWYsQ0FBVixLQUFnQyxFQUFqQyxHQUF3Q2duQyxVQUFVSSxJQUFJbm1CLFVBQUosQ0FBZWpoQixJQUFJLENBQW5CLENBQVYsS0FBb0MsRUFBNUUsR0FBbUZnbkMsVUFBVUksSUFBSW5tQixVQUFKLENBQWVqaEIsSUFBSSxDQUFuQixDQUFWLEtBQW9DLENBQXZILEdBQTRIZ25DLFVBQVVJLElBQUlubUIsVUFBSixDQUFlamhCLElBQUksQ0FBbkIsQ0FBVixDQUFsSTtBQUNBbXRCLFFBQUltYSxHQUFKLElBQVl0UixPQUFPLEVBQVIsR0FBYyxJQUF6QjtBQUNBN0ksUUFBSW1hLEdBQUosSUFBWXRSLE9BQU8sQ0FBUixHQUFhLElBQXhCO0FBQ0E3SSxRQUFJbWEsR0FBSixJQUFXdFIsTUFBTSxJQUFqQjtBQUNEOztBQUVELE1BQUlxUixpQkFBaUIsQ0FBckIsRUFBd0I7QUFDdEJyUixVQUFPZ1IsVUFBVUksSUFBSW5tQixVQUFKLENBQWVqaEIsQ0FBZixDQUFWLEtBQWdDLENBQWpDLEdBQXVDZ25DLFVBQVVJLElBQUlubUIsVUFBSixDQUFlamhCLElBQUksQ0FBbkIsQ0FBVixLQUFvQyxDQUFqRjtBQUNBbXRCLFFBQUltYSxHQUFKLElBQVd0UixNQUFNLElBQWpCO0FBQ0QsR0FIRCxNQUdPLElBQUlxUixpQkFBaUIsQ0FBckIsRUFBd0I7QUFDN0JyUixVQUFPZ1IsVUFBVUksSUFBSW5tQixVQUFKLENBQWVqaEIsQ0FBZixDQUFWLEtBQWdDLEVBQWpDLEdBQXdDZ25DLFVBQVVJLElBQUlubUIsVUFBSixDQUFlamhCLElBQUksQ0FBbkIsQ0FBVixLQUFvQyxDQUE1RSxHQUFrRmduQyxVQUFVSSxJQUFJbm1CLFVBQUosQ0FBZWpoQixJQUFJLENBQW5CLENBQVYsS0FBb0MsQ0FBNUg7QUFDQW10QixRQUFJbWEsR0FBSixJQUFZdFIsT0FBTyxDQUFSLEdBQWEsSUFBeEI7QUFDQTdJLFFBQUltYSxHQUFKLElBQVd0UixNQUFNLElBQWpCO0FBQ0Q7O0FBRUQsU0FBTzdJLEdBQVA7QUFDRDs7QUFFRCxTQUFTb2EsZUFBVCxDQUEwQkMsR0FBMUIsRUFBK0I7QUFDN0IsU0FBT1QsT0FBT1MsT0FBTyxFQUFQLEdBQVksSUFBbkIsSUFBMkJULE9BQU9TLE9BQU8sRUFBUCxHQUFZLElBQW5CLENBQTNCLEdBQXNEVCxPQUFPUyxPQUFPLENBQVAsR0FBVyxJQUFsQixDQUF0RCxHQUFnRlQsT0FBT1MsTUFBTSxJQUFiLENBQXZGO0FBQ0Q7O0FBRUQsU0FBU0MsV0FBVCxDQUFzQkMsS0FBdEIsRUFBNkJobUMsS0FBN0IsRUFBb0NpSixHQUFwQyxFQUF5QztBQUN2QyxNQUFJcXJCLEdBQUo7QUFDQSxNQUFJME4sU0FBUyxFQUFiO0FBQ0EsT0FBSyxJQUFJMWpDLElBQUkwQixLQUFiLEVBQW9CMUIsSUFBSTJLLEdBQXhCLEVBQTZCM0ssS0FBSyxDQUFsQyxFQUFxQztBQUNuQ2cyQixVQUFNLENBQUMwUixNQUFNMW5DLENBQU4sS0FBWSxFQUFiLEtBQW9CMG5DLE1BQU0xbkMsSUFBSSxDQUFWLEtBQWdCLENBQXBDLElBQTBDMG5DLE1BQU0xbkMsSUFBSSxDQUFWLENBQWhEO0FBQ0EwakMsV0FBTzVpQyxJQUFQLENBQVl5bUMsZ0JBQWdCdlIsR0FBaEIsQ0FBWjtBQUNEO0FBQ0QsU0FBTzBOLE9BQU94aUMsSUFBUCxDQUFZLEVBQVosQ0FBUDtBQUNEOztBQUVELFNBQVM0bEMsYUFBVCxDQUF3QlksS0FBeEIsRUFBK0I7QUFDN0IsTUFBSTFSLEdBQUo7QUFDQSxNQUFJOWEsTUFBTXdzQixNQUFNem5DLE1BQWhCO0FBQ0EsTUFBSTBuQyxhQUFhenNCLE1BQU0sQ0FBdkIsQ0FINkIsQ0FHSjtBQUN6QixNQUFJd29CLFNBQVMsRUFBYjtBQUNBLE1BQUlKLFFBQVEsRUFBWjtBQUNBLE1BQUlzRSxpQkFBaUIsS0FBckIsQ0FONkIsQ0FNRjs7QUFFM0I7QUFDQSxPQUFLLElBQUk1bkMsSUFBSSxDQUFSLEVBQVc2bkMsT0FBTzNzQixNQUFNeXNCLFVBQTdCLEVBQXlDM25DLElBQUk2bkMsSUFBN0MsRUFBbUQ3bkMsS0FBSzRuQyxjQUF4RCxFQUF3RTtBQUN0RXRFLFVBQU14aUMsSUFBTixDQUFXMm1DLFlBQVlDLEtBQVosRUFBbUIxbkMsQ0FBbkIsRUFBdUJBLElBQUk0bkMsY0FBTCxHQUF1QkMsSUFBdkIsR0FBOEJBLElBQTlCLEdBQXNDN25DLElBQUk0bkMsY0FBaEUsQ0FBWDtBQUNEOztBQUVEO0FBQ0EsTUFBSUQsZUFBZSxDQUFuQixFQUFzQjtBQUNwQjNSLFVBQU0wUixNQUFNeHNCLE1BQU0sQ0FBWixDQUFOO0FBQ0F3b0IsY0FBVXFELE9BQU8vUSxPQUFPLENBQWQsQ0FBVjtBQUNBME4sY0FBVXFELE9BQVEvUSxPQUFPLENBQVIsR0FBYSxJQUFwQixDQUFWO0FBQ0EwTixjQUFVLElBQVY7QUFDRCxHQUxELE1BS08sSUFBSWlFLGVBQWUsQ0FBbkIsRUFBc0I7QUFDM0IzUixVQUFNLENBQUMwUixNQUFNeHNCLE1BQU0sQ0FBWixLQUFrQixDQUFuQixJQUF5QndzQixNQUFNeHNCLE1BQU0sQ0FBWixDQUEvQjtBQUNBd29CLGNBQVVxRCxPQUFPL1EsT0FBTyxFQUFkLENBQVY7QUFDQTBOLGNBQVVxRCxPQUFRL1EsT0FBTyxDQUFSLEdBQWEsSUFBcEIsQ0FBVjtBQUNBME4sY0FBVXFELE9BQVEvUSxPQUFPLENBQVIsR0FBYSxJQUFwQixDQUFWO0FBQ0EwTixjQUFVLEdBQVY7QUFDRDs7QUFFREosUUFBTXhpQyxJQUFOLENBQVc0aUMsTUFBWDs7QUFFQSxTQUFPSixNQUFNcGlDLElBQU4sQ0FBVyxFQUFYLENBQVA7QUFDRCxDOzs7Ozs7O0FDakhEOzs7Ozs7QUFNQTs7QUFFQTs7QUFFQSxJQUFJNG1DLFNBQVMsbUJBQUF2b0IsQ0FBUSxFQUFSLENBQWI7QUFDQSxJQUFJd29CLFVBQVUsbUJBQUF4b0IsQ0FBUSxFQUFSLENBQWQ7QUFDQSxJQUFJemYsVUFBVSxtQkFBQXlmLENBQVEsRUFBUixDQUFkOztBQUVBNWdCLFFBQVFxcEMsTUFBUixHQUFpQkEsTUFBakI7QUFDQXJwQyxRQUFRc3BDLFVBQVIsR0FBcUJBLFVBQXJCO0FBQ0F0cEMsUUFBUXVwQyxpQkFBUixHQUE0QixFQUE1Qjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBRixPQUFPRyxtQkFBUCxHQUE2QmxqQyxPQUFPa2pDLG1CQUFQLEtBQStCOW9DLFNBQS9CLEdBQ3pCNEYsT0FBT2tqQyxtQkFEa0IsR0FFekJDLG1CQUZKOztBQUlBOzs7QUFHQXpwQyxRQUFRMHBDLFVBQVIsR0FBcUJBLFlBQXJCOztBQUVBLFNBQVNELGlCQUFULEdBQThCO0FBQzVCLE1BQUk7QUFDRixRQUFJamIsTUFBTSxJQUFJK1osVUFBSixDQUFlLENBQWYsQ0FBVjtBQUNBL1osUUFBSW1iLFNBQUosR0FBZ0IsRUFBQ0EsV0FBV3BCLFdBQVdwakMsU0FBdkIsRUFBa0N5a0MsS0FBSyxlQUFZO0FBQUUsZUFBTyxFQUFQO0FBQVcsT0FBaEUsRUFBaEI7QUFDQSxXQUFPcGIsSUFBSW9iLEdBQUosT0FBYyxFQUFkLElBQW9CO0FBQ3ZCLFdBQU9wYixJQUFJcWIsUUFBWCxLQUF3QixVQURyQixJQUNtQztBQUN0Q3JiLFFBQUlxYixRQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQjVCLFVBQW5CLEtBQWtDLENBRnRDLENBSEUsQ0FLc0M7QUFDekMsR0FORCxDQU1FLE9BQU9wb0MsQ0FBUCxFQUFVO0FBQ1YsV0FBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNnBDLFVBQVQsR0FBdUI7QUFDckIsU0FBT0wsT0FBT0csbUJBQVAsR0FDSCxVQURHLEdBRUgsVUFGSjtBQUdEOztBQUVELFNBQVNNLFlBQVQsQ0FBdUJDLElBQXZCLEVBQTZCem9DLE1BQTdCLEVBQXFDO0FBQ25DLE1BQUlvb0MsZUFBZXBvQyxNQUFuQixFQUEyQjtBQUN6QixVQUFNLElBQUltakMsVUFBSixDQUFlLDRCQUFmLENBQU47QUFDRDtBQUNELE1BQUk0RSxPQUFPRyxtQkFBWCxFQUFnQztBQUM5QjtBQUNBTyxXQUFPLElBQUl4QixVQUFKLENBQWVqbkMsTUFBZixDQUFQO0FBQ0F5b0MsU0FBS0osU0FBTCxHQUFpQk4sT0FBT2xrQyxTQUF4QjtBQUNELEdBSkQsTUFJTztBQUNMO0FBQ0EsUUFBSTRrQyxTQUFTLElBQWIsRUFBbUI7QUFDakJBLGFBQU8sSUFBSVYsTUFBSixDQUFXL25DLE1BQVgsQ0FBUDtBQUNEO0FBQ0R5b0MsU0FBS3pvQyxNQUFMLEdBQWNBLE1BQWQ7QUFDRDs7QUFFRCxTQUFPeW9DLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBLFNBQVNWLE1BQVQsQ0FBaUJXLEdBQWpCLEVBQXNCQyxnQkFBdEIsRUFBd0Mzb0MsTUFBeEMsRUFBZ0Q7QUFDOUMsTUFBSSxDQUFDK25DLE9BQU9HLG1CQUFSLElBQStCLEVBQUUsZ0JBQWdCSCxNQUFsQixDQUFuQyxFQUE4RDtBQUM1RCxXQUFPLElBQUlBLE1BQUosQ0FBV1csR0FBWCxFQUFnQkMsZ0JBQWhCLEVBQWtDM29DLE1BQWxDLENBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUksT0FBTzBvQyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsUUFBSSxPQUFPQyxnQkFBUCxLQUE0QixRQUFoQyxFQUEwQztBQUN4QyxZQUFNLElBQUlobkMsS0FBSixDQUNKLG1FQURJLENBQU47QUFHRDtBQUNELFdBQU9pbkMsWUFBWSxJQUFaLEVBQWtCRixHQUFsQixDQUFQO0FBQ0Q7QUFDRCxTQUFPblEsS0FBSyxJQUFMLEVBQVdtUSxHQUFYLEVBQWdCQyxnQkFBaEIsRUFBa0Mzb0MsTUFBbEMsQ0FBUDtBQUNEOztBQUVEK25DLE9BQU9jLFFBQVAsR0FBa0IsSUFBbEIsQyxDQUF1Qjs7QUFFdkI7QUFDQWQsT0FBT2UsUUFBUCxHQUFrQixVQUFVNWIsR0FBVixFQUFlO0FBQy9CQSxNQUFJbWIsU0FBSixHQUFnQk4sT0FBT2xrQyxTQUF2QjtBQUNBLFNBQU9xcEIsR0FBUDtBQUNELENBSEQ7O0FBS0EsU0FBU3FMLElBQVQsQ0FBZWtRLElBQWYsRUFBcUI5bkMsS0FBckIsRUFBNEJnb0MsZ0JBQTVCLEVBQThDM29DLE1BQTlDLEVBQXNEO0FBQ3BELE1BQUksT0FBT1csS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixVQUFNLElBQUkwQixTQUFKLENBQWMsdUNBQWQsQ0FBTjtBQUNEOztBQUVELE1BQUksT0FBTzBtQyxXQUFQLEtBQXVCLFdBQXZCLElBQXNDcG9DLGlCQUFpQm9vQyxXQUEzRCxFQUF3RTtBQUN0RSxXQUFPQyxnQkFBZ0JQLElBQWhCLEVBQXNCOW5DLEtBQXRCLEVBQTZCZ29DLGdCQUE3QixFQUErQzNvQyxNQUEvQyxDQUFQO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPVyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFdBQU9zb0MsV0FBV1IsSUFBWCxFQUFpQjluQyxLQUFqQixFQUF3QmdvQyxnQkFBeEIsQ0FBUDtBQUNEOztBQUVELFNBQU9PLFdBQVdULElBQVgsRUFBaUI5bkMsS0FBakIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBb25DLE9BQU94UCxJQUFQLEdBQWMsVUFBVTUzQixLQUFWLEVBQWlCZ29DLGdCQUFqQixFQUFtQzNvQyxNQUFuQyxFQUEyQztBQUN2RCxTQUFPdTRCLEtBQUssSUFBTCxFQUFXNTNCLEtBQVgsRUFBa0Jnb0MsZ0JBQWxCLEVBQW9DM29DLE1BQXBDLENBQVA7QUFDRCxDQUZEOztBQUlBLElBQUkrbkMsT0FBT0csbUJBQVgsRUFBZ0M7QUFDOUJILFNBQU9sa0MsU0FBUCxDQUFpQndrQyxTQUFqQixHQUE2QnBCLFdBQVdwakMsU0FBeEM7QUFDQWtrQyxTQUFPTSxTQUFQLEdBQW1CcEIsVUFBbkI7QUFDQSxNQUFJLE9BQU9rQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPQyxPQUF4QyxJQUNBckIsT0FBT29CLE9BQU9DLE9BQWQsTUFBMkJyQixNQUQvQixFQUN1QztBQUNyQztBQUNBNWlDLFdBQU8wZ0MsY0FBUCxDQUFzQmtDLE1BQXRCLEVBQThCb0IsT0FBT0MsT0FBckMsRUFBOEM7QUFDNUN6b0MsYUFBTyxJQURxQztBQUU1QzBvQyxvQkFBYztBQUY4QixLQUE5QztBQUlEO0FBQ0Y7O0FBRUQsU0FBU0MsVUFBVCxDQUFxQkMsSUFBckIsRUFBMkI7QUFDekIsTUFBSSxPQUFPQSxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLFVBQU0sSUFBSWxuQyxTQUFKLENBQWMsa0NBQWQsQ0FBTjtBQUNELEdBRkQsTUFFTyxJQUFJa25DLE9BQU8sQ0FBWCxFQUFjO0FBQ25CLFVBQU0sSUFBSXBHLFVBQUosQ0FBZSxzQ0FBZixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTcUcsS0FBVCxDQUFnQmYsSUFBaEIsRUFBc0JjLElBQXRCLEVBQTRCRSxJQUE1QixFQUFrQ0MsUUFBbEMsRUFBNEM7QUFDMUNKLGFBQVdDLElBQVg7QUFDQSxNQUFJQSxRQUFRLENBQVosRUFBZTtBQUNiLFdBQU9mLGFBQWFDLElBQWIsRUFBbUJjLElBQW5CLENBQVA7QUFDRDtBQUNELE1BQUlFLFNBQVNycUMsU0FBYixFQUF3QjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxXQUFPLE9BQU9zcUMsUUFBUCxLQUFvQixRQUFwQixHQUNIbEIsYUFBYUMsSUFBYixFQUFtQmMsSUFBbkIsRUFBeUJFLElBQXpCLENBQThCQSxJQUE5QixFQUFvQ0MsUUFBcEMsQ0FERyxHQUVIbEIsYUFBYUMsSUFBYixFQUFtQmMsSUFBbkIsRUFBeUJFLElBQXpCLENBQThCQSxJQUE5QixDQUZKO0FBR0Q7QUFDRCxTQUFPakIsYUFBYUMsSUFBYixFQUFtQmMsSUFBbkIsQ0FBUDtBQUNEOztBQUVEOzs7O0FBSUF4QixPQUFPeUIsS0FBUCxHQUFlLFVBQVVELElBQVYsRUFBZ0JFLElBQWhCLEVBQXNCQyxRQUF0QixFQUFnQztBQUM3QyxTQUFPRixNQUFNLElBQU4sRUFBWUQsSUFBWixFQUFrQkUsSUFBbEIsRUFBd0JDLFFBQXhCLENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVNkLFdBQVQsQ0FBc0JILElBQXRCLEVBQTRCYyxJQUE1QixFQUFrQztBQUNoQ0QsYUFBV0MsSUFBWDtBQUNBZCxTQUFPRCxhQUFhQyxJQUFiLEVBQW1CYyxPQUFPLENBQVAsR0FBVyxDQUFYLEdBQWVJLFFBQVFKLElBQVIsSUFBZ0IsQ0FBbEQsQ0FBUDtBQUNBLE1BQUksQ0FBQ3hCLE9BQU9HLG1CQUFaLEVBQWlDO0FBQy9CLFNBQUssSUFBSW5vQyxJQUFJLENBQWIsRUFBZ0JBLElBQUl3cEMsSUFBcEIsRUFBMEIsRUFBRXhwQyxDQUE1QixFQUErQjtBQUM3QjBvQyxXQUFLMW9DLENBQUwsSUFBVSxDQUFWO0FBQ0Q7QUFDRjtBQUNELFNBQU8wb0MsSUFBUDtBQUNEOztBQUVEOzs7QUFHQVYsT0FBT2EsV0FBUCxHQUFxQixVQUFVVyxJQUFWLEVBQWdCO0FBQ25DLFNBQU9YLFlBQVksSUFBWixFQUFrQlcsSUFBbEIsQ0FBUDtBQUNELENBRkQ7QUFHQTs7O0FBR0F4QixPQUFPNkIsZUFBUCxHQUF5QixVQUFVTCxJQUFWLEVBQWdCO0FBQ3ZDLFNBQU9YLFlBQVksSUFBWixFQUFrQlcsSUFBbEIsQ0FBUDtBQUNELENBRkQ7O0FBSUEsU0FBU04sVUFBVCxDQUFxQlIsSUFBckIsRUFBMkI5MEIsTUFBM0IsRUFBbUMrMUIsUUFBbkMsRUFBNkM7QUFDM0MsTUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXBCLElBQWdDQSxhQUFhLEVBQWpELEVBQXFEO0FBQ25EQSxlQUFXLE1BQVg7QUFDRDs7QUFFRCxNQUFJLENBQUMzQixPQUFPOEIsVUFBUCxDQUFrQkgsUUFBbEIsQ0FBTCxFQUFrQztBQUNoQyxVQUFNLElBQUlybkMsU0FBSixDQUFjLDRDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJckMsU0FBUzJtQyxXQUFXaHpCLE1BQVgsRUFBbUIrMUIsUUFBbkIsSUFBK0IsQ0FBNUM7QUFDQWpCLFNBQU9ELGFBQWFDLElBQWIsRUFBbUJ6b0MsTUFBbkIsQ0FBUDs7QUFFQSxNQUFJOHBDLFNBQVNyQixLQUFLc0IsS0FBTCxDQUFXcDJCLE1BQVgsRUFBbUIrMUIsUUFBbkIsQ0FBYjs7QUFFQSxNQUFJSSxXQUFXOXBDLE1BQWYsRUFBdUI7QUFDckI7QUFDQTtBQUNBO0FBQ0F5b0MsV0FBT0EsS0FBSy8rQixLQUFMLENBQVcsQ0FBWCxFQUFjb2dDLE1BQWQsQ0FBUDtBQUNEOztBQUVELFNBQU9yQixJQUFQO0FBQ0Q7O0FBRUQsU0FBU3VCLGFBQVQsQ0FBd0J2QixJQUF4QixFQUE4QnJ0QixLQUE5QixFQUFxQztBQUNuQyxNQUFJcGIsU0FBU29iLE1BQU1wYixNQUFOLEdBQWUsQ0FBZixHQUFtQixDQUFuQixHQUF1QjJwQyxRQUFRdnVCLE1BQU1wYixNQUFkLElBQXdCLENBQTVEO0FBQ0F5b0MsU0FBT0QsYUFBYUMsSUFBYixFQUFtQnpvQyxNQUFuQixDQUFQO0FBQ0EsT0FBSyxJQUFJRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLE1BQXBCLEVBQTRCRCxLQUFLLENBQWpDLEVBQW9DO0FBQ2xDMG9DLFNBQUsxb0MsQ0FBTCxJQUFVcWIsTUFBTXJiLENBQU4sSUFBVyxHQUFyQjtBQUNEO0FBQ0QsU0FBTzBvQyxJQUFQO0FBQ0Q7O0FBRUQsU0FBU08sZUFBVCxDQUEwQlAsSUFBMUIsRUFBZ0NydEIsS0FBaEMsRUFBdUM2dUIsVUFBdkMsRUFBbURqcUMsTUFBbkQsRUFBMkQ7QUFDekRvYixRQUFNdXJCLFVBQU4sQ0FEeUQsQ0FDeEM7O0FBRWpCLE1BQUlzRCxhQUFhLENBQWIsSUFBa0I3dUIsTUFBTXVyQixVQUFOLEdBQW1Cc0QsVUFBekMsRUFBcUQ7QUFDbkQsVUFBTSxJQUFJOUcsVUFBSixDQUFlLDZCQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJL25CLE1BQU11ckIsVUFBTixHQUFtQnNELGNBQWNqcUMsVUFBVSxDQUF4QixDQUF2QixFQUFtRDtBQUNqRCxVQUFNLElBQUltakMsVUFBSixDQUFlLDZCQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJOEcsZUFBZTdxQyxTQUFmLElBQTRCWSxXQUFXWixTQUEzQyxFQUFzRDtBQUNwRGdjLFlBQVEsSUFBSTZyQixVQUFKLENBQWU3ckIsS0FBZixDQUFSO0FBQ0QsR0FGRCxNQUVPLElBQUlwYixXQUFXWixTQUFmLEVBQTBCO0FBQy9CZ2MsWUFBUSxJQUFJNnJCLFVBQUosQ0FBZTdyQixLQUFmLEVBQXNCNnVCLFVBQXRCLENBQVI7QUFDRCxHQUZNLE1BRUE7QUFDTDd1QixZQUFRLElBQUk2ckIsVUFBSixDQUFlN3JCLEtBQWYsRUFBc0I2dUIsVUFBdEIsRUFBa0NqcUMsTUFBbEMsQ0FBUjtBQUNEOztBQUVELE1BQUkrbkMsT0FBT0csbUJBQVgsRUFBZ0M7QUFDOUI7QUFDQU8sV0FBT3J0QixLQUFQO0FBQ0FxdEIsU0FBS0osU0FBTCxHQUFpQk4sT0FBT2xrQyxTQUF4QjtBQUNELEdBSkQsTUFJTztBQUNMO0FBQ0E0a0MsV0FBT3VCLGNBQWN2QixJQUFkLEVBQW9CcnRCLEtBQXBCLENBQVA7QUFDRDtBQUNELFNBQU9xdEIsSUFBUDtBQUNEOztBQUVELFNBQVNTLFVBQVQsQ0FBcUJULElBQXJCLEVBQTJCanBCLEdBQTNCLEVBQWdDO0FBQzlCLE1BQUl1b0IsT0FBT21DLFFBQVAsQ0FBZ0IxcUIsR0FBaEIsQ0FBSixFQUEwQjtBQUN4QixRQUFJdkUsTUFBTTB1QixRQUFRbnFCLElBQUl4ZixNQUFaLElBQXNCLENBQWhDO0FBQ0F5b0MsV0FBT0QsYUFBYUMsSUFBYixFQUFtQnh0QixHQUFuQixDQUFQOztBQUVBLFFBQUl3dEIsS0FBS3pvQyxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGFBQU95b0MsSUFBUDtBQUNEOztBQUVEanBCLFFBQUkycUIsSUFBSixDQUFTMUIsSUFBVCxFQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUJ4dEIsR0FBckI7QUFDQSxXQUFPd3RCLElBQVA7QUFDRDs7QUFFRCxNQUFJanBCLEdBQUosRUFBUztBQUNQLFFBQUssT0FBT3VwQixXQUFQLEtBQXVCLFdBQXZCLElBQ0R2cEIsSUFBSTRxQixNQUFKLFlBQXNCckIsV0FEdEIsSUFDc0MsWUFBWXZwQixHQUR0RCxFQUMyRDtBQUN6RCxVQUFJLE9BQU9BLElBQUl4ZixNQUFYLEtBQXNCLFFBQXRCLElBQWtDcXFDLE1BQU03cUIsSUFBSXhmLE1BQVYsQ0FBdEMsRUFBeUQ7QUFDdkQsZUFBT3dvQyxhQUFhQyxJQUFiLEVBQW1CLENBQW5CLENBQVA7QUFDRDtBQUNELGFBQU91QixjQUFjdkIsSUFBZCxFQUFvQmpwQixHQUFwQixDQUFQO0FBQ0Q7O0FBRUQsUUFBSUEsSUFBSTllLElBQUosS0FBYSxRQUFiLElBQXlCYixRQUFRMmYsSUFBSTFZLElBQVosQ0FBN0IsRUFBZ0Q7QUFDOUMsYUFBT2tqQyxjQUFjdkIsSUFBZCxFQUFvQmpwQixJQUFJMVksSUFBeEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsUUFBTSxJQUFJekUsU0FBSixDQUFjLG9GQUFkLENBQU47QUFDRDs7QUFFRCxTQUFTc25DLE9BQVQsQ0FBa0IzcEMsTUFBbEIsRUFBMEI7QUFDeEI7QUFDQTtBQUNBLE1BQUlBLFVBQVVvb0MsWUFBZCxFQUE0QjtBQUMxQixVQUFNLElBQUlqRixVQUFKLENBQWUsb0RBQ0EsVUFEQSxHQUNhaUYsYUFBYWhqQyxRQUFiLENBQXNCLEVBQXRCLENBRGIsR0FDeUMsUUFEeEQsQ0FBTjtBQUVEO0FBQ0QsU0FBT3BGLFNBQVMsQ0FBaEI7QUFDRDs7QUFFRCxTQUFTZ29DLFVBQVQsQ0FBcUJob0MsTUFBckIsRUFBNkI7QUFDM0IsTUFBSSxDQUFDQSxNQUFELElBQVdBLE1BQWYsRUFBdUI7QUFBRTtBQUN2QkEsYUFBUyxDQUFUO0FBQ0Q7QUFDRCxTQUFPK25DLE9BQU95QixLQUFQLENBQWEsQ0FBQ3hwQyxNQUFkLENBQVA7QUFDRDs7QUFFRCtuQyxPQUFPbUMsUUFBUCxHQUFrQixTQUFTQSxRQUFULENBQW1CSSxDQUFuQixFQUFzQjtBQUN0QyxTQUFPLENBQUMsRUFBRUEsS0FBSyxJQUFMLElBQWFBLEVBQUVDLFNBQWpCLENBQVI7QUFDRCxDQUZEOztBQUlBeEMsT0FBT3lDLE9BQVAsR0FBaUIsU0FBU0EsT0FBVCxDQUFrQkMsQ0FBbEIsRUFBcUJILENBQXJCLEVBQXdCO0FBQ3ZDLE1BQUksQ0FBQ3ZDLE9BQU9tQyxRQUFQLENBQWdCTyxDQUFoQixDQUFELElBQXVCLENBQUMxQyxPQUFPbUMsUUFBUCxDQUFnQkksQ0FBaEIsQ0FBNUIsRUFBZ0Q7QUFDOUMsVUFBTSxJQUFJam9DLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSW9vQyxNQUFNSCxDQUFWLEVBQWEsT0FBTyxDQUFQOztBQUViLE1BQUlJLElBQUlELEVBQUV6cUMsTUFBVjtBQUNBLE1BQUkycUMsSUFBSUwsRUFBRXRxQyxNQUFWOztBQUVBLE9BQUssSUFBSUQsSUFBSSxDQUFSLEVBQVdrYixNQUFNcFMsS0FBSzZ1QixHQUFMLENBQVNnVCxDQUFULEVBQVlDLENBQVosQ0FBdEIsRUFBc0M1cUMsSUFBSWtiLEdBQTFDLEVBQStDLEVBQUVsYixDQUFqRCxFQUFvRDtBQUNsRCxRQUFJMHFDLEVBQUUxcUMsQ0FBRixNQUFTdXFDLEVBQUV2cUMsQ0FBRixDQUFiLEVBQW1CO0FBQ2pCMnFDLFVBQUlELEVBQUUxcUMsQ0FBRixDQUFKO0FBQ0E0cUMsVUFBSUwsRUFBRXZxQyxDQUFGLENBQUo7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSTJxQyxJQUFJQyxDQUFSLEVBQVcsT0FBTyxDQUFDLENBQVI7QUFDWCxNQUFJQSxJQUFJRCxDQUFSLEVBQVcsT0FBTyxDQUFQO0FBQ1gsU0FBTyxDQUFQO0FBQ0QsQ0FyQkQ7O0FBdUJBM0MsT0FBTzhCLFVBQVAsR0FBb0IsU0FBU0EsVUFBVCxDQUFxQkgsUUFBckIsRUFBK0I7QUFDakQsVUFBUW5wQixPQUFPbXBCLFFBQVAsRUFBaUJ6b0IsV0FBakIsRUFBUjtBQUNFLFNBQUssS0FBTDtBQUNBLFNBQUssTUFBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssTUFBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssU0FBTDtBQUNBLFNBQUssVUFBTDtBQUNFLGFBQU8sSUFBUDtBQUNGO0FBQ0UsYUFBTyxLQUFQO0FBZEo7QUFnQkQsQ0FqQkQ7O0FBbUJBOG1CLE9BQU9sNkIsTUFBUCxHQUFnQixTQUFTQSxNQUFULENBQWlCN0ssSUFBakIsRUFBdUJoRCxNQUF2QixFQUErQjtBQUM3QyxNQUFJLENBQUNILFFBQVFtRCxJQUFSLENBQUwsRUFBb0I7QUFDbEIsVUFBTSxJQUFJWCxTQUFKLENBQWMsNkNBQWQsQ0FBTjtBQUNEOztBQUVELE1BQUlXLEtBQUtoRCxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLFdBQU8rbkMsT0FBT3lCLEtBQVAsQ0FBYSxDQUFiLENBQVA7QUFDRDs7QUFFRCxNQUFJenBDLENBQUo7QUFDQSxNQUFJQyxXQUFXWixTQUFmLEVBQTBCO0FBQ3hCWSxhQUFTLENBQVQ7QUFDQSxTQUFLRCxJQUFJLENBQVQsRUFBWUEsSUFBSWlELEtBQUtoRCxNQUFyQixFQUE2QixFQUFFRCxDQUEvQixFQUFrQztBQUNoQ0MsZ0JBQVVnRCxLQUFLakQsQ0FBTCxFQUFRQyxNQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSW9xQyxTQUFTckMsT0FBT2EsV0FBUCxDQUFtQjVvQyxNQUFuQixDQUFiO0FBQ0EsTUFBSWdnQixNQUFNLENBQVY7QUFDQSxPQUFLamdCLElBQUksQ0FBVCxFQUFZQSxJQUFJaUQsS0FBS2hELE1BQXJCLEVBQTZCLEVBQUVELENBQS9CLEVBQWtDO0FBQ2hDLFFBQUk2cUMsTUFBTTVuQyxLQUFLakQsQ0FBTCxDQUFWO0FBQ0EsUUFBSSxDQUFDZ29DLE9BQU9tQyxRQUFQLENBQWdCVSxHQUFoQixDQUFMLEVBQTJCO0FBQ3pCLFlBQU0sSUFBSXZvQyxTQUFKLENBQWMsNkNBQWQsQ0FBTjtBQUNEO0FBQ0R1b0MsUUFBSVQsSUFBSixDQUFTQyxNQUFULEVBQWlCcHFCLEdBQWpCO0FBQ0FBLFdBQU80cUIsSUFBSTVxQyxNQUFYO0FBQ0Q7QUFDRCxTQUFPb3FDLE1BQVA7QUFDRCxDQTVCRDs7QUE4QkEsU0FBU3pELFVBQVQsQ0FBcUJoekIsTUFBckIsRUFBNkIrMUIsUUFBN0IsRUFBdUM7QUFDckMsTUFBSTNCLE9BQU9tQyxRQUFQLENBQWdCdjJCLE1BQWhCLENBQUosRUFBNkI7QUFDM0IsV0FBT0EsT0FBTzNULE1BQWQ7QUFDRDtBQUNELE1BQUksT0FBTytvQyxXQUFQLEtBQXVCLFdBQXZCLElBQXNDLE9BQU9BLFlBQVk4QixNQUFuQixLQUE4QixVQUFwRSxLQUNDOUIsWUFBWThCLE1BQVosQ0FBbUJsM0IsTUFBbkIsS0FBOEJBLGtCQUFrQm8xQixXQURqRCxDQUFKLEVBQ21FO0FBQ2pFLFdBQU9wMUIsT0FBT2d6QixVQUFkO0FBQ0Q7QUFDRCxNQUFJLE9BQU9oekIsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QkEsYUFBUyxLQUFLQSxNQUFkO0FBQ0Q7O0FBRUQsTUFBSXNILE1BQU10SCxPQUFPM1QsTUFBakI7QUFDQSxNQUFJaWIsUUFBUSxDQUFaLEVBQWUsT0FBTyxDQUFQOztBQUVmO0FBQ0EsTUFBSTZ2QixjQUFjLEtBQWxCO0FBQ0EsV0FBUztBQUNQLFlBQVFwQixRQUFSO0FBQ0UsV0FBSyxPQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBT3p1QixHQUFQO0FBQ0YsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSzdiLFNBQUw7QUFDRSxlQUFPMnJDLFlBQVlwM0IsTUFBWixFQUFvQjNULE1BQTNCO0FBQ0YsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0UsZUFBT2liLE1BQU0sQ0FBYjtBQUNGLFdBQUssS0FBTDtBQUNFLGVBQU9BLFFBQVEsQ0FBZjtBQUNGLFdBQUssUUFBTDtBQUNFLGVBQU8rdkIsY0FBY3IzQixNQUFkLEVBQXNCM1QsTUFBN0I7QUFDRjtBQUNFLFlBQUk4cUMsV0FBSixFQUFpQixPQUFPQyxZQUFZcDNCLE1BQVosRUFBb0IzVCxNQUEzQixDQURuQixDQUNxRDtBQUNuRDBwQyxtQkFBVyxDQUFDLEtBQUtBLFFBQU4sRUFBZ0J6b0IsV0FBaEIsRUFBWDtBQUNBNnBCLHNCQUFjLElBQWQ7QUFyQko7QUF1QkQ7QUFDRjtBQUNEL0MsT0FBT3BCLFVBQVAsR0FBb0JBLFVBQXBCOztBQUVBLFNBQVNzRSxZQUFULENBQXVCdkIsUUFBdkIsRUFBaUNqb0MsS0FBakMsRUFBd0NpSixHQUF4QyxFQUE2QztBQUMzQyxNQUFJb2dDLGNBQWMsS0FBbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlycEMsVUFBVXJDLFNBQVYsSUFBdUJxQyxRQUFRLENBQW5DLEVBQXNDO0FBQ3BDQSxZQUFRLENBQVI7QUFDRDtBQUNEO0FBQ0E7QUFDQSxNQUFJQSxRQUFRLEtBQUt6QixNQUFqQixFQUF5QjtBQUN2QixXQUFPLEVBQVA7QUFDRDs7QUFFRCxNQUFJMEssUUFBUXRMLFNBQVIsSUFBcUJzTCxNQUFNLEtBQUsxSyxNQUFwQyxFQUE0QztBQUMxQzBLLFVBQU0sS0FBSzFLLE1BQVg7QUFDRDs7QUFFRCxNQUFJMEssT0FBTyxDQUFYLEVBQWM7QUFDWixXQUFPLEVBQVA7QUFDRDs7QUFFRDtBQUNBQSxXQUFTLENBQVQ7QUFDQWpKLGFBQVcsQ0FBWDs7QUFFQSxNQUFJaUosT0FBT2pKLEtBQVgsRUFBa0I7QUFDaEIsV0FBTyxFQUFQO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDaW9DLFFBQUwsRUFBZUEsV0FBVyxNQUFYOztBQUVmLFNBQU8sSUFBUCxFQUFhO0FBQ1gsWUFBUUEsUUFBUjtBQUNFLFdBQUssS0FBTDtBQUNFLGVBQU93QixTQUFTLElBQVQsRUFBZXpwQyxLQUFmLEVBQXNCaUosR0FBdEIsQ0FBUDs7QUFFRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDRSxlQUFPeWdDLFVBQVUsSUFBVixFQUFnQjFwQyxLQUFoQixFQUF1QmlKLEdBQXZCLENBQVA7O0FBRUYsV0FBSyxPQUFMO0FBQ0UsZUFBTzBnQyxXQUFXLElBQVgsRUFBaUIzcEMsS0FBakIsRUFBd0JpSixHQUF4QixDQUFQOztBQUVGLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNFLGVBQU8yZ0MsWUFBWSxJQUFaLEVBQWtCNXBDLEtBQWxCLEVBQXlCaUosR0FBekIsQ0FBUDs7QUFFRixXQUFLLFFBQUw7QUFDRSxlQUFPNGdDLFlBQVksSUFBWixFQUFrQjdwQyxLQUFsQixFQUF5QmlKLEdBQXpCLENBQVA7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0UsZUFBTzZnQyxhQUFhLElBQWIsRUFBbUI5cEMsS0FBbkIsRUFBMEJpSixHQUExQixDQUFQOztBQUVGO0FBQ0UsWUFBSW9nQyxXQUFKLEVBQWlCLE1BQU0sSUFBSXpvQyxTQUFKLENBQWMsdUJBQXVCcW5DLFFBQXJDLENBQU47QUFDakJBLG1CQUFXLENBQUNBLFdBQVcsRUFBWixFQUFnQnpvQixXQUFoQixFQUFYO0FBQ0E2cEIsc0JBQWMsSUFBZDtBQTNCSjtBQTZCRDtBQUNGOztBQUVEO0FBQ0E7QUFDQS9DLE9BQU9sa0MsU0FBUCxDQUFpQjBtQyxTQUFqQixHQUE2QixJQUE3Qjs7QUFFQSxTQUFTaUIsSUFBVCxDQUFlbEIsQ0FBZixFQUFrQjlGLENBQWxCLEVBQXFCdGlDLENBQXJCLEVBQXdCO0FBQ3RCLE1BQUluQyxJQUFJdXFDLEVBQUU5RixDQUFGLENBQVI7QUFDQThGLElBQUU5RixDQUFGLElBQU84RixFQUFFcG9DLENBQUYsQ0FBUDtBQUNBb29DLElBQUVwb0MsQ0FBRixJQUFPbkMsQ0FBUDtBQUNEOztBQUVEZ29DLE9BQU9sa0MsU0FBUCxDQUFpQjRuQyxNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLE1BQUl4d0IsTUFBTSxLQUFLamIsTUFBZjtBQUNBLE1BQUlpYixNQUFNLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUlrb0IsVUFBSixDQUFlLDJDQUFmLENBQU47QUFDRDtBQUNELE9BQUssSUFBSXBqQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlrYixHQUFwQixFQUF5QmxiLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0J5ckMsU0FBSyxJQUFMLEVBQVd6ckMsQ0FBWCxFQUFjQSxJQUFJLENBQWxCO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVREOztBQVdBZ29DLE9BQU9sa0MsU0FBUCxDQUFpQjZuQyxNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLE1BQUl6d0IsTUFBTSxLQUFLamIsTUFBZjtBQUNBLE1BQUlpYixNQUFNLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUlrb0IsVUFBSixDQUFlLDJDQUFmLENBQU47QUFDRDtBQUNELE9BQUssSUFBSXBqQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlrYixHQUFwQixFQUF5QmxiLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0J5ckMsU0FBSyxJQUFMLEVBQVd6ckMsQ0FBWCxFQUFjQSxJQUFJLENBQWxCO0FBQ0F5ckMsU0FBSyxJQUFMLEVBQVd6ckMsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVZEOztBQVlBZ29DLE9BQU9sa0MsU0FBUCxDQUFpQjhuQyxNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLE1BQUkxd0IsTUFBTSxLQUFLamIsTUFBZjtBQUNBLE1BQUlpYixNQUFNLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUlrb0IsVUFBSixDQUFlLDJDQUFmLENBQU47QUFDRDtBQUNELE9BQUssSUFBSXBqQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlrYixHQUFwQixFQUF5QmxiLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0J5ckMsU0FBSyxJQUFMLEVBQVd6ckMsQ0FBWCxFQUFjQSxJQUFJLENBQWxCO0FBQ0F5ckMsU0FBSyxJQUFMLEVBQVd6ckMsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0F5ckMsU0FBSyxJQUFMLEVBQVd6ckMsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0F5ckMsU0FBSyxJQUFMLEVBQVd6ckMsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVpEOztBQWNBZ29DLE9BQU9sa0MsU0FBUCxDQUFpQnVCLFFBQWpCLEdBQTRCLFNBQVNBLFFBQVQsR0FBcUI7QUFDL0MsTUFBSXBGLFNBQVMsS0FBS0EsTUFBTCxHQUFjLENBQTNCO0FBQ0EsTUFBSUEsV0FBVyxDQUFmLEVBQWtCLE9BQU8sRUFBUDtBQUNsQixNQUFJd0IsVUFBVXhCLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEIsT0FBT21yQyxVQUFVLElBQVYsRUFBZ0IsQ0FBaEIsRUFBbUJuckMsTUFBbkIsQ0FBUDtBQUM1QixTQUFPaXJDLGFBQWE1a0MsS0FBYixDQUFtQixJQUFuQixFQUF5QjdFLFNBQXpCLENBQVA7QUFDRCxDQUxEOztBQU9BdW1DLE9BQU9sa0MsU0FBUCxDQUFpQituQyxNQUFqQixHQUEwQixTQUFTQSxNQUFULENBQWlCdEIsQ0FBakIsRUFBb0I7QUFDNUMsTUFBSSxDQUFDdkMsT0FBT21DLFFBQVAsQ0FBZ0JJLENBQWhCLENBQUwsRUFBeUIsTUFBTSxJQUFJam9DLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ3pCLE1BQUksU0FBU2lvQyxDQUFiLEVBQWdCLE9BQU8sSUFBUDtBQUNoQixTQUFPdkMsT0FBT3lDLE9BQVAsQ0FBZSxJQUFmLEVBQXFCRixDQUFyQixNQUE0QixDQUFuQztBQUNELENBSkQ7O0FBTUF2QyxPQUFPbGtDLFNBQVAsQ0FBaUJnb0MsT0FBakIsR0FBMkIsU0FBU0EsT0FBVCxHQUFvQjtBQUM3QyxNQUFJMXFCLE1BQU0sRUFBVjtBQUNBLE1BQUl1RixNQUFNaG9CLFFBQVF1cEMsaUJBQWxCO0FBQ0EsTUFBSSxLQUFLam9DLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNuQm1oQixVQUFNLEtBQUsvYixRQUFMLENBQWMsS0FBZCxFQUFxQixDQUFyQixFQUF3QnNoQixHQUF4QixFQUE2Qm5tQixLQUE3QixDQUFtQyxPQUFuQyxFQUE0Q1UsSUFBNUMsQ0FBaUQsR0FBakQsQ0FBTjtBQUNBLFFBQUksS0FBS2pCLE1BQUwsR0FBYzBtQixHQUFsQixFQUF1QnZGLE9BQU8sT0FBUDtBQUN4QjtBQUNELFNBQU8sYUFBYUEsR0FBYixHQUFtQixHQUExQjtBQUNELENBUkQ7O0FBVUE0bUIsT0FBT2xrQyxTQUFQLENBQWlCMm1DLE9BQWpCLEdBQTJCLFNBQVNBLE9BQVQsQ0FBa0JzQixNQUFsQixFQUEwQnJxQyxLQUExQixFQUFpQ2lKLEdBQWpDLEVBQXNDcWhDLFNBQXRDLEVBQWlEQyxPQUFqRCxFQUEwRDtBQUNuRixNQUFJLENBQUNqRSxPQUFPbUMsUUFBUCxDQUFnQjRCLE1BQWhCLENBQUwsRUFBOEI7QUFDNUIsVUFBTSxJQUFJenBDLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSVosVUFBVXJDLFNBQWQsRUFBeUI7QUFDdkJxQyxZQUFRLENBQVI7QUFDRDtBQUNELE1BQUlpSixRQUFRdEwsU0FBWixFQUF1QjtBQUNyQnNMLFVBQU1vaEMsU0FBU0EsT0FBTzlyQyxNQUFoQixHQUF5QixDQUEvQjtBQUNEO0FBQ0QsTUFBSStyQyxjQUFjM3NDLFNBQWxCLEVBQTZCO0FBQzNCMnNDLGdCQUFZLENBQVo7QUFDRDtBQUNELE1BQUlDLFlBQVk1c0MsU0FBaEIsRUFBMkI7QUFDekI0c0MsY0FBVSxLQUFLaHNDLE1BQWY7QUFDRDs7QUFFRCxNQUFJeUIsUUFBUSxDQUFSLElBQWFpSixNQUFNb2hDLE9BQU85ckMsTUFBMUIsSUFBb0MrckMsWUFBWSxDQUFoRCxJQUFxREMsVUFBVSxLQUFLaHNDLE1BQXhFLEVBQWdGO0FBQzlFLFVBQU0sSUFBSW1qQyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNEOztBQUVELE1BQUk0SSxhQUFhQyxPQUFiLElBQXdCdnFDLFNBQVNpSixHQUFyQyxFQUEwQztBQUN4QyxXQUFPLENBQVA7QUFDRDtBQUNELE1BQUlxaEMsYUFBYUMsT0FBakIsRUFBMEI7QUFDeEIsV0FBTyxDQUFDLENBQVI7QUFDRDtBQUNELE1BQUl2cUMsU0FBU2lKLEdBQWIsRUFBa0I7QUFDaEIsV0FBTyxDQUFQO0FBQ0Q7O0FBRURqSixhQUFXLENBQVg7QUFDQWlKLFdBQVMsQ0FBVDtBQUNBcWhDLGlCQUFlLENBQWY7QUFDQUMsZUFBYSxDQUFiOztBQUVBLE1BQUksU0FBU0YsTUFBYixFQUFxQixPQUFPLENBQVA7O0FBRXJCLE1BQUlwQixJQUFJc0IsVUFBVUQsU0FBbEI7QUFDQSxNQUFJcEIsSUFBSWpnQyxNQUFNakosS0FBZDtBQUNBLE1BQUl3WixNQUFNcFMsS0FBSzZ1QixHQUFMLENBQVNnVCxDQUFULEVBQVlDLENBQVosQ0FBVjs7QUFFQSxNQUFJc0IsV0FBVyxLQUFLdmlDLEtBQUwsQ0FBV3FpQyxTQUFYLEVBQXNCQyxPQUF0QixDQUFmO0FBQ0EsTUFBSUUsYUFBYUosT0FBT3BpQyxLQUFQLENBQWFqSSxLQUFiLEVBQW9CaUosR0FBcEIsQ0FBakI7O0FBRUEsT0FBSyxJQUFJM0ssSUFBSSxDQUFiLEVBQWdCQSxJQUFJa2IsR0FBcEIsRUFBeUIsRUFBRWxiLENBQTNCLEVBQThCO0FBQzVCLFFBQUlrc0MsU0FBU2xzQyxDQUFULE1BQWdCbXNDLFdBQVduc0MsQ0FBWCxDQUFwQixFQUFtQztBQUNqQzJxQyxVQUFJdUIsU0FBU2xzQyxDQUFULENBQUo7QUFDQTRxQyxVQUFJdUIsV0FBV25zQyxDQUFYLENBQUo7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSTJxQyxJQUFJQyxDQUFSLEVBQVcsT0FBTyxDQUFDLENBQVI7QUFDWCxNQUFJQSxJQUFJRCxDQUFSLEVBQVcsT0FBTyxDQUFQO0FBQ1gsU0FBTyxDQUFQO0FBQ0QsQ0F6REQ7O0FBMkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVN5QixvQkFBVCxDQUErQi9CLE1BQS9CLEVBQXVDamYsR0FBdkMsRUFBNEM4ZSxVQUE1QyxFQUF3RFAsUUFBeEQsRUFBa0VydEIsR0FBbEUsRUFBdUU7QUFDckU7QUFDQSxNQUFJK3RCLE9BQU9wcUMsTUFBUCxLQUFrQixDQUF0QixFQUF5QixPQUFPLENBQUMsQ0FBUjs7QUFFekI7QUFDQSxNQUFJLE9BQU9pcUMsVUFBUCxLQUFzQixRQUExQixFQUFvQztBQUNsQ1AsZUFBV08sVUFBWDtBQUNBQSxpQkFBYSxDQUFiO0FBQ0QsR0FIRCxNQUdPLElBQUlBLGFBQWEsVUFBakIsRUFBNkI7QUFDbENBLGlCQUFhLFVBQWI7QUFDRCxHQUZNLE1BRUEsSUFBSUEsYUFBYSxDQUFDLFVBQWxCLEVBQThCO0FBQ25DQSxpQkFBYSxDQUFDLFVBQWQ7QUFDRDtBQUNEQSxlQUFhLENBQUNBLFVBQWQsQ0FicUUsQ0FhM0M7QUFDMUIsTUFBSXQxQixNQUFNczFCLFVBQU4sQ0FBSixFQUF1QjtBQUNyQjtBQUNBQSxpQkFBYTV0QixNQUFNLENBQU4sR0FBVyt0QixPQUFPcHFDLE1BQVAsR0FBZ0IsQ0FBeEM7QUFDRDs7QUFFRDtBQUNBLE1BQUlpcUMsYUFBYSxDQUFqQixFQUFvQkEsYUFBYUcsT0FBT3BxQyxNQUFQLEdBQWdCaXFDLFVBQTdCO0FBQ3BCLE1BQUlBLGNBQWNHLE9BQU9wcUMsTUFBekIsRUFBaUM7QUFDL0IsUUFBSXFjLEdBQUosRUFBUyxPQUFPLENBQUMsQ0FBUixDQUFULEtBQ0s0dEIsYUFBYUcsT0FBT3BxQyxNQUFQLEdBQWdCLENBQTdCO0FBQ04sR0FIRCxNQUdPLElBQUlpcUMsYUFBYSxDQUFqQixFQUFvQjtBQUN6QixRQUFJNXRCLEdBQUosRUFBUzR0QixhQUFhLENBQWIsQ0FBVCxLQUNLLE9BQU8sQ0FBQyxDQUFSO0FBQ047O0FBRUQ7QUFDQSxNQUFJLE9BQU85ZSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0JBLFVBQU00YyxPQUFPeFAsSUFBUCxDQUFZcE4sR0FBWixFQUFpQnVlLFFBQWpCLENBQU47QUFDRDs7QUFFRDtBQUNBLE1BQUkzQixPQUFPbUMsUUFBUCxDQUFnQi9lLEdBQWhCLENBQUosRUFBMEI7QUFDeEI7QUFDQSxRQUFJQSxJQUFJbnJCLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixhQUFPLENBQUMsQ0FBUjtBQUNEO0FBQ0QsV0FBT29zQyxhQUFhaEMsTUFBYixFQUFxQmpmLEdBQXJCLEVBQTBCOGUsVUFBMUIsRUFBc0NQLFFBQXRDLEVBQWdEcnRCLEdBQWhELENBQVA7QUFDRCxHQU5ELE1BTU8sSUFBSSxPQUFPOE8sR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ2xDQSxVQUFNQSxNQUFNLElBQVosQ0FEa0MsQ0FDakI7QUFDakIsUUFBSTRjLE9BQU9HLG1CQUFQLElBQ0EsT0FBT2pCLFdBQVdwakMsU0FBWCxDQUFxQmdHLE9BQTVCLEtBQXdDLFVBRDVDLEVBQ3dEO0FBQ3RELFVBQUl3UyxHQUFKLEVBQVM7QUFDUCxlQUFPNHFCLFdBQVdwakMsU0FBWCxDQUFxQmdHLE9BQXJCLENBQTZCdkksSUFBN0IsQ0FBa0M4b0MsTUFBbEMsRUFBMENqZixHQUExQyxFQUErQzhlLFVBQS9DLENBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPaEQsV0FBV3BqQyxTQUFYLENBQXFCczlCLFdBQXJCLENBQWlDNy9CLElBQWpDLENBQXNDOG9DLE1BQXRDLEVBQThDamYsR0FBOUMsRUFBbUQ4ZSxVQUFuRCxDQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU9tQyxhQUFhaEMsTUFBYixFQUFxQixDQUFFamYsR0FBRixDQUFyQixFQUE4QjhlLFVBQTlCLEVBQTBDUCxRQUExQyxFQUFvRHJ0QixHQUFwRCxDQUFQO0FBQ0Q7O0FBRUQsUUFBTSxJQUFJaGEsU0FBSixDQUFjLHNDQUFkLENBQU47QUFDRDs7QUFFRCxTQUFTK3BDLFlBQVQsQ0FBdUJsZixHQUF2QixFQUE0Qi9CLEdBQTVCLEVBQWlDOGUsVUFBakMsRUFBNkNQLFFBQTdDLEVBQXVEcnRCLEdBQXZELEVBQTREO0FBQzFELE1BQUlnd0IsWUFBWSxDQUFoQjtBQUNBLE1BQUlDLFlBQVlwZixJQUFJbHRCLE1BQXBCO0FBQ0EsTUFBSXVzQyxZQUFZcGhCLElBQUluckIsTUFBcEI7O0FBRUEsTUFBSTBwQyxhQUFhdHFDLFNBQWpCLEVBQTRCO0FBQzFCc3FDLGVBQVducEIsT0FBT21wQixRQUFQLEVBQWlCem9CLFdBQWpCLEVBQVg7QUFDQSxRQUFJeW9CLGFBQWEsTUFBYixJQUF1QkEsYUFBYSxPQUFwQyxJQUNBQSxhQUFhLFNBRGIsSUFDMEJBLGFBQWEsVUFEM0MsRUFDdUQ7QUFDckQsVUFBSXhjLElBQUlsdEIsTUFBSixHQUFhLENBQWIsSUFBa0JtckIsSUFBSW5yQixNQUFKLEdBQWEsQ0FBbkMsRUFBc0M7QUFDcEMsZUFBTyxDQUFDLENBQVI7QUFDRDtBQUNEcXNDLGtCQUFZLENBQVo7QUFDQUMsbUJBQWEsQ0FBYjtBQUNBQyxtQkFBYSxDQUFiO0FBQ0F0QyxvQkFBYyxDQUFkO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTdUMsSUFBVCxDQUFlNUIsR0FBZixFQUFvQjdxQyxDQUFwQixFQUF1QjtBQUNyQixRQUFJc3NDLGNBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsYUFBT3pCLElBQUk3cUMsQ0FBSixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBTzZxQyxJQUFJNkIsWUFBSixDQUFpQjFzQyxJQUFJc3NDLFNBQXJCLENBQVA7QUFDRDtBQUNGOztBQUVELE1BQUl0c0MsQ0FBSjtBQUNBLE1BQUlzYyxHQUFKLEVBQVM7QUFDUCxRQUFJcXdCLGFBQWEsQ0FBQyxDQUFsQjtBQUNBLFNBQUszc0MsSUFBSWtxQyxVQUFULEVBQXFCbHFDLElBQUl1c0MsU0FBekIsRUFBb0N2c0MsR0FBcEMsRUFBeUM7QUFDdkMsVUFBSXlzQyxLQUFLdGYsR0FBTCxFQUFVbnRCLENBQVYsTUFBaUJ5c0MsS0FBS3JoQixHQUFMLEVBQVV1aEIsZUFBZSxDQUFDLENBQWhCLEdBQW9CLENBQXBCLEdBQXdCM3NDLElBQUkyc0MsVUFBdEMsQ0FBckIsRUFBd0U7QUFDdEUsWUFBSUEsZUFBZSxDQUFDLENBQXBCLEVBQXVCQSxhQUFhM3NDLENBQWI7QUFDdkIsWUFBSUEsSUFBSTJzQyxVQUFKLEdBQWlCLENBQWpCLEtBQXVCSCxTQUEzQixFQUFzQyxPQUFPRyxhQUFhTCxTQUFwQjtBQUN2QyxPQUhELE1BR087QUFDTCxZQUFJSyxlQUFlLENBQUMsQ0FBcEIsRUFBdUIzc0MsS0FBS0EsSUFBSTJzQyxVQUFUO0FBQ3ZCQSxxQkFBYSxDQUFDLENBQWQ7QUFDRDtBQUNGO0FBQ0YsR0FYRCxNQVdPO0FBQ0wsUUFBSXpDLGFBQWFzQyxTQUFiLEdBQXlCRCxTQUE3QixFQUF3Q3JDLGFBQWFxQyxZQUFZQyxTQUF6QjtBQUN4QyxTQUFLeHNDLElBQUlrcUMsVUFBVCxFQUFxQmxxQyxLQUFLLENBQTFCLEVBQTZCQSxHQUE3QixFQUFrQztBQUNoQyxVQUFJMHVCLFFBQVEsSUFBWjtBQUNBLFdBQUssSUFBSWxhLElBQUksQ0FBYixFQUFnQkEsSUFBSWc0QixTQUFwQixFQUErQmg0QixHQUEvQixFQUFvQztBQUNsQyxZQUFJaTRCLEtBQUt0ZixHQUFMLEVBQVVudEIsSUFBSXdVLENBQWQsTUFBcUJpNEIsS0FBS3JoQixHQUFMLEVBQVU1VyxDQUFWLENBQXpCLEVBQXVDO0FBQ3JDa2Esa0JBQVEsS0FBUjtBQUNBO0FBQ0Q7QUFDRjtBQUNELFVBQUlBLEtBQUosRUFBVyxPQUFPMXVCLENBQVA7QUFDWjtBQUNGOztBQUVELFNBQU8sQ0FBQyxDQUFSO0FBQ0Q7O0FBRURnb0MsT0FBT2xrQyxTQUFQLENBQWlCOG9DLFFBQWpCLEdBQTRCLFNBQVNBLFFBQVQsQ0FBbUJ4aEIsR0FBbkIsRUFBd0I4ZSxVQUF4QixFQUFvQ1AsUUFBcEMsRUFBOEM7QUFDeEUsU0FBTyxLQUFLNy9CLE9BQUwsQ0FBYXNoQixHQUFiLEVBQWtCOGUsVUFBbEIsRUFBOEJQLFFBQTlCLE1BQTRDLENBQUMsQ0FBcEQ7QUFDRCxDQUZEOztBQUlBM0IsT0FBT2xrQyxTQUFQLENBQWlCZ0csT0FBakIsR0FBMkIsU0FBU0EsT0FBVCxDQUFrQnNoQixHQUFsQixFQUF1QjhlLFVBQXZCLEVBQW1DUCxRQUFuQyxFQUE2QztBQUN0RSxTQUFPeUMscUJBQXFCLElBQXJCLEVBQTJCaGhCLEdBQTNCLEVBQWdDOGUsVUFBaEMsRUFBNENQLFFBQTVDLEVBQXNELElBQXRELENBQVA7QUFDRCxDQUZEOztBQUlBM0IsT0FBT2xrQyxTQUFQLENBQWlCczlCLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JoVyxHQUF0QixFQUEyQjhlLFVBQTNCLEVBQXVDUCxRQUF2QyxFQUFpRDtBQUM5RSxTQUFPeUMscUJBQXFCLElBQXJCLEVBQTJCaGhCLEdBQTNCLEVBQWdDOGUsVUFBaEMsRUFBNENQLFFBQTVDLEVBQXNELEtBQXRELENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVNrRCxRQUFULENBQW1CaEMsR0FBbkIsRUFBd0JqM0IsTUFBeEIsRUFBZ0M4Z0IsTUFBaEMsRUFBd0N6MEIsTUFBeEMsRUFBZ0Q7QUFDOUN5MEIsV0FBU2dELE9BQU9oRCxNQUFQLEtBQWtCLENBQTNCO0FBQ0EsTUFBSW9ZLFlBQVlqQyxJQUFJNXFDLE1BQUosR0FBYXkwQixNQUE3QjtBQUNBLE1BQUksQ0FBQ3owQixNQUFMLEVBQWE7QUFDWEEsYUFBUzZzQyxTQUFUO0FBQ0QsR0FGRCxNQUVPO0FBQ0w3c0MsYUFBU3kzQixPQUFPejNCLE1BQVAsQ0FBVDtBQUNBLFFBQUlBLFNBQVM2c0MsU0FBYixFQUF3QjtBQUN0QjdzQyxlQUFTNnNDLFNBQVQ7QUFDRDtBQUNGOztBQUVEO0FBQ0EsTUFBSUMsU0FBU241QixPQUFPM1QsTUFBcEI7QUFDQSxNQUFJOHNDLFNBQVMsQ0FBVCxLQUFlLENBQW5CLEVBQXNCLE1BQU0sSUFBSXpxQyxTQUFKLENBQWMsb0JBQWQsQ0FBTjs7QUFFdEIsTUFBSXJDLFNBQVM4c0MsU0FBUyxDQUF0QixFQUF5QjtBQUN2QjlzQyxhQUFTOHNDLFNBQVMsQ0FBbEI7QUFDRDtBQUNELE9BQUssSUFBSS9zQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLE1BQXBCLEVBQTRCLEVBQUVELENBQTlCLEVBQWlDO0FBQy9CLFFBQUkrdkIsU0FBU2xiLFNBQVNqQixPQUFPbkQsTUFBUCxDQUFjelEsSUFBSSxDQUFsQixFQUFxQixDQUFyQixDQUFULEVBQWtDLEVBQWxDLENBQWI7QUFDQSxRQUFJNFUsTUFBTW1iLE1BQU4sQ0FBSixFQUFtQixPQUFPL3ZCLENBQVA7QUFDbkI2cUMsUUFBSW5XLFNBQVMxMEIsQ0FBYixJQUFrQit2QixNQUFsQjtBQUNEO0FBQ0QsU0FBTy92QixDQUFQO0FBQ0Q7O0FBRUQsU0FBU2d0QyxTQUFULENBQW9CbkMsR0FBcEIsRUFBeUJqM0IsTUFBekIsRUFBaUM4Z0IsTUFBakMsRUFBeUN6MEIsTUFBekMsRUFBaUQ7QUFDL0MsU0FBT2d0QyxXQUFXakMsWUFBWXAzQixNQUFaLEVBQW9CaTNCLElBQUk1cUMsTUFBSixHQUFheTBCLE1BQWpDLENBQVgsRUFBcURtVyxHQUFyRCxFQUEwRG5XLE1BQTFELEVBQWtFejBCLE1BQWxFLENBQVA7QUFDRDs7QUFFRCxTQUFTaXRDLFVBQVQsQ0FBcUJyQyxHQUFyQixFQUEwQmozQixNQUExQixFQUFrQzhnQixNQUFsQyxFQUEwQ3owQixNQUExQyxFQUFrRDtBQUNoRCxTQUFPZ3RDLFdBQVdFLGFBQWF2NUIsTUFBYixDQUFYLEVBQWlDaTNCLEdBQWpDLEVBQXNDblcsTUFBdEMsRUFBOEN6MEIsTUFBOUMsQ0FBUDtBQUNEOztBQUVELFNBQVNtdEMsV0FBVCxDQUFzQnZDLEdBQXRCLEVBQTJCajNCLE1BQTNCLEVBQW1DOGdCLE1BQW5DLEVBQTJDejBCLE1BQTNDLEVBQW1EO0FBQ2pELFNBQU9pdEMsV0FBV3JDLEdBQVgsRUFBZ0JqM0IsTUFBaEIsRUFBd0I4Z0IsTUFBeEIsRUFBZ0N6MEIsTUFBaEMsQ0FBUDtBQUNEOztBQUVELFNBQVNvdEMsV0FBVCxDQUFzQnhDLEdBQXRCLEVBQTJCajNCLE1BQTNCLEVBQW1DOGdCLE1BQW5DLEVBQTJDejBCLE1BQTNDLEVBQW1EO0FBQ2pELFNBQU9ndEMsV0FBV2hDLGNBQWNyM0IsTUFBZCxDQUFYLEVBQWtDaTNCLEdBQWxDLEVBQXVDblcsTUFBdkMsRUFBK0N6MEIsTUFBL0MsQ0FBUDtBQUNEOztBQUVELFNBQVNxdEMsU0FBVCxDQUFvQnpDLEdBQXBCLEVBQXlCajNCLE1BQXpCLEVBQWlDOGdCLE1BQWpDLEVBQXlDejBCLE1BQXpDLEVBQWlEO0FBQy9DLFNBQU9ndEMsV0FBV00sZUFBZTM1QixNQUFmLEVBQXVCaTNCLElBQUk1cUMsTUFBSixHQUFheTBCLE1BQXBDLENBQVgsRUFBd0RtVyxHQUF4RCxFQUE2RG5XLE1BQTdELEVBQXFFejBCLE1BQXJFLENBQVA7QUFDRDs7QUFFRCtuQyxPQUFPbGtDLFNBQVAsQ0FBaUJrbUMsS0FBakIsR0FBeUIsU0FBU0EsS0FBVCxDQUFnQnAyQixNQUFoQixFQUF3QjhnQixNQUF4QixFQUFnQ3owQixNQUFoQyxFQUF3QzBwQyxRQUF4QyxFQUFrRDtBQUN6RTtBQUNBLE1BQUlqVixXQUFXcjFCLFNBQWYsRUFBMEI7QUFDeEJzcUMsZUFBVyxNQUFYO0FBQ0ExcEMsYUFBUyxLQUFLQSxNQUFkO0FBQ0F5MEIsYUFBUyxDQUFUO0FBQ0Y7QUFDQyxHQUxELE1BS08sSUFBSXowQixXQUFXWixTQUFYLElBQXdCLE9BQU9xMUIsTUFBUCxLQUFrQixRQUE5QyxFQUF3RDtBQUM3RGlWLGVBQVdqVixNQUFYO0FBQ0F6MEIsYUFBUyxLQUFLQSxNQUFkO0FBQ0F5MEIsYUFBUyxDQUFUO0FBQ0Y7QUFDQyxHQUxNLE1BS0EsSUFBSThZLFNBQVM5WSxNQUFULENBQUosRUFBc0I7QUFDM0JBLGFBQVNBLFNBQVMsQ0FBbEI7QUFDQSxRQUFJOFksU0FBU3Z0QyxNQUFULENBQUosRUFBc0I7QUFDcEJBLGVBQVNBLFNBQVMsQ0FBbEI7QUFDQSxVQUFJMHBDLGFBQWF0cUMsU0FBakIsRUFBNEJzcUMsV0FBVyxNQUFYO0FBQzdCLEtBSEQsTUFHTztBQUNMQSxpQkFBVzFwQyxNQUFYO0FBQ0FBLGVBQVNaLFNBQVQ7QUFDRDtBQUNIO0FBQ0MsR0FWTSxNQVVBO0FBQ0wsVUFBTSxJQUFJdUMsS0FBSixDQUNKLHlFQURJLENBQU47QUFHRDs7QUFFRCxNQUFJa3JDLFlBQVksS0FBSzdzQyxNQUFMLEdBQWN5MEIsTUFBOUI7QUFDQSxNQUFJejBCLFdBQVdaLFNBQVgsSUFBd0JZLFNBQVM2c0MsU0FBckMsRUFBZ0Q3c0MsU0FBUzZzQyxTQUFUOztBQUVoRCxNQUFLbDVCLE9BQU8zVCxNQUFQLEdBQWdCLENBQWhCLEtBQXNCQSxTQUFTLENBQVQsSUFBY3kwQixTQUFTLENBQTdDLENBQUQsSUFBcURBLFNBQVMsS0FBS3owQixNQUF2RSxFQUErRTtBQUM3RSxVQUFNLElBQUltakMsVUFBSixDQUFlLHdDQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJLENBQUN1RyxRQUFMLEVBQWVBLFdBQVcsTUFBWDs7QUFFZixNQUFJb0IsY0FBYyxLQUFsQjtBQUNBLFdBQVM7QUFDUCxZQUFRcEIsUUFBUjtBQUNFLFdBQUssS0FBTDtBQUNFLGVBQU9rRCxTQUFTLElBQVQsRUFBZWo1QixNQUFmLEVBQXVCOGdCLE1BQXZCLEVBQStCejBCLE1BQS9CLENBQVA7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0UsZUFBTytzQyxVQUFVLElBQVYsRUFBZ0JwNUIsTUFBaEIsRUFBd0I4Z0IsTUFBeEIsRUFBZ0N6MEIsTUFBaEMsQ0FBUDs7QUFFRixXQUFLLE9BQUw7QUFDRSxlQUFPaXRDLFdBQVcsSUFBWCxFQUFpQnQ1QixNQUFqQixFQUF5QjhnQixNQUF6QixFQUFpQ3owQixNQUFqQyxDQUFQOztBQUVGLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNFLGVBQU9tdEMsWUFBWSxJQUFaLEVBQWtCeDVCLE1BQWxCLEVBQTBCOGdCLE1BQTFCLEVBQWtDejBCLE1BQWxDLENBQVA7O0FBRUYsV0FBSyxRQUFMO0FBQ0U7QUFDQSxlQUFPb3RDLFlBQVksSUFBWixFQUFrQno1QixNQUFsQixFQUEwQjhnQixNQUExQixFQUFrQ3owQixNQUFsQyxDQUFQOztBQUVGLFdBQUssTUFBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssVUFBTDtBQUNFLGVBQU9xdEMsVUFBVSxJQUFWLEVBQWdCMTVCLE1BQWhCLEVBQXdCOGdCLE1BQXhCLEVBQWdDejBCLE1BQWhDLENBQVA7O0FBRUY7QUFDRSxZQUFJOHFDLFdBQUosRUFBaUIsTUFBTSxJQUFJem9DLFNBQUosQ0FBYyx1QkFBdUJxbkMsUUFBckMsQ0FBTjtBQUNqQkEsbUJBQVcsQ0FBQyxLQUFLQSxRQUFOLEVBQWdCem9CLFdBQWhCLEVBQVg7QUFDQTZwQixzQkFBYyxJQUFkO0FBNUJKO0FBOEJEO0FBQ0YsQ0F0RUQ7O0FBd0VBL0MsT0FBT2xrQyxTQUFQLENBQWlCMnBDLE1BQWpCLEdBQTBCLFNBQVNBLE1BQVQsR0FBbUI7QUFDM0MsU0FBTztBQUNMOXNDLFVBQU0sUUFERDtBQUVMb0csVUFBTWxILE1BQU1pRSxTQUFOLENBQWdCNkYsS0FBaEIsQ0FBc0JwSSxJQUF0QixDQUEyQixLQUFLbXNDLElBQUwsSUFBYSxJQUF4QyxFQUE4QyxDQUE5QztBQUZELEdBQVA7QUFJRCxDQUxEOztBQU9BLFNBQVNuQyxXQUFULENBQXNCVixHQUF0QixFQUEyQm5wQyxLQUEzQixFQUFrQ2lKLEdBQWxDLEVBQXVDO0FBQ3JDLE1BQUlqSixVQUFVLENBQVYsSUFBZWlKLFFBQVFrZ0MsSUFBSTVxQyxNQUEvQixFQUF1QztBQUNyQyxXQUFPNm5DLE9BQU9oQixhQUFQLENBQXFCK0QsR0FBckIsQ0FBUDtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU8vQyxPQUFPaEIsYUFBUCxDQUFxQitELElBQUlsaEMsS0FBSixDQUFVakksS0FBVixFQUFpQmlKLEdBQWpCLENBQXJCLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQVN5Z0MsU0FBVCxDQUFvQlAsR0FBcEIsRUFBeUJucEMsS0FBekIsRUFBZ0NpSixHQUFoQyxFQUFxQztBQUNuQ0EsUUFBTTdCLEtBQUs2dUIsR0FBTCxDQUFTa1QsSUFBSTVxQyxNQUFiLEVBQXFCMEssR0FBckIsQ0FBTjtBQUNBLE1BQUl1dEIsTUFBTSxFQUFWOztBQUVBLE1BQUlsNEIsSUFBSTBCLEtBQVI7QUFDQSxTQUFPMUIsSUFBSTJLLEdBQVgsRUFBZ0I7QUFDZCxRQUFJZ2pDLFlBQVk5QyxJQUFJN3FDLENBQUosQ0FBaEI7QUFDQSxRQUFJOGpDLFlBQVksSUFBaEI7QUFDQSxRQUFJOEosbUJBQW9CRCxZQUFZLElBQWIsR0FBcUIsQ0FBckIsR0FDbEJBLFlBQVksSUFBYixHQUFxQixDQUFyQixHQUNDQSxZQUFZLElBQWIsR0FBcUIsQ0FBckIsR0FDQSxDQUhKOztBQUtBLFFBQUkzdEMsSUFBSTR0QyxnQkFBSixJQUF3QmpqQyxHQUE1QixFQUFpQztBQUMvQixVQUFJa2pDLFVBQUosRUFBZ0JDLFNBQWhCLEVBQTJCQyxVQUEzQixFQUF1Q0MsYUFBdkM7O0FBRUEsY0FBUUosZ0JBQVI7QUFDRSxhQUFLLENBQUw7QUFDRSxjQUFJRCxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCN0osd0JBQVk2SixTQUFaO0FBQ0Q7QUFDRDtBQUNGLGFBQUssQ0FBTDtBQUNFRSx1QkFBYWhELElBQUk3cUMsSUFBSSxDQUFSLENBQWI7QUFDQSxjQUFJLENBQUM2dEMsYUFBYSxJQUFkLE1BQXdCLElBQTVCLEVBQWtDO0FBQ2hDRyw0QkFBZ0IsQ0FBQ0wsWUFBWSxJQUFiLEtBQXNCLEdBQXRCLEdBQTZCRSxhQUFhLElBQTFEO0FBQ0EsZ0JBQUlHLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QmxLLDBCQUFZa0ssYUFBWjtBQUNEO0FBQ0Y7QUFDRDtBQUNGLGFBQUssQ0FBTDtBQUNFSCx1QkFBYWhELElBQUk3cUMsSUFBSSxDQUFSLENBQWI7QUFDQTh0QyxzQkFBWWpELElBQUk3cUMsSUFBSSxDQUFSLENBQVo7QUFDQSxjQUFJLENBQUM2dEMsYUFBYSxJQUFkLE1BQXdCLElBQXhCLElBQWdDLENBQUNDLFlBQVksSUFBYixNQUF1QixJQUEzRCxFQUFpRTtBQUMvREUsNEJBQWdCLENBQUNMLFlBQVksR0FBYixLQUFxQixHQUFyQixHQUEyQixDQUFDRSxhQUFhLElBQWQsS0FBdUIsR0FBbEQsR0FBeURDLFlBQVksSUFBckY7QUFDQSxnQkFBSUUsZ0JBQWdCLEtBQWhCLEtBQTBCQSxnQkFBZ0IsTUFBaEIsSUFBMEJBLGdCQUFnQixNQUFwRSxDQUFKLEVBQWlGO0FBQy9FbEssMEJBQVlrSyxhQUFaO0FBQ0Q7QUFDRjtBQUNEO0FBQ0YsYUFBSyxDQUFMO0FBQ0VILHVCQUFhaEQsSUFBSTdxQyxJQUFJLENBQVIsQ0FBYjtBQUNBOHRDLHNCQUFZakQsSUFBSTdxQyxJQUFJLENBQVIsQ0FBWjtBQUNBK3RDLHVCQUFhbEQsSUFBSTdxQyxJQUFJLENBQVIsQ0FBYjtBQUNBLGNBQUksQ0FBQzZ0QyxhQUFhLElBQWQsTUFBd0IsSUFBeEIsSUFBZ0MsQ0FBQ0MsWUFBWSxJQUFiLE1BQXVCLElBQXZELElBQStELENBQUNDLGFBQWEsSUFBZCxNQUF3QixJQUEzRixFQUFpRztBQUMvRkMsNEJBQWdCLENBQUNMLFlBQVksR0FBYixLQUFxQixJQUFyQixHQUE0QixDQUFDRSxhQUFhLElBQWQsS0FBdUIsR0FBbkQsR0FBeUQsQ0FBQ0MsWUFBWSxJQUFiLEtBQXNCLEdBQS9FLEdBQXNGQyxhQUFhLElBQW5IO0FBQ0EsZ0JBQUlDLGdCQUFnQixNQUFoQixJQUEwQkEsZ0JBQWdCLFFBQTlDLEVBQXdEO0FBQ3REbEssMEJBQVlrSyxhQUFaO0FBQ0Q7QUFDRjtBQWxDTDtBQW9DRDs7QUFFRCxRQUFJbEssY0FBYyxJQUFsQixFQUF3QjtBQUN0QjtBQUNBO0FBQ0FBLGtCQUFZLE1BQVo7QUFDQThKLHlCQUFtQixDQUFuQjtBQUNELEtBTEQsTUFLTyxJQUFJOUosWUFBWSxNQUFoQixFQUF3QjtBQUM3QjtBQUNBQSxtQkFBYSxPQUFiO0FBQ0E1TCxVQUFJcDNCLElBQUosQ0FBU2dqQyxjQUFjLEVBQWQsR0FBbUIsS0FBbkIsR0FBMkIsTUFBcEM7QUFDQUEsa0JBQVksU0FBU0EsWUFBWSxLQUFqQztBQUNEOztBQUVENUwsUUFBSXAzQixJQUFKLENBQVNnakMsU0FBVDtBQUNBOWpDLFNBQUs0dEMsZ0JBQUw7QUFDRDs7QUFFRCxTQUFPSyxzQkFBc0IvVixHQUF0QixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSWdXLHVCQUF1QixNQUEzQjs7QUFFQSxTQUFTRCxxQkFBVCxDQUFnQ0UsVUFBaEMsRUFBNEM7QUFDMUMsTUFBSWp6QixNQUFNaXpCLFdBQVdsdUMsTUFBckI7QUFDQSxNQUFJaWIsT0FBT2d6QixvQkFBWCxFQUFpQztBQUMvQixXQUFPMXRCLE9BQU9DLFlBQVAsQ0FBb0JuYSxLQUFwQixDQUEwQmthLE1BQTFCLEVBQWtDMnRCLFVBQWxDLENBQVAsQ0FEK0IsQ0FDc0I7QUFDdEQ7O0FBRUQ7QUFDQSxNQUFJalcsTUFBTSxFQUFWO0FBQ0EsTUFBSWw0QixJQUFJLENBQVI7QUFDQSxTQUFPQSxJQUFJa2IsR0FBWCxFQUFnQjtBQUNkZ2QsV0FBTzFYLE9BQU9DLFlBQVAsQ0FBb0JuYSxLQUFwQixDQUNMa2EsTUFESyxFQUVMMnRCLFdBQVd4a0MsS0FBWCxDQUFpQjNKLENBQWpCLEVBQW9CQSxLQUFLa3VDLG9CQUF6QixDQUZLLENBQVA7QUFJRDtBQUNELFNBQU9oVyxHQUFQO0FBQ0Q7O0FBRUQsU0FBU21ULFVBQVQsQ0FBcUJSLEdBQXJCLEVBQTBCbnBDLEtBQTFCLEVBQWlDaUosR0FBakMsRUFBc0M7QUFDcEMsTUFBSXlqQyxNQUFNLEVBQVY7QUFDQXpqQyxRQUFNN0IsS0FBSzZ1QixHQUFMLENBQVNrVCxJQUFJNXFDLE1BQWIsRUFBcUIwSyxHQUFyQixDQUFOOztBQUVBLE9BQUssSUFBSTNLLElBQUkwQixLQUFiLEVBQW9CMUIsSUFBSTJLLEdBQXhCLEVBQTZCLEVBQUUzSyxDQUEvQixFQUFrQztBQUNoQ291QyxXQUFPNXRCLE9BQU9DLFlBQVAsQ0FBb0JvcUIsSUFBSTdxQyxDQUFKLElBQVMsSUFBN0IsQ0FBUDtBQUNEO0FBQ0QsU0FBT291QyxHQUFQO0FBQ0Q7O0FBRUQsU0FBUzlDLFdBQVQsQ0FBc0JULEdBQXRCLEVBQTJCbnBDLEtBQTNCLEVBQWtDaUosR0FBbEMsRUFBdUM7QUFDckMsTUFBSXlqQyxNQUFNLEVBQVY7QUFDQXpqQyxRQUFNN0IsS0FBSzZ1QixHQUFMLENBQVNrVCxJQUFJNXFDLE1BQWIsRUFBcUIwSyxHQUFyQixDQUFOOztBQUVBLE9BQUssSUFBSTNLLElBQUkwQixLQUFiLEVBQW9CMUIsSUFBSTJLLEdBQXhCLEVBQTZCLEVBQUUzSyxDQUEvQixFQUFrQztBQUNoQ291QyxXQUFPNXRCLE9BQU9DLFlBQVAsQ0FBb0JvcUIsSUFBSTdxQyxDQUFKLENBQXBCLENBQVA7QUFDRDtBQUNELFNBQU9vdUMsR0FBUDtBQUNEOztBQUVELFNBQVNqRCxRQUFULENBQW1CTixHQUFuQixFQUF3Qm5wQyxLQUF4QixFQUErQmlKLEdBQS9CLEVBQW9DO0FBQ2xDLE1BQUl1USxNQUFNMnZCLElBQUk1cUMsTUFBZDs7QUFFQSxNQUFJLENBQUN5QixLQUFELElBQVVBLFFBQVEsQ0FBdEIsRUFBeUJBLFFBQVEsQ0FBUjtBQUN6QixNQUFJLENBQUNpSixHQUFELElBQVFBLE1BQU0sQ0FBZCxJQUFtQkEsTUFBTXVRLEdBQTdCLEVBQWtDdlEsTUFBTXVRLEdBQU47O0FBRWxDLE1BQUlzcEIsTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJeGtDLElBQUkwQixLQUFiLEVBQW9CMUIsSUFBSTJLLEdBQXhCLEVBQTZCLEVBQUUzSyxDQUEvQixFQUFrQztBQUNoQ3drQyxXQUFPNkosTUFBTXhELElBQUk3cUMsQ0FBSixDQUFOLENBQVA7QUFDRDtBQUNELFNBQU93a0MsR0FBUDtBQUNEOztBQUVELFNBQVNnSCxZQUFULENBQXVCWCxHQUF2QixFQUE0Qm5wQyxLQUE1QixFQUFtQ2lKLEdBQW5DLEVBQXdDO0FBQ3RDLE1BQUkyakMsUUFBUXpELElBQUlsaEMsS0FBSixDQUFVakksS0FBVixFQUFpQmlKLEdBQWpCLENBQVo7QUFDQSxNQUFJdXRCLE1BQU0sRUFBVjtBQUNBLE9BQUssSUFBSWw0QixJQUFJLENBQWIsRUFBZ0JBLElBQUlzdUMsTUFBTXJ1QyxNQUExQixFQUFrQ0QsS0FBSyxDQUF2QyxFQUEwQztBQUN4Q2s0QixXQUFPMVgsT0FBT0MsWUFBUCxDQUFvQjZ0QixNQUFNdHVDLENBQU4sSUFBV3N1QyxNQUFNdHVDLElBQUksQ0FBVixJQUFlLEdBQTlDLENBQVA7QUFDRDtBQUNELFNBQU9rNEIsR0FBUDtBQUNEOztBQUVEOFAsT0FBT2xrQyxTQUFQLENBQWlCNkYsS0FBakIsR0FBeUIsU0FBU0EsS0FBVCxDQUFnQmpJLEtBQWhCLEVBQXVCaUosR0FBdkIsRUFBNEI7QUFDbkQsTUFBSXVRLE1BQU0sS0FBS2piLE1BQWY7QUFDQXlCLFVBQVEsQ0FBQyxDQUFDQSxLQUFWO0FBQ0FpSixRQUFNQSxRQUFRdEwsU0FBUixHQUFvQjZiLEdBQXBCLEdBQTBCLENBQUMsQ0FBQ3ZRLEdBQWxDOztBQUVBLE1BQUlqSixRQUFRLENBQVosRUFBZTtBQUNiQSxhQUFTd1osR0FBVDtBQUNBLFFBQUl4WixRQUFRLENBQVosRUFBZUEsUUFBUSxDQUFSO0FBQ2hCLEdBSEQsTUFHTyxJQUFJQSxRQUFRd1osR0FBWixFQUFpQjtBQUN0QnhaLFlBQVF3WixHQUFSO0FBQ0Q7O0FBRUQsTUFBSXZRLE1BQU0sQ0FBVixFQUFhO0FBQ1hBLFdBQU91USxHQUFQO0FBQ0EsUUFBSXZRLE1BQU0sQ0FBVixFQUFhQSxNQUFNLENBQU47QUFDZCxHQUhELE1BR08sSUFBSUEsTUFBTXVRLEdBQVYsRUFBZTtBQUNwQnZRLFVBQU11USxHQUFOO0FBQ0Q7O0FBRUQsTUFBSXZRLE1BQU1qSixLQUFWLEVBQWlCaUosTUFBTWpKLEtBQU47O0FBRWpCLE1BQUk2c0MsTUFBSjtBQUNBLE1BQUl2RyxPQUFPRyxtQkFBWCxFQUFnQztBQUM5Qm9HLGFBQVMsS0FBSy9GLFFBQUwsQ0FBYzltQyxLQUFkLEVBQXFCaUosR0FBckIsQ0FBVDtBQUNBNGpDLFdBQU9qRyxTQUFQLEdBQW1CTixPQUFPbGtDLFNBQTFCO0FBQ0QsR0FIRCxNQUdPO0FBQ0wsUUFBSTBxQyxXQUFXN2pDLE1BQU1qSixLQUFyQjtBQUNBNnNDLGFBQVMsSUFBSXZHLE1BQUosQ0FBV3dHLFFBQVgsRUFBcUJudkMsU0FBckIsQ0FBVDtBQUNBLFNBQUssSUFBSVcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJd3VDLFFBQXBCLEVBQThCLEVBQUV4dUMsQ0FBaEMsRUFBbUM7QUFDakN1dUMsYUFBT3Z1QyxDQUFQLElBQVksS0FBS0EsSUFBSTBCLEtBQVQsQ0FBWjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTzZzQyxNQUFQO0FBQ0QsQ0FsQ0Q7O0FBb0NBOzs7QUFHQSxTQUFTRSxXQUFULENBQXNCL1osTUFBdEIsRUFBOEJnYSxHQUE5QixFQUFtQ3p1QyxNQUFuQyxFQUEyQztBQUN6QyxNQUFLeTBCLFNBQVMsQ0FBVixLQUFpQixDQUFqQixJQUFzQkEsU0FBUyxDQUFuQyxFQUFzQyxNQUFNLElBQUkwTyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUN0QyxNQUFJMU8sU0FBU2dhLEdBQVQsR0FBZXp1QyxNQUFuQixFQUEyQixNQUFNLElBQUltakMsVUFBSixDQUFlLHVDQUFmLENBQU47QUFDNUI7O0FBRUQ0RSxPQUFPbGtDLFNBQVAsQ0FBaUI2cUMsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQmphLE1BQXJCLEVBQTZCa1MsVUFBN0IsRUFBeUNnSSxRQUF6QyxFQUFtRDtBQUMvRWxhLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQWtTLGVBQWFBLGFBQWEsQ0FBMUI7QUFDQSxNQUFJLENBQUNnSSxRQUFMLEVBQWVILFlBQVkvWixNQUFaLEVBQW9Ca1MsVUFBcEIsRUFBZ0MsS0FBSzNtQyxNQUFyQzs7QUFFZixNQUFJbXJCLE1BQU0sS0FBS3NKLE1BQUwsQ0FBVjtBQUNBLE1BQUltYSxNQUFNLENBQVY7QUFDQSxNQUFJN3VDLElBQUksQ0FBUjtBQUNBLFNBQU8sRUFBRUEsQ0FBRixHQUFNNG1DLFVBQU4sS0FBcUJpSSxPQUFPLEtBQTVCLENBQVAsRUFBMkM7QUFDekN6akIsV0FBTyxLQUFLc0osU0FBUzEwQixDQUFkLElBQW1CNnVDLEdBQTFCO0FBQ0Q7O0FBRUQsU0FBT3pqQixHQUFQO0FBQ0QsQ0FiRDs7QUFlQTRjLE9BQU9sa0MsU0FBUCxDQUFpQmdyQyxVQUFqQixHQUE4QixTQUFTQSxVQUFULENBQXFCcGEsTUFBckIsRUFBNkJrUyxVQUE3QixFQUF5Q2dJLFFBQXpDLEVBQW1EO0FBQy9FbGEsV0FBU0EsU0FBUyxDQUFsQjtBQUNBa1MsZUFBYUEsYUFBYSxDQUExQjtBQUNBLE1BQUksQ0FBQ2dJLFFBQUwsRUFBZTtBQUNiSCxnQkFBWS9aLE1BQVosRUFBb0JrUyxVQUFwQixFQUFnQyxLQUFLM21DLE1BQXJDO0FBQ0Q7O0FBRUQsTUFBSW1yQixNQUFNLEtBQUtzSixTQUFTLEVBQUVrUyxVQUFoQixDQUFWO0FBQ0EsTUFBSWlJLE1BQU0sQ0FBVjtBQUNBLFNBQU9qSSxhQUFhLENBQWIsS0FBbUJpSSxPQUFPLEtBQTFCLENBQVAsRUFBeUM7QUFDdkN6akIsV0FBTyxLQUFLc0osU0FBUyxFQUFFa1MsVUFBaEIsSUFBOEJpSSxHQUFyQztBQUNEOztBQUVELFNBQU96akIsR0FBUDtBQUNELENBZEQ7O0FBZ0JBNGMsT0FBT2xrQyxTQUFQLENBQWlCaXJDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0JyYSxNQUFwQixFQUE0QmthLFFBQTVCLEVBQXNDO0FBQ2pFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZL1osTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLejBCLE1BQTVCO0FBQ2YsU0FBTyxLQUFLeTBCLE1BQUwsQ0FBUDtBQUNELENBSEQ7O0FBS0FzVCxPQUFPbGtDLFNBQVAsQ0FBaUJrckMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QnRhLE1BQXZCLEVBQStCa2EsUUFBL0IsRUFBeUM7QUFDdkUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVkvWixNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUt6MEIsTUFBNUI7QUFDZixTQUFPLEtBQUt5MEIsTUFBTCxJQUFnQixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FBM0M7QUFDRCxDQUhEOztBQUtBc1QsT0FBT2xrQyxTQUFQLENBQWlCNG9DLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJoWSxNQUF2QixFQUErQmthLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZL1osTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLejBCLE1BQTVCO0FBQ2YsU0FBUSxLQUFLeTBCLE1BQUwsS0FBZ0IsQ0FBakIsR0FBc0IsS0FBS0EsU0FBUyxDQUFkLENBQTdCO0FBQ0QsQ0FIRDs7QUFLQXNULE9BQU9sa0MsU0FBUCxDQUFpQm1yQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCdmEsTUFBdkIsRUFBK0JrYSxRQUEvQixFQUF5QztBQUN2RSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWS9aLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS3owQixNQUE1Qjs7QUFFZixTQUFPLENBQUUsS0FBS3kwQixNQUFMLENBQUQsR0FDSCxLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FEakIsR0FFSCxLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFGbEIsSUFHRixLQUFLQSxTQUFTLENBQWQsSUFBbUIsU0FIeEI7QUFJRCxDQVBEOztBQVNBc1QsT0FBT2xrQyxTQUFQLENBQWlCb3JDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJ4YSxNQUF2QixFQUErQmthLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZL1osTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLejBCLE1BQTVCOztBQUVmLFNBQVEsS0FBS3kwQixNQUFMLElBQWUsU0FBaEIsSUFDSCxLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFBckIsR0FDQSxLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FEcEIsR0FFRCxLQUFLQSxTQUFTLENBQWQsQ0FISyxDQUFQO0FBSUQsQ0FQRDs7QUFTQXNULE9BQU9sa0MsU0FBUCxDQUFpQnFyQyxTQUFqQixHQUE2QixTQUFTQSxTQUFULENBQW9CemEsTUFBcEIsRUFBNEJrUyxVQUE1QixFQUF3Q2dJLFFBQXhDLEVBQWtEO0FBQzdFbGEsV0FBU0EsU0FBUyxDQUFsQjtBQUNBa1MsZUFBYUEsYUFBYSxDQUExQjtBQUNBLE1BQUksQ0FBQ2dJLFFBQUwsRUFBZUgsWUFBWS9aLE1BQVosRUFBb0JrUyxVQUFwQixFQUFnQyxLQUFLM21DLE1BQXJDOztBQUVmLE1BQUltckIsTUFBTSxLQUFLc0osTUFBTCxDQUFWO0FBQ0EsTUFBSW1hLE1BQU0sQ0FBVjtBQUNBLE1BQUk3dUMsSUFBSSxDQUFSO0FBQ0EsU0FBTyxFQUFFQSxDQUFGLEdBQU00bUMsVUFBTixLQUFxQmlJLE9BQU8sS0FBNUIsQ0FBUCxFQUEyQztBQUN6Q3pqQixXQUFPLEtBQUtzSixTQUFTMTBCLENBQWQsSUFBbUI2dUMsR0FBMUI7QUFDRDtBQUNEQSxTQUFPLElBQVA7O0FBRUEsTUFBSXpqQixPQUFPeWpCLEdBQVgsRUFBZ0J6akIsT0FBT3RpQixLQUFLc21DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXhJLFVBQWhCLENBQVA7O0FBRWhCLFNBQU94YixHQUFQO0FBQ0QsQ0FoQkQ7O0FBa0JBNGMsT0FBT2xrQyxTQUFQLENBQWlCdXJDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0IzYSxNQUFwQixFQUE0QmtTLFVBQTVCLEVBQXdDZ0ksUUFBeEMsRUFBa0Q7QUFDN0VsYSxXQUFTQSxTQUFTLENBQWxCO0FBQ0FrUyxlQUFhQSxhQUFhLENBQTFCO0FBQ0EsTUFBSSxDQUFDZ0ksUUFBTCxFQUFlSCxZQUFZL1osTUFBWixFQUFvQmtTLFVBQXBCLEVBQWdDLEtBQUszbUMsTUFBckM7O0FBRWYsTUFBSUQsSUFBSTRtQyxVQUFSO0FBQ0EsTUFBSWlJLE1BQU0sQ0FBVjtBQUNBLE1BQUl6akIsTUFBTSxLQUFLc0osU0FBUyxFQUFFMTBCLENBQWhCLENBQVY7QUFDQSxTQUFPQSxJQUFJLENBQUosS0FBVTZ1QyxPQUFPLEtBQWpCLENBQVAsRUFBZ0M7QUFDOUJ6akIsV0FBTyxLQUFLc0osU0FBUyxFQUFFMTBCLENBQWhCLElBQXFCNnVDLEdBQTVCO0FBQ0Q7QUFDREEsU0FBTyxJQUFQOztBQUVBLE1BQUl6akIsT0FBT3lqQixHQUFYLEVBQWdCempCLE9BQU90aUIsS0FBS3NtQyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUl4SSxVQUFoQixDQUFQOztBQUVoQixTQUFPeGIsR0FBUDtBQUNELENBaEJEOztBQWtCQTRjLE9BQU9sa0MsU0FBUCxDQUFpQndyQyxRQUFqQixHQUE0QixTQUFTQSxRQUFULENBQW1CNWEsTUFBbkIsRUFBMkJrYSxRQUEzQixFQUFxQztBQUMvRCxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWS9aLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS3owQixNQUE1QjtBQUNmLE1BQUksRUFBRSxLQUFLeTBCLE1BQUwsSUFBZSxJQUFqQixDQUFKLEVBQTRCLE9BQVEsS0FBS0EsTUFBTCxDQUFSO0FBQzVCLFNBQVEsQ0FBQyxPQUFPLEtBQUtBLE1BQUwsQ0FBUCxHQUFzQixDQUF2QixJQUE0QixDQUFDLENBQXJDO0FBQ0QsQ0FKRDs7QUFNQXNULE9BQU9sa0MsU0FBUCxDQUFpQnlyQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCN2EsTUFBdEIsRUFBOEJrYSxRQUE5QixFQUF3QztBQUNyRSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWS9aLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS3owQixNQUE1QjtBQUNmLE1BQUltckIsTUFBTSxLQUFLc0osTUFBTCxJQUFnQixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FBOUM7QUFDQSxTQUFRdEosTUFBTSxNQUFQLEdBQWlCQSxNQUFNLFVBQXZCLEdBQW9DQSxHQUEzQztBQUNELENBSkQ7O0FBTUE0YyxPQUFPbGtDLFNBQVAsQ0FBaUIwckMsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQjlhLE1BQXRCLEVBQThCa2EsUUFBOUIsRUFBd0M7QUFDckUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVkvWixNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUt6MEIsTUFBNUI7QUFDZixNQUFJbXJCLE1BQU0sS0FBS3NKLFNBQVMsQ0FBZCxJQUFvQixLQUFLQSxNQUFMLEtBQWdCLENBQTlDO0FBQ0EsU0FBUXRKLE1BQU0sTUFBUCxHQUFpQkEsTUFBTSxVQUF2QixHQUFvQ0EsR0FBM0M7QUFDRCxDQUpEOztBQU1BNGMsT0FBT2xrQyxTQUFQLENBQWlCMnJDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0IvYSxNQUF0QixFQUE4QmthLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZL1osTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLejBCLE1BQTVCOztBQUVmLFNBQVEsS0FBS3kwQixNQUFMLENBQUQsR0FDSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FEaEIsR0FFSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFGaEIsR0FHSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFIdkI7QUFJRCxDQVBEOztBQVNBc1QsT0FBT2xrQyxTQUFQLENBQWlCNHJDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JoYixNQUF0QixFQUE4QmthLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZL1osTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLejBCLE1BQTVCOztBQUVmLFNBQVEsS0FBS3kwQixNQUFMLEtBQWdCLEVBQWpCLEdBQ0osS0FBS0EsU0FBUyxDQUFkLEtBQW9CLEVBRGhCLEdBRUosS0FBS0EsU0FBUyxDQUFkLEtBQW9CLENBRmhCLEdBR0osS0FBS0EsU0FBUyxDQUFkLENBSEg7QUFJRCxDQVBEOztBQVNBc1QsT0FBT2xrQyxTQUFQLENBQWlCNnJDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JqYixNQUF0QixFQUE4QmthLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZL1osTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLejBCLE1BQTVCO0FBQ2YsU0FBTzhuQyxRQUFRMEUsSUFBUixDQUFhLElBQWIsRUFBbUIvWCxNQUFuQixFQUEyQixJQUEzQixFQUFpQyxFQUFqQyxFQUFxQyxDQUFyQyxDQUFQO0FBQ0QsQ0FIRDs7QUFLQXNULE9BQU9sa0MsU0FBUCxDQUFpQjhyQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCbGIsTUFBdEIsRUFBOEJrYSxRQUE5QixFQUF3QztBQUNyRSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWS9aLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS3owQixNQUE1QjtBQUNmLFNBQU84bkMsUUFBUTBFLElBQVIsQ0FBYSxJQUFiLEVBQW1CL1gsTUFBbkIsRUFBMkIsS0FBM0IsRUFBa0MsRUFBbEMsRUFBc0MsQ0FBdEMsQ0FBUDtBQUNELENBSEQ7O0FBS0FzVCxPQUFPbGtDLFNBQVAsQ0FBaUIrckMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1Qm5iLE1BQXZCLEVBQStCa2EsUUFBL0IsRUFBeUM7QUFDdkUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVkvWixNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUt6MEIsTUFBNUI7QUFDZixTQUFPOG5DLFFBQVEwRSxJQUFSLENBQWEsSUFBYixFQUFtQi9YLE1BQW5CLEVBQTJCLElBQTNCLEVBQWlDLEVBQWpDLEVBQXFDLENBQXJDLENBQVA7QUFDRCxDQUhEOztBQUtBc1QsT0FBT2xrQyxTQUFQLENBQWlCZ3NDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJwYixNQUF2QixFQUErQmthLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZL1osTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLejBCLE1BQTVCO0FBQ2YsU0FBTzhuQyxRQUFRMEUsSUFBUixDQUFhLElBQWIsRUFBbUIvWCxNQUFuQixFQUEyQixLQUEzQixFQUFrQyxFQUFsQyxFQUFzQyxDQUF0QyxDQUFQO0FBQ0QsQ0FIRDs7QUFLQSxTQUFTcWIsUUFBVCxDQUFtQmxGLEdBQW5CLEVBQXdCanFDLEtBQXhCLEVBQStCOHpCLE1BQS9CLEVBQXVDZ2EsR0FBdkMsRUFBNEMvbkIsR0FBNUMsRUFBaURnUixHQUFqRCxFQUFzRDtBQUNwRCxNQUFJLENBQUNxUSxPQUFPbUMsUUFBUCxDQUFnQlUsR0FBaEIsQ0FBTCxFQUEyQixNQUFNLElBQUl2b0MsU0FBSixDQUFjLDZDQUFkLENBQU47QUFDM0IsTUFBSTFCLFFBQVErbEIsR0FBUixJQUFlL2xCLFFBQVErMkIsR0FBM0IsRUFBZ0MsTUFBTSxJQUFJeUwsVUFBSixDQUFlLG1DQUFmLENBQU47QUFDaEMsTUFBSTFPLFNBQVNnYSxHQUFULEdBQWU3RCxJQUFJNXFDLE1BQXZCLEVBQStCLE1BQU0sSUFBSW1qQyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNoQzs7QUFFRDRFLE9BQU9sa0MsU0FBUCxDQUFpQmtzQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCcHZDLEtBQXRCLEVBQTZCOHpCLE1BQTdCLEVBQXFDa1MsVUFBckMsRUFBaURnSSxRQUFqRCxFQUEyRDtBQUN4Rmh1QyxVQUFRLENBQUNBLEtBQVQ7QUFDQTh6QixXQUFTQSxTQUFTLENBQWxCO0FBQ0FrUyxlQUFhQSxhQUFhLENBQTFCO0FBQ0EsTUFBSSxDQUFDZ0ksUUFBTCxFQUFlO0FBQ2IsUUFBSXFCLFdBQVdubkMsS0FBS3NtQyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUl4SSxVQUFoQixJQUE4QixDQUE3QztBQUNBbUosYUFBUyxJQUFULEVBQWVudkMsS0FBZixFQUFzQjh6QixNQUF0QixFQUE4QmtTLFVBQTlCLEVBQTBDcUosUUFBMUMsRUFBb0QsQ0FBcEQ7QUFDRDs7QUFFRCxNQUFJcEIsTUFBTSxDQUFWO0FBQ0EsTUFBSTd1QyxJQUFJLENBQVI7QUFDQSxPQUFLMDBCLE1BQUwsSUFBZTl6QixRQUFRLElBQXZCO0FBQ0EsU0FBTyxFQUFFWixDQUFGLEdBQU00bUMsVUFBTixLQUFxQmlJLE9BQU8sS0FBNUIsQ0FBUCxFQUEyQztBQUN6QyxTQUFLbmEsU0FBUzEwQixDQUFkLElBQW9CWSxRQUFRaXVDLEdBQVQsR0FBZ0IsSUFBbkM7QUFDRDs7QUFFRCxTQUFPbmEsU0FBU2tTLFVBQWhCO0FBQ0QsQ0FqQkQ7O0FBbUJBb0IsT0FBT2xrQyxTQUFQLENBQWlCb3NDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0J0dkMsS0FBdEIsRUFBNkI4ekIsTUFBN0IsRUFBcUNrUyxVQUFyQyxFQUFpRGdJLFFBQWpELEVBQTJEO0FBQ3hGaHVDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBOHpCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQWtTLGVBQWFBLGFBQWEsQ0FBMUI7QUFDQSxNQUFJLENBQUNnSSxRQUFMLEVBQWU7QUFDYixRQUFJcUIsV0FBV25uQyxLQUFLc21DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXhJLFVBQWhCLElBQThCLENBQTdDO0FBQ0FtSixhQUFTLElBQVQsRUFBZW52QyxLQUFmLEVBQXNCOHpCLE1BQXRCLEVBQThCa1MsVUFBOUIsRUFBMENxSixRQUExQyxFQUFvRCxDQUFwRDtBQUNEOztBQUVELE1BQUlqd0MsSUFBSTRtQyxhQUFhLENBQXJCO0FBQ0EsTUFBSWlJLE1BQU0sQ0FBVjtBQUNBLE9BQUtuYSxTQUFTMTBCLENBQWQsSUFBbUJZLFFBQVEsSUFBM0I7QUFDQSxTQUFPLEVBQUVaLENBQUYsSUFBTyxDQUFQLEtBQWE2dUMsT0FBTyxLQUFwQixDQUFQLEVBQW1DO0FBQ2pDLFNBQUtuYSxTQUFTMTBCLENBQWQsSUFBb0JZLFFBQVFpdUMsR0FBVCxHQUFnQixJQUFuQztBQUNEOztBQUVELFNBQU9uYSxTQUFTa1MsVUFBaEI7QUFDRCxDQWpCRDs7QUFtQkFvQixPQUFPbGtDLFNBQVAsQ0FBaUJxc0MsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQnZ2QyxLQUFyQixFQUE0Qjh6QixNQUE1QixFQUFvQ2thLFFBQXBDLEVBQThDO0FBQzFFaHVDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBOHpCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNrYSxRQUFMLEVBQWVtQixTQUFTLElBQVQsRUFBZW52QyxLQUFmLEVBQXNCOHpCLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLElBQWpDLEVBQXVDLENBQXZDO0FBQ2YsTUFBSSxDQUFDc1QsT0FBT0csbUJBQVosRUFBaUN2bkMsUUFBUWtJLEtBQUtvNkIsS0FBTCxDQUFXdGlDLEtBQVgsQ0FBUjtBQUNqQyxPQUFLOHpCLE1BQUwsSUFBZ0I5ekIsUUFBUSxJQUF4QjtBQUNBLFNBQU84ekIsU0FBUyxDQUFoQjtBQUNELENBUEQ7O0FBU0EsU0FBUzBiLGlCQUFULENBQTRCdkYsR0FBNUIsRUFBaUNqcUMsS0FBakMsRUFBd0M4ekIsTUFBeEMsRUFBZ0QyYixZQUFoRCxFQUE4RDtBQUM1RCxNQUFJenZDLFFBQVEsQ0FBWixFQUFlQSxRQUFRLFNBQVNBLEtBQVQsR0FBaUIsQ0FBekI7QUFDZixPQUFLLElBQUlaLElBQUksQ0FBUixFQUFXd1UsSUFBSTFMLEtBQUs2dUIsR0FBTCxDQUFTa1QsSUFBSTVxQyxNQUFKLEdBQWF5MEIsTUFBdEIsRUFBOEIsQ0FBOUIsQ0FBcEIsRUFBc0QxMEIsSUFBSXdVLENBQTFELEVBQTZELEVBQUV4VSxDQUEvRCxFQUFrRTtBQUNoRTZxQyxRQUFJblcsU0FBUzEwQixDQUFiLElBQWtCLENBQUNZLFFBQVMsUUFBUyxLQUFLeXZDLGVBQWVyd0MsQ0FBZixHQUFtQixJQUFJQSxDQUE1QixDQUFuQixNQUNoQixDQUFDcXdDLGVBQWVyd0MsQ0FBZixHQUFtQixJQUFJQSxDQUF4QixJQUE2QixDQUQvQjtBQUVEO0FBQ0Y7O0FBRURnb0MsT0FBT2xrQyxTQUFQLENBQWlCd3NDLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsQ0FBd0IxdkMsS0FBeEIsRUFBK0I4ekIsTUFBL0IsRUFBdUNrYSxRQUF2QyxFQUFpRDtBQUNoRmh1QyxVQUFRLENBQUNBLEtBQVQ7QUFDQTh6QixXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDa2EsUUFBTCxFQUFlbUIsU0FBUyxJQUFULEVBQWVudkMsS0FBZixFQUFzQjh6QixNQUF0QixFQUE4QixDQUE5QixFQUFpQyxNQUFqQyxFQUF5QyxDQUF6QztBQUNmLE1BQUlzVCxPQUFPRyxtQkFBWCxFQUFnQztBQUM5QixTQUFLelQsTUFBTCxJQUFnQjl6QixRQUFRLElBQXhCO0FBQ0EsU0FBSzh6QixTQUFTLENBQWQsSUFBb0I5ekIsVUFBVSxDQUE5QjtBQUNELEdBSEQsTUFHTztBQUNMd3ZDLHNCQUFrQixJQUFsQixFQUF3Qnh2QyxLQUF4QixFQUErQjh6QixNQUEvQixFQUF1QyxJQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBWEQ7O0FBYUFzVCxPQUFPbGtDLFNBQVAsQ0FBaUJ5c0MsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QjN2QyxLQUF4QixFQUErQjh6QixNQUEvQixFQUF1Q2thLFFBQXZDLEVBQWlEO0FBQ2hGaHVDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBOHpCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNrYSxRQUFMLEVBQWVtQixTQUFTLElBQVQsRUFBZW52QyxLQUFmLEVBQXNCOHpCLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLE1BQWpDLEVBQXlDLENBQXpDO0FBQ2YsTUFBSXNULE9BQU9HLG1CQUFYLEVBQWdDO0FBQzlCLFNBQUt6VCxNQUFMLElBQWdCOXpCLFVBQVUsQ0FBMUI7QUFDQSxTQUFLOHpCLFNBQVMsQ0FBZCxJQUFvQjl6QixRQUFRLElBQTVCO0FBQ0QsR0FIRCxNQUdPO0FBQ0x3dkMsc0JBQWtCLElBQWxCLEVBQXdCeHZDLEtBQXhCLEVBQStCOHpCLE1BQS9CLEVBQXVDLEtBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FYRDs7QUFhQSxTQUFTOGIsaUJBQVQsQ0FBNEIzRixHQUE1QixFQUFpQ2pxQyxLQUFqQyxFQUF3Qzh6QixNQUF4QyxFQUFnRDJiLFlBQWhELEVBQThEO0FBQzVELE1BQUl6dkMsUUFBUSxDQUFaLEVBQWVBLFFBQVEsYUFBYUEsS0FBYixHQUFxQixDQUE3QjtBQUNmLE9BQUssSUFBSVosSUFBSSxDQUFSLEVBQVd3VSxJQUFJMUwsS0FBSzZ1QixHQUFMLENBQVNrVCxJQUFJNXFDLE1BQUosR0FBYXkwQixNQUF0QixFQUE4QixDQUE5QixDQUFwQixFQUFzRDEwQixJQUFJd1UsQ0FBMUQsRUFBNkQsRUFBRXhVLENBQS9ELEVBQWtFO0FBQ2hFNnFDLFFBQUluVyxTQUFTMTBCLENBQWIsSUFBbUJZLFVBQVUsQ0FBQ3l2QyxlQUFlcndDLENBQWYsR0FBbUIsSUFBSUEsQ0FBeEIsSUFBNkIsQ0FBeEMsR0FBNkMsSUFBL0Q7QUFDRDtBQUNGOztBQUVEZ29DLE9BQU9sa0MsU0FBUCxDQUFpQjJzQyxhQUFqQixHQUFpQyxTQUFTQSxhQUFULENBQXdCN3ZDLEtBQXhCLEVBQStCOHpCLE1BQS9CLEVBQXVDa2EsUUFBdkMsRUFBaUQ7QUFDaEZodUMsVUFBUSxDQUFDQSxLQUFUO0FBQ0E4ekIsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ2thLFFBQUwsRUFBZW1CLFNBQVMsSUFBVCxFQUFlbnZDLEtBQWYsRUFBc0I4ekIsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsVUFBakMsRUFBNkMsQ0FBN0M7QUFDZixNQUFJc1QsT0FBT0csbUJBQVgsRUFBZ0M7QUFDOUIsU0FBS3pULFNBQVMsQ0FBZCxJQUFvQjl6QixVQUFVLEVBQTlCO0FBQ0EsU0FBSzh6QixTQUFTLENBQWQsSUFBb0I5ekIsVUFBVSxFQUE5QjtBQUNBLFNBQUs4ekIsU0FBUyxDQUFkLElBQW9COXpCLFVBQVUsQ0FBOUI7QUFDQSxTQUFLOHpCLE1BQUwsSUFBZ0I5ekIsUUFBUSxJQUF4QjtBQUNELEdBTEQsTUFLTztBQUNMNHZDLHNCQUFrQixJQUFsQixFQUF3QjV2QyxLQUF4QixFQUErQjh6QixNQUEvQixFQUF1QyxJQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBYkQ7O0FBZUFzVCxPQUFPbGtDLFNBQVAsQ0FBaUI0c0MsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3Qjl2QyxLQUF4QixFQUErQjh6QixNQUEvQixFQUF1Q2thLFFBQXZDLEVBQWlEO0FBQ2hGaHVDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBOHpCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNrYSxRQUFMLEVBQWVtQixTQUFTLElBQVQsRUFBZW52QyxLQUFmLEVBQXNCOHpCLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLFVBQWpDLEVBQTZDLENBQTdDO0FBQ2YsTUFBSXNULE9BQU9HLG1CQUFYLEVBQWdDO0FBQzlCLFNBQUt6VCxNQUFMLElBQWdCOXpCLFVBQVUsRUFBMUI7QUFDQSxTQUFLOHpCLFNBQVMsQ0FBZCxJQUFvQjl6QixVQUFVLEVBQTlCO0FBQ0EsU0FBSzh6QixTQUFTLENBQWQsSUFBb0I5ekIsVUFBVSxDQUE5QjtBQUNBLFNBQUs4ekIsU0FBUyxDQUFkLElBQW9COXpCLFFBQVEsSUFBNUI7QUFDRCxHQUxELE1BS087QUFDTDR2QyxzQkFBa0IsSUFBbEIsRUFBd0I1dkMsS0FBeEIsRUFBK0I4ekIsTUFBL0IsRUFBdUMsS0FBdkM7QUFDRDtBQUNELFNBQU9BLFNBQVMsQ0FBaEI7QUFDRCxDQWJEOztBQWVBc1QsT0FBT2xrQyxTQUFQLENBQWlCNnNDLFVBQWpCLEdBQThCLFNBQVNBLFVBQVQsQ0FBcUIvdkMsS0FBckIsRUFBNEI4ekIsTUFBNUIsRUFBb0NrUyxVQUFwQyxFQUFnRGdJLFFBQWhELEVBQTBEO0FBQ3RGaHVDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBOHpCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNrYSxRQUFMLEVBQWU7QUFDYixRQUFJZ0MsUUFBUTluQyxLQUFLc21DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXhJLFVBQUosR0FBaUIsQ0FBN0IsQ0FBWjs7QUFFQW1KLGFBQVMsSUFBVCxFQUFlbnZDLEtBQWYsRUFBc0I4ekIsTUFBdEIsRUFBOEJrUyxVQUE5QixFQUEwQ2dLLFFBQVEsQ0FBbEQsRUFBcUQsQ0FBQ0EsS0FBdEQ7QUFDRDs7QUFFRCxNQUFJNXdDLElBQUksQ0FBUjtBQUNBLE1BQUk2dUMsTUFBTSxDQUFWO0FBQ0EsTUFBSWdDLE1BQU0sQ0FBVjtBQUNBLE9BQUtuYyxNQUFMLElBQWU5ekIsUUFBUSxJQUF2QjtBQUNBLFNBQU8sRUFBRVosQ0FBRixHQUFNNG1DLFVBQU4sS0FBcUJpSSxPQUFPLEtBQTVCLENBQVAsRUFBMkM7QUFDekMsUUFBSWp1QyxRQUFRLENBQVIsSUFBYWl3QyxRQUFRLENBQXJCLElBQTBCLEtBQUtuYyxTQUFTMTBCLENBQVQsR0FBYSxDQUFsQixNQUF5QixDQUF2RCxFQUEwRDtBQUN4RDZ3QyxZQUFNLENBQU47QUFDRDtBQUNELFNBQUtuYyxTQUFTMTBCLENBQWQsSUFBbUIsQ0FBRVksUUFBUWl1QyxHQUFULElBQWlCLENBQWxCLElBQXVCZ0MsR0FBdkIsR0FBNkIsSUFBaEQ7QUFDRDs7QUFFRCxTQUFPbmMsU0FBU2tTLFVBQWhCO0FBQ0QsQ0FyQkQ7O0FBdUJBb0IsT0FBT2xrQyxTQUFQLENBQWlCZ3RDLFVBQWpCLEdBQThCLFNBQVNBLFVBQVQsQ0FBcUJsd0MsS0FBckIsRUFBNEI4ekIsTUFBNUIsRUFBb0NrUyxVQUFwQyxFQUFnRGdJLFFBQWhELEVBQTBEO0FBQ3RGaHVDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBOHpCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNrYSxRQUFMLEVBQWU7QUFDYixRQUFJZ0MsUUFBUTluQyxLQUFLc21DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXhJLFVBQUosR0FBaUIsQ0FBN0IsQ0FBWjs7QUFFQW1KLGFBQVMsSUFBVCxFQUFlbnZDLEtBQWYsRUFBc0I4ekIsTUFBdEIsRUFBOEJrUyxVQUE5QixFQUEwQ2dLLFFBQVEsQ0FBbEQsRUFBcUQsQ0FBQ0EsS0FBdEQ7QUFDRDs7QUFFRCxNQUFJNXdDLElBQUk0bUMsYUFBYSxDQUFyQjtBQUNBLE1BQUlpSSxNQUFNLENBQVY7QUFDQSxNQUFJZ0MsTUFBTSxDQUFWO0FBQ0EsT0FBS25jLFNBQVMxMEIsQ0FBZCxJQUFtQlksUUFBUSxJQUEzQjtBQUNBLFNBQU8sRUFBRVosQ0FBRixJQUFPLENBQVAsS0FBYTZ1QyxPQUFPLEtBQXBCLENBQVAsRUFBbUM7QUFDakMsUUFBSWp1QyxRQUFRLENBQVIsSUFBYWl3QyxRQUFRLENBQXJCLElBQTBCLEtBQUtuYyxTQUFTMTBCLENBQVQsR0FBYSxDQUFsQixNQUF5QixDQUF2RCxFQUEwRDtBQUN4RDZ3QyxZQUFNLENBQU47QUFDRDtBQUNELFNBQUtuYyxTQUFTMTBCLENBQWQsSUFBbUIsQ0FBRVksUUFBUWl1QyxHQUFULElBQWlCLENBQWxCLElBQXVCZ0MsR0FBdkIsR0FBNkIsSUFBaEQ7QUFDRDs7QUFFRCxTQUFPbmMsU0FBU2tTLFVBQWhCO0FBQ0QsQ0FyQkQ7O0FBdUJBb0IsT0FBT2xrQyxTQUFQLENBQWlCaXRDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0Jud0MsS0FBcEIsRUFBMkI4ekIsTUFBM0IsRUFBbUNrYSxRQUFuQyxFQUE2QztBQUN4RWh1QyxVQUFRLENBQUNBLEtBQVQ7QUFDQTh6QixXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDa2EsUUFBTCxFQUFlbUIsU0FBUyxJQUFULEVBQWVudkMsS0FBZixFQUFzQjh6QixNQUF0QixFQUE4QixDQUE5QixFQUFpQyxJQUFqQyxFQUF1QyxDQUFDLElBQXhDO0FBQ2YsTUFBSSxDQUFDc1QsT0FBT0csbUJBQVosRUFBaUN2bkMsUUFBUWtJLEtBQUtvNkIsS0FBTCxDQUFXdGlDLEtBQVgsQ0FBUjtBQUNqQyxNQUFJQSxRQUFRLENBQVosRUFBZUEsUUFBUSxPQUFPQSxLQUFQLEdBQWUsQ0FBdkI7QUFDZixPQUFLOHpCLE1BQUwsSUFBZ0I5ekIsUUFBUSxJQUF4QjtBQUNBLFNBQU84ekIsU0FBUyxDQUFoQjtBQUNELENBUkQ7O0FBVUFzVCxPQUFPbGtDLFNBQVAsQ0FBaUJrdEMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QnB3QyxLQUF2QixFQUE4Qjh6QixNQUE5QixFQUFzQ2thLFFBQXRDLEVBQWdEO0FBQzlFaHVDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBOHpCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNrYSxRQUFMLEVBQWVtQixTQUFTLElBQVQsRUFBZW52QyxLQUFmLEVBQXNCOHpCLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLE1BQWpDLEVBQXlDLENBQUMsTUFBMUM7QUFDZixNQUFJc1QsT0FBT0csbUJBQVgsRUFBZ0M7QUFDOUIsU0FBS3pULE1BQUwsSUFBZ0I5ekIsUUFBUSxJQUF4QjtBQUNBLFNBQUs4ekIsU0FBUyxDQUFkLElBQW9COXpCLFVBQVUsQ0FBOUI7QUFDRCxHQUhELE1BR087QUFDTHd2QyxzQkFBa0IsSUFBbEIsRUFBd0J4dkMsS0FBeEIsRUFBK0I4ekIsTUFBL0IsRUFBdUMsSUFBdkM7QUFDRDtBQUNELFNBQU9BLFNBQVMsQ0FBaEI7QUFDRCxDQVhEOztBQWFBc1QsT0FBT2xrQyxTQUFQLENBQWlCbXRDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJyd0MsS0FBdkIsRUFBOEI4ekIsTUFBOUIsRUFBc0NrYSxRQUF0QyxFQUFnRDtBQUM5RWh1QyxVQUFRLENBQUNBLEtBQVQ7QUFDQTh6QixXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDa2EsUUFBTCxFQUFlbUIsU0FBUyxJQUFULEVBQWVudkMsS0FBZixFQUFzQjh6QixNQUF0QixFQUE4QixDQUE5QixFQUFpQyxNQUFqQyxFQUF5QyxDQUFDLE1BQTFDO0FBQ2YsTUFBSXNULE9BQU9HLG1CQUFYLEVBQWdDO0FBQzlCLFNBQUt6VCxNQUFMLElBQWdCOXpCLFVBQVUsQ0FBMUI7QUFDQSxTQUFLOHpCLFNBQVMsQ0FBZCxJQUFvQjl6QixRQUFRLElBQTVCO0FBQ0QsR0FIRCxNQUdPO0FBQ0x3dkMsc0JBQWtCLElBQWxCLEVBQXdCeHZDLEtBQXhCLEVBQStCOHpCLE1BQS9CLEVBQXVDLEtBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FYRDs7QUFhQXNULE9BQU9sa0MsU0FBUCxDQUFpQm90QyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCdHdDLEtBQXZCLEVBQThCOHpCLE1BQTlCLEVBQXNDa2EsUUFBdEMsRUFBZ0Q7QUFDOUVodUMsVUFBUSxDQUFDQSxLQUFUO0FBQ0E4ekIsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ2thLFFBQUwsRUFBZW1CLFNBQVMsSUFBVCxFQUFlbnZDLEtBQWYsRUFBc0I4ekIsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsVUFBakMsRUFBNkMsQ0FBQyxVQUE5QztBQUNmLE1BQUlzVCxPQUFPRyxtQkFBWCxFQUFnQztBQUM5QixTQUFLelQsTUFBTCxJQUFnQjl6QixRQUFRLElBQXhCO0FBQ0EsU0FBSzh6QixTQUFTLENBQWQsSUFBb0I5ekIsVUFBVSxDQUE5QjtBQUNBLFNBQUs4ekIsU0FBUyxDQUFkLElBQW9COXpCLFVBQVUsRUFBOUI7QUFDQSxTQUFLOHpCLFNBQVMsQ0FBZCxJQUFvQjl6QixVQUFVLEVBQTlCO0FBQ0QsR0FMRCxNQUtPO0FBQ0w0dkMsc0JBQWtCLElBQWxCLEVBQXdCNXZDLEtBQXhCLEVBQStCOHpCLE1BQS9CLEVBQXVDLElBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FiRDs7QUFlQXNULE9BQU9sa0MsU0FBUCxDQUFpQnF0QyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCdndDLEtBQXZCLEVBQThCOHpCLE1BQTlCLEVBQXNDa2EsUUFBdEMsRUFBZ0Q7QUFDOUVodUMsVUFBUSxDQUFDQSxLQUFUO0FBQ0E4ekIsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ2thLFFBQUwsRUFBZW1CLFNBQVMsSUFBVCxFQUFlbnZDLEtBQWYsRUFBc0I4ekIsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsVUFBakMsRUFBNkMsQ0FBQyxVQUE5QztBQUNmLE1BQUk5ekIsUUFBUSxDQUFaLEVBQWVBLFFBQVEsYUFBYUEsS0FBYixHQUFxQixDQUE3QjtBQUNmLE1BQUlvbkMsT0FBT0csbUJBQVgsRUFBZ0M7QUFDOUIsU0FBS3pULE1BQUwsSUFBZ0I5ekIsVUFBVSxFQUExQjtBQUNBLFNBQUs4ekIsU0FBUyxDQUFkLElBQW9COXpCLFVBQVUsRUFBOUI7QUFDQSxTQUFLOHpCLFNBQVMsQ0FBZCxJQUFvQjl6QixVQUFVLENBQTlCO0FBQ0EsU0FBSzh6QixTQUFTLENBQWQsSUFBb0I5ekIsUUFBUSxJQUE1QjtBQUNELEdBTEQsTUFLTztBQUNMNHZDLHNCQUFrQixJQUFsQixFQUF3QjV2QyxLQUF4QixFQUErQjh6QixNQUEvQixFQUF1QyxLQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBZEQ7O0FBZ0JBLFNBQVMwYyxZQUFULENBQXVCdkcsR0FBdkIsRUFBNEJqcUMsS0FBNUIsRUFBbUM4ekIsTUFBbkMsRUFBMkNnYSxHQUEzQyxFQUFnRC9uQixHQUFoRCxFQUFxRGdSLEdBQXJELEVBQTBEO0FBQ3hELE1BQUlqRCxTQUFTZ2EsR0FBVCxHQUFlN0QsSUFBSTVxQyxNQUF2QixFQUErQixNQUFNLElBQUltakMsVUFBSixDQUFlLG9CQUFmLENBQU47QUFDL0IsTUFBSTFPLFNBQVMsQ0FBYixFQUFnQixNQUFNLElBQUkwTyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNqQjs7QUFFRCxTQUFTaU8sVUFBVCxDQUFxQnhHLEdBQXJCLEVBQTBCanFDLEtBQTFCLEVBQWlDOHpCLE1BQWpDLEVBQXlDMmIsWUFBekMsRUFBdUR6QixRQUF2RCxFQUFpRTtBQUMvRCxNQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNid0MsaUJBQWF2RyxHQUFiLEVBQWtCanFDLEtBQWxCLEVBQXlCOHpCLE1BQXpCLEVBQWlDLENBQWpDLEVBQW9DLHNCQUFwQyxFQUE0RCxDQUFDLHNCQUE3RDtBQUNEO0FBQ0RxVCxVQUFRaUMsS0FBUixDQUFjYSxHQUFkLEVBQW1CanFDLEtBQW5CLEVBQTBCOHpCLE1BQTFCLEVBQWtDMmIsWUFBbEMsRUFBZ0QsRUFBaEQsRUFBb0QsQ0FBcEQ7QUFDQSxTQUFPM2IsU0FBUyxDQUFoQjtBQUNEOztBQUVEc1QsT0FBT2xrQyxTQUFQLENBQWlCd3RDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUIxd0MsS0FBdkIsRUFBOEI4ekIsTUFBOUIsRUFBc0NrYSxRQUF0QyxFQUFnRDtBQUM5RSxTQUFPeUMsV0FBVyxJQUFYLEVBQWlCendDLEtBQWpCLEVBQXdCOHpCLE1BQXhCLEVBQWdDLElBQWhDLEVBQXNDa2EsUUFBdEMsQ0FBUDtBQUNELENBRkQ7O0FBSUE1RyxPQUFPbGtDLFNBQVAsQ0FBaUJ5dEMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QjN3QyxLQUF2QixFQUE4Qjh6QixNQUE5QixFQUFzQ2thLFFBQXRDLEVBQWdEO0FBQzlFLFNBQU95QyxXQUFXLElBQVgsRUFBaUJ6d0MsS0FBakIsRUFBd0I4ekIsTUFBeEIsRUFBZ0MsS0FBaEMsRUFBdUNrYSxRQUF2QyxDQUFQO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTNEMsV0FBVCxDQUFzQjNHLEdBQXRCLEVBQTJCanFDLEtBQTNCLEVBQWtDOHpCLE1BQWxDLEVBQTBDMmIsWUFBMUMsRUFBd0R6QixRQUF4RCxFQUFrRTtBQUNoRSxNQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNid0MsaUJBQWF2RyxHQUFiLEVBQWtCanFDLEtBQWxCLEVBQXlCOHpCLE1BQXpCLEVBQWlDLENBQWpDLEVBQW9DLHVCQUFwQyxFQUE2RCxDQUFDLHVCQUE5RDtBQUNEO0FBQ0RxVCxVQUFRaUMsS0FBUixDQUFjYSxHQUFkLEVBQW1CanFDLEtBQW5CLEVBQTBCOHpCLE1BQTFCLEVBQWtDMmIsWUFBbEMsRUFBZ0QsRUFBaEQsRUFBb0QsQ0FBcEQ7QUFDQSxTQUFPM2IsU0FBUyxDQUFoQjtBQUNEOztBQUVEc1QsT0FBT2xrQyxTQUFQLENBQWlCMnRDLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsQ0FBd0I3d0MsS0FBeEIsRUFBK0I4ekIsTUFBL0IsRUFBdUNrYSxRQUF2QyxFQUFpRDtBQUNoRixTQUFPNEMsWUFBWSxJQUFaLEVBQWtCNXdDLEtBQWxCLEVBQXlCOHpCLE1BQXpCLEVBQWlDLElBQWpDLEVBQXVDa2EsUUFBdkMsQ0FBUDtBQUNELENBRkQ7O0FBSUE1RyxPQUFPbGtDLFNBQVAsQ0FBaUI0dEMsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3Qjl3QyxLQUF4QixFQUErQjh6QixNQUEvQixFQUF1Q2thLFFBQXZDLEVBQWlEO0FBQ2hGLFNBQU80QyxZQUFZLElBQVosRUFBa0I1d0MsS0FBbEIsRUFBeUI4ekIsTUFBekIsRUFBaUMsS0FBakMsRUFBd0NrYSxRQUF4QyxDQUFQO0FBQ0QsQ0FGRDs7QUFJQTtBQUNBNUcsT0FBT2xrQyxTQUFQLENBQWlCc21DLElBQWpCLEdBQXdCLFNBQVNBLElBQVQsQ0FBZTJCLE1BQWYsRUFBdUI0RixXQUF2QixFQUFvQ2p3QyxLQUFwQyxFQUEyQ2lKLEdBQTNDLEVBQWdEO0FBQ3RFLE1BQUksQ0FBQ2pKLEtBQUwsRUFBWUEsUUFBUSxDQUFSO0FBQ1osTUFBSSxDQUFDaUosR0FBRCxJQUFRQSxRQUFRLENBQXBCLEVBQXVCQSxNQUFNLEtBQUsxSyxNQUFYO0FBQ3ZCLE1BQUkweEMsZUFBZTVGLE9BQU85ckMsTUFBMUIsRUFBa0MweEMsY0FBYzVGLE9BQU85ckMsTUFBckI7QUFDbEMsTUFBSSxDQUFDMHhDLFdBQUwsRUFBa0JBLGNBQWMsQ0FBZDtBQUNsQixNQUFJaG5DLE1BQU0sQ0FBTixJQUFXQSxNQUFNakosS0FBckIsRUFBNEJpSixNQUFNakosS0FBTjs7QUFFNUI7QUFDQSxNQUFJaUosUUFBUWpKLEtBQVosRUFBbUIsT0FBTyxDQUFQO0FBQ25CLE1BQUlxcUMsT0FBTzlyQyxNQUFQLEtBQWtCLENBQWxCLElBQXVCLEtBQUtBLE1BQUwsS0FBZ0IsQ0FBM0MsRUFBOEMsT0FBTyxDQUFQOztBQUU5QztBQUNBLE1BQUkweEMsY0FBYyxDQUFsQixFQUFxQjtBQUNuQixVQUFNLElBQUl2TyxVQUFKLENBQWUsMkJBQWYsQ0FBTjtBQUNEO0FBQ0QsTUFBSTFoQyxRQUFRLENBQVIsSUFBYUEsU0FBUyxLQUFLekIsTUFBL0IsRUFBdUMsTUFBTSxJQUFJbWpDLFVBQUosQ0FBZSwyQkFBZixDQUFOO0FBQ3ZDLE1BQUl6NEIsTUFBTSxDQUFWLEVBQWEsTUFBTSxJQUFJeTRCLFVBQUosQ0FBZSx5QkFBZixDQUFOOztBQUViO0FBQ0EsTUFBSXo0QixNQUFNLEtBQUsxSyxNQUFmLEVBQXVCMEssTUFBTSxLQUFLMUssTUFBWDtBQUN2QixNQUFJOHJDLE9BQU85ckMsTUFBUCxHQUFnQjB4QyxXQUFoQixHQUE4QmhuQyxNQUFNakosS0FBeEMsRUFBK0M7QUFDN0NpSixVQUFNb2hDLE9BQU85ckMsTUFBUCxHQUFnQjB4QyxXQUFoQixHQUE4Qmp3QyxLQUFwQztBQUNEOztBQUVELE1BQUl3WixNQUFNdlEsTUFBTWpKLEtBQWhCO0FBQ0EsTUFBSTFCLENBQUo7O0FBRUEsTUFBSSxTQUFTK3JDLE1BQVQsSUFBbUJycUMsUUFBUWl3QyxXQUEzQixJQUEwQ0EsY0FBY2huQyxHQUE1RCxFQUFpRTtBQUMvRDtBQUNBLFNBQUszSyxJQUFJa2IsTUFBTSxDQUFmLEVBQWtCbGIsS0FBSyxDQUF2QixFQUEwQixFQUFFQSxDQUE1QixFQUErQjtBQUM3QityQyxhQUFPL3JDLElBQUkyeEMsV0FBWCxJQUEwQixLQUFLM3hDLElBQUkwQixLQUFULENBQTFCO0FBQ0Q7QUFDRixHQUxELE1BS08sSUFBSXdaLE1BQU0sSUFBTixJQUFjLENBQUM4c0IsT0FBT0csbUJBQTFCLEVBQStDO0FBQ3BEO0FBQ0EsU0FBS25vQyxJQUFJLENBQVQsRUFBWUEsSUFBSWtiLEdBQWhCLEVBQXFCLEVBQUVsYixDQUF2QixFQUEwQjtBQUN4QityQyxhQUFPL3JDLElBQUkyeEMsV0FBWCxJQUEwQixLQUFLM3hDLElBQUkwQixLQUFULENBQTFCO0FBQ0Q7QUFDRixHQUxNLE1BS0E7QUFDTHdsQyxlQUFXcGpDLFNBQVgsQ0FBcUIrVSxHQUFyQixDQUF5QnRYLElBQXpCLENBQ0V3cUMsTUFERixFQUVFLEtBQUt2RCxRQUFMLENBQWM5bUMsS0FBZCxFQUFxQkEsUUFBUXdaLEdBQTdCLENBRkYsRUFHRXkyQixXQUhGO0FBS0Q7O0FBRUQsU0FBT3oyQixHQUFQO0FBQ0QsQ0E5Q0Q7O0FBZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E4c0IsT0FBT2xrQyxTQUFQLENBQWlCNGxDLElBQWpCLEdBQXdCLFNBQVNBLElBQVQsQ0FBZXRlLEdBQWYsRUFBb0IxcEIsS0FBcEIsRUFBMkJpSixHQUEzQixFQUFnQ2cvQixRQUFoQyxFQUEwQztBQUNoRTtBQUNBLE1BQUksT0FBT3ZlLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixRQUFJLE9BQU8xcEIsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QmlvQyxpQkFBV2pvQyxLQUFYO0FBQ0FBLGNBQVEsQ0FBUjtBQUNBaUosWUFBTSxLQUFLMUssTUFBWDtBQUNELEtBSkQsTUFJTyxJQUFJLE9BQU8wSyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDbENnL0IsaUJBQVdoL0IsR0FBWDtBQUNBQSxZQUFNLEtBQUsxSyxNQUFYO0FBQ0Q7QUFDRCxRQUFJbXJCLElBQUluckIsTUFBSixLQUFlLENBQW5CLEVBQXNCO0FBQ3BCLFVBQUkrZ0IsT0FBT29LLElBQUluSyxVQUFKLENBQWUsQ0FBZixDQUFYO0FBQ0EsVUFBSUQsT0FBTyxHQUFYLEVBQWdCO0FBQ2RvSyxjQUFNcEssSUFBTjtBQUNEO0FBQ0Y7QUFDRCxRQUFJMm9CLGFBQWF0cUMsU0FBYixJQUEwQixPQUFPc3FDLFFBQVAsS0FBb0IsUUFBbEQsRUFBNEQ7QUFDMUQsWUFBTSxJQUFJcm5DLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ0Q7QUFDRCxRQUFJLE9BQU9xbkMsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxDQUFDM0IsT0FBTzhCLFVBQVAsQ0FBa0JILFFBQWxCLENBQXJDLEVBQWtFO0FBQ2hFLFlBQU0sSUFBSXJuQyxTQUFKLENBQWMsdUJBQXVCcW5DLFFBQXJDLENBQU47QUFDRDtBQUNGLEdBckJELE1BcUJPLElBQUksT0FBT3ZlLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQ0EsVUFBTUEsTUFBTSxHQUFaO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJMXBCLFFBQVEsQ0FBUixJQUFhLEtBQUt6QixNQUFMLEdBQWN5QixLQUEzQixJQUFvQyxLQUFLekIsTUFBTCxHQUFjMEssR0FBdEQsRUFBMkQ7QUFDekQsVUFBTSxJQUFJeTRCLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ0Q7O0FBRUQsTUFBSXo0QixPQUFPakosS0FBWCxFQUFrQjtBQUNoQixXQUFPLElBQVA7QUFDRDs7QUFFREEsVUFBUUEsVUFBVSxDQUFsQjtBQUNBaUosUUFBTUEsUUFBUXRMLFNBQVIsR0FBb0IsS0FBS1ksTUFBekIsR0FBa0MwSyxRQUFRLENBQWhEOztBQUVBLE1BQUksQ0FBQ3lnQixHQUFMLEVBQVVBLE1BQU0sQ0FBTjs7QUFFVixNQUFJcHJCLENBQUo7QUFDQSxNQUFJLE9BQU9vckIsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFNBQUtwckIsSUFBSTBCLEtBQVQsRUFBZ0IxQixJQUFJMkssR0FBcEIsRUFBeUIsRUFBRTNLLENBQTNCLEVBQThCO0FBQzVCLFdBQUtBLENBQUwsSUFBVW9yQixHQUFWO0FBQ0Q7QUFDRixHQUpELE1BSU87QUFDTCxRQUFJa2pCLFFBQVF0RyxPQUFPbUMsUUFBUCxDQUFnQi9lLEdBQWhCLElBQ1JBLEdBRFEsR0FFUjRmLFlBQVksSUFBSWhELE1BQUosQ0FBVzVjLEdBQVgsRUFBZ0J1ZSxRQUFoQixFQUEwQnRrQyxRQUExQixFQUFaLENBRko7QUFHQSxRQUFJNlYsTUFBTW96QixNQUFNcnVDLE1BQWhCO0FBQ0EsU0FBS0QsSUFBSSxDQUFULEVBQVlBLElBQUkySyxNQUFNakosS0FBdEIsRUFBNkIsRUFBRTFCLENBQS9CLEVBQWtDO0FBQ2hDLFdBQUtBLElBQUkwQixLQUFULElBQWtCNHNDLE1BQU10dUMsSUFBSWtiLEdBQVYsQ0FBbEI7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNELENBekREOztBQTJEQTtBQUNBOztBQUVBLElBQUkwMkIsb0JBQW9CLG9CQUF4Qjs7QUFFQSxTQUFTQyxXQUFULENBQXNCendCLEdBQXRCLEVBQTJCO0FBQ3pCO0FBQ0FBLFFBQU0wd0IsV0FBVzF3QixHQUFYLEVBQWdCcGdCLE9BQWhCLENBQXdCNHdDLGlCQUF4QixFQUEyQyxFQUEzQyxDQUFOO0FBQ0E7QUFDQSxNQUFJeHdCLElBQUluaEIsTUFBSixHQUFhLENBQWpCLEVBQW9CLE9BQU8sRUFBUDtBQUNwQjtBQUNBLFNBQU9taEIsSUFBSW5oQixNQUFKLEdBQWEsQ0FBYixLQUFtQixDQUExQixFQUE2QjtBQUMzQm1oQixVQUFNQSxNQUFNLEdBQVo7QUFDRDtBQUNELFNBQU9BLEdBQVA7QUFDRDs7QUFFRCxTQUFTMHdCLFVBQVQsQ0FBcUIxd0IsR0FBckIsRUFBMEI7QUFDeEIsTUFBSUEsSUFBSWtCLElBQVIsRUFBYyxPQUFPbEIsSUFBSWtCLElBQUosRUFBUDtBQUNkLFNBQU9sQixJQUFJcGdCLE9BQUosQ0FBWSxZQUFaLEVBQTBCLEVBQTFCLENBQVA7QUFDRDs7QUFFRCxTQUFTcXRDLEtBQVQsQ0FBZ0I1SixDQUFoQixFQUFtQjtBQUNqQixNQUFJQSxJQUFJLEVBQVIsRUFBWSxPQUFPLE1BQU1BLEVBQUVwL0IsUUFBRixDQUFXLEVBQVgsQ0FBYjtBQUNaLFNBQU9vL0IsRUFBRXAvQixRQUFGLENBQVcsRUFBWCxDQUFQO0FBQ0Q7O0FBRUQsU0FBUzJsQyxXQUFULENBQXNCcDNCLE1BQXRCLEVBQThCbStCLEtBQTlCLEVBQXFDO0FBQ25DQSxVQUFRQSxTQUFTQyxRQUFqQjtBQUNBLE1BQUlsTyxTQUFKO0FBQ0EsTUFBSTdqQyxTQUFTMlQsT0FBTzNULE1BQXBCO0FBQ0EsTUFBSWd5QyxnQkFBZ0IsSUFBcEI7QUFDQSxNQUFJM0QsUUFBUSxFQUFaOztBQUVBLE9BQUssSUFBSXR1QyxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLE1BQXBCLEVBQTRCLEVBQUVELENBQTlCLEVBQWlDO0FBQy9COGpDLGdCQUFZbHdCLE9BQU9xTixVQUFQLENBQWtCamhCLENBQWxCLENBQVo7O0FBRUE7QUFDQSxRQUFJOGpDLFlBQVksTUFBWixJQUFzQkEsWUFBWSxNQUF0QyxFQUE4QztBQUM1QztBQUNBLFVBQUksQ0FBQ21PLGFBQUwsRUFBb0I7QUFDbEI7QUFDQSxZQUFJbk8sWUFBWSxNQUFoQixFQUF3QjtBQUN0QjtBQUNBLGNBQUksQ0FBQ2lPLFNBQVMsQ0FBVixJQUFlLENBQUMsQ0FBcEIsRUFBdUJ6RCxNQUFNeHRDLElBQU4sQ0FBVyxJQUFYLEVBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ3ZCO0FBQ0QsU0FKRCxNQUlPLElBQUlkLElBQUksQ0FBSixLQUFVQyxNQUFkLEVBQXNCO0FBQzNCO0FBQ0EsY0FBSSxDQUFDOHhDLFNBQVMsQ0FBVixJQUFlLENBQUMsQ0FBcEIsRUFBdUJ6RCxNQUFNeHRDLElBQU4sQ0FBVyxJQUFYLEVBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ3ZCO0FBQ0Q7O0FBRUQ7QUFDQW14Qyx3QkFBZ0JuTyxTQUFoQjs7QUFFQTtBQUNEOztBQUVEO0FBQ0EsVUFBSUEsWUFBWSxNQUFoQixFQUF3QjtBQUN0QixZQUFJLENBQUNpTyxTQUFTLENBQVYsSUFBZSxDQUFDLENBQXBCLEVBQXVCekQsTUFBTXh0QyxJQUFOLENBQVcsSUFBWCxFQUFpQixJQUFqQixFQUF1QixJQUF2QjtBQUN2Qm14Qyx3QkFBZ0JuTyxTQUFoQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQUEsa0JBQVksQ0FBQ21PLGdCQUFnQixNQUFoQixJQUEwQixFQUExQixHQUErQm5PLFlBQVksTUFBNUMsSUFBc0QsT0FBbEU7QUFDRCxLQTdCRCxNQTZCTyxJQUFJbU8sYUFBSixFQUFtQjtBQUN4QjtBQUNBLFVBQUksQ0FBQ0YsU0FBUyxDQUFWLElBQWUsQ0FBQyxDQUFwQixFQUF1QnpELE1BQU14dEMsSUFBTixDQUFXLElBQVgsRUFBaUIsSUFBakIsRUFBdUIsSUFBdkI7QUFDeEI7O0FBRURteEMsb0JBQWdCLElBQWhCOztBQUVBO0FBQ0EsUUFBSW5PLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsVUFBSSxDQUFDaU8sU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEJ6RCxZQUFNeHRDLElBQU4sQ0FBV2dqQyxTQUFYO0FBQ0QsS0FIRCxNQUdPLElBQUlBLFlBQVksS0FBaEIsRUFBdUI7QUFDNUIsVUFBSSxDQUFDaU8sU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEJ6RCxZQUFNeHRDLElBQU4sQ0FDRWdqQyxhQUFhLEdBQWIsR0FBbUIsSUFEckIsRUFFRUEsWUFBWSxJQUFaLEdBQW1CLElBRnJCO0FBSUQsS0FOTSxNQU1BLElBQUlBLFlBQVksT0FBaEIsRUFBeUI7QUFDOUIsVUFBSSxDQUFDaU8sU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEJ6RCxZQUFNeHRDLElBQU4sQ0FDRWdqQyxhQUFhLEdBQWIsR0FBbUIsSUFEckIsRUFFRUEsYUFBYSxHQUFiLEdBQW1CLElBQW5CLEdBQTBCLElBRjVCLEVBR0VBLFlBQVksSUFBWixHQUFtQixJQUhyQjtBQUtELEtBUE0sTUFPQSxJQUFJQSxZQUFZLFFBQWhCLEVBQTBCO0FBQy9CLFVBQUksQ0FBQ2lPLFNBQVMsQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ3RCekQsWUFBTXh0QyxJQUFOLENBQ0VnakMsYUFBYSxJQUFiLEdBQW9CLElBRHRCLEVBRUVBLGFBQWEsR0FBYixHQUFtQixJQUFuQixHQUEwQixJQUY1QixFQUdFQSxhQUFhLEdBQWIsR0FBbUIsSUFBbkIsR0FBMEIsSUFINUIsRUFJRUEsWUFBWSxJQUFaLEdBQW1CLElBSnJCO0FBTUQsS0FSTSxNQVFBO0FBQ0wsWUFBTSxJQUFJbGlDLEtBQUosQ0FBVSxvQkFBVixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPMHNDLEtBQVA7QUFDRDs7QUFFRCxTQUFTbkIsWUFBVCxDQUF1Qi9yQixHQUF2QixFQUE0QjtBQUMxQixNQUFJOHdCLFlBQVksRUFBaEI7QUFDQSxPQUFLLElBQUlseUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJb2hCLElBQUluaEIsTUFBeEIsRUFBZ0MsRUFBRUQsQ0FBbEMsRUFBcUM7QUFDbkM7QUFDQWt5QyxjQUFVcHhDLElBQVYsQ0FBZXNnQixJQUFJSCxVQUFKLENBQWVqaEIsQ0FBZixJQUFvQixJQUFuQztBQUNEO0FBQ0QsU0FBT2t5QyxTQUFQO0FBQ0Q7O0FBRUQsU0FBUzNFLGNBQVQsQ0FBeUJuc0IsR0FBekIsRUFBOEIyd0IsS0FBOUIsRUFBcUM7QUFDbkMsTUFBSTN4QixDQUFKLEVBQU8reEIsRUFBUCxFQUFXQyxFQUFYO0FBQ0EsTUFBSUYsWUFBWSxFQUFoQjtBQUNBLE9BQUssSUFBSWx5QyxJQUFJLENBQWIsRUFBZ0JBLElBQUlvaEIsSUFBSW5oQixNQUF4QixFQUFnQyxFQUFFRCxDQUFsQyxFQUFxQztBQUNuQyxRQUFJLENBQUMreEMsU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7O0FBRXRCM3hCLFFBQUlnQixJQUFJSCxVQUFKLENBQWVqaEIsQ0FBZixDQUFKO0FBQ0FteUMsU0FBSy94QixLQUFLLENBQVY7QUFDQWd5QixTQUFLaHlCLElBQUksR0FBVDtBQUNBOHhCLGNBQVVweEMsSUFBVixDQUFlc3hDLEVBQWY7QUFDQUYsY0FBVXB4QyxJQUFWLENBQWVxeEMsRUFBZjtBQUNEOztBQUVELFNBQU9ELFNBQVA7QUFDRDs7QUFFRCxTQUFTakgsYUFBVCxDQUF3QjdwQixHQUF4QixFQUE2QjtBQUMzQixTQUFPMG1CLE9BQU9qQixXQUFQLENBQW1CZ0wsWUFBWXp3QixHQUFaLENBQW5CLENBQVA7QUFDRDs7QUFFRCxTQUFTNnJCLFVBQVQsQ0FBcUIxakMsR0FBckIsRUFBMEI4b0MsR0FBMUIsRUFBK0IzZCxNQUEvQixFQUF1Q3owQixNQUF2QyxFQUErQztBQUM3QyxPQUFLLElBQUlELElBQUksQ0FBYixFQUFnQkEsSUFBSUMsTUFBcEIsRUFBNEIsRUFBRUQsQ0FBOUIsRUFBaUM7QUFDL0IsUUFBS0EsSUFBSTAwQixNQUFKLElBQWMyZCxJQUFJcHlDLE1BQW5CLElBQStCRCxLQUFLdUosSUFBSXRKLE1BQTVDLEVBQXFEO0FBQ3JEb3lDLFFBQUlyeUMsSUFBSTAwQixNQUFSLElBQWtCbnJCLElBQUl2SixDQUFKLENBQWxCO0FBQ0Q7QUFDRCxTQUFPQSxDQUFQO0FBQ0Q7O0FBRUQsU0FBU3NxQyxLQUFULENBQWdCbGYsR0FBaEIsRUFBcUI7QUFDbkIsU0FBT0EsUUFBUUEsR0FBZixDQURtQixDQUNBO0FBQ3BCLEM7Ozs7Ozs7Ozs7QUM1dkREOzs7O0FBSUE7QUFDQTFzQixPQUFPQyxPQUFQLEdBQWlCLFVBQVMyekMsWUFBVCxFQUF1QjtBQUN2QyxLQUFJcnZDLE9BQU8sRUFBWDs7QUFFQTtBQUNBQSxNQUFLb0MsUUFBTCxHQUFnQixTQUFTQSxRQUFULEdBQW9CO0FBQ25DLFNBQU8sS0FBSzRJLEdBQUwsQ0FBUyxVQUFVOFEsSUFBVixFQUFnQjtBQUMvQixPQUFJcFAsVUFBVTRpQyx1QkFBdUJ4ekIsSUFBdkIsRUFBNkJ1ekIsWUFBN0IsQ0FBZDtBQUNBLE9BQUd2ekIsS0FBSyxDQUFMLENBQUgsRUFBWTtBQUNYLFdBQU8sWUFBWUEsS0FBSyxDQUFMLENBQVosR0FBc0IsR0FBdEIsR0FBNEJwUCxPQUE1QixHQUFzQyxHQUE3QztBQUNBLElBRkQsTUFFTztBQUNOLFdBQU9BLE9BQVA7QUFDQTtBQUNELEdBUE0sRUFPSnpPLElBUEksQ0FPQyxFQVBELENBQVA7QUFRQSxFQVREOztBQVdBO0FBQ0ErQixNQUFLakQsQ0FBTCxHQUFTLFVBQVN3eUMsT0FBVCxFQUFrQkMsVUFBbEIsRUFBOEI7QUFDdEMsTUFBRyxPQUFPRCxPQUFQLEtBQW1CLFFBQXRCLEVBQ0NBLFVBQVUsQ0FBQyxDQUFDLElBQUQsRUFBT0EsT0FBUCxFQUFnQixFQUFoQixDQUFELENBQVY7QUFDRCxNQUFJRSx5QkFBeUIsRUFBN0I7QUFDQSxPQUFJLElBQUkxeUMsSUFBSSxDQUFaLEVBQWVBLElBQUksS0FBS0MsTUFBeEIsRUFBZ0NELEdBQWhDLEVBQXFDO0FBQ3BDLE9BQUlhLEtBQUssS0FBS2IsQ0FBTCxFQUFRLENBQVIsQ0FBVDtBQUNBLE9BQUcsT0FBT2EsRUFBUCxLQUFjLFFBQWpCLEVBQ0M2eEMsdUJBQXVCN3hDLEVBQXZCLElBQTZCLElBQTdCO0FBQ0Q7QUFDRCxPQUFJYixJQUFJLENBQVIsRUFBV0EsSUFBSXd5QyxRQUFRdnlDLE1BQXZCLEVBQStCRCxHQUEvQixFQUFvQztBQUNuQyxPQUFJK2UsT0FBT3l6QixRQUFReHlDLENBQVIsQ0FBWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBRyxPQUFPK2UsS0FBSyxDQUFMLENBQVAsS0FBbUIsUUFBbkIsSUFBK0IsQ0FBQzJ6Qix1QkFBdUIzekIsS0FBSyxDQUFMLENBQXZCLENBQW5DLEVBQW9FO0FBQ25FLFFBQUcwekIsY0FBYyxDQUFDMXpCLEtBQUssQ0FBTCxDQUFsQixFQUEyQjtBQUMxQkEsVUFBSyxDQUFMLElBQVUwekIsVUFBVjtBQUNBLEtBRkQsTUFFTyxJQUFHQSxVQUFILEVBQWU7QUFDckIxekIsVUFBSyxDQUFMLElBQVUsTUFBTUEsS0FBSyxDQUFMLENBQU4sR0FBZ0IsU0FBaEIsR0FBNEIwekIsVUFBNUIsR0FBeUMsR0FBbkQ7QUFDQTtBQUNEeHZDLFNBQUtuQyxJQUFMLENBQVVpZSxJQUFWO0FBQ0E7QUFDRDtBQUNELEVBeEJEO0FBeUJBLFFBQU85YixJQUFQO0FBQ0EsQ0ExQ0Q7O0FBNENBLFNBQVNzdkMsc0JBQVQsQ0FBZ0N4ekIsSUFBaEMsRUFBc0N1ekIsWUFBdEMsRUFBb0Q7QUFDbkQsS0FBSTNpQyxVQUFVb1AsS0FBSyxDQUFMLEtBQVcsRUFBekI7QUFDQSxLQUFJNHpCLGFBQWE1ekIsS0FBSyxDQUFMLENBQWpCO0FBQ0EsS0FBSSxDQUFDNHpCLFVBQUwsRUFBaUI7QUFDaEIsU0FBT2hqQyxPQUFQO0FBQ0E7O0FBRUQsS0FBSTJpQyxZQUFKLEVBQWtCO0FBQ2pCLE1BQUlNLGdCQUFnQkMsVUFBVUYsVUFBVixDQUFwQjtBQUNBLE1BQUlHLGFBQWFILFdBQVc3eUIsT0FBWCxDQUFtQjdSLEdBQW5CLENBQXVCLFVBQVVtRCxNQUFWLEVBQWtCO0FBQ3pELFVBQU8sbUJBQW1CdWhDLFdBQVdJLFVBQTlCLEdBQTJDM2hDLE1BQTNDLEdBQW9ELEtBQTNEO0FBQ0EsR0FGZ0IsQ0FBakI7O0FBSUEsU0FBTyxDQUFDekIsT0FBRCxFQUFVN0IsTUFBVixDQUFpQmdsQyxVQUFqQixFQUE2QmhsQyxNQUE3QixDQUFvQyxDQUFDOGtDLGFBQUQsQ0FBcEMsRUFBcUQxeEMsSUFBckQsQ0FBMEQsSUFBMUQsQ0FBUDtBQUNBOztBQUVELFFBQU8sQ0FBQ3lPLE9BQUQsRUFBVXpPLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDQTs7QUFFRDtBQUNBLFNBQVMyeEMsU0FBVCxDQUFtQkcsU0FBbkIsRUFBOEI7QUFDNUIsS0FBSWxMLFNBQVMsSUFBSUUsTUFBSixDQUFXaGhDLEtBQUtDLFNBQUwsQ0FBZStyQyxTQUFmLENBQVgsRUFBc0MzdEMsUUFBdEMsQ0FBK0MsUUFBL0MsQ0FBYjtBQUNBLEtBQUkwQixPQUFPLGlFQUFpRStnQyxNQUE1RTs7QUFFQSxRQUFPLFNBQVMvZ0MsSUFBVCxHQUFnQixLQUF2QjtBQUNELEM7Ozs7Ozs7Ozs7QUMxRURwSSxRQUFROHRDLElBQVIsR0FBZSxVQUFVcEMsTUFBVixFQUFrQjNWLE1BQWxCLEVBQTBCdWUsSUFBMUIsRUFBZ0NDLElBQWhDLEVBQXNDQyxNQUF0QyxFQUE4QztBQUMzRCxNQUFJMzBDLENBQUosRUFBTzJELENBQVA7QUFDQSxNQUFJaXhDLE9BQU9ELFNBQVMsQ0FBVCxHQUFhRCxJQUFiLEdBQW9CLENBQS9CO0FBQ0EsTUFBSUcsT0FBTyxDQUFDLEtBQUtELElBQU4sSUFBYyxDQUF6QjtBQUNBLE1BQUlFLFFBQVFELFFBQVEsQ0FBcEI7QUFDQSxNQUFJRSxRQUFRLENBQUMsQ0FBYjtBQUNBLE1BQUl2ekMsSUFBSWl6QyxPQUFRRSxTQUFTLENBQWpCLEdBQXNCLENBQTlCO0FBQ0EsTUFBSUssSUFBSVAsT0FBTyxDQUFDLENBQVIsR0FBWSxDQUFwQjtBQUNBLE1BQUk1YSxJQUFJZ1MsT0FBTzNWLFNBQVMxMEIsQ0FBaEIsQ0FBUjs7QUFFQUEsT0FBS3d6QyxDQUFMOztBQUVBaDFDLE1BQUk2NUIsSUFBSyxDQUFDLEtBQU0sQ0FBQ2tiLEtBQVIsSUFBa0IsQ0FBM0I7QUFDQWxiLFFBQU8sQ0FBQ2tiLEtBQVI7QUFDQUEsV0FBU0gsSUFBVDtBQUNBLFNBQU9HLFFBQVEsQ0FBZixFQUFrQi8wQyxJQUFJQSxJQUFJLEdBQUosR0FBVTZyQyxPQUFPM1YsU0FBUzEwQixDQUFoQixDQUFkLEVBQWtDQSxLQUFLd3pDLENBQXZDLEVBQTBDRCxTQUFTLENBQXJFLEVBQXdFLENBQUU7O0FBRTFFcHhDLE1BQUkzRCxJQUFLLENBQUMsS0FBTSxDQUFDKzBDLEtBQVIsSUFBa0IsQ0FBM0I7QUFDQS8wQyxRQUFPLENBQUMrMEMsS0FBUjtBQUNBQSxXQUFTTCxJQUFUO0FBQ0EsU0FBT0ssUUFBUSxDQUFmLEVBQWtCcHhDLElBQUlBLElBQUksR0FBSixHQUFVa29DLE9BQU8zVixTQUFTMTBCLENBQWhCLENBQWQsRUFBa0NBLEtBQUt3ekMsQ0FBdkMsRUFBMENELFNBQVMsQ0FBckUsRUFBd0UsQ0FBRTs7QUFFMUUsTUFBSS8wQyxNQUFNLENBQVYsRUFBYTtBQUNYQSxRQUFJLElBQUk4MEMsS0FBUjtBQUNELEdBRkQsTUFFTyxJQUFJOTBDLE1BQU02MEMsSUFBVixFQUFnQjtBQUNyQixXQUFPbHhDLElBQUlzeEMsR0FBSixHQUFXLENBQUNwYixJQUFJLENBQUMsQ0FBTCxHQUFTLENBQVYsSUFBZTJaLFFBQWpDO0FBQ0QsR0FGTSxNQUVBO0FBQ0w3dkMsUUFBSUEsSUFBSTJHLEtBQUtzbUMsR0FBTCxDQUFTLENBQVQsRUFBWThELElBQVosQ0FBUjtBQUNBMTBDLFFBQUlBLElBQUk4MEMsS0FBUjtBQUNEO0FBQ0QsU0FBTyxDQUFDamIsSUFBSSxDQUFDLENBQUwsR0FBUyxDQUFWLElBQWVsMkIsQ0FBZixHQUFtQjJHLEtBQUtzbUMsR0FBTCxDQUFTLENBQVQsRUFBWTV3QyxJQUFJMDBDLElBQWhCLENBQTFCO0FBQ0QsQ0EvQkQ7O0FBaUNBdjBDLFFBQVFxckMsS0FBUixHQUFnQixVQUFVSyxNQUFWLEVBQWtCenBDLEtBQWxCLEVBQXlCOHpCLE1BQXpCLEVBQWlDdWUsSUFBakMsRUFBdUNDLElBQXZDLEVBQTZDQyxNQUE3QyxFQUFxRDtBQUNuRSxNQUFJMzBDLENBQUosRUFBTzJELENBQVAsRUFBVWllLENBQVY7QUFDQSxNQUFJZ3pCLE9BQU9ELFNBQVMsQ0FBVCxHQUFhRCxJQUFiLEdBQW9CLENBQS9CO0FBQ0EsTUFBSUcsT0FBTyxDQUFDLEtBQUtELElBQU4sSUFBYyxDQUF6QjtBQUNBLE1BQUlFLFFBQVFELFFBQVEsQ0FBcEI7QUFDQSxNQUFJSyxLQUFNUixTQUFTLEVBQVQsR0FBY3BxQyxLQUFLc21DLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQyxFQUFiLElBQW1CdG1DLEtBQUtzbUMsR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDLEVBQWIsQ0FBakMsR0FBb0QsQ0FBOUQ7QUFDQSxNQUFJcHZDLElBQUlpekMsT0FBTyxDQUFQLEdBQVlFLFNBQVMsQ0FBN0I7QUFDQSxNQUFJSyxJQUFJUCxPQUFPLENBQVAsR0FBVyxDQUFDLENBQXBCO0FBQ0EsTUFBSTVhLElBQUl6M0IsUUFBUSxDQUFSLElBQWNBLFVBQVUsQ0FBVixJQUFlLElBQUlBLEtBQUosR0FBWSxDQUF6QyxHQUE4QyxDQUE5QyxHQUFrRCxDQUExRDs7QUFFQUEsVUFBUWtJLEtBQUtzRyxHQUFMLENBQVN4TyxLQUFULENBQVI7O0FBRUEsTUFBSWdVLE1BQU1oVSxLQUFOLEtBQWdCQSxVQUFVb3hDLFFBQTlCLEVBQXdDO0FBQ3RDN3ZDLFFBQUl5UyxNQUFNaFUsS0FBTixJQUFlLENBQWYsR0FBbUIsQ0FBdkI7QUFDQXBDLFFBQUk2MEMsSUFBSjtBQUNELEdBSEQsTUFHTztBQUNMNzBDLFFBQUlzSyxLQUFLbzZCLEtBQUwsQ0FBV3A2QixLQUFLNnFDLEdBQUwsQ0FBUy95QyxLQUFULElBQWtCa0ksS0FBSzhxQyxHQUFsQyxDQUFKO0FBQ0EsUUFBSWh6QyxTQUFTd2YsSUFBSXRYLEtBQUtzbUMsR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDNXdDLENBQWIsQ0FBYixJQUFnQyxDQUFwQyxFQUF1QztBQUNyQ0E7QUFDQTRoQixXQUFLLENBQUw7QUFDRDtBQUNELFFBQUk1aEIsSUFBSTgwQyxLQUFKLElBQWEsQ0FBakIsRUFBb0I7QUFDbEIxeUMsZUFBUzh5QyxLQUFLdHpCLENBQWQ7QUFDRCxLQUZELE1BRU87QUFDTHhmLGVBQVM4eUMsS0FBSzVxQyxLQUFLc21DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSWtFLEtBQWhCLENBQWQ7QUFDRDtBQUNELFFBQUkxeUMsUUFBUXdmLENBQVIsSUFBYSxDQUFqQixFQUFvQjtBQUNsQjVoQjtBQUNBNGhCLFdBQUssQ0FBTDtBQUNEOztBQUVELFFBQUk1aEIsSUFBSTgwQyxLQUFKLElBQWFELElBQWpCLEVBQXVCO0FBQ3JCbHhDLFVBQUksQ0FBSjtBQUNBM0QsVUFBSTYwQyxJQUFKO0FBQ0QsS0FIRCxNQUdPLElBQUk3MEMsSUFBSTgwQyxLQUFKLElBQWEsQ0FBakIsRUFBb0I7QUFDekJueEMsVUFBSSxDQUFDdkIsUUFBUXdmLENBQVIsR0FBWSxDQUFiLElBQWtCdFgsS0FBS3NtQyxHQUFMLENBQVMsQ0FBVCxFQUFZOEQsSUFBWixDQUF0QjtBQUNBMTBDLFVBQUlBLElBQUk4MEMsS0FBUjtBQUNELEtBSE0sTUFHQTtBQUNMbnhDLFVBQUl2QixRQUFRa0ksS0FBS3NtQyxHQUFMLENBQVMsQ0FBVCxFQUFZa0UsUUFBUSxDQUFwQixDQUFSLEdBQWlDeHFDLEtBQUtzbUMsR0FBTCxDQUFTLENBQVQsRUFBWThELElBQVosQ0FBckM7QUFDQTEwQyxVQUFJLENBQUo7QUFDRDtBQUNGOztBQUVELFNBQU8wMEMsUUFBUSxDQUFmLEVBQWtCN0ksT0FBTzNWLFNBQVMxMEIsQ0FBaEIsSUFBcUJtQyxJQUFJLElBQXpCLEVBQStCbkMsS0FBS3d6QyxDQUFwQyxFQUF1Q3J4QyxLQUFLLEdBQTVDLEVBQWlEK3dDLFFBQVEsQ0FBM0UsRUFBOEUsQ0FBRTs7QUFFaEYxMEMsTUFBS0EsS0FBSzAwQyxJQUFOLEdBQWMvd0MsQ0FBbEI7QUFDQWl4QyxVQUFRRixJQUFSO0FBQ0EsU0FBT0UsT0FBTyxDQUFkLEVBQWlCL0ksT0FBTzNWLFNBQVMxMEIsQ0FBaEIsSUFBcUJ4QixJQUFJLElBQXpCLEVBQStCd0IsS0FBS3d6QyxDQUFwQyxFQUF1Q2gxQyxLQUFLLEdBQTVDLEVBQWlENDBDLFFBQVEsQ0FBMUUsRUFBNkUsQ0FBRTs7QUFFL0UvSSxTQUFPM1YsU0FBUzEwQixDQUFULEdBQWF3ekMsQ0FBcEIsS0FBMEJuYixJQUFJLEdBQTlCO0FBQ0QsQ0FsREQsQzs7Ozs7Ozs7O0FDakNBLElBQUloekIsV0FBVyxHQUFHQSxRQUFsQjs7QUFFQTNHLE9BQU9DLE9BQVAsR0FBaUJrQixNQUFNQyxPQUFOLElBQWlCLFVBQVVxdEIsR0FBVixFQUFlO0FBQy9DLFNBQU85bkIsU0FBUzlELElBQVQsQ0FBYzRyQixHQUFkLEtBQXNCLGdCQUE3QjtBQUNELENBRkQsQzs7Ozs7Ozs7O0FDREE7Ozs7Ozs7Ozs7Ozs7QUFhQXp1QixPQUFPQyxPQUFQLEdBQWlCLFVBQVVrMUMsR0FBVixFQUFlO0FBQzlCO0FBQ0EsS0FBSXYrQixXQUFXLE9BQU83VyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPNlcsUUFBdkQ7O0FBRUEsS0FBSSxDQUFDQSxRQUFMLEVBQWU7QUFDYixRQUFNLElBQUkxVCxLQUFKLENBQVUsa0NBQVYsQ0FBTjtBQUNEOztBQUVGO0FBQ0EsS0FBSSxDQUFDaXlDLEdBQUQsSUFBUSxPQUFPQSxHQUFQLEtBQWUsUUFBM0IsRUFBcUM7QUFDbkMsU0FBT0EsR0FBUDtBQUNBOztBQUVELEtBQUlDLFVBQVV4K0IsU0FBUzJhLFFBQVQsR0FBb0IsSUFBcEIsR0FBMkIzYSxTQUFTK3JCLElBQWxEO0FBQ0EsS0FBSTBTLGFBQWFELFVBQVV4K0IsU0FBU2dDLFFBQVQsQ0FBa0J0VyxPQUFsQixDQUEwQixXQUExQixFQUF1QyxHQUF2QyxDQUEzQjs7QUFFRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxLQUFJZ3pDLFdBQVdILElBQUk3eUMsT0FBSixDQUFZLHFEQUFaLEVBQW1FLFVBQVNpekMsU0FBVCxFQUFvQkMsT0FBcEIsRUFBNkI7QUFDOUc7QUFDQSxNQUFJQyxrQkFBa0JELFFBQ3BCNXhCLElBRG9CLEdBRXBCdGhCLE9BRm9CLENBRVosVUFGWSxFQUVBLFVBQVNrTixDQUFULEVBQVlrbUMsRUFBWixFQUFlO0FBQUUsVUFBT0EsRUFBUDtBQUFZLEdBRjdCLEVBR3BCcHpDLE9BSG9CLENBR1osVUFIWSxFQUdBLFVBQVNrTixDQUFULEVBQVlrbUMsRUFBWixFQUFlO0FBQUUsVUFBT0EsRUFBUDtBQUFZLEdBSDdCLENBQXRCOztBQUtBO0FBQ0EsTUFBSSwrQ0FBK0M3ckMsSUFBL0MsQ0FBb0Q0ckMsZUFBcEQsQ0FBSixFQUEwRTtBQUN4RSxVQUFPRixTQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJSSxNQUFKOztBQUVBLE1BQUlGLGdCQUFnQnJxQyxPQUFoQixDQUF3QixJQUF4QixNQUFrQyxDQUF0QyxFQUF5QztBQUN0QztBQUNGdXFDLFlBQVNGLGVBQVQ7QUFDQSxHQUhELE1BR08sSUFBSUEsZ0JBQWdCcnFDLE9BQWhCLENBQXdCLEdBQXhCLE1BQWlDLENBQXJDLEVBQXdDO0FBQzlDO0FBQ0F1cUMsWUFBU1AsVUFBVUssZUFBbkIsQ0FGOEMsQ0FFVjtBQUNwQyxHQUhNLE1BR0E7QUFDTjtBQUNBRSxZQUFTTixhQUFhSSxnQkFBZ0JuekMsT0FBaEIsQ0FBd0IsT0FBeEIsRUFBaUMsRUFBakMsQ0FBdEIsQ0FGTSxDQUVzRDtBQUM1RDs7QUFFRDtBQUNBLFNBQU8sU0FBU2dHLEtBQUtDLFNBQUwsQ0FBZW90QyxNQUFmLENBQVQsR0FBa0MsR0FBekM7QUFDQSxFQTVCYyxDQUFmOztBQThCQTtBQUNBLFFBQU9MLFFBQVA7QUFDQSxDQTFFRCxDOzs7Ozs7QUNkQTtBQUNBOzs7QUFHQTtBQUNBLGdEQUFpRCxXQUFXLGVBQWUsa0JBQWtCLHVCQUF1QixXQUFXLGVBQWUsa0JBQWtCLHlCQUF5QixrQkFBa0IsV0FBVywwQkFBMEIseUJBQXlCLGtCQUFrQixNQUFNLG1CQUFtQixhQUFhLGNBQWMsWUFBWSx1QkFBdUIsT0FBTyx1QkFBdUIsU0FBUyxzQkFBc0IseUJBQXlCLGlCQUFpQixnQkFBZ0IseUJBQXlCLFdBQVcsWUFBWSxZQUFZLHlCQUF5QixZQUFZLGVBQWU7O0FBRXpsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pTQTtBQUNBOzs7QUFHQTtBQUNBLGtEQUFtRCxrQkFBa0IsV0FBVywwQkFBMEIseUJBQXlCLGlCQUFpQixnQkFBZ0I7O0FBRXBLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDWEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMTZmODhlN2U5OTVhNWNmZDY2NWUiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgdW5kZWZpbmVkKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIHVuZGVmaW5lZCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSkgcmV0dXJuXG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCBcIlwiKVxuXHRcdFx0XHRlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXkyLCB2YWx1ZSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0TGF0ZUF0dHJzKHZub2RlKSB7XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwidmFsdWVcIiwgbnVsbCwgYXR0cnMyLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMyLnNlbGVjdGVkSW5kZXgsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cnModm5vZGUsIG9sZCwgYXR0cnMyLCBucykge1xuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5Miwgb2xkICYmIG9sZFtrZXkyXSwgYXR0cnMyW2tleTJdLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRpZiAoYXR0cnMyID09IG51bGwgfHwgIShrZXkyIGluIGF0dHJzMikpIHtcblx0XHRcdFx0XHRpZiAoa2V5MiA9PT0gXCJjbGFzc05hbWVcIikga2V5MiA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZWxzZSBpZiAoa2V5MiAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXHQvL3N0eWxlXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgc3R5bGUpIHtcblx0XHRpZiAob2xkID09PSBzdHlsZSkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIiwgb2xkID0gbnVsbFxuXHRcdGlmIChzdHlsZSA9PSBudWxsKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0ZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGQgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRcdGZvciAodmFyIGtleTIgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXkyXSA9IHN0eWxlW2tleTJdXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkICE9IG51bGwgJiYgdHlwZW9mIG9sZCAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleTIgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleTJdID0gXCJcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkyIGluIGVsZW1lbnQpIGVsZW1lbnRba2V5Ml0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleTIuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gPT09IGNhbGxiYWNrKSByZXR1cm5cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5Ml0gPSBjYWxsYmFja1xuXHRcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyKGRvbSwgdm5vZGVzKSB7XG5cdFx0aWYgKCFkb20pIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKVxuXHRcdHZhciBob29rcyA9IFtdXG5cdFx0dmFyIGFjdGl2ZSA9ICRkb2MuYWN0aXZlRWxlbWVudFxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCB1bmRlZmluZWQpXG5cdFx0ZG9tLnZub2RlcyA9IHZub2Rlc1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIGhvb2tzW2ldKClcblx0XHRpZiAoJGRvYy5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpXG5cdH1cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0RXZlbnRDYWxsYmFjazogc2V0RXZlbnRDYWxsYmFja31cbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrKSB7XG5cdC8vNjBmcHMgdHJhbnNsYXRlcyB0byAxNi42bXMsIHJvdW5kIGl0IGRvd24gc2luY2Ugc2V0VGltZW91dCByZXF1aXJlcyBpbnRcblx0dmFyIHRpbWUgPSAxNlxuXHR2YXIgbGFzdCA9IDAsIHBlbmRpbmcgPSBudWxsXG5cdHZhciB0aW1lb3V0ID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dFxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KClcblx0XHRpZiAobGFzdCA9PT0gMCB8fCBub3cgLSBsYXN0ID49IHRpbWUpIHtcblx0XHRcdGxhc3QgPSBub3dcblx0XHRcdGNhbGxiYWNrKClcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuXHRcdFx0cGVuZGluZyA9IHRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrKClcblx0XHRcdFx0bGFzdCA9IERhdGUubm93KClcblx0XHRcdH0sIHRpbWUgLSAobm93IC0gbGFzdCkpXG5cdFx0fVxuXHR9XG59XG52YXIgXzExID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgcmVuZGVyU2VydmljZSA9IGNvcmVSZW5kZXJlcigkd2luZG93KVxuXHRyZW5kZXJTZXJ2aWNlLnNldEV2ZW50Q2FsbGJhY2soZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLnJlZHJhdyAhPT0gZmFsc2UpIHJlZHJhdygpXG5cdH0pXG5cdHZhciBjYWxsYmFja3MgPSBbXVxuXHRmdW5jdGlvbiBzdWJzY3JpYmUoa2V5MSwgY2FsbGJhY2spIHtcblx0XHR1bnN1YnNjcmliZShrZXkxKVxuXHRcdGNhbGxiYWNrcy5wdXNoKGtleTEsIHRocm90dGxlKGNhbGxiYWNrKSlcblx0fVxuXHRmdW5jdGlvbiB1bnN1YnNjcmliZShrZXkxKSB7XG5cdFx0dmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2Yoa2V5MSlcblx0XHRpZiAoaW5kZXggPiAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMilcblx0fVxuXHRmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdGNhbGxiYWNrc1tpXSgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiB7c3Vic2NyaWJlOiBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSwgcmVkcmF3OiByZWRyYXcsIHJlbmRlcjogcmVuZGVyU2VydmljZS5yZW5kZXJ9XG59XG52YXIgcmVkcmF3U2VydmljZSA9IF8xMSh3aW5kb3cpXG5yZXF1ZXN0U2VydmljZS5zZXRDb21wbGV0aW9uQ2FsbGJhY2socmVkcmF3U2VydmljZS5yZWRyYXcpXG52YXIgXzE2ID0gZnVuY3Rpb24ocmVkcmF3U2VydmljZTApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudCkge1xuXHRcdGlmIChjb21wb25lbnQgPT09IG51bGwpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBbXSlcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnVuc3Vic2NyaWJlKHJvb3QpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNvbXBvbmVudC52aWV3ID09IG51bGwgJiYgdHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJtLm1vdW50KGVsZW1lbnQsIGNvbXBvbmVudCkgZXhwZWN0cyBhIGNvbXBvbmVudCwgbm90IGEgdm5vZGVcIilcblx0XHRcblx0XHR2YXIgcnVuMCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFZub2RlKGNvbXBvbmVudCkpXG5cdFx0fVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4wKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnJlZHJhdygpXG5cdH1cbn1cbm0ubW91bnQgPSBfMTYocmVkcmF3U2VydmljZSlcbnZhciBQcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG52YXIgcGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRpZiAoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PSBudWxsKSByZXR1cm4ge31cblx0aWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSlcblx0dmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCImXCIpLCBkYXRhMCA9IHt9LCBjb3VudGVycyA9IHt9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IGVudHJpZXNbaV0uc3BsaXQoXCI9XCIpXG5cdFx0dmFyIGtleTUgPSBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMF0pXG5cdFx0dmFyIHZhbHVlID0gZW50cnkubGVuZ3RoID09PSAyID8gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzFdKSA6IFwiXCJcblx0XHRpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWVcblx0XHRlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB2YWx1ZSA9IGZhbHNlXG5cdFx0dmFyIGxldmVscyA9IGtleTUuc3BsaXQoL1xcXVxcWz98XFxbLylcblx0XHR2YXIgY3Vyc29yID0gZGF0YTBcblx0XHRpZiAoa2V5NS5pbmRleE9mKFwiW1wiKSA+IC0xKSBsZXZlbHMucG9wKClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzW2pdLCBuZXh0TGV2ZWwgPSBsZXZlbHNbaiArIDFdXG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBuZXh0TGV2ZWwgPT0gXCJcIiB8fCAhaXNOYU4ocGFyc2VJbnQobmV4dExldmVsLCAxMCkpXG5cdFx0XHR2YXIgaXNWYWx1ZSA9IGogPT09IGxldmVscy5sZW5ndGggLSAxXG5cdFx0XHRpZiAobGV2ZWwgPT09IFwiXCIpIHtcblx0XHRcdFx0dmFyIGtleTUgPSBsZXZlbHMuc2xpY2UoMCwgaikuam9pbigpXG5cdFx0XHRcdGlmIChjb3VudGVyc1trZXk1XSA9PSBudWxsKSBjb3VudGVyc1trZXk1XSA9IDBcblx0XHRcdFx0bGV2ZWwgPSBjb3VudGVyc1trZXk1XSsrXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3Vyc29yW2xldmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdGN1cnNvcltsZXZlbF0gPSBpc1ZhbHVlID8gdmFsdWUgOiBpc051bWJlciA/IFtdIDoge31cblx0XHRcdH1cblx0XHRcdGN1cnNvciA9IGN1cnNvcltsZXZlbF1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGEwXG59XG52YXIgY29yZVJvdXRlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gdHlwZW9mICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPT09IFwiZnVuY3Rpb25cIlxuXHR2YXIgY2FsbEFzeW5jMCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gbm9ybWFsaXplMShmcmFnbWVudDApIHtcblx0XHR2YXIgZGF0YSA9ICR3aW5kb3cubG9jYXRpb25bZnJhZ21lbnQwXS5yZXBsYWNlKC8oPzolW2EtZjg5XVthLWYwLTldKSsvZ2ltLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0aWYgKGZyYWdtZW50MCA9PT0gXCJwYXRobmFtZVwiICYmIGRhdGFbMF0gIT09IFwiL1wiKSBkYXRhID0gXCIvXCIgKyBkYXRhXG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHR2YXIgYXN5bmNJZFxuXHRmdW5jdGlvbiBkZWJvdW5jZUFzeW5jKGNhbGxiYWNrMCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChhc3luY0lkICE9IG51bGwpIHJldHVyblxuXHRcdFx0YXN5bmNJZCA9IGNhbGxBc3luYzAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFzeW5jSWQgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrMCgpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSkge1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKVxuXHRcdHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpXG5cdFx0dmFyIHBhdGhFbmQgPSBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRcdHZhciBxdWVyeVBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSwgcXVlcnlFbmQpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBxdWVyeVBhcmFtcykgcXVlcnlEYXRhW2tleTRdID0gcXVlcnlQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0aWYgKGhhc2hJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgaGFzaFBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShoYXNoSW5kZXggKyAxKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gaGFzaFBhcmFtcykgaGFzaERhdGFba2V5NF0gPSBoYXNoUGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdHJldHVybiBwYXRoLnNsaWNlKDAsIHBhdGhFbmQpXG5cdH1cblx0dmFyIHJvdXRlciA9IHtwcmVmaXg6IFwiIyFcIn1cblx0cm91dGVyLmdldFBhdGggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZTIgPSByb3V0ZXIucHJlZml4LmNoYXJBdCgwKVxuXHRcdHN3aXRjaCAodHlwZTIpIHtcblx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBub3JtYWxpemUxKFwiaGFzaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aClcblx0XHRcdGNhc2UgXCI/XCI6IHJldHVybiBub3JtYWxpemUxKFwic2VhcmNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gbm9ybWFsaXplMShcInBhdGhuYW1lXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdH1cblx0fVxuXHRyb3V0ZXIuc2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHR2YXIgcXVlcnlEYXRhID0ge30sIGhhc2hEYXRhID0ge31cblx0XHRwYXRoID0gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpXG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBkYXRhKSBxdWVyeURhdGFba2V5NF0gPSBkYXRhW2tleTRdXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXSspL2csIGZ1bmN0aW9uKG1hdGNoMiwgdG9rZW4pIHtcblx0XHRcdFx0ZGVsZXRlIHF1ZXJ5RGF0YVt0b2tlbl1cblx0XHRcdFx0cmV0dXJuIGRhdGFbdG9rZW5dXG5cdFx0XHR9KVxuXHRcdH1cblx0XHR2YXIgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKHF1ZXJ5RGF0YSlcblx0XHRpZiAocXVlcnkpIHBhdGggKz0gXCI/XCIgKyBxdWVyeVxuXHRcdHZhciBoYXNoID0gYnVpbGRRdWVyeVN0cmluZyhoYXNoRGF0YSlcblx0XHRpZiAoaGFzaCkgcGF0aCArPSBcIiNcIiArIGhhc2hcblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnN0YXRlIDogbnVsbFxuXHRcdFx0dmFyIHRpdGxlID0gb3B0aW9ucyA/IG9wdGlvbnMudGl0bGUgOiBudWxsXG5cdFx0XHQkd2luZG93Lm9ucG9wc3RhdGUoKVxuXHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0XHRlbHNlICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHR9XG5cdFx0ZWxzZSAkd2luZG93LmxvY2F0aW9uLmhyZWYgPSByb3V0ZXIucHJlZml4ICsgcGF0aFxuXHR9XG5cdHJvdXRlci5kZWZpbmVSb3V0ZXMgPSBmdW5jdGlvbihyb3V0ZXMsIHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZ1bmN0aW9uIHJlc29sdmVSb3V0ZSgpIHtcblx0XHRcdHZhciBwYXRoID0gcm91dGVyLmdldFBhdGgoKVxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9XG5cdFx0XHR2YXIgcGF0aG5hbWUgPSBwYXJzZVBhdGgocGF0aCwgcGFyYW1zLCBwYXJhbXMpXG5cdFx0XHR2YXIgc3RhdGUgPSAkd2luZG93Lmhpc3Rvcnkuc3RhdGVcblx0XHRcdGlmIChzdGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGsgaW4gc3RhdGUpIHBhcmFtc1trXSA9IHN0YXRlW2tdXG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciByb3V0ZTAgaW4gcm91dGVzKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChcIl5cIiArIHJvdXRlMC5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZywgXCIoLio/KVwiKS5yZXBsYWNlKC86W15cXC9dKy9nLCBcIihbXlxcXFwvXSspXCIpICsgXCJcXC8/JFwiKVxuXHRcdFx0XHRpZiAobWF0Y2hlci50ZXN0KHBhdGhuYW1lKSkge1xuXHRcdFx0XHRcdHBhdGhuYW1lLnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5cyA9IHJvdXRlMC5tYXRjaCgvOlteXFwvXSsvZykgfHwgW11cblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTIpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zW2tleXNbaV0ucmVwbGFjZSgvOnxcXC4vZywgXCJcIildID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpXSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc29sdmUocm91dGVzW3JvdXRlMF0sIHBhcmFtcywgcGF0aCwgcm91dGUwKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlamVjdChwYXRoLCBwYXJhbXMpXG5cdFx0fVxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkgJHdpbmRvdy5vbnBvcHN0YXRlID0gZGVib3VuY2VBc3luYyhyZXNvbHZlUm91dGUpXG5cdFx0ZWxzZSBpZiAocm91dGVyLnByZWZpeC5jaGFyQXQoMCkgPT09IFwiI1wiKSAkd2luZG93Lm9uaGFzaGNoYW5nZSA9IHJlc29sdmVSb3V0ZVxuXHRcdHJlc29sdmVSb3V0ZSgpXG5cdH1cblx0cmV0dXJuIHJvdXRlclxufVxudmFyIF8yMCA9IGZ1bmN0aW9uKCR3aW5kb3csIHJlZHJhd1NlcnZpY2UwKSB7XG5cdHZhciByb3V0ZVNlcnZpY2UgPSBjb3JlUm91dGVyKCR3aW5kb3cpXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHYpIHtyZXR1cm4gdn1cblx0dmFyIHJlbmRlcjEsIGNvbXBvbmVudCwgYXR0cnMzLCBjdXJyZW50UGF0aCwgbGFzdFVwZGF0ZVxuXHR2YXIgcm91dGUgPSBmdW5jdGlvbihyb290LCBkZWZhdWx0Um91dGUsIHJvdXRlcykge1xuXHRcdGlmIChyb290ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIGBtLnJvdXRlYCBpcyBub3QgdW5kZWZpbmVkXCIpXG5cdFx0dmFyIHJ1bjEgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZW5kZXIxICE9IG51bGwpIHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCByZW5kZXIxKFZub2RlKGNvbXBvbmVudCwgYXR0cnMzLmtleSwgYXR0cnMzKSkpXG5cdFx0fVxuXHRcdHZhciBiYWlsID0gZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0aWYgKHBhdGggIT09IGRlZmF1bHRSb3V0ZSkgcm91dGVTZXJ2aWNlLnNldFBhdGgoZGVmYXVsdFJvdXRlLCBudWxsLCB7cmVwbGFjZTogdHJ1ZX0pXG5cdFx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGRlZmF1bHQgcm91dGUgXCIgKyBkZWZhdWx0Um91dGUpXG5cdFx0fVxuXHRcdHJvdXRlU2VydmljZS5kZWZpbmVSb3V0ZXMocm91dGVzLCBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIHBhdGgpIHtcblx0XHRcdHZhciB1cGRhdGUgPSBsYXN0VXBkYXRlID0gZnVuY3Rpb24ocm91dGVSZXNvbHZlciwgY29tcCkge1xuXHRcdFx0XHRpZiAodXBkYXRlICE9PSBsYXN0VXBkYXRlKSByZXR1cm5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcCAhPSBudWxsICYmICh0eXBlb2YgY29tcC52aWV3ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNvbXAgPT09IFwiZnVuY3Rpb25cIik/IGNvbXAgOiBcImRpdlwiXG5cdFx0XHRcdGF0dHJzMyA9IHBhcmFtcywgY3VycmVudFBhdGggPSBwYXRoLCBsYXN0VXBkYXRlID0gbnVsbFxuXHRcdFx0XHRyZW5kZXIxID0gKHJvdXRlUmVzb2x2ZXIucmVuZGVyIHx8IGlkZW50aXR5KS5iaW5kKHJvdXRlUmVzb2x2ZXIpXG5cdFx0XHRcdHJ1bjEoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBheWxvYWQudmlldyB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGUoe30sIHBheWxvYWQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHBheWxvYWQub25tYXRjaCkge1xuXHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShwYXlsb2FkLm9ubWF0Y2gocGFyYW1zLCBwYXRoKSkudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKHBheWxvYWQsIHJlc29sdmVkKVxuXHRcdFx0XHRcdH0sIGJhaWwpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB1cGRhdGUocGF5bG9hZCwgXCJkaXZcIilcblx0XHRcdH1cblx0XHR9LCBiYWlsKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4xKVxuXHR9XG5cdHJvdXRlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRpZiAobGFzdFVwZGF0ZSAhPSBudWxsKSBvcHRpb25zID0ge3JlcGxhY2U6IHRydWV9XG5cdFx0bGFzdFVwZGF0ZSA9IG51bGxcblx0XHRyb3V0ZVNlcnZpY2Uuc2V0UGF0aChwYXRoLCBkYXRhLCBvcHRpb25zKVxuXHR9XG5cdHJvdXRlLmdldCA9IGZ1bmN0aW9uKCkge3JldHVybiBjdXJyZW50UGF0aH1cblx0cm91dGUucHJlZml4ID0gZnVuY3Rpb24ocHJlZml4MCkge3JvdXRlU2VydmljZS5wcmVmaXggPSBwcmVmaXgwfVxuXHRyb3V0ZS5saW5rID0gZnVuY3Rpb24odm5vZGUxKSB7XG5cdFx0dm5vZGUxLmRvbS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHJvdXRlU2VydmljZS5wcmVmaXggKyB2bm9kZTEuYXR0cnMuaHJlZilcblx0XHR2bm9kZTEuZG9tLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGUud2hpY2ggPT09IDIpIHJldHVyblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRlLnJlZHJhdyA9IGZhbHNlXG5cdFx0XHR2YXIgaHJlZiA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuXHRcdFx0aWYgKGhyZWYuaW5kZXhPZihyb3V0ZVNlcnZpY2UucHJlZml4KSA9PT0gMCkgaHJlZiA9IGhyZWYuc2xpY2Uocm91dGVTZXJ2aWNlLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRyb3V0ZS5zZXQoaHJlZiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdHJvdXRlLnBhcmFtID0gZnVuY3Rpb24oa2V5Mykge1xuXHRcdGlmKHR5cGVvZiBhdHRyczMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGtleTMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBhdHRyczNba2V5M11cblx0XHRyZXR1cm4gYXR0cnMzXG5cdH1cblx0cmV0dXJuIHJvdXRlXG59XG5tLnJvdXRlID0gXzIwKHdpbmRvdywgcmVkcmF3U2VydmljZSlcbm0ud2l0aEF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSwgY2FsbGJhY2sxLCBjb250ZXh0KSB7XG5cdHJldHVybiBmdW5jdGlvbihlKSB7XG5cdFx0Y2FsbGJhY2sxLmNhbGwoY29udGV4dCB8fCB0aGlzLCBhdHRyTmFtZSBpbiBlLmN1cnJlbnRUYXJnZXQgPyBlLmN1cnJlbnRUYXJnZXRbYXR0ck5hbWVdIDogZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpXG5cdH1cbn1cbnZhciBfMjggPSBjb3JlUmVuZGVyZXIod2luZG93KVxubS5yZW5kZXIgPSBfMjgucmVuZGVyXG5tLnJlZHJhdyA9IHJlZHJhd1NlcnZpY2UucmVkcmF3XG5tLnJlcXVlc3QgPSByZXF1ZXN0U2VydmljZS5yZXF1ZXN0XG5tLmpzb25wID0gcmVxdWVzdFNlcnZpY2UuanNvbnBcbm0ucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmdcbm0uYnVpbGRRdWVyeVN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmdcbm0udmVyc2lvbiA9IFwiMS4xLjFcIlxubS52bm9kZSA9IFZub2RlXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IG1cbmVsc2Ugd2luZG93Lm0gPSBtXG59KCkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21pdGhyaWwvbWl0aHJpbC5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudC5qcyc7XG5cbm0ubW91bnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKSwgQ29tcG9uZW50KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VudHJ5LmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCIvLyBVdGlsaXRpZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG9iamVjdCcpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cbi8vIFVzZWZ1bCBmb3Igc29tZSBvcGVyYXRpb25zIHdpdGggdG9rZW5zXG5mdW5jdGlvbiBhcnJheVJlcGxhY2VBdChzcmMsIHBvcywgbmV3RWxlbWVudHMpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChzcmMuc2xpY2UoMCwgcG9zKSwgbmV3RWxlbWVudHMsIHNyYy5zbGljZShwb3MgKyAxKSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlKGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gbmV2ZXIgdXNlZFxuICBpZiAoYyA+PSAweEZERDAgJiYgYyA8PSAweEZERUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICgoYyAmIDB4RkZGRikgPT09IDB4RkZGRiB8fCAoYyAmIDB4RkZGRikgPT09IDB4RkZGRSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPT09IDB4MEIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gb3V0IG9mIHJhbmdlXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDA7XG4gICAgdmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoYyA+PiAxMCksXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuXG5cbnZhciBVTkVTQ0FQRV9NRF9SRSAgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZztcbnZhciBFTlRJVFlfUkUgICAgICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xudmFyIFVORVNDQVBFX0FMTF9SRSA9IG5ldyBSZWdFeHAoVU5FU0NBUEVfTURfUkUuc291cmNlICsgJ3wnICsgRU5USVRZX1JFLnNvdXJjZSwgJ2dpJyk7XG5cbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xuXG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCcuL2VudGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gIHZhciBjb2RlID0gMDtcblxuICBpZiAoaGFzKGVudGl0aWVzLCBuYW1lKSkge1xuICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgfVxuXG4gIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MjMvKiAjICovICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNilcbiAgICA6XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG4gICAgaWYgKGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShFTlRJVFlfUkUsIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKTtcbn0qL1xuXG5mdW5jdGlvbiB1bmVzY2FwZU1kKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfTURfUkUsICckMScpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUFsbChzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCdcXFxcJykgPCAwICYmIHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfQUxMX1JFLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZWQsIGVudGl0eSkge1xuICAgIGlmIChlc2NhcGVkKSB7IHJldHVybiBlc2NhcGVkOyB9XG4gICAgcmV0dXJuIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBlbnRpdHkpO1xuICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIEhUTUxfRVNDQVBFX1RFU1RfUkUgPSAvWyY8PlwiXS87XG52YXIgSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSA9IC9bJjw+XCJdL2c7XG52YXIgSFRNTF9SRVBMQUNFTUVOVFMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7J1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIoY2gpIHtcbiAgcmV0dXJuIEhUTUxfUkVQTEFDRU1FTlRTW2NoXTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgaWYgKEhUTUxfRVNDQVBFX1RFU1RfUkUudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgUkVHRVhQX0VTQ0FQRV9SRSA9IC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRV9SRSwgJ1xcXFwkJicpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1NwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OlxuICAgIGNhc2UgMHgyMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWnMgKHVuaWNvZGUgY2xhc3MpIHx8IFtcXHRcXGZcXHZcXHJcXG5dXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY29kZSkge1xuICBpZiAoY29kZSA+PSAweDIwMDAgJiYgY29kZSA8PSAweDIwMEEpIHsgcmV0dXJuIHRydWU7IH1cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OiAvLyBcXHRcbiAgICBjYXNlIDB4MEE6IC8vIFxcblxuICAgIGNhc2UgMHgwQjogLy8gXFx2XG4gICAgY2FzZSAweDBDOiAvLyBcXGZcbiAgICBjYXNlIDB4MEQ6IC8vIFxcclxuICAgIGNhc2UgMHgyMDpcbiAgICBjYXNlIDB4QTA6XG4gICAgY2FzZSAweDE2ODA6XG4gICAgY2FzZSAweDIwMkY6XG4gICAgY2FzZSAweDIwNUY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG52YXIgVU5JQ09ERV9QVU5DVF9SRSA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuXG4vLyBDdXJyZW50bHkgd2l0aG91dCBhc3RyYWwgY2hhcmFjdGVycyBzdXBwb3J0LlxuZnVuY3Rpb24gaXNQdW5jdENoYXIoY2gpIHtcbiAgcmV0dXJuIFVOSUNPREVfUFVOQ1RfUkUudGVzdChjaCk7XG59XG5cblxuLy8gTWFya2Rvd24gQVNDSUkgcHVuY3R1YXRpb24gY2hhcmFjdGVycy5cbi8vXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuLy9cbi8vIERvbid0IGNvbmZ1c2Ugd2l0aCB1bmljb2RlIHB1bmN0dWF0aW9uICEhISBJdCBsYWNrcyBzb21lIGNoYXJzIGluIGFzY2lpIHJhbmdlLlxuLy9cbmZ1bmN0aW9uIGlzTWRBc2NpaVB1bmN0KGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMi8qIFwiICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDI3LyogJyAqLzpcbiAgICBjYXNlIDB4MjgvKiAoICovOlxuICAgIGNhc2UgMHgyOS8qICkgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyQy8qICwgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4MkUvKiAuICovOlxuICAgIGNhc2UgMHgyRi8qIC8gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0IvKiA7ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHgzRi8qID8gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0MvKiB8ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVwbGVyIHRvIHVuaWZ5IFtyZWZlcmVuY2UgbGFiZWxzXS5cbi8vXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gIC8vIHVzZSAudG9VcHBlckNhc2UoKSBpbnN0ZWFkIG9mIC50b0xvd2VyQ2FzZSgpXG4gIC8vIGhlcmUgdG8gYXZvaWQgYSBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGVcbiAgLy8gbWVtYmVycyAobW9zdCBub3RhYmx5LCBgX19wcm90b19fYClcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFJlLWV4cG9ydCBsaWJyYXJpZXMgY29tbW9ubHkgdXNlZCBpbiBib3RoIG1hcmtkb3duLWl0IGFuZCBpdHMgcGx1Z2lucyxcbi8vIHNvIHBsdWdpbnMgd29uJ3QgaGF2ZSB0byBkZXBlbmQgb24gdGhlbSBleHBsaWNpdGx5LCB3aGljaCByZWR1Y2VzIHRoZWlyXG4vLyBidW5kbGVkIHNpemUgKGUuZy4gYSBicm93c2VyIGJ1aWxkKS5cbi8vXG5leHBvcnRzLmxpYiAgICAgICAgICAgICAgICAgPSB7fTtcbmV4cG9ydHMubGliLm1kdXJsICAgICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XG5leHBvcnRzLmxpYi51Y21pY3JvICAgICAgICAgPSByZXF1aXJlKCd1Yy5taWNybycpO1xuXG5leHBvcnRzLmFzc2lnbiAgICAgICAgICAgICAgPSBhc3NpZ247XG5leHBvcnRzLmlzU3RyaW5nICAgICAgICAgICAgPSBpc1N0cmluZztcbmV4cG9ydHMuaGFzICAgICAgICAgICAgICAgICA9IGhhcztcbmV4cG9ydHMudW5lc2NhcGVNZCAgICAgICAgICA9IHVuZXNjYXBlTWQ7XG5leHBvcnRzLnVuZXNjYXBlQWxsICAgICAgICAgPSB1bmVzY2FwZUFsbDtcbmV4cG9ydHMuaXNWYWxpZEVudGl0eUNvZGUgICA9IGlzVmFsaWRFbnRpdHlDb2RlO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ICAgICAgID0gZnJvbUNvZGVQb2ludDtcbi8vIGV4cG9ydHMucmVwbGFjZUVudGl0aWVzICAgICA9IHJlcGxhY2VFbnRpdGllcztcbmV4cG9ydHMuZXNjYXBlSHRtbCAgICAgICAgICA9IGVzY2FwZUh0bWw7XG5leHBvcnRzLmFycmF5UmVwbGFjZUF0ICAgICAgPSBhcnJheVJlcGxhY2VBdDtcbmV4cG9ydHMuaXNTcGFjZSAgICAgICAgICAgICA9IGlzU3BhY2U7XG5leHBvcnRzLmlzV2hpdGVTcGFjZSAgICAgICAgPSBpc1doaXRlU3BhY2U7XG5leHBvcnRzLmlzTWRBc2NpaVB1bmN0ICAgICAgPSBpc01kQXNjaWlQdW5jdDtcbmV4cG9ydHMuaXNQdW5jdENoYXIgICAgICAgICA9IGlzUHVuY3RDaGFyO1xuZXhwb3J0cy5lc2NhcGVSRSAgICAgICAgICAgID0gZXNjYXBlUkU7XG5leHBvcnRzLm5vcm1hbGl6ZVJlZmVyZW5jZSAgPSBub3JtYWxpemVSZWZlcmVuY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwiLyoqXG4gKiBjbGFzcyBSdWxlclxuICpcbiAqIEhlbHBlciBjbGFzcywgdXNlZCBieSBbW01hcmtkb3duSXQjY29yZV1dLCBbW01hcmtkb3duSXQjYmxvY2tdXSBhbmRcbiAqIFtbTWFya2Rvd25JdCNpbmxpbmVdXSB0byBtYW5hZ2Ugc2VxdWVuY2VzIG9mIGZ1bmN0aW9ucyAocnVsZXMpOlxuICpcbiAqIC0ga2VlcCBydWxlcyBpbiBkZWZpbmVkIG9yZGVyXG4gKiAtIGFzc2lnbiB0aGUgbmFtZSB0byBlYWNoIHJ1bGVcbiAqIC0gZW5hYmxlL2Rpc2FibGUgcnVsZXNcbiAqIC0gYWRkL3JlcGxhY2UgcnVsZXNcbiAqIC0gYWxsb3cgYXNzaWduIHJ1bGVzIHRvIGFkZGl0aW9uYWwgbmFtZWQgY2hhaW5zIChpbiB0aGUgc2FtZSlcbiAqIC0gY2FjaGVpbmcgbGlzdHMgb2YgYWN0aXZlIHJ1bGVzXG4gKlxuICogWW91IHdpbGwgbm90IG5lZWQgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHkgdW50aWwgd3JpdGUgcGx1Z2lucy4gRm9yIHNpbXBsZVxuICogcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSwgW1tNYXJrZG93bkl0LmVuYWJsZV1dIGFuZFxuICogW1tNYXJrZG93bkl0LnVzZV1dLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogbmV3IFJ1bGVyKClcbiAqKi9cbmZ1bmN0aW9uIFJ1bGVyKCkge1xuICAvLyBMaXN0IG9mIGFkZGVkIHJ1bGVzLiBFYWNoIGVsZW1lbnQgaXM6XG4gIC8vXG4gIC8vIHtcbiAgLy8gICBuYW1lOiBYWFgsXG4gIC8vICAgZW5hYmxlZDogQm9vbGVhbixcbiAgLy8gICBmbjogRnVuY3Rpb24oKSxcbiAgLy8gICBhbHQ6IFsgbmFtZTIsIG5hbWUzIF1cbiAgLy8gfVxuICAvL1xuICB0aGlzLl9fcnVsZXNfXyA9IFtdO1xuXG4gIC8vIENhY2hlZCBydWxlIGNoYWlucy5cbiAgLy9cbiAgLy8gRmlyc3QgbGV2ZWwgLSBjaGFpbiBuYW1lLCAnJyBmb3IgZGVmYXVsdC5cbiAgLy8gU2Vjb25kIGxldmVsIC0gZGlnaW5hbCBhbmNob3IgZm9yIGZhc3QgZmlsdGVyaW5nIGJ5IGNoYXJjb2Rlcy5cbiAgLy9cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIG1ldGhvZHMsIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseVxuXG5cbi8vIEZpbmQgcnVsZSBpbmRleCBieSBuYW1lXG4vL1xuUnVsZXIucHJvdG90eXBlLl9fZmluZF9fID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9fcnVsZXNfXy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLl9fcnVsZXNfX1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vLyBCdWlsZCBydWxlcyBsb29rdXAgY2FjaGVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19jb21waWxlX18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNoYWlucyA9IFsgJycgXTtcblxuICAvLyBjb2xsZWN0IHVuaXF1ZSBuYW1lc1xuICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBydWxlLmFsdC5mb3JFYWNoKGZ1bmN0aW9uIChhbHROYW1lKSB7XG4gICAgICBpZiAoY2hhaW5zLmluZGV4T2YoYWx0TmFtZSkgPCAwKSB7XG4gICAgICAgIGNoYWlucy5wdXNoKGFsdE5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBzZWxmLl9fY2FjaGVfXyA9IHt9O1xuXG4gIGNoYWlucy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXSA9IFtdO1xuICAgIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIGlmICghcnVsZS5lbmFibGVkKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAoY2hhaW4gJiYgcnVsZS5hbHQuaW5kZXhPZihjaGFpbikgPCAwKSB7IHJldHVybjsgfVxuXG4gICAgICBzZWxmLl9fY2FjaGVfX1tjaGFpbl0ucHVzaChydWxlLmZuKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuYXQobmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgbmFtZSB0byByZXBsYWNlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBuZXcgcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogbmV3IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogUmVwbGFjZSBydWxlIGJ5IG5hbWUgd2l0aCBuZXcgZnVuY3Rpb24gJiBvcHRpb25zLiBUaHJvd3MgZXJyb3IgaWYgbmFtZSBub3RcbiAqIGZvdW5kLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogUmVwbGFjZSBleGlzdGluZyB0eXBvcmdhcGhlciByZXBsYWNlbWVudCBydWxlIHdpdGggbmV3IG9uZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5hdCgncmVwbGFjZW1lbnRzJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgbmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uZm4gPSBmbjtcbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmFsdCA9IG9wdC5hbHQgfHwgW107XG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5iZWZvcmUoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBiZWZvcmVOYW1lIChTdHJpbmcpOiBuZXcgcnVsZSB3aWxsIGJlIGFkZGVkIGJlZm9yZSB0aGlzIG9uZS5cbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgdG8gY2hhaW4gYmVmb3JlIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmFmdGVyXV0sIFtbUnVsZXIucHVzaF1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmJsb2NrLnJ1bGVyLmJlZm9yZSgncGFyYWdyYXBoJywgJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uIChiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhiZWZvcmVOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGJlZm9yZU5hbWUpOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hZnRlcihhZnRlck5hbWUsIHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gYWZ0ZXJOYW1lIChTdHJpbmcpOiBuZXcgcnVsZSB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBhZnRlciBvbmUgd2l0aCBnaXZlbiBuYW1lLiBTZWUgYWxzb1xuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuaW5saW5lLnJ1bGVyLmFmdGVyKCd0ZXh0JywgJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmFmdGVyID0gZnVuY3Rpb24gKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18oYWZ0ZXJOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGFmdGVyTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXggKyAxLCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cbi8qKlxuICogUnVsZXIucHVzaChydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogUHVzaCBuZXcgcnVsZSB0byB0aGUgZW5kIG9mIGNoYWluLiBTZWUgYWxzb1xuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5hZnRlcl1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmNvcmUucnVsZXIucHVzaCgnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fX3J1bGVzX18ucHVzaCh7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGUobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSkgLT4gQXJyYXlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGVuYWJsZVxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICBpZiAoaWdub3JlSW52YWxpZCkgeyByZXR1cm47IH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZXMgbWFuYWdlcjogaW52YWxpZCBydWxlIG5hbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSB0cnVlO1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZW5hYmxlT25seShsaXN0IFssIGlnbm9yZUludmFsaWRdKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlICh3aGl0ZWxpc3QpLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMsIGFuZCBkaXNhYmxlIGV2ZXJ5dGhpbmcgZWxzZS4gSWYgYW55IHJ1bGUgbmFtZVxuICogbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZGlzYWJsZV1dLCBbW1J1bGVyLmVuYWJsZV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmVuYWJsZU9ubHkgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkgeyBydWxlLmVuYWJsZWQgPSBmYWxzZTsgfSk7XG5cbiAgdGhpcy5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZCk7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZGlzYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZGlzYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIERpc2FibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgYW55IHJ1bGUgbmFtZSBub3QgZm91bmQgLSB0aHJvdyBFcnJvci5cbiAqIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFJldHVybnMgbGlzdCBvZiBmb3VuZCBydWxlIG5hbWVzIChpZiBubyBleGNlcHRpb24gaGFwcGVuZWQpLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZW5hYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFNlYXJjaCBieSBuYW1lIGFuZCBkaXNhYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IGZhbHNlO1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZ2V0UnVsZXMoY2hhaW5OYW1lKSAtPiBBcnJheVxuICpcbiAqIFJldHVybiBhcnJheSBvZiBhY3RpdmUgZnVuY3Rpb25zIChydWxlcykgZm9yIGdpdmVuIGNoYWluIG5hbWUuIEl0IGFuYWx5emVzXG4gKiBydWxlcyBjb25maWd1cmF0aW9uLCBjb21waWxlcyBjYWNoZXMgaWYgbm90IGV4aXN0cyBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogRGVmYXVsdCBjaGFpbiBuYW1lIGlzIGAnJ2AgKGVtcHR5IHN0cmluZykuIEl0IGNhbid0IGJlIHNraXBwZWQuIFRoYXQnc1xuICogZG9uZSBpbnRlbnRpb25hbGx5LCB0byBrZWVwIHNpZ25hdHVyZSBtb25vbW9ycGhpYyBmb3IgaGlnaCBzcGVlZC5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5nZXRSdWxlcyA9IGZ1bmN0aW9uIChjaGFpbk5hbWUpIHtcbiAgaWYgKHRoaXMuX19jYWNoZV9fID09PSBudWxsKSB7XG4gICAgdGhpcy5fX2NvbXBpbGVfXygpO1xuICB9XG5cbiAgLy8gQ2hhaW4gY2FuIGJlIGVtcHR5LCBpZiBydWxlcyBkaXNhYmxlZC4gQnV0IHdlIHN0aWxsIGhhdmUgdG8gcmV0dXJuIEFycmF5LlxuICByZXR1cm4gdGhpcy5fX2NhY2hlX19bY2hhaW5OYW1lXSB8fCBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUnVsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCIvLyBUb2tlbiBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBjbGFzcyBUb2tlblxuICoqL1xuXG4vKipcbiAqIG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpXG4gKlxuICogQ3JlYXRlIG5ldyB0b2tlbiBhbmQgZmlsbCBwYXNzZWQgcHJvcGVydGllcy5cbiAqKi9cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAvKipcbiAgICogVG9rZW4jdHlwZSAtPiBTdHJpbmdcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgdG9rZW4gKHN0cmluZywgZS5nLiBcInBhcmFncmFwaF9vcGVuXCIpXG4gICAqKi9cbiAgdGhpcy50eXBlICAgICA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRva2VuI3RhZyAtPiBTdHJpbmdcbiAgICpcbiAgICogaHRtbCB0YWcgbmFtZSwgZS5nLiBcInBcIlxuICAgKiovXG4gIHRoaXMudGFnICAgICAgPSB0YWc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2F0dHJzIC0+IEFycmF5XG4gICAqXG4gICAqIEh0bWwgYXR0cmlidXRlcy4gRm9ybWF0OiBgWyBbIG5hbWUxLCB2YWx1ZTEgXSwgWyBuYW1lMiwgdmFsdWUyIF0gXWBcbiAgICoqL1xuICB0aGlzLmF0dHJzICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbWFwIC0+IEFycmF5XG4gICAqXG4gICAqIFNvdXJjZSBtYXAgaW5mby4gRm9ybWF0OiBgWyBsaW5lX2JlZ2luLCBsaW5lX2VuZCBdYFxuICAgKiovXG4gIHRoaXMubWFwICAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNuZXN0aW5nIC0+IE51bWJlclxuICAgKlxuICAgKiBMZXZlbCBjaGFuZ2UgKG51bWJlciBpbiB7LTEsIDAsIDF9IHNldCksIHdoZXJlOlxuICAgKlxuICAgKiAtICBgMWAgbWVhbnMgdGhlIHRhZyBpcyBvcGVuaW5nXG4gICAqIC0gIGAwYCBtZWFucyB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZ1xuICAgKiAtIGAtMWAgbWVhbnMgdGhlIHRhZyBpcyBjbG9zaW5nXG4gICAqKi9cbiAgdGhpcy5uZXN0aW5nICA9IG5lc3Rpbmc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2xldmVsIC0+IE51bWJlclxuICAgKlxuICAgKiBuZXN0aW5nIGxldmVsLCB0aGUgc2FtZSBhcyBgc3RhdGUubGV2ZWxgXG4gICAqKi9cbiAgdGhpcy5sZXZlbCAgICA9IDA7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XG4gICAqXG4gICAqIEFuIGFycmF5IG9mIGNoaWxkIG5vZGVzIChpbmxpbmUgYW5kIGltZyB0b2tlbnMpXG4gICAqKi9cbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NvbnRlbnQgLT4gU3RyaW5nXG4gICAqXG4gICAqIEluIGEgY2FzZSBvZiBzZWxmLWNsb3NpbmcgdGFnIChjb2RlLCBodG1sLCBmZW5jZSwgZXRjLiksXG4gICAqIGl0IGhhcyBjb250ZW50cyBvZiB0aGlzIHRhZy5cbiAgICoqL1xuICB0aGlzLmNvbnRlbnQgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcmt1cCAtPiBTdHJpbmdcbiAgICpcbiAgICogJyonIG9yICdfJyBmb3IgZW1waGFzaXMsIGZlbmNlIHN0cmluZyBmb3IgZmVuY2UsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm1hcmt1cCAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2luZm8gLT4gU3RyaW5nXG4gICAqXG4gICAqIGZlbmNlIGluZm9zdHJpbmdcbiAgICoqL1xuICB0aGlzLmluZm8gICAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21ldGEgLT4gT2JqZWN0XG4gICAqXG4gICAqIEEgcGxhY2UgZm9yIHBsdWdpbnMgdG8gc3RvcmUgYW4gYXJiaXRyYXJ5IGRhdGFcbiAgICoqL1xuICB0aGlzLm1ldGEgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jYmxvY2sgLT4gQm9vbGVhblxuICAgKlxuICAgKiBUcnVlIGZvciBibG9jay1sZXZlbCB0b2tlbnMsIGZhbHNlIGZvciBpbmxpbmUgdG9rZW5zLlxuICAgKiBVc2VkIGluIHJlbmRlcmVyIHRvIGNhbGN1bGF0ZSBsaW5lIGJyZWFrc1xuICAgKiovXG4gIHRoaXMuYmxvY2sgICAgPSBmYWxzZTtcblxuICAvKipcbiAgICogVG9rZW4jaGlkZGVuIC0+IEJvb2xlYW5cbiAgICpcbiAgICogSWYgaXQncyB0cnVlLCBpZ25vcmUgdGhpcyBlbGVtZW50IHdoZW4gcmVuZGVyaW5nLiBVc2VkIGZvciB0aWdodCBsaXN0c1xuICAgKiB0byBoaWRlIHBhcmFncmFwaHMuXG4gICAqKi9cbiAgdGhpcy5oaWRkZW4gICA9IGZhbHNlO1xufVxuXG5cbi8qKlxuICogVG9rZW4uYXR0ckluZGV4KG5hbWUpIC0+IE51bWJlclxuICpcbiAqIFNlYXJjaCBhdHRyaWJ1dGUgaW5kZXggYnkgbmFtZS5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySW5kZXggPSBmdW5jdGlvbiBhdHRySW5kZXgobmFtZSkge1xuICB2YXIgYXR0cnMsIGksIGxlbjtcblxuICBpZiAoIXRoaXMuYXR0cnMpIHsgcmV0dXJuIC0xOyB9XG5cbiAgYXR0cnMgPSB0aGlzLmF0dHJzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGF0dHJzW2ldWzBdID09PSBuYW1lKSB7IHJldHVybiBpOyB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJQdXNoKGF0dHJEYXRhKVxuICpcbiAqIEFkZCBgWyBuYW1lLCB2YWx1ZSBdYCBhdHRyaWJ1dGUgdG8gbGlzdC4gSW5pdCBhdHRycyBpZiBuZWNlc3NhcnlcbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyUHVzaCA9IGZ1bmN0aW9uIGF0dHJQdXNoKGF0dHJEYXRhKSB7XG4gIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgdGhpcy5hdHRycy5wdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzID0gWyBhdHRyRGF0YSBdO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clNldChuYW1lLCB2YWx1ZSlcbiAqXG4gKiBTZXQgYG5hbWVgIGF0dHJpYnV0ZSB0byBgdmFsdWVgLiBPdmVycmlkZSBvbGQgdmFsdWUgaWYgZXhpc3RzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJTZXQgPSBmdW5jdGlvbiBhdHRyU2V0KG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSxcbiAgICAgIGF0dHJEYXRhID0gWyBuYW1lLCB2YWx1ZSBdO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdID0gYXR0ckRhdGE7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyR2V0KG5hbWUpXG4gKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhdHRyaWJ1dGUgYG5hbWVgLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJHZXQgPSBmdW5jdGlvbiBhdHRyR2V0KG5hbWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLCB2YWx1ZSA9IG51bGw7XG4gIGlmIChpZHggPj0gMCkge1xuICAgIHZhbHVlID0gdGhpcy5hdHRyc1tpZHhdWzFdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySm9pbihuYW1lLCB2YWx1ZSlcbiAqXG4gKiBKb2luIHZhbHVlIHRvIGV4aXN0aW5nIGF0dHJpYnV0ZSB2aWEgc3BhY2UuIE9yIGNyZWF0ZSBuZXcgYXR0cmlidXRlIGlmIG5vdFxuICogZXhpc3RzLiBVc2VmdWwgdG8gb3BlcmF0ZSB3aXRoIHRva2VuIGNsYXNzZXMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckpvaW4gPSBmdW5jdGlvbiBhdHRySm9pbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSk7XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKFsgbmFtZSwgdmFsdWUgXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdWzFdID0gdGhpcy5hdHRyc1tpZHhdWzFdICsgJyAnICsgdmFsdWU7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIS0jJS1cXCosLS86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDRcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQzRCLVxcdURDNEZcXHVEQzVCXFx1REM1RFxcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERTYwLVxcdURFNkNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDdbXFx1REM0MS1cXHVEQzQ1XFx1REM3MFxcdURDNzFdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODNBW1xcdURENUVcXHVERDVGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCIvLyBIVE1MNSBlbnRpdGllcyBtYXA6IHsgbmFtZSAtPiB1dGYxNnN0cmluZyB9XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBxdW90ZXM6MCovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2VudGl0aWVzL21hcHMvZW50aXRpZXMuanNvbicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIi8vIFJlZ2V4cHMgdG8gbWF0Y2ggaHRtbCBlbGVtZW50c1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRyX25hbWUgICAgID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcblxudmFyIHVucXVvdGVkICAgICAgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgc2luZ2xlX3F1b3RlZCA9IFwiJ1teJ10qJ1wiO1xudmFyIGRvdWJsZV9xdW90ZWQgPSAnXCJbXlwiXSpcIic7XG5cbnZhciBhdHRyX3ZhbHVlICA9ICcoPzonICsgdW5xdW90ZWQgKyAnfCcgKyBzaW5nbGVfcXVvdGVkICsgJ3wnICsgZG91YmxlX3F1b3RlZCArICcpJztcblxudmFyIGF0dHJpYnV0ZSAgID0gJyg/OlxcXFxzKycgKyBhdHRyX25hbWUgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBhdHRyX3ZhbHVlICsgJyk/KSc7XG5cbnZhciBvcGVuX3RhZyAgICA9ICc8W0EtWmEtel1bQS1aYS16MC05XFxcXC1dKicgKyBhdHRyaWJ1dGUgKyAnKlxcXFxzKlxcXFwvPz4nO1xuXG52YXIgY2xvc2VfdGFnICAgPSAnPFxcXFwvW0EtWmEtel1bQS1aYS16MC05XFxcXC1dKlxcXFxzKj4nO1xudmFyIGNvbW1lbnQgICAgID0gJzwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4nO1xudmFyIHByb2Nlc3NpbmcgID0gJzxbP10uKj9bP10+JztcbnZhciBkZWNsYXJhdGlvbiA9ICc8IVtBLVpdK1xcXFxzK1tePl0qPic7XG52YXIgY2RhdGEgICAgICAgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JztcblxudmFyIEhUTUxfVEFHX1JFID0gbmV3IFJlZ0V4cCgnXig/OicgKyBvcGVuX3RhZyArICd8JyArIGNsb3NlX3RhZyArICd8JyArIGNvbW1lbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgcHJvY2Vzc2luZyArICd8JyArIGRlY2xhcmF0aW9uICsgJ3wnICsgY2RhdGEgKyAnKScpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJyknKTtcblxubW9kdWxlLmV4cG9ydHMuSFRNTF9UQUdfUkUgPSBIVE1MX1RBR19SRTtcbm1vZHVsZS5leHBvcnRzLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwiLy8gUHJvY2VzcyAqdGhpcyogYW5kIF90aGF0X1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBJbnNlcnQgZWFjaCBtYXJrZXIgYXMgYSBzZXBhcmF0ZSB0ZXh0IHRva2VuLCBhbmQgYWRkIGl0IHRvIGRlbGltaXRlciBsaXN0XG4vL1xubW9kdWxlLmV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbiBlbXBoYXNpcyhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbixcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg1RiAvKiBfICovICYmIG1hcmtlciAhPT0gMHgyQSAvKiAqICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHNjYW5uZWQgPSBzdGF0ZS5zY2FuRGVsaW1zKHN0YXRlLnBvcywgbWFya2VyID09PSAweDJBKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2Nhbm5lZC5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgLy8gQ2hhciBjb2RlIG9mIHRoZSBzdGFydGluZyBtYXJrZXIgKG51bWJlcikuXG4gICAgICAvL1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG5cbiAgICAgIC8vIFRvdGFsIGxlbmd0aCBvZiB0aGVzZSBzZXJpZXMgb2YgZGVsaW1pdGVycy5cbiAgICAgIC8vXG4gICAgICBsZW5ndGg6IHNjYW5uZWQubGVuZ3RoLFxuXG4gICAgICAvLyBBbiBhbW91bnQgb2YgY2hhcmFjdGVycyBiZWZvcmUgdGhpcyBvbmUgdGhhdCdzIGVxdWl2YWxlbnQgdG9cbiAgICAgIC8vIGN1cnJlbnQgb25lLiBJbiBwbGFpbiBFbmdsaXNoOiBpZiB0aGlzIGRlbGltaXRlciBkb2VzIG5vdCBvcGVuXG4gICAgICAvLyBhbiBlbXBoYXNpcywgbmVpdGhlciBkbyBwcmV2aW91cyBganVtcGAgY2hhcmFjdGVycy5cbiAgICAgIC8vXG4gICAgICAvLyBVc2VkIHRvIHNraXAgc2VxdWVuY2VzIGxpa2UgXCIqKioqKlwiIGluIG9uZSBzdGVwLCBmb3IgMXN0IGFzdGVyaXNrXG4gICAgICAvLyB2YWx1ZSB3aWxsIGJlIDAsIGZvciAybmQgaXQncyAxIGFuZCBzbyBvbi5cbiAgICAgIC8vXG4gICAgICBqdW1wOiAgIGksXG5cbiAgICAgIC8vIEEgcG9zaXRpb24gb2YgdGhlIHRva2VuIHRoaXMgZGVsaW1pdGVyIGNvcnJlc3BvbmRzIHRvLlxuICAgICAgLy9cbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG5cbiAgICAgIC8vIFRva2VuIGxldmVsLlxuICAgICAgLy9cbiAgICAgIGxldmVsOiAgc3RhdGUubGV2ZWwsXG5cbiAgICAgIC8vIElmIHRoaXMgZGVsaW1pdGVyIGlzIG1hdGNoZWQgYXMgYSB2YWxpZCBvcGVuZXIsIGBlbmRgIHdpbGwgYmVcbiAgICAgIC8vIGVxdWFsIHRvIGl0cyBwb3NpdGlvbiwgb3RoZXJ3aXNlIGl0J3MgYC0xYC5cbiAgICAgIC8vXG4gICAgICBlbmQ6ICAgIC0xLFxuXG4gICAgICAvLyBCb29sZWFuIGZsYWdzIHRoYXQgZGV0ZXJtaW5lIGlmIHRoaXMgZGVsaW1pdGVyIGNvdWxkIG9wZW4gb3IgY2xvc2VcbiAgICAgIC8vIGFuIGVtcGhhc2lzLlxuICAgICAgLy9cbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUpIHtcbiAgdmFyIGksXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGNoLFxuICAgICAgaXNTdHJvbmcsXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDVGLyogXyAqLyAmJiBzdGFydERlbGltLm1hcmtlciAhPT0gMHgyQS8qICogKi8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3Mgb25seSBvcGVuaW5nIG1hcmtlcnNcbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgLy8gSWYgdGhlIG5leHQgZGVsaW1pdGVyIGhhcyB0aGUgc2FtZSBtYXJrZXIgYW5kIGlzIGFkamFjZW50IHRvIHRoaXMgb25lLFxuICAgIC8vIG1lcmdlIHRob3NlIGludG8gb25lIHN0cm9uZyBkZWxpbWl0ZXIuXG4gICAgLy9cbiAgICAvLyBgPGVtPjxlbT53aGF0ZXZlcjwvZW0+PC9lbT5gIC0+IGA8c3Ryb25nPndoYXRldmVyPC9zdHJvbmc+YFxuICAgIC8vXG4gICAgaXNTdHJvbmcgPSBpICsgMSA8IG1heCAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpICsgMV0uZW5kID09PSBzdGFydERlbGltLmVuZCAtIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSArIDFdLnRva2VuID09PSBzdGFydERlbGltLnRva2VuICsgMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCAtIDFdLnRva2VuID09PSBlbmREZWxpbS50b2tlbiAtIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSArIDFdLm1hcmtlciA9PT0gc3RhcnREZWxpbS5tYXJrZXI7XG5cbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnREZWxpbS5tYXJrZXIpO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX29wZW4nIDogJ2VtX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19jbG9zZScgOiAnZW1fY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gLTE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChpc1N0cm9uZykge1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbaSArIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCAtIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIi8vIH5+c3RyaWtlIHRocm91Z2h+flxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBJbnNlcnQgZWFjaCBtYXJrZXIgYXMgYSBzZXBhcmF0ZSB0ZXh0IHRva2VuLCBhbmQgYWRkIGl0IHRvIGRlbGltaXRlciBsaXN0XG4vL1xubW9kdWxlLmV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLCBsZW4sIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIHRydWUpO1xuICBsZW4gPSBzY2FubmVkLmxlbmd0aDtcbiAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgaWYgKGxlbiA8IDIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGxlbiAlIDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2g7XG4gICAgbGVuLS07XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2ggKyBjaDtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgIGp1bXA6ICAgaSxcbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuICAgICAgZW5kOiAgICAtMSxcbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSkge1xuICB2YXIgaSwgaixcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgbG9uZU1hcmtlcnMgPSBbXSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4N0UvKiB+ICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3Nfb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9ICdzJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3NfY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSAnfn4nO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW4gLSAxXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0uY29udGVudCA9PT0gJ34nKSB7XG5cbiAgICAgIGxvbmVNYXJrZXJzLnB1c2goZW5kRGVsaW0udG9rZW4gLSAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBhIG1hcmtlciBzZXF1ZW5jZSBoYXMgYW4gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBpdCdzIHNwbGl0dGVkXG4gIC8vIGxpa2UgdGhpczogYH5+fn5+YCAtPiBgfmAgKyBgfn5gICsgYH5+YCwgbGVhdmluZyBvbmUgbWFya2VyIGF0IHRoZVxuICAvLyBzdGFydCBvZiB0aGUgc2VxdWVuY2UuXG4gIC8vXG4gIC8vIFNvLCB3ZSBoYXZlIHRvIG1vdmUgYWxsIHRob3NlIG1hcmtlcnMgYWZ0ZXIgc3Vic2VxdWVudCBzX2Nsb3NlIHRhZ3MuXG4gIC8vXG4gIHdoaWxlIChsb25lTWFya2Vycy5sZW5ndGgpIHtcbiAgICBpID0gbG9uZU1hcmtlcnMucG9wKCk7XG4gICAgaiA9IGkgKyAxO1xuXG4gICAgd2hpbGUgKGogPCBzdGF0ZS50b2tlbnMubGVuZ3RoICYmIHN0YXRlLnRva2Vuc1tqXS50eXBlID09PSAnc19jbG9zZScpIHtcbiAgICAgIGorKztcbiAgICB9XG5cbiAgICBqLS07XG5cbiAgICBpZiAoaSAhPT0gaikge1xuICAgICAgdG9rZW4gPSBzdGF0ZS50b2tlbnNbal07XG4gICAgICBzdGF0ZS50b2tlbnNbal0gPSBzdGF0ZS50b2tlbnNbaV07XG4gICAgICBzdGF0ZS50b2tlbnNbaV0gPSB0b2tlbjtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2guanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5tb2R1bGUuZXhwb3J0cy5mb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xcMC1cXHgxRlxceDdGLVxceDlGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xcMC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzIiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICdsaWJzL2NvbXBvbmVudHMvY2VsbCc7XG5pbXBvcnQgVGl0bGUgZnJvbSAnbGlicy9jb21wb25lbnRzL3RpdGxlJztcbmltcG9ydCBUYWdzIGZyb20gJ2xpYnMvY29tcG9uZW50cy90YWdzJztcbmltcG9ydCBFZGl0b3IgZnJvbSAnbGlicy9jb21wb25lbnRzL2VkaXRvcic7XG5pbXBvcnQgUHJldmlldyBmcm9tICdsaWJzL2NvbXBvbmVudHMvcHJldmlldyc7XG5pbXBvcnQgU2F2ZSBmcm9tICdsaWJzL2NvbXBvbmVudHMvc2F2ZSc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnbGlicy9tb2RlbHMvYXJ0aWNsZSc7XG5cbmNvbnN0IG1vZGVsID0gbmV3IE1vZGVsKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nbWRsLWdyaWQnPlxuICAgICAgPFRpdGxlIG1vZGVsPXttb2RlbH0gLz5cbiAgICAgIDxUYWdzIG1vZGVsPXttb2RlbH0gLz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZWRpdG9yV3JhcH0+XG4gICAgICAgIDxFZGl0b3Iga2V5PSdlZGl0b3InIG1vZGVsPXttb2RlbH0gLz5cbiAgICAgICAgPFByZXZpZXcga2V5PSdwcmV2aWV3JyBib2R5PXttb2RlbC5tZEJvZHkoKX0gLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPFNhdmUgbW9kZWw9e21vZGVsfSAvPlxuICAgIDwvZGl2PlxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnQuanMiLCJpbXBvcnQgcmVxdWVzdCBmcm9tICcuLi9yZXF1ZXN0LmpzJztcbmltcG9ydCBNYXJrZG93bkl0IGZyb20gJ21hcmtkb3duLWl0JztcblxuY29uc3QgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHtcbiAgICAgIHRpdGxlOiAnJyxcbiAgICAgIGJvZHk6ICcnLFxuICAgICAgc2x1ZzogJycsXG4gICAgICBwdWJsaXNoOiBmYWxzZSxcbiAgICAgIHRhZ3M6IFtdLFxuICAgICAgZGF0ZTogbnVsbCxcbiAgICB9O1xuICAgIHRoaXMuZmV0Y2hlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVzb3VyY2VzVXJsID0gJy9hcGkvYXJ0aWNsZXMnO1xuICAgIHRoaXMucmVzb3VyY2VVcmwgPSBgJHt0aGlzLnJlc291cmNlc1VybH0vJHtsb2NhdGlvbi5ocmVmLnNwbGl0KCcvJykuc2xpY2UoNCkuam9pbignLycpfWA7XG4gIH1cbiAgZmV0Y2goKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QoJ0dFVCcsIHRoaXMucmVzb3VyY2VVcmwpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHRoaXMuZmV0Y2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0YSA9IHJlc3BvbnNlO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gcmVxdWVzdCgnUE9TVCcsIHRoaXMucmVzb3VyY2VzVXJsLCB0aGlzLmRhdGEpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHJlc3BvbnNlO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICByZXR1cm4gcmVxdWVzdCgnUFVUJywgdGhpcy5yZXNvdXJjZVVybCwgdGhpcy5kYXRhKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICB0aGlzLmRhdGEgPSByZXNwb25zZTtcbiAgICB9KTtcbiAgfVxuICBkZWxldGUoKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QoJ0RFTEVURScsIHRoaXMucmVzb3VyY2VVcmwpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICB9KTtcbiAgfVxuICBtZEJvZHkoKSB7XG4gICAgcmV0dXJuIG1kLnJlbmRlcih0aGlzLmRhdGEuYm9keSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9saWJzL21vZGVscy9hcnRpY2xlLmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBkYXRhKSB7XG4gIHJldHVybiBtLnJlcXVlc3QoeyBtZXRob2QsIHVybCwgZGF0YSwgZGVzZXJpYWxpemU6IEpTT04ucGFyc2V9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9saWJzL3JlcXVlc3QuanMiLCIndXNlIHN0cmljdCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlcnNcblxuLy8gTWVyZ2Ugb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJzsgfVxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nOyB9XG5cblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJyk7IH1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZ1enp5TGluazogdHJ1ZSxcbiAgZnV6enlFbWFpbDogdHJ1ZSxcbiAgZnV6enlJUDogZmFsc2Vcbn07XG5cblxuZnVuY3Rpb24gaXNPcHRpb25zT2JqKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaykge1xuICAgIHJldHVybiBhY2MgfHwgZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkoayk7XG4gIH0sIGZhbHNlKTtcbn1cblxuXG52YXIgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICdodHRwOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5odHRwKSB7XG4gICAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUuaHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeXFxcXC9cXFxcLycgKyBzZWxmLnJlLnNyY19hdXRoICsgc2VsZi5yZS5zcmNfaG9zdF9wb3J0X3N0cmljdCArIHNlbGYucmUuc3JjX3BhdGgsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUuaHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUuaHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnaHR0cHM6JzogICdodHRwOicsXG4gICdmdHA6JzogICAgJ2h0dHA6JyxcbiAgJy8vJzogICAgICB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xuICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5ub19odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19hdXRoICtcbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyBzaW5nbGUtbGV2ZWwgZG9tYWlucywgYmVjYXVzZSBvZiBmYWxzZSBwb3NpdGl2ZXMgbGlrZSAnLy90ZXN0J1xuICAgICAgICAgIC8vIHdpdGggY29kZSBjb21tZW50c1xuICAgICAgICAgICcoPzpsb2NhbGhvc3R8KD86KD86JyArIHNlbGYucmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKycgKyBzZWxmLnJlLnNyY19kb21haW5fcm9vdCArICcpJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcG9ydCArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wYXRoLFxuXG4gICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlLm5vX2h0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gICYgYC8vL2AsIHRoYXQgcHJvdGVjdHMgZnJvbSBlcnJvcnMgaW4gcHJvdG9jb2wgbmFtZVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwOyB9XG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnLycpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdtYWlsdG86Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICBzZWxmLnJlLm1haWx0byA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArIHNlbGYucmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyBzZWxmLnJlLnNyY19ob3N0X3N0cmljdCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5tYWlsdG8udGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm1haWx0bylbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG4vLyBSRSBwYXR0ZXJuIGZvciAyLWNoYXJhY3RlciB0bGRzIChhdXRvZ2VuZXJhdGVkIGJ5IC4vc3VwcG9ydC90bGRzXzJjaGFyX2dlbi5qcylcbnZhciB0bGRzXzJjaF9zcmNfcmUgPSAnYVtjZGVmZ2lsbW5vcXJzdHV3eHpdfGJbYWJkZWZnaGlqbW5vcnN0dnd5el18Y1thY2RmZ2hpa2xtbm9ydXZ3eHl6XXxkW2Vqa21vel18ZVtjZWdyc3R1XXxmW2lqa21vcl18Z1thYmRlZmdoaWxtbnBxcnN0dXd5XXxoW2ttbnJ0dV18aVtkZWxtbm9xcnN0XXxqW2Vtb3BdfGtbZWdoaW1ucHJ3eXpdfGxbYWJjaWtyc3R1dnldfG1bYWNkZWdoa2xtbm9wcXJzdHV2d3h5el18blthY2VmZ2lsb3BydXpdfG9tfHBbYWVmZ2hrbG1ucnN0d3ldfHFhfHJbZW9zdXddfHNbYWJjZGVnaGlqa2xtbm9ydHV2eHl6XXx0W2NkZmdoamtsbW5vcnR2d3pdfHVbYWdrc3l6XXx2W2FjZWdpbnVdfHdbZnNdfHlbZXRdfHpbYW13XSc7XG5cbi8vIERPTidUIHRyeSB0byBtYWtlIFBScyB3aXRoIGNoYW5nZXMuIEV4dGVuZCBUTERzIHdpdGggTGlua2lmeUl0LnRsZHMoKSBpbnN0ZWFkXG52YXIgdGxkc19kZWZhdWx0ID0gJ2Jpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEJy5zcGxpdCgnfCcpO1xuXG4vKmVzbGludC1lbmFibGUgbWF4LWxlbiovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHJlc2V0U2NhbkNhY2hlKHNlbGYpIHtcbiAgc2VsZi5fX2luZGV4X18gPSAtMTtcbiAgc2VsZi5fX3RleHRfY2FjaGVfXyAgID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcihyZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIHBvcykge1xuICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgaWYgKHJlLnRlc3QodGFpbCkpIHtcbiAgICAgIHJldHVybiB0YWlsLm1hdGNoKHJlKVswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBzZWxmKSB7XG4gICAgc2VsZi5ub3JtYWxpemUobWF0Y2gpO1xuICB9O1xufVxuXG4vLyBTY2hlbWFzIGNvbXBpbGVyLiBCdWlsZCByZWdleHBzLlxuLy9cbmZ1bmN0aW9uIGNvbXBpbGUoc2VsZikge1xuXG4gIC8vIExvYWQgJiBjbG9uZSBSRSBwYXR0ZXJucy5cbiAgdmFyIHJlID0gc2VsZi5yZSA9IHJlcXVpcmUoJy4vbGliL3JlJykoc2VsZi5fX29wdHNfXyk7XG5cbiAgLy8gRGVmaW5lIGR5bmFtaWMgcGF0dGVybnNcbiAgdmFyIHRsZHMgPSBzZWxmLl9fdGxkc19fLnNsaWNlKCk7XG5cbiAgc2VsZi5vbkNvbXBpbGUoKTtcblxuICBpZiAoIXNlbGYuX190bGRzX3JlcGxhY2VkX18pIHtcbiAgICB0bGRzLnB1c2godGxkc18yY2hfc3JjX3JlKTtcbiAgfVxuICB0bGRzLnB1c2gocmUuc3JjX3huKTtcblxuICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbignfCcpO1xuXG4gIGZ1bmN0aW9uIHVudHBsKHRwbCkgeyByZXR1cm4gdHBsLnJlcGxhY2UoJyVUTERTJScsIHJlLnNyY190bGRzKTsgfVxuXG4gIHJlLmVtYWlsX2Z1enp5ICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2VtYWlsX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19mdXp6eSAgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfbm9faXBfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfbm9faXBfZnV6enkpLCAnaScpO1xuICByZS5ob3N0X2Z1enp5X3Rlc3QgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QpLCAnaScpO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgZWFjaCBzY2hlbWFcbiAgLy9cblxuICB2YXIgYWxpYXNlcyA9IFtdO1xuXG4gIHNlbGYuX19jb21waWxlZF9fID0ge307IC8vIFJlc2V0IGNvbXBpbGVkIGRhdGFcblxuICBmdW5jdGlvbiBzY2hlbWFFcnJvcihuYW1lLCB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xuICB9XG5cbiAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuXG4gICAgLy8gc2tpcCBkaXNhYmxlZCBtZXRob2RzXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblxuICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcblxuICAgIHNlbGYuX19jb21waWxlZF9fW25hbWVdID0gY29tcGlsZWQ7XG5cbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsLm5vcm1hbGl6ZSkpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gdmFsLm5vcm1hbGl6ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5ub3JtYWxpemUpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBwb3N0cG9uZWQgYWxpYXNlc1xuICAvL1xuXG4gIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICBpZiAoIXNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXSkge1xuICAgICAgLy8gU2lsZW50bHkgZmFpbCBvbiBtaXNzZWQgc2NoZW1hcyB0byBhdm9pZCBlcnJvbnMgb24gZGlzYWJsZS5cbiAgICAgIC8vIHNjaGVtYUVycm9yKGFsaWFzLCBzZWxmLl9fc2NoZW1hc19fW2FsaWFzXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLnZhbGlkYXRlID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS52YWxpZGF0ZTtcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10ubm9ybWFsaXplID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS5ub3JtYWxpemU7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIEZha2UgcmVjb3JkIGZvciBndWVzc2VkIGxpbmtzXG4gIC8vXG4gIHNlbGYuX19jb21waWxlZF9fWycnXSA9IHsgdmFsaWRhdGU6IG51bGwsIG5vcm1hbGl6ZTogY3JlYXRlTm9ybWFsaXplcigpIH07XG5cbiAgLy9cbiAgLy8gQnVpbGQgc2NoZW1hIGNvbmRpdGlvblxuICAvL1xuICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXylcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZGlzYWJsZWQgJiBmYWtlIHNjaGVtYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aCA+IDAgJiYgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGVzY2FwZVJFKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gIC8vICg/IV8pIGNhdXNlIDEuNXggc2xvd2Rvd25cbiAgc2VsZi5yZS5zY2hlbWFfdGVzdCAgID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpJyk7XG4gIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKTtcblxuICBzZWxmLnJlLnByZXRlc3QgICAgICAgPSBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzZWxmLnJlLmhvc3RfZnV6enlfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2knKTtcblxuICAvL1xuICAvLyBDbGVhbnVwXG4gIC8vXG5cbiAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XG59XG5cbi8qKlxuICogY2xhc3MgTWF0Y2hcbiAqXG4gKiBNYXRjaCByZXN1bHQuIFNpbmdsZSBlbGVtZW50IG9mIGFycmF5LCByZXR1cm5lZCBieSBbW0xpbmtpZnlJdCNtYXRjaF1dXG4gKiovXG5mdW5jdGlvbiBNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXyxcbiAgICAgIGVuZCAgID0gc2VsZi5fX2xhc3RfaW5kZXhfXyxcbiAgICAgIHRleHQgID0gc2VsZi5fX3RleHRfY2FjaGVfXy5zbGljZShzdGFydCwgZW5kKTtcblxuICAvKipcbiAgICogTWF0Y2gjc2NoZW1hIC0+IFN0cmluZ1xuICAgKlxuICAgKiBQcmVmaXggKHByb3RvY29sKSBmb3IgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5zY2hlbWEgICAgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgLyoqXG4gICAqIE1hdGNoI2luZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBGaXJzdCBwb3NpdGlvbiBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmluZGV4ICAgICA9IHN0YXJ0ICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNsYXN0SW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIE5leHQgcG9zaXRpb24gYWZ0ZXIgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI3JhdyAtPiBTdHJpbmdcbiAgICpcbiAgICogTWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5yYXcgICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdGV4dCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm90bWFsaXplZCB0ZXh0IG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudGV4dCAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3VybCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm9ybWFsaXplZCB1cmwgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy51cmwgICAgICAgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuXG4gIHNlbGYuX19jb21waWxlZF9fW21hdGNoLnNjaGVtYV0ubm9ybWFsaXplKG1hdGNoLCBzZWxmKTtcblxuICByZXR1cm4gbWF0Y2g7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBMaW5raWZ5SXRcbiAqKi9cblxuLyoqXG4gKiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogQ3JlYXRlcyBuZXcgbGlua2lmaWVyIGluc3RhbmNlIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBzY2hlbWFzLlxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdW5kZXJzdGFuZHM6XG4gKlxuICogLSBgaHR0cChzKTovLy4uLmAgLCBgZnRwOi8vLi4uYCwgYG1haWx0bzouLi5gICYgYC8vLi4uYCBsaW5rc1xuICogLSBcImZ1enp5XCIgbGlua3MgYW5kIGVtYWlscyAoZXhhbXBsZS5jb20sIGZvb0BiYXIuY29tKS5cbiAqXG4gKiBgc2NoZW1hc2AgaXMgYW4gb2JqZWN0LCB3aGVyZSBlYWNoIGtleS92YWx1ZSBkZXNjcmliZXMgcHJvdG9jb2wvcnVsZTpcbiAqXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxuICogICBmb3IgZXhhbXBsZSkuIGBsaW5raWZ5LWl0YCBtYWtlcyBzaHVyZSB0aGF0IHByZWZpeCBpcyBub3QgcHJlY2VlZGVkIHdpdGhcbiAqICAgYWxwaGFudW1lcmljIGNoYXIgYW5kIHN5bWJvbHMuIE9ubHkgd2hpdGVzcGFjZXMgYW5kIHB1bmN0dWF0aW9uIGFsbG93ZWQuXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxuICogICAtIF9TdHJpbmdfIC0ganVzdCBhbGlhcyB0byBleGlzdGluZyBydWxlXG4gKiAgIC0gX09iamVjdF9cbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXG4gKiAgICAgICBvciBgUmVnRXhwYC5cbiAqICAgICAtIF9ub3JtYWxpemVfIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbm9ybWFsaXplIHRleHQgJiB1cmwgb2YgbWF0Y2hlZCByZXN1bHRcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cbiAqXG4gKiBgb3B0aW9uc2A6XG4gKlxuICogLSBfX2Z1enp5TGlua19fIC0gcmVjb2duaWdlIFVSTC1zIHdpdGhvdXQgYGh0dHAocyk6YCBwcmVmaXguIERlZmF1bHQgYHRydWVgLlxuICogLSBfX2Z1enp5SVBfXyAtIGFsbG93IElQcyBpbiBmdXp6eSBsaW5rcyBhYm92ZS4gQ2FuIGNvbmZsaWN0IHdpdGggc29tZSB0ZXh0c1xuICogICBsaWtlIHZlcnNpb24gbnVtYmVycy4gRGVmYXVsdCBgZmFsc2VgLlxuICogLSBfX2Z1enp5RW1haWxfXyAtIHJlY29nbml6ZSBlbWFpbHMgd2l0aG91dCBgbWFpbHRvOmAgcHJlZml4LlxuICpcbiAqKi9cbmZ1bmN0aW9uIExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5raWZ5SXQpKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoaXNPcHRpb25zT2JqKHNjaGVtYXMpKSB7XG4gICAgICBvcHRpb25zID0gc2NoZW1hcztcbiAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9fb3B0c19fICAgICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIENhY2hlIGxhc3QgdGVzdGVkIHJlc3VsdC4gVXNlZCB0byBza2lwIHJlcGVhdGluZyBzdGVwcyBvbiBuZXh0IGBtYXRjaGAgY2FsbC5cbiAgdGhpcy5fX2luZGV4X18gICAgICAgICAgPSAtMTtcbiAgdGhpcy5fX2xhc3RfaW5kZXhfXyAgICAgPSAtMTsgLy8gTmV4dCBzY2FuIHBvc2l0aW9uXG4gIHRoaXMuX19zY2hlbWFfXyAgICAgICAgID0gJyc7XG4gIHRoaXMuX190ZXh0X2NhY2hlX18gICAgID0gJyc7XG5cbiAgdGhpcy5fX3NjaGVtYXNfXyAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgdGhpcy5fX2NvbXBpbGVkX18gICAgICAgPSB7fTtcblxuICB0aGlzLl9fdGxkc19fICAgICAgICAgICA9IHRsZHNfZGVmYXVsdDtcbiAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyAgPSBmYWxzZTtcblxuICB0aGlzLnJlID0ge307XG5cbiAgY29tcGlsZSh0aGlzKTtcbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjYWRkKHNjaGVtYSwgZGVmaW5pdGlvbilcbiAqIC0gc2NoZW1hIChTdHJpbmcpOiBydWxlIG5hbWUgKGZpeGVkIHBhdHRlcm4gcHJlZml4KVxuICogLSBkZWZpbml0aW9uIChTdHJpbmd8UmVnRXhwfE9iamVjdCk6IHNjaGVtYSBkZWZpbml0aW9uXG4gKlxuICogQWRkIG5ldyBydWxlIGRlZmluaXRpb24uIFNlZSBjb25zdHJ1Y3RvciBkZXNjcmlwdGlvbiBmb3IgZGV0YWlscy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHNjaGVtYSwgZGVmaW5pdGlvbikge1xuICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3NldChvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIFNldCByZWNvZ25pdGlvbiBvcHRpb25zIGZvciBsaW5rcyB3aXRob3V0IHNjaGVtYS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFNlYXJjaGVzIGxpbmtpZmlhYmxlIHBhdHRlcm4gYW5kIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3Mgb3IgYGZhbHNlYCBvbiBmYWlsLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdCh0ZXh0KSB7XG4gIC8vIFJlc2V0IHNjYW4gY2FjaGVcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHQ7XG4gIHRoaXMuX19pbmRleF9fICAgICAgPSAtMTtcblxuICBpZiAoIXRleHQubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XG5cbiAgLy8gdHJ5IHRvIHNjYW4gZm9yIGxpbmsgd2l0aCBzY2hlbWEgLSB0aGF0J3MgdGhlIG1vc3Qgc2ltcGxlIHJ1bGVcbiAgaWYgKHRoaXMucmUuc2NoZW1hX3Rlc3QudGVzdCh0ZXh0KSkge1xuICAgIHJlID0gdGhpcy5yZS5zY2hlbWFfc2VhcmNoO1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgIGxlbiA9IHRoaXMudGVzdFNjaGVtYUF0KHRleHQsIG1bMl0sIHJlLmxhc3RJbmRleCk7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSBtWzJdO1xuICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoO1xuICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoICsgbGVuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUxpbmsgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ2h0dHA6J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGxpbmtzXG4gICAgdGxkX3BvcyA9IHRleHQuc2VhcmNoKHRoaXMucmUuaG9zdF9mdXp6eV90ZXN0KTtcbiAgICBpZiAodGxkX3BvcyA+PSAwKSB7XG4gICAgICAvLyBpZiB0bGQgaXMgbG9jYXRlZCBhZnRlciBmb3VuZCBsaW5rIC0gbm8gbmVlZCB0byBjaGVjayBmdXp6eSBwYXR0ZXJuXG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICBpZiAoKG1sID0gdGV4dC5tYXRjaCh0aGlzLl9fb3B0c19fLmZ1enp5SVAgPyB0aGlzLnJlLmxpbmtfZnV6enkgOiB0aGlzLnJlLmxpbmtfbm9faXBfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgc2hpZnQgPSBtbC5pbmRleCArIG1sWzFdLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG1sLmluZGV4ICsgbWxbMF0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ21haWx0bzonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgZW1haWxzXG4gICAgYXRfcG9zID0gdGV4dC5pbmRleE9mKCdAJyk7XG4gICAgaWYgKGF0X3BvcyA+PSAwKSB7XG4gICAgICAvLyBXZSBjYW4ndCBza2lwIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhpcyBjYXNlcyBhcmUgcG9zc2libGU6XG4gICAgICAvLyAxOTIuMTY4LjEuMUBnbWFpbC5jb20sIG15LmluQGV4YW1wbGUuY29tXG4gICAgICBpZiAoKG1lID0gdGV4dC5tYXRjaCh0aGlzLnJlLmVtYWlsX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICBuZXh0ICA9IG1lLmluZGV4ICsgbWVbMF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXyB8fFxuICAgICAgICAgICAgKHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykpIHtcbiAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJ21haWx0bzonO1xuICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLl9faW5kZXhfXyA+PSAwO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNwcmV0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBWZXJ5IHF1aWNrIGNoZWNrLCB0aGF0IGNhbiBnaXZlIGZhbHNlIHBvc2l0aXZlcy4gUmV0dXJucyB0cnVlIGlmIGxpbmsgTUFZIEJFXG4gKiBjYW4gZXhpc3RzLiBDYW4gYmUgdXNlZCBmb3Igc3BlZWQgb3B0aW1pemF0aW9uLCB3aGVuIHlvdSBuZWVkIHRvIGNoZWNrIHRoYXRcbiAqIGxpbmsgTk9UIGV4aXN0cy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUucHJldGVzdCA9IGZ1bmN0aW9uIHByZXRlc3QodGV4dCkge1xuICByZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QodGV4dCk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3RTY2hlbWFBdCh0ZXh0LCBuYW1lLCBwb3NpdGlvbikgLT4gTnVtYmVyXG4gKiAtIHRleHQgKFN0cmluZyk6IHRleHQgdG8gc2NhblxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIChzY2hlbWEpIG5hbWVcbiAqIC0gcG9zaXRpb24gKE51bWJlcik6IHRleHQgb2Zmc2V0IHRvIGNoZWNrIGZyb21cbiAqXG4gKiBTaW1pbGFyIHRvIFtbTGlua2lmeUl0I3Rlc3RdXSBidXQgY2hlY2tzIG9ubHkgc3BlY2lmaWMgcHJvdG9jb2wgdGFpbCBleGFjdGx5XG4gKiBhdCBnaXZlbiBwb3NpdGlvbi4gUmV0dXJucyBsZW5ndGggb2YgZm91bmQgcGF0dGVybiAoMCBvbiBmYWlsKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdFNjaGVtYUF0ID0gZnVuY3Rpb24gdGVzdFNjaGVtYUF0KHRleHQsIHNjaGVtYSwgcG9zKSB7XG4gIC8vIElmIG5vdCBzdXBwb3J0ZWQgc2NoZW1hIGNoZWNrIHJlcXVlc3RlZCAtIHRlcm1pbmF0ZVxuICBpZiAoIXRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0udmFsaWRhdGUodGV4dCwgcG9zLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjbWF0Y2godGV4dCkgLT4gQXJyYXl8bnVsbFxuICpcbiAqIFJldHVybnMgYXJyYXkgb2YgZm91bmQgbGluayBkZXNjcmlwdGlvbnMgb3IgYG51bGxgIG9uIGZhaWwuIFdlIHN0cm9uZ2x5XG4gKiByZWNvbW1lbmQgdG8gdXNlIFtbTGlua2lmeUl0I3Rlc3RdXSBmaXJzdCwgZm9yIGJlc3Qgc3BlZWQuXG4gKlxuICogIyMjIyMgUmVzdWx0IG1hdGNoIGRlc2NyaXB0aW9uXG4gKlxuICogLSBfX3NjaGVtYV9fIC0gbGluayBzY2hlbWEsIGNhbiBiZSBlbXB0eSBmb3IgZnV6enkgbGlua3MsIG9yIGAvL2AgZm9yXG4gKiAgIHByb3RvY29sLW5ldXRyYWwgIGxpbmtzLlxuICogLSBfX2luZGV4X18gLSBvZmZzZXQgb2YgbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fbGFzdEluZGV4X18gLSBpbmRleCBvZiBuZXh0IGNoYXIgYWZ0ZXIgbWF0aGNoIGVuZFxuICogLSBfX3Jhd19fIC0gbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fdGV4dF9fIC0gbm9ybWFsaXplZCB0ZXh0XG4gKiAtIF9fdXJsX18gLSBsaW5rLCBnZW5lcmF0ZWQgZnJvbSBtYXRjaGVkIHRleHRcbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0ZXh0KSB7XG4gIHZhciBzaGlmdCA9IDAsIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFRyeSB0byB0YWtlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSBjYWNoZSwgaWYgLnRlc3QoKSBjYWxsZWQgYmVmb3JlXG4gIGlmICh0aGlzLl9faW5kZXhfXyA+PSAwICYmIHRoaXMuX190ZXh0X2NhY2hlX18gPT09IHRleHQpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuICAgIHNoaWZ0ID0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIC8vIEN1dCBoZWFkIGlmIGNhY2hlIHdhcyB1c2VkXG4gIHZhciB0YWlsID0gc2hpZnQgPyB0ZXh0LnNsaWNlKHNoaWZ0KSA6IHRleHQ7XG5cbiAgLy8gU2NhbiBzdHJpbmcgdW50aWwgZW5kIHJlYWNoZWRcbiAgd2hpbGUgKHRoaXMudGVzdCh0YWlsKSkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG5cbiAgICB0YWlsID0gdGFpbC5zbGljZSh0aGlzLl9fbGFzdF9pbmRleF9fKTtcbiAgICBzaGlmdCArPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCN0bGRzKGxpc3QgWywga2VlcE9sZF0pIC0+IHRoaXNcbiAqIC0gbGlzdCAoQXJyYXkpOiBsaXN0IG9mIHRsZHNcbiAqIC0ga2VlcE9sZCAoQm9vbGVhbik6IG1lcmdlIHdpdGggY3VycmVudCBsaXN0IGlmIGB0cnVlYCAoYGZhbHNlYCBieSBkZWZhdWx0KVxuICpcbiAqIExvYWQgKG9yIG1lcmdlKSBuZXcgdGxkcyBsaXN0LiBUaG9zZSBhcmUgdXNlciBmb3IgZnV6enkgbGlua3MgKHdpdGhvdXQgcHJlZml4KVxuICogdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzLiBCeSBkZWZhdWx0IHRoaXMgYWxnb3J5dGhtIHVzZWQ6XG4gKlxuICogLSBob3N0bmFtZSB3aXRoIGFueSAyLWxldHRlciByb290IHpvbmVzIGFyZSBvay5cbiAqIC0gYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcbiAqICAgYXJlIG9rLlxuICogLSBlbmNvZGVkIChgeG4tLS4uLmApIHJvb3Qgem9uZXMgYXJlIG9rLlxuICpcbiAqIElmIGxpc3QgaXMgcmVwbGFjZWQsIHRoZW4gZXhhY3QgbWF0Y2ggZm9yIDItY2hhcnMgcm9vdCB6b25lcyB3aWxsIGJlIGNoZWNrZWQuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiB0bGRzKGxpc3QsIGtlZXBPbGQpIHtcbiAgbGlzdCA9IEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0IDogWyBsaXN0IF07XG5cbiAgaWYgKCFrZWVwT2xkKSB7XG4gICAgdGhpcy5fX3RsZHNfXyA9IGxpc3Quc2xpY2UoKTtcbiAgICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fID0gdHJ1ZTtcbiAgICBjb21waWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fX3RsZHNfXyA9IHRoaXMuX190bGRzX18uY29uY2F0KGxpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsLCBpZHgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsICE9PSBhcnJbaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpO1xuXG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaW5raWZ5SXQjbm9ybWFsaXplKG1hdGNoKVxuICpcbiAqIERlZmF1bHQgbm9ybWFsaXplciAoaWYgc2NoZW1hIGRvZXMgbm90IGRlZmluZSBpdCdzIG93bikuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtYXRjaCkge1xuXG4gIC8vIERvIG1pbmltYWwgcG9zc2libGUgY2hhbmdlcyBieSBkZWZhdWx0LiBOZWVkIHRvIGNvbGxlY3QgZmVlZGJhY2sgcHJpb3JcbiAgLy8gdG8gbW92ZSBmb3J3YXJkIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0L2lzc3Vlcy8xXG5cbiAgaWYgKCFtYXRjaC5zY2hlbWEpIHsgbWF0Y2gudXJsID0gJ2h0dHA6Ly8nICsgbWF0Y2gudXJsOyB9XG5cbiAgaWYgKG1hdGNoLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KG1hdGNoLnVybCkpIHtcbiAgICBtYXRjaC51cmwgPSAnbWFpbHRvOicgKyBtYXRjaC51cmw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjb25Db21waWxlKClcbiAqXG4gKiBPdmVycmlkZSB0byBtb2RpZnkgYmFzaWMgUmVnRXhwLXMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSgpIHtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5raWZ5SXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHJlID0ge307XG5cbiAgLy8gVXNlIGRpcmVjdCBleHRyYWN0IGluc3RlYWQgb2YgYHJlZ2VuZXJhdGVgIHRvIHJlZHVzZSBicm93c2VyaWZpZWQgc2l6ZVxuICByZS5zcmNfQW55ID0gcmVxdWlyZSgndWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19DYyAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfWiAgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfUCAgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jykuc291cmNlO1xuXG4gIC8vIFxccHtcXFpcXFBcXENjXFxDRn0gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wgKyBmb3JtYXQgKyBwdW5jdHVhdGlvbilcbiAgcmUuc3JjX1pQQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfUCwgcmUuc3JjX0NjIF0uam9pbignfCcpO1xuXG4gIC8vIFxccHtcXFpcXENjfSAod2hpdGUgc3BhY2VzICsgY29udHJvbClcbiAgcmUuc3JjX1pDYyA9IFsgcmUuc3JjX1osIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBFeHBlcmltZW50YWwuIExpc3Qgb2YgY2hhcnMsIGNvbXBsZXRlbHkgcHJvaGliaXRlZCBpbiBsaW5rc1xuICAvLyBiZWNhdXNlIGNhbiBzZXBhcmF0ZSBpdCBmcm9tIG90aGVyIHBhcnQgb2YgdGV4dFxuICB2YXIgdGV4dF9zZXBhcmF0b3JzID0gJ1s+PFxcdWZmNWNdJztcblxuICAvLyBBbGwgcG9zc2libGUgd29yZCBjaGFyYWN0ZXJzIChldmVyeXRoaW5nIHdpdGhvdXQgcHVuY3R1YXRpb24sIHNwYWNlcyAmIGNvbnRyb2xzKVxuICAvLyBEZWZpbmVkIHZpYSBwdW5jdHVhdGlvbiAmIHNwYWNlcyB0byBzYXZlIHNwYWNlXG4gIC8vIFNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSBcXHB7XFxMXFxOXFxTXFxNfSAoXFx3IGJ1dCB3aXRob3V0IGBfYClcbiAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgICAgICAgPSAnKD86KD8hJyArIHRleHRfc2VwYXJhdG9ycyArICd8JyArIHJlLnNyY19aUENjICsgJyknICsgcmUuc3JjX0FueSArICcpJztcbiAgLy8gVGhlIHNhbWUgYXMgYWJvdGhlIGJ1dCB3aXRob3V0IFswLTldXG4gIC8vIHZhciBzcmNfcHNldWRvX2xldHRlcl9ub25fZCA9ICcoPzooPyFbMC05XXwnICsgc3JjX1pQQ2MgKyAnKScgKyBzcmNfQW55ICsgJyknO1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgcmUuc3JjX2lwNCA9XG5cbiAgICAnKD86KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXFxcLil7M30oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSc7XG5cbiAgLy8gUHJvaGliaXQgYW55IG9mIFwiQC9bXSgpXCIgaW4gdXNlci9wYXNzIHRvIGF2b2lkIHdyb25nIGRvbWFpbiBmZXRjaC5cbiAgcmUuc3JjX2F1dGggICAgPSAnKD86KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtAL1xcXFxbXFxcXF0oKV0pLikrQCk/JztcblxuICByZS5zcmNfcG9ydCA9XG5cbiAgICAnKD86Oig/OjYoPzpbMC00XVxcXFxkezN9fDUoPzpbMC00XVxcXFxkezJ9fDUoPzpbMC0yXVxcXFxkfDNbMC01XSkpKXxbMS01XT9cXFxcZHsxLDR9KSk/JztcblxuICByZS5zcmNfaG9zdF90ZXJtaW5hdG9yID1cblxuICAgICcoPz0kfCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpKD8hLXxffDpcXFxcZHxcXFxcLi18XFxcXC4oPyEkfCcgKyByZS5zcmNfWlBDYyArICcpKSc7XG5cbiAgcmUuc3JjX3BhdGggPVxuXG4gICAgJyg/OicgK1xuICAgICAgJ1svPyNdJyArXG4gICAgICAgICcoPzonICtcbiAgICAgICAgICAnKD8hJyArIHJlLnNyY19aQ2MgKyAnfCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfFsoKVtcXFxcXXt9LixcIlxcJz8hXFxcXC1dKS58JyArXG4gICAgICAgICAgJ1xcXFxbKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFxcXFxdKS4pKlxcXFxdfCcgK1xuICAgICAgICAgICdcXFxcKCg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbKV0pLikqXFxcXCl8JyArXG4gICAgICAgICAgJ1xcXFx7KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFt9XSkuKSpcXFxcfXwnICtcbiAgICAgICAgICAnXFxcXFwiKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtcIl0pLikrXFxcXFwifCcgK1xuICAgICAgICAgIFwiXFxcXCcoPzooPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbJ10pLikrXFxcXCd8XCIgK1xuICAgICAgICAgIFwiXFxcXCcoPz1cIiArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3xbLV0pLnwnICsgIC8vIGFsbG93IGBJJ21fa2luZ2AgaWYgbm8gcGFpciBmb3VuZFxuICAgICAgICAgICdcXFxcLnsyLDN9W2EtekEtWjAtOSUvXXwnICsgLy8gZ2l0aHViIGhhcyAuLi4gaW4gY29tbWl0IHJhbmdlIGxpbmtzLiBSZXN0cmljdCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gZW5nbGlzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGVyY2VudC1lbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwYXJ0cyBvZiBmaWxlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnRpbCBtb3JlIGV4YW1wbGVzIGZvdW5kLlxuICAgICAgICAgICdcXFxcLig/IScgKyByZS5zcmNfWkNjICsgJ3xbLl0pLnwnICtcbiAgICAgICAgICAob3B0cyAmJiBvcHRzWyctLS0nXSA/XG4gICAgICAgICAgICAnXFxcXC0oPyEtLSg/OlteLV18JCkpKD86LSopfCcgLy8gYC0tLWAgPT4gbG9uZyBkYXNoLCB0ZXJtaW5hdGVcbiAgICAgICAgICA6XG4gICAgICAgICAgICAnXFxcXC0rfCdcbiAgICAgICAgICApICtcbiAgICAgICAgICAnXFxcXCwoPyEnICsgcmUuc3JjX1pDYyArICcpLnwnICsgICAgICAvLyBhbGxvdyBgLCwsYCBpbiBwYXRoc1xuICAgICAgICAgICdcXFxcISg/IScgKyByZS5zcmNfWkNjICsgJ3xbIV0pLnwnICtcbiAgICAgICAgICAnXFxcXD8oPyEnICsgcmUuc3JjX1pDYyArICd8Wz9dKS4nICtcbiAgICAgICAgJykrJyArXG4gICAgICAnfFxcXFwvJyArXG4gICAgJyk/JztcblxuICByZS5zcmNfZW1haWxfbmFtZSA9XG5cbiAgICAnW1xcXFwtOzomPVxcXFwrXFxcXCQsXFxcXFwiXFxcXC5hLXpBLVowLTlfXSsnO1xuXG4gIHJlLnNyY194biA9XG5cbiAgICAneG4tLVthLXowLTlcXFxcLV17MSw1OX0nO1xuXG4gIC8vIE1vcmUgdG8gcmVhZCBhYm91dCBkb21haW4gbmFtZXNcbiAgLy8gaHR0cDovL3NlcnZlcmZhdWx0LmNvbS9xdWVzdGlvbnMvNjM4MjYwL1xuXG4gIHJlLnNyY19kb21haW5fcm9vdCA9XG5cbiAgICAvLyBBbGxvdyBsZXR0ZXJzICYgZGlnaXRzIChodHRwOi8vdGVzdDEpXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICByZS5zcmNfcHNldWRvX2xldHRlciArICd7MSw2M30nICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2RvbWFpbiA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICAgJ3wnICtcbiAgICAgIC8vIGRvbid0IGFsbG93IGAtLWAgaW4gZG9tYWluIG5hbWVzLCBiZWNhdXNlOlxuICAgICAgLy8gLSB0aGF0IGNhbiBjb25mbGljdCB3aXRoIG1hcmtkb3duICZtZGFzaDsgLyAmbmRhc2g7XG4gICAgICAvLyAtIG5vYm9keSB1c2UgdGhvc2UgYW55d2F5XG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyg/Oi0oPyEtKXwnICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKXswLDYxfScgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19ob3N0ID1cblxuICAgICcoPzonICtcbiAgICAvLyBEb24ndCBuZWVkIElQIGNoZWNrLCBiZWNhdXNlIGRpZ2l0cyBhcmUgYWxyZWFkeSBhbGxvd2VkIGluIG5vcm1hbCBkb21haW4gbmFtZXNcbiAgICAvLyAgIHNyY19pcDQgK1xuICAgIC8vICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSonICsgcmUuc3JjX2RvbWFpbi8qX3Jvb3QqLyArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5ID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY19pcDQgK1xuICAgICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSA9XG5cbiAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKSc7XG5cbiAgcmUuc3JjX2hvc3Rfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnNyY19ob3N0X3BvcnRfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTWFpbiBydWxlc1xuXG4gIC8vIFJ1ZGUgdGVzdCBmdXp6eSBsaW5rcyBieSBob3N0LCBmb3IgcXVpY2sgZGVueVxuICByZS50cGxfaG9zdF9mdXp6eV90ZXN0ID1cblxuICAgICdsb2NhbGhvc3R8d3d3XFxcXC58XFxcXC5cXFxcZHsxLDN9XFxcXC58KD86XFxcXC4oPzolVExEUyUpKD86JyArIHJlLnNyY19aUENjICsgJ3w+fCQpKSc7XG5cbiAgcmUudHBsX2VtYWlsX2Z1enp5ID1cblxuICAgICAgJyhefCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfFxcXFwofCcgKyByZS5zcmNfWkNjICsgJykoJyArIHJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX25vX2lwX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJldHVybiByZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2xpYi9yZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvaW5kZXguanMiLCIvLyBMaXN0IG9mIHZhbGlkIGh0bWwgYmxvY2tzIG5hbWVzLCBhY2NvcnRpbmcgdG8gY29tbW9ubWFyayBzcGVjXG4vLyBodHRwOi8vamdtLmdpdGh1Yi5pby9Db21tb25NYXJrL3NwZWMuaHRtbCNodG1sLWJsb2Nrc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhZGRyZXNzJyxcbiAgJ2FydGljbGUnLFxuICAnYXNpZGUnLFxuICAnYmFzZScsXG4gICdiYXNlZm9udCcsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnY2FwdGlvbicsXG4gICdjZW50ZXInLFxuICAnY29sJyxcbiAgJ2NvbGdyb3VwJyxcbiAgJ2RkJyxcbiAgJ2RldGFpbHMnLFxuICAnZGlhbG9nJyxcbiAgJ2RpcicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZmllbGRzZXQnLFxuICAnZmlnY2FwdGlvbicsXG4gICdmaWd1cmUnLFxuICAnZm9vdGVyJyxcbiAgJ2Zvcm0nLFxuICAnZnJhbWUnLFxuICAnZnJhbWVzZXQnLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnaGVhZCcsXG4gICdoZWFkZXInLFxuICAnaHInLFxuICAnaHRtbCcsXG4gICdpZnJhbWUnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ2xpbmsnLFxuICAnbWFpbicsXG4gICdtZW51JyxcbiAgJ21lbnVpdGVtJyxcbiAgJ21ldGEnLFxuICAnbmF2JyxcbiAgJ25vZnJhbWVzJyxcbiAgJ29sJyxcbiAgJ29wdGdyb3VwJyxcbiAgJ29wdGlvbicsXG4gICdwJyxcbiAgJ3BhcmFtJyxcbiAgJ3ByZScsXG4gICdzZWN0aW9uJyxcbiAgJ3NvdXJjZScsXG4gICd0aXRsZScsXG4gICdzdW1tYXJ5JyxcbiAgJ3RhYmxlJyxcbiAgJ3Rib2R5JyxcbiAgJ3RkJyxcbiAgJ3Rmb290JyxcbiAgJ3RoJyxcbiAgJ3RoZWFkJyxcbiAgJ3RpdGxlJyxcbiAgJ3RyJyxcbiAgJ3RyYWNrJyxcbiAgJ3VsJ1xuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCIvLyBKdXN0IGEgc2hvcnRjdXQgZm9yIGJ1bGsgZXhwb3J0XG4ndXNlIHN0cmljdCc7XG5cblxuZXhwb3J0cy5wYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19sYWJlbCcpO1xuZXhwb3J0cy5wYXJzZUxpbmtEZXN0aW5hdGlvbiA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19kZXN0aW5hdGlvbicpO1xuZXhwb3J0cy5wYXJzZUxpbmtUaXRsZSAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua190aXRsZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCIvLyBQYXJzZSBsaW5rIGRlc3RpbmF0aW9uXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1NwYWNlICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsIGxldmVsLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgzQyAvKiA8ICovKSB7XG4gICAgcG9zKys7XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoY29kZSA9PT0gMHgwQSAvKiBcXG4gKi8gfHwgaXNTcGFjZShjb2RlKSkgeyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICBpZiAoY29kZSA9PT0gMHgzRSAvKiA+ICovKSB7XG4gICAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgLy8gbm8gY2xvc2luZyAnPidcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gdGhpcyBzaG91bGQgYmUgLi4uIH0gZWxzZSB7IC4uLiBicmFuY2hcblxuICBsZXZlbCA9IDA7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjb2RlID09PSAweDIwKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBhc2NpaSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDB4MjAgfHwgY29kZSA9PT0gMHg3RikgeyBicmVhazsgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovKSB7XG4gICAgICBsZXZlbCsrO1xuICAgICAgaWYgKGxldmVsID4gMSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI5IC8qICkgKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICByZXN1bHQucG9zID0gcG9zO1xuICByZXN1bHQub2sgPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24uanMiLCIvLyBQYXJzZSBsaW5rIGxhYmVsXG4vL1xuLy8gdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgZmlyc3QgY2hhcmFjdGVyIChcIltcIikgYWxyZWFkeSBtYXRjaGVzO1xuLy8gcmV0dXJucyB0aGUgZW5kIG9mIHRoZSBsYWJlbFxuLy9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhcnQsIGRpc2FibGVOZXN0ZWQpIHtcbiAgdmFyIGxldmVsLCBmb3VuZCwgbWFya2VyLCBwcmV2UG9zLFxuICAgICAgbGFiZWxFbmQgPSAtMSxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcztcblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG4gIGxldmVsID0gMTtcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XG4gICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKTtcbiAgICBpZiAobWFya2VyID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2UG9zID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLm1kLmlubGluZS5za2lwVG9rZW4oc3RhdGUpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgaWYgKHByZXZQb3MgPT09IHN0YXRlLnBvcyAtIDEpIHtcbiAgICAgICAgLy8gaW5jcmVhc2UgbGV2ZWwgaWYgd2UgZmluZCB0ZXh0IGBbYCwgd2hpY2ggaXMgbm90IGEgcGFydCBvZiBhbnkgdG9rZW5cbiAgICAgICAgbGV2ZWwrKztcbiAgICAgIH0gZWxzZSBpZiAoZGlzYWJsZU5lc3RlZCkge1xuICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZm91bmQpIHtcbiAgICBsYWJlbEVuZCA9IHN0YXRlLnBvcztcbiAgfVxuXG4gIC8vIHJlc3RvcmUgb2xkIHN0YXRlXG4gIHN0YXRlLnBvcyA9IG9sZFBvcztcblxuICByZXR1cm4gbGFiZWxFbmQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcyIsIi8vIFBhcnNlIGxpbmsgdGl0bGVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KSB7XG4gIHZhciBjb2RlLFxuICAgICAgbWFya2VyLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgbWFya2VyID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDIyIC8qIFwiICovICYmIG1hcmtlciAhPT0gMHgyNyAvKiAnICovICYmIG1hcmtlciAhPT0gMHgyOCAvKiAoICovKSB7IHJldHVybiByZXN1bHQ7IH1cblxuICBwb3MrKztcblxuICAvLyBpZiBvcGVuaW5nIG1hcmtlciBpcyBcIihcIiwgc3dpdGNoIGl0IHRvIGNsb3NpbmcgbWFya2VyIFwiKVwiXG4gIGlmIChtYXJrZXIgPT09IDB4MjgpIHsgbWFya2VyID0gMHgyOTsgfVxuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCIvLyBNYWluIHBhcnNlciBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG52YXIgaGVscGVycyAgICAgID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcbnZhciBtZHVybCAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xudmFyIHB1bnljb2RlICAgICA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGNvbmZpZyA9IHtcbiAgJ2RlZmF1bHQnOiByZXF1aXJlKCcuL3ByZXNldHMvZGVmYXVsdCcpLFxuICB6ZXJvOiByZXF1aXJlKCcuL3ByZXNldHMvemVybycpLFxuICBjb21tb25tYXJrOiByZXF1aXJlKCcuL3ByZXNldHMvY29tbW9ubWFyaycpXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vIFRoaXMgdmFsaWRhdG9yIGNhbiBwcm9oaWJpdCBtb3JlIHRoYW4gcmVhbGx5IG5lZWRlZCB0byBwcmV2ZW50IFhTUy4gSXQncyBhXG4vLyB0cmFkZW9mZiB0byBrZWVwIGNvZGUgc2ltcGxlIGFuZCB0byBiZSBzZWN1cmUgYnkgZGVmYXVsdC5cbi8vXG4vLyBJZiB5b3UgbmVlZCBkaWZmZXJlbnQgc2V0dXAgLSBvdmVycmlkZSB2YWxpZGF0b3IgbWV0aG9kIGFzIHlvdSB3aXNoLiBPclxuLy8gcmVwbGFjZSBpdCB3aXRoIGR1bW15IGZ1bmN0aW9uIGFuZCB1c2UgZXh0ZXJuYWwgc2FuaXRpemVyLlxuLy9cblxudmFyIEJBRF9QUk9UT19SRSA9IC9eKHZic2NyaXB0fGphdmFzY3JpcHR8ZmlsZXxkYXRhKTovO1xudmFyIEdPT0RfREFUQV9SRSA9IC9eZGF0YTppbWFnZVxcLyhnaWZ8cG5nfGpwZWd8d2VicCk7LztcblxuZnVuY3Rpb24gdmFsaWRhdGVMaW5rKHVybCkge1xuICAvLyB1cmwgc2hvdWxkIGJlIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludCwgYW5kIGV4aXN0aW5nIGVudGl0aWVzIGFyZSBkZWNvZGVkXG4gIHZhciBzdHIgPSB1cmwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIEJBRF9QUk9UT19SRS50ZXN0KHN0cikgPyAoR09PRF9EQVRBX1JFLnRlc3Qoc3RyKSA/IHRydWUgOiBmYWxzZSkgOiB0cnVlO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBSRUNPREVfSE9TVE5BTUVfRk9SID0gWyAnaHR0cDonLCAnaHR0cHM6JywgJ21haWx0bzonIF07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmsodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvVW5pY29kZShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBNYXJrZG93bkl0XG4gKlxuICogTWFpbiBwYXJzZXIvcmVuZGVyZXIgY2xhc3MuXG4gKlxuICogIyMjIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XG4gKiB2YXIgTWFya2Rvd25JdCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JyksXG4gKiAgICAgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gbm9kZS5qcywgdGhlIHNhbWUsIGJ1dCB3aXRoIHN1Z2FyOlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxuICogLy8gTm90ZSwgdGhlcmUgYXJlIG5vIGRhc2guXG4gKiB2YXIgbWQgPSB3aW5kb3cubWFya2Rvd25pdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKiBgYGBcbiAqXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSgnX19tYXJrZG93bi1pdF9fIHJ1bGV6eiEnKTtcbiAqIGBgYFxuICoqL1xuXG4vKipcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcbiAqIC0gcHJlc2V0TmFtZSAoU3RyaW5nKTogb3B0aW9uYWwsIGBjb21tb25tYXJrYCAvIGB6ZXJvYFxuICogLSBvcHRpb25zIChPYmplY3QpXG4gKlxuICogQ3JlYXRlcyBwYXJzZXIgaW5zdGFuc2Ugd2l0aCBnaXZlbiBjb25maWcuIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YC5cbiAqXG4gKiAjIyMjIyBwcmVzZXROYW1lXG4gKlxuICogTWFya2Rvd25JdCBwcm92aWRlcyBuYW1lZCBwcmVzZXRzIGFzIGEgY29udmVuaWVuY2UgdG8gcXVpY2tseVxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cbiAqXG4gKiAtIFtcImNvbW1vbm1hcmtcIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQuanMpIC1cbiAqICAgc2ltaWxhciB0byBHRk0sIHVzZWQgd2hlbiBubyBwcmVzZXQgbmFtZSBnaXZlbi4gRW5hYmxlcyBhbGwgYXZhaWxhYmxlIHJ1bGVzLFxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXG4gKiAtIFtcInplcm9cIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL3plcm8uanMpIC1cbiAqICAgYWxsIHJ1bGVzIGRpc2FibGVkLiBVc2VmdWwgdG8gcXVpY2tseSBzZXR1cCB5b3VyIGNvbmZpZyB2aWEgYC5lbmFibGUoKWAuXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiAjIyMjIyBvcHRpb25zOlxuICpcbiAqIC0gX19odG1sX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlLiBCZSBjYXJlZnVsIVxuICogICBUaGF0J3Mgbm90IHNhZmUhIFlvdSBtYXkgbmVlZCBleHRlcm5hbCBzYW5pdGl6ZXIgdG8gcHJvdGVjdCBvdXRwdXQgZnJvbSBYU1MuXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxuICogLSBfX3hodG1sT3V0X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGFkZCAnLycgd2hlbiBjbG9zaW5nIHNpbmdsZSB0YWdzXG4gKiAgIChgPGJyIC8+YCkuIFRoaXMgaXMgbmVlZGVkIG9ubHkgZm9yIGZ1bGwgQ29tbW9uTWFyayBjb21wYXRpYmlsaXR5LiBJbiByZWFsXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXG4gKiAtIF9fYnJlYWtzX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGNvbnZlcnQgYFxcbmAgaW4gcGFyYWdyYXBocyBpbnRvIGA8YnI+YC5cbiAqIC0gX19sYW5nUHJlZml4X18gLSBgbGFuZ3VhZ2UtYC4gQ1NTIGxhbmd1YWdlIGNsYXNzIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrcy5cbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxuICogLSBfX2xpbmtpZnlfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dCB0byBsaW5rcy5cbiAqIC0gX190eXBvZ3JhcGhlcl9fICAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIFtzb21lIGxhbmd1YWdlLW5ldXRyYWxcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcbiAgICAgIHByZXNldE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlcklubGluZV1dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW0NvcmVdXSBjaGFpbiBleGVjdXRvci4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tSZW5kZXJlcl1dLiBVc2UgaXQgdG8gbW9kaWZ5IG91dHB1dCBsb29rLiBPciB0byBhZGQgcmVuZGVyaW5nXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBmdW5jdGlvbiBteVRva2VuKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNlbGYpIHtcbiAgICogICAvLy4uLlxuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH07XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxuICAgKiovXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNsaW5raWZ5IC0+IExpbmtpZnlJdFxuICAgKlxuICAgKiBbbGlua2lmeS1pdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQpIGluc3RhbmNlLlxuICAgKiBVc2VkIGJ5IFtsaW5raWZ5XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcylcbiAgICogcnVsZS5cbiAgICoqL1xuICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdmFsaWRhdGVMaW5rKHVybCkgLT4gQm9vbGVhblxuICAgKlxuICAgKiBMaW5rIHZhbGlkYXRpb24gZnVuY3Rpb24uIENvbW1vbk1hcmsgYWxsb3dzIHRvbyBtdWNoIGluIGxpbmtzLiBCeSBkZWZhdWx0XG4gICAqIHdlIGRpc2FibGUgYGphdmFzY3JpcHQ6YCwgYHZic2NyaXB0OmAsIGBmaWxlOmAgc2NoZW1hcywgYW5kIGFsbW9zdCBhbGwgYGRhdGE6Li4uYCBzY2hlbWFzXG4gICAqIGV4Y2VwdCBzb21lIGVtYmVkZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW91cjpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gICAqIG1kLnZhbGlkYXRlTGluayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICogYGBgXG4gICAqKi9cbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRlY29kZSBsaW5rIHVybCB0byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdGBcbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG5cblxuICAvLyBFeHBvc2UgdXRpbHMgJiBoZWxwZXJzIGZvciBlYXN5IGFjY2VzIGZyb20gcGx1Z2luc1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3V0aWxzIC0+IHV0aWxzXG4gICAqXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvY29tbW9uL3V0aWxzLmpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHM7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXG4gICAqXG4gICAqIExpbmsgY29tcG9uZW50cyBwYXJzZXIgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXG4gICAqKi9cbiAgdGhpcy5oZWxwZXJzID0gdXRpbHMuYXNzaWduKHt9LCBoZWxwZXJzKTtcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKTsgfVxufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlLCBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5jb25maWd1cmUocHJlc2V0cylcbiAqXG4gKiBCYXRjaCBsb2FkIG9mIGFsbCBvcHRpb25zIGFuZCBjb21wZW5lbnQgc2V0dGluZ3MuIFRoaXMgaXMgaW50ZXJuYWwgbWV0aG9kLFxuICogYW5kIHlvdSBwcm9iYWJseSB3aWxsIG5vdCBuZWVkIGl0LiBCdXQgaWYgeW91IHdpdGggLSBzZWUgYXZhaWxhYmxlIHByZXNldHNcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgcHJlc2V0cyBpbnN0ZWFkIG9mIGRpcmVjdCBjb25maWcgbG9hZHMuIFRoYXRcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocHJlc2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHByZXNldHMpKSB7XG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgcHJlc2V0cyA9IGNvbmZpZ1twcmVzZXROYW1lXTtcbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJyk7IH1cbiAgfVxuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0LCBjYW5cXCd0IGJlIGVtcHR5Jyk7IH1cblxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBsaXN0IG9yIHJ1bGVzLiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhcHByb3ByaWF0ZSBjb21wb25lbnRzLFxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxuICogbm90IHNldCAtIHRocm93cyBleGNlcHRpb24uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLmVuYWJsZShbJ3N1YicsICdzdXAnXSlcbiAqICAgICAgICAgICAgIC5kaXNhYmxlKCdzbWFydHF1b3RlcycpO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC51c2UocGx1Z2luLCBwYXJhbXMpXG4gKlxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXG4gKiBJdCdzIGp1c3QgYSBzdWdhciB0byBjYWxsIGBwbHVnaW4obWQsIHBhcmFtcylgIHdpdGggY3VycmluZy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAudXNlKGl0ZXJhdG9yLCAnZm9vX3JlcGxhY2UnLCAndGV4dCcsIGZ1bmN0aW9uICh0b2tlbnMsIGlkeCkge1xuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICogICAgICAgICAgICAgfSk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4gLyosIHBhcmFtcywgLi4uICovKSB7XG4gIHZhciBhcmdzID0gWyB0aGlzIF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFBhcnNlIGlucHV0IHN0cmluZyBhbmQgcmV0dXJucyBsaXN0IG9mIGJsb2NrIHRva2VucyAoc3BlY2lhbCB0b2tlbiB0eXBlXG4gKiBcImlubGluZVwiIHdpbGwgY29udGFpbiBsaXN0IG9mIGlubGluZSB0b2tlbnMpLiBZb3Ugc2hvdWxkIG5vdCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBkaXJlY3RseSwgdW50aWwgeW91IHdyaXRlIGN1c3RvbSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIHRvIHByb2R1Y2VcbiAqIEFTVCkuXG4gKlxuICogYGVudmAgaXMgdXNlZCB0byBwYXNzIGRhdGEgYmV0d2VlbiBcImRpc3RyaWJ1dGVkXCIgcnVsZXMgYW5kIHJldHVybiBhZGRpdGlvbmFsXG4gKiBtZXRhZGF0YSBsaWtlIHJlZmVyZW5jZSBpbmZvLCBuZWVkZWQgZm9yIHRoZSByZW5kZXJlci4gSXQgYWxzbyBjYW4gYmUgdXNlZCB0b1xuICogaW5qZWN0IGRhdGEgaW4gc3BlY2lmaWMgY2FzZXMuIFVzdWFsbHksIHlvdSB3aWxsIGJlIG9rIHRvIHBhc3MgYHt9YCxcbiAqIGFuZCB0aGVuIHBhc3MgdXBkYXRlZCBvYmplY3QgdG8gcmVuZGVyZXIuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nJyk7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcihzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBSZW5kZXIgbWFya2Rvd24gc3RyaW5nIGludG8gaHRtbC4gSXQgZG9lcyBhbGwgbWFnaWMgZm9yIHlvdSA6KS5cbiAqXG4gKiBgZW52YCBjYW4gYmUgdXNlZCB0byBpbmplY3QgYWRkaXRpb25hbCBtZXRhZGF0YSAoYHt9YCBieSBkZWZhdWx0KS5cbiAqIEJ1dCB5b3Ugd2lsbCBub3QgbmVlZCBpdCB3aXRoIGhpZ2ggcHJvYmFiaWxpdHkuIFNlZSBhbHNvIGNvbW1lbnRcbiAqIGluIFtbTWFya2Rvd25JdC5wYXJzZV1dLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlSW5saW5lKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LnBhcnNlXV0gYnV0IHNraXAgYWxsIGJsb2NrIHJ1bGVzLiBJdCByZXR1cm5zIHRoZVxuICogYmxvY2sgdG9rZW5zIGxpc3Qgd2l0aCB0aGUgc2luZ2xlIGBpbmxpbmVgIGVsZW1lbnQsIGNvbnRhaW5pbmcgcGFyc2VkIGlubGluZVxuICogdG9rZW5zIGluIGBjaGlsZHJlbmAgcHJvcGVydHkuIEFsc28gdXBkYXRlcyBgZW52YCBvYmplY3QuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICBzdGF0ZS5pbmxpbmVNb2RlID0gdHJ1ZTtcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXJJbmxpbmUoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogU2ltaWxhciB0byBbW01hcmtkb3duSXQucmVuZGVyXV0gYnV0IGZvciBzaW5nbGUgcGFyYWdyYXBoIGNvbnRlbnQuIFJlc3VsdFxuICogd2lsbCBOT1QgYmUgd3JhcHBlZCBpbnRvIGA8cD5gIHRhZ3MuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlSW5saW5lKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaW5kZXguanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIFBhcnNlckJsb2NrXG4gKlxuICogQmxvY2stbGV2ZWwgdG9rZW5pemVyLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgLy8gRmlyc3QgMiBwYXJhbXMgLSBydWxlIG5hbWUgJiBzb3VyY2UuIFNlY29uZGFyeSBhcnJheSAtIGxpc3Qgb2YgcnVsZXMsXG4gIC8vIHdoaWNoIGNhbiBiZSB0ZXJtaW5hdGVkIGJ5IHRoaXMgb25lLlxuICBbICd0YWJsZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay90YWJsZScpLCAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnIF0gXSxcbiAgWyAnY29kZScsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svY29kZScpIF0sXG4gIFsgJ2ZlbmNlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2ZlbmNlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnYmxvY2txdW90ZScsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svYmxvY2txdW90ZScpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2xpc3QnIF0gXSxcbiAgWyAnaHInLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHInKSwgICAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdsaXN0JywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9saXN0JyksICAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdyZWZlcmVuY2UnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9yZWZlcmVuY2UnKSBdLFxuICBbICdoZWFkaW5nJywgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9oZWFkaW5nJyksICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdsaGVhZGluZycsICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9saGVhZGluZycpIF0sXG4gIFsgJ2h0bWxfYmxvY2snLCByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2snKSwgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ3BhcmFncmFwaCcsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3BhcmFncmFwaCcpIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgUGFyc2VyQmxvY2soKVxuICoqL1xuZnVuY3Rpb24gUGFyc2VyQmxvY2soKSB7XG4gIC8qKlxuICAgKiBQYXJzZXJCbG9jayNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBibG9jayBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0sIHsgYWx0OiAoX3J1bGVzW2ldWzJdIHx8IFtdKS5zbGljZSgpIH0pO1xuICB9XG59XG5cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlckJsb2NrLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gIHZhciBvaywgaSxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBsaW5lID0gc3RhcnRMaW5lLFxuICAgICAgaGFzRW1wdHlMaW5lcyA9IGZhbHNlLFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcblxuICB3aGlsZSAobGluZSA8IGVuZExpbmUpIHtcbiAgICBzdGF0ZS5saW5lID0gbGluZSA9IHN0YXRlLnNraXBFbXB0eUxpbmVzKGxpbmUpO1xuICAgIGlmIChsaW5lID49IGVuZExpbmUpIHsgYnJlYWs7IH1cblxuICAgIC8vIFRlcm1pbmF0aW9uIGNvbmRpdGlvbiBmb3IgbmVzdGVkIGNhbGxzLlxuICAgIC8vIE5lc3RlZCBjYWxscyBjdXJyZW50bHkgdXNlZCBmb3IgYmxvY2txdW90ZXMgJiBsaXN0c1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIC8vIElmIG5lc3RpbmcgbGV2ZWwgZXhjZWVkZWQgLSBza2lwIHRhaWwgdG8gdGhlIGVuZC4gVGhhdCdzIG5vdCBvcmRpbmFyeVxuICAgIC8vIHNpdHVhdGlvbiBhbmQgd2Ugc2hvdWxkIG5vdCBjYXJlIGFib3V0IGNvbnRlbnQuXG4gICAgaWYgKHN0YXRlLmxldmVsID49IG1heE5lc3RpbmcpIHtcbiAgICAgIHN0YXRlLmxpbmUgPSBlbmRMaW5lO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCBydWxlIHNob3VsZDpcbiAgICAvL1xuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5saW5lYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBsaW5lLCBlbmRMaW5lLCBmYWxzZSk7XG4gICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBzZXQgc3RhdGUudGlnaHQgaWZmIHdlIGhhZCBhbiBlbXB0eSBsaW5lIGJlZm9yZSBjdXJyZW50IHRhZ1xuICAgIC8vIGkuZS4gbGF0ZXN0IGVtcHR5IGxpbmUgc2hvdWxkIG5vdCBjb3VudFxuICAgIHN0YXRlLnRpZ2h0ID0gIWhhc0VtcHR5TGluZXM7XG5cbiAgICAvLyBwYXJhZ3JhcGggbWlnaHQgXCJlYXRcIiBvbmUgbmV3bGluZSBhZnRlciBpdCBpbiBuZXN0ZWQgbGlzdHNcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xuXG4gICAgaWYgKGxpbmUgPCBlbmRMaW5lICYmIHN0YXRlLmlzRW1wdHkobGluZSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgbGluZSsrO1xuICAgICAgc3RhdGUubGluZSA9IGxpbmU7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VyQmxvY2sucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggYmxvY2sgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlckJsb2NrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzcmMpIHsgcmV0dXJuOyB9XG5cbiAgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSwgc3RhdGUubGluZSwgc3RhdGUubGluZU1heCk7XG59O1xuXG5cblBhcnNlckJsb2NrLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svc3RhdGVfYmxvY2snKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckJsb2NrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9ibG9jay5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgQ29yZVxuICpcbiAqIFRvcC1sZXZlbCBydWxlcyBleGVjdXRvci4gR2x1ZXMgYmxvY2svaW5saW5lIHBhcnNlcnMgYW5kIGRvZXMgaW50ZXJtZWRpYXRlXG4gKiB0cmFuc2Zvcm1hdGlvbnMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICBbICdub3JtYWxpemUnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ub3JtYWxpemUnKSAgICAgIF0sXG4gIFsgJ2Jsb2NrJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2Jsb2NrJykgICAgICAgICAgXSxcbiAgWyAnaW5saW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvaW5saW5lJykgICAgICAgICBdLFxuICBbICdsaW5raWZ5JywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9saW5raWZ5JykgICAgICAgIF0sXG4gIFsgJ3JlcGxhY2VtZW50cycsICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cycpICAgXSxcbiAgWyAnc21hcnRxdW90ZXMnLCAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMnKSAgICBdXG5dO1xuXG5cbi8qKlxuICogbmV3IENvcmUoKVxuICoqL1xuZnVuY3Rpb24gQ29yZSgpIHtcbiAgLyoqXG4gICAqIENvcmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgY29yZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG59XG5cblxuLyoqXG4gKiBDb3JlLnByb2Nlc3Moc3RhdGUpXG4gKlxuICogRXhlY3V0ZXMgY29yZSBjaGFpbiBydWxlcy5cbiAqKi9cbkNvcmUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIGksIGwsIHJ1bGVzO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuQ29yZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc3RhdGVfY29yZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VySW5saW5lXG4gKlxuICogVG9rZW5pemVzIHBhcmFncmFwaCBjb250ZW50LlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFBhcnNlciBydWxlc1xuXG52YXIgX3J1bGVzID0gW1xuICBbICd0ZXh0JywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0JykgXSxcbiAgWyAnbmV3bGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbmV3bGluZScpIF0sXG4gIFsgJ2VzY2FwZScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VzY2FwZScpIF0sXG4gIFsgJ2JhY2t0aWNrcycsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhY2t0aWNrcycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS50b2tlbml6ZSBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnRva2VuaXplIF0sXG4gIFsgJ2xpbmsnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2xpbmsnKSBdLFxuICBbICdpbWFnZScsICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9pbWFnZScpIF0sXG4gIFsgJ2F1dG9saW5rJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2F1dG9saW5rJykgXSxcbiAgWyAnaHRtbF9pbmxpbmUnLCAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUnKSBdLFxuICBbICdlbnRpdHknLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbnRpdHknKSBdXG5dO1xuXG52YXIgX3J1bGVzMiA9IFtcbiAgWyAnYmFsYW5jZV9wYWlycycsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS5wb3N0UHJvY2VzcyBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ3RleHRfY29sbGFwc2UnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlcklubGluZSgpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJJbmxpbmUoKSB7XG4gIHZhciBpO1xuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgaW5saW5lIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gU2Vjb25kIHJ1bGVyIHVzZWQgZm9yIHBvc3QtcHJvY2Vzc2luZ1xuICAgKiAoZS5nLiBpbiBlbXBoYXNpcy1saWtlIHJ1bGVzKS5cbiAgICoqL1xuICB0aGlzLnJ1bGVyMiA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlcjIucHVzaChfcnVsZXMyW2ldWzBdLCBfcnVsZXMyW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8vIFNraXAgc2luZ2xlIHRva2VuIGJ5IHJ1bm5pbmcgYWxsIHJ1bGVzIGluIHZhbGlkYXRpb24gbW9kZTtcbi8vIHJldHVybnMgYHRydWVgIGlmIGFueSBydWxlIHJlcG9ydGVkIHN1Y2Nlc3Ncbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnNraXBUb2tlbiA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgb2ssIGksIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nLFxuICAgICAgY2FjaGUgPSBzdGF0ZS5jYWNoZTtcblxuXG4gIGlmICh0eXBlb2YgY2FjaGVbcG9zXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5wb3MgPSBjYWNoZVtwb3NdO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIEluY3JlbWVudCBzdGF0ZS5sZXZlbCBhbmQgZGVjcmVtZW50IGl0IGxhdGVyIHRvIGxpbWl0IHJlY3Vyc2lvbi5cbiAgICAgIC8vIEl0J3MgaGFybWxlc3MgdG8gZG8gaGVyZSwgYmVjYXVzZSBubyB0b2tlbnMgYXJlIGNyZWF0ZWQuIEJ1dCBpZGVhbGx5LFxuICAgICAgLy8gd2UnZCBuZWVkIGEgc2VwYXJhdGUgcHJpdmF0ZSBzdGF0ZSB2YXJpYWJsZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgLy9cbiAgICAgIHN0YXRlLmxldmVsKys7XG4gICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCB0cnVlKTtcbiAgICAgIHN0YXRlLmxldmVsLS07XG5cbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUb28gbXVjaCBuZXN0aW5nLCBqdXN0IHNraXAgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGFyYWdyYXBoLlxuICAgIC8vXG4gICAgLy8gTk9URTogdGhpcyB3aWxsIGNhdXNlIGxpbmtzIHRvIGJlaGF2ZSBpbmNvcnJlY3RseSBpbiB0aGUgZm9sbG93aW5nIGNhc2UsXG4gICAgLy8gICAgICAgd2hlbiBhbiBhbW91bnQgb2YgYFtgIGlzIGV4YWN0bHkgZXF1YWwgdG8gYG1heE5lc3RpbmcgKyAxYDpcbiAgICAvL1xuICAgIC8vICAgICAgIFtbW1tbW1tbW1tbW1tbW1tbW1tbW2Zvb10oKVxuICAgIC8vXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCB3aGVuIENNIHN0YW5kYXJkIHdpbGwgYWxsb3cgbmVzdGVkIGxpbmtzXG4gICAgLy8gICAgICAgKHdlIGNhbiByZXBsYWNlIGl0IGJ5IHByZXZlbnRpbmcgbGlua3MgZnJvbSBiZWluZyBwYXJzZWQgaW5cbiAgICAvLyAgICAgICB2YWxpZGF0aW9uIG1vZGUpXG4gICAgLy9cbiAgICBzdGF0ZS5wb3MgPSBzdGF0ZS5wb3NNYXg7XG4gIH1cblxuICBpZiAoIW9rKSB7IHN0YXRlLnBvcysrOyB9XG4gIGNhY2hlW3Bvc10gPSBzdGF0ZS5wb3M7XG59O1xuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBlbmQgPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBlbmQpIHtcbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnBvc2BcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvaykge1xuICAgICAgaWYgKHN0YXRlLnBvcyA+PSBlbmQpIHsgYnJlYWs7IH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3N0YXRlLnBvcysrXTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgc3RhdGUucHVzaFBlbmRpbmcoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlcklubGluZS5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBpbmxpbmUgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlcklubGluZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIGksIHJ1bGVzLCBsZW47XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLlN0YXRlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKTtcblxuICB0aGlzLnRva2VuaXplKHN0YXRlKTtcblxuICBydWxlcyA9IHRoaXMucnVsZXIyLmdldFJ1bGVzKCcnKTtcbiAgbGVuID0gcnVsZXMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJJbmxpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qcyIsIi8vIENvbW1vbm1hcmsgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgdHJ1ZSwgICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgdHJ1ZSwgICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYmxvY2txdW90ZScsXG4gICAgICAgICdjb2RlJyxcbiAgICAgICAgJ2ZlbmNlJyxcbiAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAnaHInLFxuICAgICAgICAnaHRtbF9ibG9jaycsXG4gICAgICAgICdsaGVhZGluZycsXG4gICAgICAgICdsaXN0JyxcbiAgICAgICAgJ3JlZmVyZW5jZScsXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2F1dG9saW5rJyxcbiAgICAgICAgJ2JhY2t0aWNrcycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICdlbnRpdHknLFxuICAgICAgICAnZXNjYXBlJyxcbiAgICAgICAgJ2h0bWxfaW5saW5lJyxcbiAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgJ2xpbmsnLFxuICAgICAgICAnbmV3bGluZScsXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMiLCIvLyBtYXJrZG93bi1pdCBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMTAwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge30sXG4gICAgYmxvY2s6IHt9LFxuICAgIGlubGluZToge31cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCIvLyBcIlplcm9cIiBwcmVzZXQsIHdpdGggbm90aGluZyBlbmFibGVkLiBVc2VmdWwgZm9yIG1hbnVhbCBjb25maWd1cmluZyBvZiBzaW1wbGVcbi8vIG1vZGVzLiBGb3IgZXhhbXBsZSwgdG8gcGFyc2UgYm9sZC9pdGFsaWMgb25seS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvemVyby5qcyIsIi8qKlxuICogY2xhc3MgUmVuZGVyZXJcbiAqXG4gKiBHZW5lcmF0ZXMgSFRNTCBmcm9tIHBhcnNlZCB0b2tlbiBzdHJlYW0uIEVhY2ggaW5zdGFuY2UgaGFzIGluZGVwZW5kZW50XG4gKiBjb3B5IG9mIHJ1bGVzLiBUaG9zZSBjYW4gYmUgcmV3cml0dGVuIHdpdGggZWFzZS4gQWxzbywgeW91IGNhbiBhZGQgbmV3XG4gKiBydWxlcyBpZiB5b3UgY3JlYXRlIHBsdWdpbiBhbmQgYWRkcyBuZXcgdG9rZW4gdHlwZXMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGFzc2lnbiAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuYXNzaWduO1xudmFyIHVuZXNjYXBlQWxsICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG52YXIgZXNjYXBlSHRtbCAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5lc2NhcGVIdG1sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBkZWZhdWx0X3J1bGVzID0ge307XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgcmV0dXJuICAnPGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxwcmUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+PGNvZGU+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmZlbmNlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XSxcbiAgICAgIGluZm8gPSB0b2tlbi5pbmZvID8gdW5lc2NhcGVBbGwodG9rZW4uaW5mbykudHJpbSgpIDogJycsXG4gICAgICBsYW5nTmFtZSA9ICcnLFxuICAgICAgaGlnaGxpZ2h0ZWQsIGksIHRtcEF0dHJzLCB0bXBUb2tlbjtcblxuICBpZiAoaW5mbykge1xuICAgIGxhbmdOYW1lID0gaW5mby5zcGxpdCgvXFxzKy9nKVswXTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIGhpZ2hsaWdodGVkID0gb3B0aW9ucy5oaWdobGlnaHQodG9rZW4uY29udGVudCwgbGFuZ05hbWUpIHx8IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9XG5cbiAgaWYgKGhpZ2hsaWdodGVkLmluZGV4T2YoJzxwcmUnKSA9PT0gMCkge1xuICAgIHJldHVybiBoaWdobGlnaHRlZCArICdcXG4nO1xuICB9XG5cbiAgLy8gSWYgbGFuZ3VhZ2UgZXhpc3RzLCBpbmplY3QgY2xhc3MgZ2VudGx5LCB3aXRob3V0IG11ZG9meWluZyBvcmlnaW5hbCB0b2tlbi5cbiAgLy8gTWF5IGJlLCBvbmUgZGF5IHdlIHdpbGwgYWRkIC5jbG9uZSgpIGZvciB0b2tlbiBhbmQgc2ltcGxpZnkgdGhpcyBwYXJ0LCBidXRcbiAgLy8gbm93IHdlIHByZWZlciB0byBrZWVwIHRoaW5ncyBsb2NhbC5cbiAgaWYgKGluZm8pIHtcbiAgICBpICAgICAgICA9IHRva2VuLmF0dHJJbmRleCgnY2xhc3MnKTtcbiAgICB0bXBBdHRycyA9IHRva2VuLmF0dHJzID8gdG9rZW4uYXR0cnMuc2xpY2UoKSA6IFtdO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0bXBBdHRycy5wdXNoKFsgJ2NsYXNzJywgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWUgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcEF0dHJzW2ldWzFdICs9ICcgJyArIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lO1xuICAgIH1cblxuICAgIC8vIEZha2UgdG9rZW4ganVzdCB0byByZW5kZXIgYXR0cmlidXRlc1xuICAgIHRtcFRva2VuID0ge1xuICAgICAgYXR0cnM6IHRtcEF0dHJzXG4gICAgfTtcblxuICAgIHJldHVybiAgJzxwcmU+PGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRtcFRva2VuKSArICc+J1xuICAgICAgICAgICsgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgfVxuXG5cbiAgcmV0dXJuICAnPHByZT48Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz4nXG4gICAgICAgICsgaGlnaGxpZ2h0ZWRcbiAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaW1hZ2UgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIC8vIFwiYWx0XCIgYXR0ciBNVVNUIGJlIHNldCwgZXZlbiBpZiBlbXB0eS4gQmVjYXVzZSBpdCdzIG1hbmRhdG9yeSBhbmRcbiAgLy8gc2hvdWxkIGJlIHBsYWNlZCBvbiBwcm9wZXIgcG9zaXRpb24gZm9yIHRlc3RzLlxuICAvL1xuICAvLyBSZXBsYWNlIGNvbnRlbnQgd2l0aCBhY3R1YWwgdmFsdWVcblxuICB0b2tlbi5hdHRyc1t0b2tlbi5hdHRySW5kZXgoJ2FsdCcpXVsxXSA9XG4gICAgc2xmLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbi5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcblxuICByZXR1cm4gc2xmLnJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKTtcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5oYXJkYnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nO1xufTtcbmRlZmF1bHRfcnVsZXMuc29mdGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMuYnJlYWtzID8gKG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJykgOiAnXFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy50ZXh0ID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCk7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaHRtbF9ibG9jayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xufTtcbmRlZmF1bHRfcnVsZXMuaHRtbF9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5cblxuLyoqXG4gKiBuZXcgUmVuZGVyZXIoKVxuICpcbiAqIENyZWF0ZXMgbmV3IFtbUmVuZGVyZXJdXSBpbnN0YW5jZSBhbmQgZmlsbCBbW1JlbmRlcmVyI3J1bGVzXV0gd2l0aCBkZWZhdWx0cy5cbiAqKi9cbmZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuXG4gIC8qKlxuICAgKiBSZW5kZXJlciNydWxlcyAtPiBPYmplY3RcbiAgICpcbiAgICogQ29udGFpbnMgcmVuZGVyIHJ1bGVzIGZvciB0b2tlbnMuIENhbiBiZSB1cGRhdGVkIGFuZCBleHRlbmRlZC5cbiAgICpcbiAgICogIyMjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICpcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX29wZW4gID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzxiPic7IH07XG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19jbG9zZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8L2I+JzsgfTtcbiAgICpcbiAgICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSguLi4pO1xuICAgKiBgYGBcbiAgICpcbiAgICogRWFjaCBydWxlIGlzIGNhbGxlZCBhcyBpbmRlcGVuZGVkIHN0YXRpYyBmdW5jdGlvbiB3aXRoIGZpeGVkIHNpZ25hdHVyZTpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBmdW5jdGlvbiBteV90b2tlbl9yZW5kZXIodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgcmVuZGVyZXIpIHtcbiAgICogICAvLyAuLi5cbiAgICogICByZXR1cm4gcmVuZGVyZWRIVE1MO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBTZWUgW3NvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3JlbmRlcmVyLmpzKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVzID0gYXNzaWduKHt9LCBkZWZhdWx0X3J1bGVzKTtcbn1cblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlckF0dHJzKHRva2VuKSAtPiBTdHJpbmdcbiAqXG4gKiBSZW5kZXIgdG9rZW4gYXR0cmlidXRlcyB0byBzdHJpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQXR0cnMgPSBmdW5jdGlvbiByZW5kZXJBdHRycyh0b2tlbikge1xuICB2YXIgaSwgbCwgcmVzdWx0O1xuXG4gIGlmICghdG9rZW4uYXR0cnMpIHsgcmV0dXJuICcnOyB9XG5cbiAgcmVzdWx0ID0gJyc7XG5cbiAgZm9yIChpID0gMCwgbCA9IHRva2VuLmF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJlc3VsdCArPSAnICcgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzBdKSArICc9XCInICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVsxXSkgKyAnXCInO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9mIHRva2Vuc1xuICogLSBpZHggKE51bWJlZCk6IHRva2VuIGluZGV4IHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKlxuICogRGVmYXVsdCB0b2tlbiByZW5kZXJlci4gQ2FuIGJlIG92ZXJyaWRlbiBieSBjdXN0b20gZnVuY3Rpb25cbiAqIGluIFtbUmVuZGVyZXIjcnVsZXNdXS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbiA9IGZ1bmN0aW9uIHJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSB7XG4gIHZhciBuZXh0VG9rZW4sXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIG5lZWRMZiA9IGZhbHNlLFxuICAgICAgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBUaWdodCBsaXN0IHBhcmFncmFwaHNcbiAgaWYgKHRva2VuLmhpZGRlbikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEluc2VydCBhIG5ld2xpbmUgYmV0d2VlbiBoaWRkZW4gcGFyYWdyYXBoIGFuZCBzdWJzZXF1ZW50IG9wZW5pbmdcbiAgLy8gYmxvY2stbGV2ZWwgdGFnLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgaGVyZSB3ZSBzaG91bGQgaW5zZXJ0IGEgbmV3bGluZSBiZWZvcmUgYmxvY2txdW90ZTpcbiAgLy8gIC0gYVxuICAvLyAgICA+XG4gIC8vXG4gIGlmICh0b2tlbi5ibG9jayAmJiB0b2tlbi5uZXN0aW5nICE9PSAtMSAmJiBpZHggJiYgdG9rZW5zW2lkeCAtIDFdLmhpZGRlbikge1xuICAgIHJlc3VsdCArPSAnXFxuJztcbiAgfVxuXG4gIC8vIEFkZCB0b2tlbiBuYW1lLCBlLmcuIGA8aW1nYFxuICByZXN1bHQgKz0gKHRva2VuLm5lc3RpbmcgPT09IC0xID8gJzwvJyA6ICc8JykgKyB0b2tlbi50YWc7XG5cbiAgLy8gRW5jb2RlIGF0dHJpYnV0ZXMsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCJgXG4gIHJlc3VsdCArPSB0aGlzLnJlbmRlckF0dHJzKHRva2VuKTtcblxuICAvLyBBZGQgYSBzbGFzaCBmb3Igc2VsZi1jbG9zaW5nIHRhZ3MsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCIgL2BcbiAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDAgJiYgb3B0aW9ucy54aHRtbE91dCkge1xuICAgIHJlc3VsdCArPSAnIC8nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgYSBuZXdsaW5lIGFmdGVyIHRoaXMgdGFnXG4gIGlmICh0b2tlbi5ibG9jaykge1xuICAgIG5lZWRMZiA9IHRydWU7XG5cbiAgICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMSkge1xuICAgICAgaWYgKGlkeCArIDEgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIG5leHRUb2tlbiA9IHRva2Vuc1tpZHggKyAxXTtcblxuICAgICAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09ICdpbmxpbmUnIHx8IG5leHRUb2tlbi5oaWRkZW4pIHtcbiAgICAgICAgICAvLyBCbG9jay1sZXZlbCB0YWcgY29udGFpbmluZyBhbiBpbmxpbmUgdGFnLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0VG9rZW4ubmVzdGluZyA9PT0gLTEgJiYgbmV4dFRva2VuLnRhZyA9PT0gdG9rZW4udGFnKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyB0YWcgKyBjbG9zaW5nIHRhZyBvZiB0aGUgc2FtZSB0eXBlLiBFLmcuIGA8bGk+PC9saT5gLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXN1bHQgKz0gbmVlZExmID8gJz5cXG4nIDogJz4nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVySW5saW5lKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW1JlbmRlcmVyLnJlbmRlcl1dLCBidXQgZm9yIHNpbmdsZSB0b2tlbiBvZiBgaW5saW5lYCB0eXBlLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3R5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogU3BlY2lhbCBrbHVkZ2UgZm9yIGltYWdlIGBhbHRgIGF0dHJpYnV0ZXMgdG8gY29uZm9ybSBDb21tb25NYXJrIHNwZWMuXG4gKiBEb24ndCB0cnkgdG8gdXNlIGl0ISBTcGVjIHJlcXVpcmVzIHRvIHNob3cgYGFsdGAgY29udGVudCB3aXRoIHN0cmlwcGVkIG1hcmt1cCxcbiAqIGluc3RlYWQgb2Ygc2ltcGxlIGVzY2FwaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZUFzVGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICByZXN1bHQgKz0gdG9rZW5zW2ldLmNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lQXNUZXh0KHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlcih0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogVGFrZXMgdG9rZW4gc3RyZWFtIGFuZCBnZW5lcmF0ZXMgSFRNTC4gUHJvYmFibHksIHlvdSB3aWxsIG5ldmVyIG5lZWQgdG8gY2FsbFxuICogdGhpcyBtZXRob2QgZGlyZWN0bHkuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciBpLCBsZW4sIHR5cGUsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICBmb3IgKGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZSh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHQgKz0gcnVsZXNbdG9rZW5zW2ldLnR5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwiLy8gQmxvY2sgcXVvdGVzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2txdW90ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGFkanVzdFRhYixcbiAgICAgIGNoLFxuICAgICAgaSxcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc091dGRlbnRlZCxcbiAgICAgIGwsXG4gICAgICBsYXN0TGluZUVtcHR5LFxuICAgICAgbGluZXMsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEJNYXJrcyxcbiAgICAgIG9sZEJTQ291bnQsXG4gICAgICBvbGRJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkU0NvdW50LFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgc3BhY2VBZnRlck1hcmtlcixcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRva2VuLFxuICAgICAgb2xkTGluZU1heCA9IHN0YXRlLmxpbmVNYXgsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY2hlY2sgdGhlIGJsb2NrIHF1b3RlIG1hcmtlclxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspICE9PSAweDNFLyogPiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyB3ZSBrbm93IHRoYXQgaXQncyBnb2luZyB0byBiZSBhIHZhbGlkIGJsb2NrcXVvdGUsXG4gIC8vIHNvIG5vIHBvaW50IHRyeWluZyB0byBmaW5kIHRoZSBlbmQgb2YgaXQgaW4gc2lsZW50IG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNraXAgc3BhY2VzIGFmdGVyIFwiPlwiIGFuZCByZS1jYWxjdWxhdGUgb2Zmc2V0XG4gIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIHBvcyAtIChzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdKTtcblxuICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjAgLyogc3BhY2UgKi8pIHtcbiAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgcG9zKys7XG4gICAgaW5pdGlhbCsrO1xuICAgIG9mZnNldCsrO1xuICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG5cbiAgICBpZiAoKHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIG9mZnNldCkgJSA0ID09PSAzKSB7XG4gICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgIHBvcysrO1xuICAgICAgaW5pdGlhbCsrO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgIC8vICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICsgc2hpZnQgYnNDb3VudCBzbGlnaHRseVxuICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICB9XG5cbiAgb2xkQk1hcmtzID0gWyBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSA9IHBvcztcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgb2xkQlNDb3VudCA9IFsgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdIF07XG4gIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdICsgMSArIChzcGFjZUFmdGVyTWFya2VyID8gMSA6IDApO1xuXG4gIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4O1xuXG4gIG9sZFNDb3VudCA9IFsgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsO1xuXG4gIG9sZFRTaGlmdCA9IFsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnYmxvY2txdW90ZScpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2Jsb2NrcXVvdGUnO1xuXG4gIC8vIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBibG9ja1xuICAvL1xuICAvLyBCbG9jayBlbmRzIHdpdGggZWl0aGVyOlxuICAvLyAgMS4gYW4gZW1wdHkgbGluZSBvdXRzaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy9cbiAgLy8gICAgIGBgYFxuICAvLyAgMi4gYW4gZW1wdHkgbGluZSBpbnNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID5cbiAgLy8gICAgIHRlc3RcbiAgLy8gICAgIGBgYFxuICAvLyAgMy4gYW5vdGhlciB0YWc6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvLyAgICAgIC0gLSAtXG4gIC8vICAgICBgYGBcbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIC8vIGNoZWNrIGlmIGl0J3Mgb3V0ZGVudGVkLCBpLmUuIGl0J3MgaW5zaWRlIGxpc3QgaXRlbSBhbmQgaW5kZW50ZWRcbiAgICAvLyBsZXNzIHRoYW4gc2FpZCBsaXN0IGl0ZW06XG4gICAgLy9cbiAgICAvLyBgYGBcbiAgICAvLyAxLiBhbnl0aGluZ1xuICAgIC8vICAgID4gY3VycmVudCBibG9ja3F1b3RlXG4gICAgLy8gMi4gY2hlY2tpbmcgdGhpcyBsaW5lXG4gICAgLy8gYGBgXG4gICAgaXNPdXRkZW50ZWQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50O1xuXG4gICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAvLyBDYXNlIDE6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoaXMgbGluZSBpcyBlbXB0eS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgPT09IDB4M0UvKiA+ICovICYmICFpc091dGRlbnRlZCkge1xuICAgICAgLy8gVGhpcyBsaW5lIGlzIGluc2lkZSB0aGUgYmxvY2txdW90ZS5cblxuICAgICAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcblxuICAgICAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgICAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAgICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgICAgICBwb3MrKztcbiAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5iTWFya3NbbmV4dExpbmVdID0gcG9zO1xuXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUudFNoaWZ0W25leHRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tuZXh0TGluZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDYXNlIDI6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoZSBsYXN0IGxpbmUgd2FzIGVtcHR5LlxuICAgIGlmIChsYXN0TGluZUVtcHR5KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBDYXNlIDM6IGFub3RoZXIgdGFnIGZvdW5kLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgLy8gUXVpcmsgdG8gZW5mb3JjZSBcImhhcmQgdGVybWluYXRpb24gbW9kZVwiIGZvciBwYXJhZ3JhcGhzO1xuICAgICAgLy8gbm9ybWFsbHkgaWYgeW91IGNhbGwgYHRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKWAsXG4gICAgICAvLyBwYXJhZ3JhcGhzIHdpbGwgbG9vayBiZWxvdyBuZXh0TGluZSBmb3IgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbixcbiAgICAgIC8vIGJ1dCBpZiBibG9ja3F1b3RlIGlzIHRlcm1pbmF0ZWQgYnkgYW5vdGhlciB0YWcsIHRoZXkgc2hvdWxkbid0XG4gICAgICBzdGF0ZS5saW5lTWF4ID0gbmV4dExpbmU7XG5cbiAgICAgIGlmIChzdGF0ZS5ibGtJbmRlbnQgIT09IDApIHtcbiAgICAgICAgLy8gc3RhdGUuYmxrSW5kZW50IHdhcyBub24temVybywgd2Ugbm93IHNldCBpdCB0byB6ZXJvLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBhbGwgb2Zmc2V0cyB0byBhcHBlYXIgYXNcbiAgICAgICAgLy8gaWYgaW5kZW50IHdhc24ndCBjaGFuZ2VkXG4gICAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLT0gc3RhdGUuYmxrSW5kZW50O1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaXNPdXRkZW50ZWQpIGJyZWFrO1xuXG4gICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcblxuICAgIC8vIEEgbmVnYXRpdmUgaW5kZW50YXRpb24gbWVhbnMgdGhhdCB0aGlzIGlzIGEgcGFyYWdyYXBoIGNvbnRpbnVhdGlvblxuICAgIC8vXG4gICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IC0xO1xuICB9XG5cbiAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICBzdGF0ZS5ibGtJbmRlbnQgPSAwO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfb3BlbicsICdibG9ja3F1b3RlJywgMSk7XG4gIHRva2VuLm1hcmt1cCA9ICc+JztcbiAgdG9rZW4ubWFwICAgID0gbGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX2Nsb3NlJywgJ2Jsb2NrcXVvdGUnLCAtMSk7XG4gIHRva2VuLm1hcmt1cCA9ICc+JztcblxuICBzdGF0ZS5saW5lTWF4ID0gb2xkTGluZU1heDtcbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG4gIGxpbmVzWzFdID0gc3RhdGUubGluZTtcblxuICAvLyBSZXN0b3JlIG9yaWdpbmFsIHRTaGlmdDsgdGhpcyBtaWdodCBub3QgYmUgbmVjZXNzYXJ5IHNpbmNlIHRoZSBwYXJzZXJcbiAgLy8gaGFzIGFscmVhZHkgYmVlbiBoZXJlLCBidXQganVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIGRvIHRoYXQuXG4gIGZvciAoaSA9IDA7IGkgPCBvbGRUU2hpZnQubGVuZ3RoOyBpKyspIHtcbiAgICBzdGF0ZS5iTWFya3NbaSArIHN0YXJ0TGluZV0gPSBvbGRCTWFya3NbaV07XG4gICAgc3RhdGUudFNoaWZ0W2kgKyBzdGFydExpbmVdID0gb2xkVFNoaWZ0W2ldO1xuICAgIHN0YXRlLnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZFNDb3VudFtpXTtcbiAgICBzdGF0ZS5ic0NvdW50W2kgKyBzdGFydExpbmVdID0gb2xkQlNDb3VudFtpXTtcbiAgfVxuICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCIvLyBDb2RlIGJsb2NrICg0IHNwYWNlcyBwYWRkZWQpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvZGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgbmV4dExpbmUsIGxhc3QsIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA8IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFzdCA9IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgaWYgKHN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGxhc3QgPSBuZXh0TGluZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBsYXN0O1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2Jsb2NrJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbGFzdCwgNCArIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLmpzIiwiLy8gZmVuY2VzIChgYGAgbGFuZywgfn5+IGxhbmcpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZlbmNlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBsZW4sIHBhcmFtcywgbmV4dExpbmUsIG1lbSwgdG9rZW4sIG1hcmt1cCxcbiAgICAgIGhhdmVFbmRNYXJrZXIgPSBmYWxzZSxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovICYmIG1hcmtlciAhPT0gMHg2MCAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gc2NhbiBtYXJrZXIgbGVuZ3RoXG4gIG1lbSA9IHBvcztcbiAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICBsZW4gPSBwb3MgLSBtZW07XG5cbiAgaWYgKGxlbiA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya3VwID0gc3RhdGUuc3JjLnNsaWNlKG1lbSwgcG9zKTtcbiAgcGFyYW1zID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBpZiAocGFyYW1zLmluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKSA+PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbmNlIHN0YXJ0IGlzIGZvdW5kLCB3ZSBjYW4gcmVwb3J0IHN1Y2Nlc3MgaGVyZSBpbiB2YWxpZGF0aW9uIG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNlYXJjaCBlbmQgb2YgYmxvY2tcbiAgbmV4dExpbmUgPSBzdGFydExpbmU7XG5cbiAgZm9yICg7Oykge1xuICAgIG5leHRMaW5lKys7XG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHtcbiAgICAgIC8vIHVuY2xvc2VkIGJsb2NrIHNob3VsZCBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBkb2N1bWVudC5cbiAgICAgIC8vIGFsc28gYmxvY2sgc2VlbXMgdG8gYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgcGFyZW50XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MgPSBtZW0gPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAvLyBub24tZW1wdHkgbGluZSB3aXRoIG5lZ2F0aXZlIGluZGVudCBzaG91bGQgc3RvcCB0aGUgbGlzdDpcbiAgICAgIC8vIC0gYGBgXG4gICAgICAvLyAgdGVzdFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IG1hcmtlcikgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgLy8gY2xvc2luZyBmZW5jZSBzaG91bGQgYmUgaW5kZW50ZWQgbGVzcyB0aGFuIDQgc3BhY2VzXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gICAgLy8gY2xvc2luZyBjb2RlIGZlbmNlIG11c3QgYmUgYXQgbGVhc3QgYXMgbG9uZyBhcyB0aGUgb3BlbmluZyBvbmVcbiAgICBpZiAocG9zIC0gbWVtIDwgbGVuKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGFpbCBoYXMgc3BhY2VzIG9ubHlcbiAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICBpZiAocG9zIDwgbWF4KSB7IGNvbnRpbnVlOyB9XG5cbiAgICBoYXZlRW5kTWFya2VyID0gdHJ1ZTtcbiAgICAvLyBmb3VuZCFcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIElmIGEgZmVuY2UgaGFzIGhlYWRpbmcgc3BhY2VzLCB0aGV5IHNob3VsZCBiZSByZW1vdmVkIGZyb20gaXRzIGlubmVyIGJsb2NrXG4gIGxlbiA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIChoYXZlRW5kTWFya2VyID8gMSA6IDApO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdmZW5jZScsICdjb2RlJywgMCk7XG4gIHRva2VuLmluZm8gICAgPSBwYXJhbXM7XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUgKyAxLCBuZXh0TGluZSwgbGVuLCB0cnVlKTtcbiAgdG9rZW4ubWFya3VwICA9IG1hcmt1cDtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzIiwiLy8gaGVhZGluZyAoIywgIyMsIC4uLilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxldmVsLCB0bXAsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoICA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKGNoICE9PSAweDIzLyogIyAqLyB8fCBwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNvdW50IGhlYWRpbmcgbGV2ZWxcbiAgbGV2ZWwgPSAxO1xuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgd2hpbGUgKGNoID09PSAweDIzLyogIyAqLyAmJiBwb3MgPCBtYXggJiYgbGV2ZWwgPD0gNikge1xuICAgIGxldmVsKys7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIH1cblxuICBpZiAobGV2ZWwgPiA2IHx8IChwb3MgPCBtYXggJiYgIWlzU3BhY2UoY2gpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gTGV0J3MgY3V0IHRhaWxzIGxpa2UgJyAgICAjIyMgICcgZnJvbSB0aGUgZW5kIG9mIHN0cmluZ1xuXG4gIG1heCA9IHN0YXRlLnNraXBTcGFjZXNCYWNrKG1heCwgcG9zKTtcbiAgdG1wID0gc3RhdGUuc2tpcENoYXJzQmFjayhtYXgsIDB4MjMsIHBvcyk7IC8vICNcbiAgaWYgKHRtcCA+IHBvcyAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHRtcCAtIDEpKSkge1xuICAgIG1heCA9IHRtcDtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpLnRyaW0oKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwiLy8gSG9yaXpvbnRhbCBydWxlXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGNudCwgY2gsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAvLyBDaGVjayBociBtYXJrZXJcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBtYXJrZXJzIGNhbiBiZSBtaXhlZCB3aXRoIHNwYWNlcywgYnV0IHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCAzIG9mIHRoZW1cblxuICBjbnQgPSAxO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKGNoICE9PSBtYXJrZXIgJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChjaCA9PT0gbWFya2VyKSB7IGNudCsrOyB9XG4gIH1cblxuICBpZiAoY250IDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaHInLCAnaHInLCAwKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4ubWFya3VwID0gQXJyYXkoY250ICsgMSkuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5qcyIsIi8vIEhUTUwgYmxvY2tcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBibG9ja19uYW1lcyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX2Jsb2NrcycpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cbi8vIEFuIGFycmF5IG9mIG9wZW5pbmcgYW5kIGNvcnJlc3BvbmRpbmcgY2xvc2luZyBzZXF1ZW5jZXMgZm9yIGh0bWwgdGFncyxcbi8vIGxhc3QgYXJndW1lbnQgZGVmaW5lcyB3aGV0aGVyIGl0IGNhbiB0ZXJtaW5hdGUgYSBwYXJhZ3JhcGggb3Igbm90XG4vL1xudmFyIEhUTUxfU0VRVUVOQ0VTID0gW1xuICBbIC9ePChzY3JpcHR8cHJlfHN0eWxlKSg/PShcXHN8PnwkKSkvaSwgLzxcXC8oc2NyaXB0fHByZXxzdHlsZSk+L2ksIHRydWUgXSxcbiAgWyAvXjwhLS0vLCAgICAgICAgLy0tPi8sICAgdHJ1ZSBdLFxuICBbIC9ePFxcPy8sICAgICAgICAgL1xcPz4vLCAgIHRydWUgXSxcbiAgWyAvXjwhW0EtWl0vLCAgICAgLz4vLCAgICAgdHJ1ZSBdLFxuICBbIC9ePCFcXFtDREFUQVxcWy8sIC9cXF1cXF0+LywgdHJ1ZSBdLFxuICBbIG5ldyBSZWdFeHAoJ148Lz8oJyArIGJsb2NrX25hbWVzLmpvaW4oJ3wnKSArICcpKD89KFxcXFxzfC8/PnwkKSknLCAnaScpLCAvXiQvLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cChIVE1MX09QRU5fQ0xPU0VfVEFHX1JFLnNvdXJjZSArICdcXFxccyokJyksICAvXiQvLCBmYWxzZSBdXG5dO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9ibG9jayhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGksIG5leHRMaW5lLCB0b2tlbiwgbGluZVRleHQsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBmb3IgKGkgPSAwOyBpIDwgSFRNTF9TRVFVRU5DRVMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoSFRNTF9TRVFVRU5DRVNbaV1bMF0udGVzdChsaW5lVGV4dCkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmIChpID09PSBIVE1MX1NFUVVFTkNFUy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkge1xuICAgIC8vIHRydWUgaWYgdGhpcyBzZXF1ZW5jZSBjYW4gYmUgYSB0ZXJtaW5hdG9yLCBmYWxzZSBvdGhlcndpc2VcbiAgICByZXR1cm4gSFRNTF9TRVFVRU5DRVNbaV1bMl07XG4gIH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gSWYgd2UgYXJlIGhlcmUgLSB3ZSBkZXRlY3RlZCBIVE1MIGJsb2NrLlxuICAvLyBMZXQncyByb2xsIGRvd24gdGlsbCBibG9jayBlbmQuXG4gIGlmICghSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG4gICAgICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoICE9PSAwKSB7IG5leHRMaW5lKys7IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2Jsb2NrJywgJycsIDApO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIG5leHRMaW5lIF07XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwiLy8gbGhlYWRpbmcgKC0tLSwgPT09KVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBwb3MsIG1heCwgbGV2ZWwsIG1hcmtlcixcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSwgb2xkUGFyZW50VHlwZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnOyAvLyB1c2UgcGFyYWdyYXBoIHRvIG1hdGNoIHRlcm1pbmF0b3JSdWxlc1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvL1xuICAgIC8vIENoZWNrIGZvciB1bmRlcmxpbmUgaW4gc2V0ZXh0IGhlYWRlclxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAobWFya2VyID09PSAweDJELyogLSAqLyB8fCBtYXJrZXIgPT09IDB4M0QvKiA9ICovKSB7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICAgICAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgICAgICAgbGV2ZWwgPSAobWFya2VyID09PSAweDNELyogPSAqLyA/IDEgOiAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmICghbGV2ZWwpIHtcbiAgICAvLyBEaWRuJ3QgZmluZCB2YWxpZCB1bmRlcmxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIC0gMSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzIiwiLy8gTGlzdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuLy8gU2VhcmNoIGBbLSsqXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYXJ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBtYXJrZXIsIHBvcywgbWF4LCBjaDtcblxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIC8vIENoZWNrIGJ1bGxldFxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJCLyogKyAqLykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAtdGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbi8vIFNlYXJjaCBgXFxkK1suKV1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFydGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgcG9zID0gc3RhcnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIGNoYXJzIChkaWdpdCArIGRvdClcbiAgaWYgKHBvcyArIDEgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIGlmIChjaCA8IDB4MzAvKiAwICovIHx8IGNoID4gMHgzOS8qIDkgKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgZm9yICg7Oykge1xuICAgIC8vIEVPTCAtPiBmYWlsXG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmIChjaCA+PSAweDMwLyogMCAqLyAmJiBjaCA8PSAweDM5LyogOSAqLykge1xuXG4gICAgICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBubyBtb3JlIHRoYW4gOSBkaWdpdHNcbiAgICAgIC8vIChwcmV2ZW50cyBpbnRlZ2VyIG92ZXJmbG93IGluIGJyb3dzZXJzKVxuICAgICAgaWYgKHBvcyAtIHN0YXJ0ID49IDEwKSB7IHJldHVybiAtMTsgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmb3VuZCB2YWxpZCBtYXJrZXJcbiAgICBpZiAoY2ggPT09IDB4MjkvKiApICovIHx8IGNoID09PSAweDJlLyogLiAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgMS50ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICB2YXIgaSwgbCxcbiAgICAgIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xuXG4gIGZvciAoaSA9IGlkeCArIDIsIGwgPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbaSArIDJdLmhpZGRlbiA9IHRydWU7XG4gICAgICBzdGF0ZS50b2tlbnNbaV0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGkgKz0gMjtcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgIGksXG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRBZnRlck1hcmtlcixcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc09yZGVyZWQsXG4gICAgICBpdGVtTGluZXMsXG4gICAgICBsLFxuICAgICAgbGlzdExpbmVzLFxuICAgICAgbGlzdFRva0lkeCxcbiAgICAgIG1hcmtlckNoYXJDb2RlLFxuICAgICAgbWFya2VyVmFsdWUsXG4gICAgICBtYXgsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZExJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgb2xkVGlnaHQsXG4gICAgICBwb3MsXG4gICAgICBwb3NBZnRlck1hcmtlcixcbiAgICAgIHByZXZFbXB0eUVuZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gZmFsc2UsXG4gICAgICB0aWdodCA9IHRydWU7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc3Vic3RyKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIHN0YXJ0IC0gMSkpO1xuXG4gICAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgb3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gICAgLy8gYSBwYXJhZ3JhcGgsIGl0IHNob3VsZCBzdGFydCB3aXRoIDEuXG4gICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXG4gIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcblxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X29wZW4nLCAnb2wnLCAxKTtcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X29wZW4nLCAndWwnLCAxKTtcbiAgfVxuXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgY29udGVudFN0YXJ0ID0gcG9zO1xuXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXgpIHtcbiAgICAgIC8vIHRyaW1taW5nIHNwYWNlIGluIFwiLSAgICBcXG4gIDNcIiBjYXNlLCBpbmRlbnQgaXMgMSBoZXJlXG4gICAgICBpbmRlbnRBZnRlck1hcmtlciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gb2Zmc2V0IC0gaW5pdGlhbDtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiA0IHNwYWNlcywgdGhlIGluZGVudCBpcyAxXG4gICAgLy8gKHRoZSByZXN0IGlzIGp1c3QgaW5kZW50ZWQgY29kZSBibG9jaylcbiAgICBpZiAoaW5kZW50QWZ0ZXJNYXJrZXIgPiA0KSB7IGluZGVudEFmdGVyTWFya2VyID0gMTsgfVxuXG4gICAgLy8gXCIgIC0gIHRlc3RcIlxuICAgIC8vICBeXl5eXiAtIGNhbGN1bGF0aW5nIHRvdGFsIGxlbmd0aCBvZiB0aGlzIHRoaW5nXG4gICAgaW5kZW50ID0gaW5pdGlhbCArIGluZGVudEFmdGVyTWFya2VyO1xuXG4gICAgLy8gUnVuIHN1YnBhcnNlciAmIHdyaXRlIHRva2Vuc1xuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9vcGVuJywgJ2xpJywgMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG4gICAgdG9rZW4ubWFwICAgID0gaXRlbUxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICAgIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgICBvbGRUaWdodCA9IHN0YXRlLnRpZ2h0O1xuICAgIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG9sZExJbmRlbnQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBpbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQ7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCAmJiBzdGF0ZS5pc0VtcHR5KHN0YXJ0TGluZSArIDEpKSB7XG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciB0aGlzIGNhc2VcbiAgICAgIC8vIChsaXN0IGl0ZW0gaXMgZW1wdHksIGxpc3QgdGVybWluYXRlcyBiZWZvcmUgXCJmb29cIik6XG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgLy8gICAtXG4gICAgICAvL1xuICAgICAgLy8gICAgIGZvb1xuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIHN0YXRlLmxpbmUgPSBNYXRoLm1pbihzdGF0ZS5saW5lICsgMiwgZW5kTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICB0aWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBJdGVtIGJlY29tZSBsb29zZSBpZiBmaW5pc2ggd2l0aCBlbXB0eSBsaW5lLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGQgZmlsdGVyIGxhc3QgZWxlbWVudCwgYmVjYXVzZSBpdCBtZWFucyBsaXN0IGZpbmlzaFxuICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gc3RhcnRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBvbGRUU2hpZnQ7XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvbGRMSW5kZW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fY2xvc2UnLCAnbGknLCAtMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgaXRlbUxpbmVzWzFdID0gbmV4dExpbmU7XG4gICAgY29udGVudFN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy9cbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIHRlcm1pbmF0aW5nIGJsb2NrIGZvdW5kXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiBsaXN0IGhhcyBhbm90aGVyIHR5cGVcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlckNoYXJDb2RlICE9PSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpKSB7IGJyZWFrOyB9XG4gIH1cblxuICAvLyBGaW5pbGl6ZSBsaXN0XG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9jbG9zZScsICdvbCcsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X2Nsb3NlJywgJ3VsJywgLTEpO1xuICB9XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIGxpc3RMaW5lc1sxXSA9IG5leHRMaW5lO1xuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgLy8gbWFyayBwYXJhZ3JhcGhzIHRpZ2h0IGlmIG5lZWRlZFxuICBpZiAodGlnaHQpIHtcbiAgICBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBsaXN0VG9rSWR4KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzIiwiLy8gUGFyYWdyYXBoXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmFncmFwaChzdGF0ZSwgc3RhcnRMaW5lLyosIGVuZExpbmUqLykge1xuICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgb2xkUGFyZW50VHlwZSxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKSxcbiAgICAgIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3BhcmFncmFwaCc7XG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgncGFyYWdyYXBoX29wZW4nLCAncCcsIDEpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgncGFyYWdyYXBoX2Nsb3NlJywgJ3AnLCAtMSk7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVmZXJlbmNlKHN0YXRlLCBzdGFydExpbmUsIF9lbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgZGVzdEVuZFBvcyxcbiAgICAgIGRlc3RFbmRMaW5lTm8sXG4gICAgICBlbmRMaW5lLFxuICAgICAgaHJlZixcbiAgICAgIGksXG4gICAgICBsLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICByZXMsXG4gICAgICBzdGFydCxcbiAgICAgIHN0cixcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW1wbGUgY2hlY2sgdG8gcXVpY2tseSBpbnRlcnJ1cHQgc2NhbiBvbiBbbGlua10odXJsKSBhdCB0aGUgc3RhcnQgb2YgbGluZS5cbiAgLy8gQ2FuIGJlIHVzZWZ1bCBvbiBwcmFjdGljZTogaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2lzc3Vlcy81NFxuICB3aGlsZSAoKytwb3MgPCBtYXgpIHtcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1RCAvKiBdICovICYmXG4gICAgICAgIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyAtIDEpICE9PSAweDVDLyogXFwgKi8pIHtcbiAgICAgIGlmIChwb3MgKyAxID09PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncmVmZXJlbmNlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncmVmZXJlbmNlJztcblxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIHN0ciA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcbiAgbWF4ID0gc3RyLmxlbmd0aDtcblxuICBmb3IgKHBvcyA9IDE7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxhYmVsRW5kID0gcG9zO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgwQSAvKiBcXG4gKi8pIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLykge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZXMrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobGFiZWxFbmQgPCAwIHx8IHN0ci5jaGFyQ29kZUF0KGxhYmVsRW5kICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgXl5eIHNraXAgb3B0aW9uYWwgd2hpdGVzcGFjZSBoZXJlXG4gIGZvciAocG9zID0gbGFiZWxFbmQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICBeXl5eXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCk7XG4gIGlmICghcmVzLm9rKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSByZXMucG9zO1xuICBsaW5lcyArPSByZXMubGluZXM7XG5cbiAgLy8gc2F2ZSBjdXJzb3Igc3RhdGUsIHdlIGNvdWxkIHJlcXVpcmUgdG8gcm9sbGJhY2sgbGF0ZXJcbiAgZGVzdEVuZFBvcyA9IHBvcztcbiAgZGVzdEVuZExpbmVObyA9IGxpbmVzO1xuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBeXl4gc2tpcHBpbmcgdGhvc2Ugc3BhY2VzXG4gIHN0YXJ0ID0gcG9zO1xuICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICBwb3MgPSByZXMucG9zO1xuICAgIGxpbmVzICs9IHJlcy5saW5lcztcbiAgfSBlbHNlIHtcbiAgICB0aXRsZSA9ICcnO1xuICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICB9XG5cbiAgLy8gc2tpcCB0cmFpbGluZyBzcGFjZXMgdW50aWwgdGhlIHJlc3Qgb2YgdGhlIGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSBhZnRlciB0aXRsZSxcbiAgICAgIC8vIGJ1dCBpdCBjb3VsZCBzdGlsbCBiZSBhIHZhbGlkIHJlZmVyZW5jZSBpZiB3ZSByb2xsIGJhY2tcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2Uoc3RyLnNsaWNlKDEsIGxhYmVsRW5kKSk7XG4gIGlmICghbGFiZWwpIHtcbiAgICAvLyBDb21tb25NYXJrIDAuMjAgZGlzYWxsb3dzIGVtcHR5IGxhYmVsc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFJlZmVyZW5jZSBjYW4gbm90IHRlcm1pbmF0ZSBhbnl0aGluZy4gVGhpcyBjaGVjayBpcyBmb3Igc2FmZXR5IG9ubHkuXG4gIC8qaXN0YW5idWwgaWdub3JlIGlmKi9cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXMgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPSB7IHRpdGxlOiB0aXRsZSwgaHJlZjogaHJlZiB9O1xuICB9XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIGxpbmVzICsgMTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5qcyIsIi8vIFBhcnNlciBzdGF0ZSBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gU3RhdGVCbG9jayhzcmMsIG1kLCBlbnYsIHRva2Vucykge1xuICB2YXIgY2gsIHMsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBvZmZzZXQsIGluZGVudF9mb3VuZDtcblxuICB0aGlzLnNyYyA9IHNyYztcblxuICAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxuICB0aGlzLm1kICAgICA9IG1kO1xuXG4gIHRoaXMuZW52ID0gZW52O1xuXG4gIC8vXG4gIC8vIEludGVybmFsIHN0YXRlIHZhcnRpYWJsZXNcbiAgLy9cblxuICB0aGlzLnRva2VucyA9IHRva2VucztcblxuICB0aGlzLmJNYXJrcyA9IFtdOyAgLy8gbGluZSBiZWdpbiBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMuZU1hcmtzID0gW107ICAvLyBsaW5lIGVuZCBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMudFNoaWZ0ID0gW107ICAvLyBvZmZzZXRzIG9mIHRoZSBmaXJzdCBub24tc3BhY2UgY2hhcmFjdGVycyAodGFicyBub3QgZXhwYW5kZWQpXG4gIHRoaXMuc0NvdW50ID0gW107ICAvLyBpbmRlbnRzIGZvciBlYWNoIGxpbmUgKHRhYnMgZXhwYW5kZWQpXG5cbiAgLy8gQW4gYW1vdW50IG9mIHZpcnR1YWwgc3BhY2VzICh0YWJzIGV4cGFuZGVkKSBiZXR3ZWVuIGJlZ2lubmluZ1xuICAvLyBvZiBlYWNoIGxpbmUgKGJNYXJrcykgYW5kIHJlYWwgYmVnaW5uaW5nIG9mIHRoYXQgbGluZS5cbiAgLy9cbiAgLy8gSXQgZXhpc3RzIG9ubHkgYXMgYSBoYWNrIGJlY2F1c2UgYmxvY2txdW90ZXMgb3ZlcnJpZGUgYk1hcmtzXG4gIC8vIGxvc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgcHJvY2Vzcy5cbiAgLy9cbiAgLy8gSXQncyB1c2VkIG9ubHkgd2hlbiBleHBhbmRpbmcgdGFicywgeW91IGNhbiB0aGluayBhYm91dCBpdCBhc1xuICAvLyBhbiBpbml0aWFsIHRhYiBsZW5ndGgsIGUuZy4gYnNDb3VudD0yMSBhcHBsaWVkIHRvIHN0cmluZyBgXFx0MTIzYFxuICAvLyBtZWFucyBmaXJzdCB0YWIgc2hvdWxkIGJlIGV4cGFuZGVkIHRvIDQtMjElNCA9PT0gMyBzcGFjZXMuXG4gIC8vXG4gIHRoaXMuYnNDb3VudCA9IFtdO1xuXG4gIC8vIGJsb2NrIHBhcnNlciB2YXJpYWJsZXNcbiAgdGhpcy5ibGtJbmRlbnQgID0gMDsgLy8gcmVxdWlyZWQgYmxvY2sgY29udGVudCBpbmRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gKGZvciBleGFtcGxlLCBpZiB3ZSBhcmUgaW4gbGlzdClcbiAgdGhpcy5saW5lICAgICAgID0gMDsgLy8gbGluZSBpbmRleCBpbiBzcmNcbiAgdGhpcy5saW5lTWF4ICAgID0gMDsgLy8gbGluZXMgY291bnRcbiAgdGhpcy50aWdodCAgICAgID0gZmFsc2U7ICAvLyBsb29zZS90aWdodCBtb2RlIGZvciBsaXN0c1xuICB0aGlzLmRkSW5kZW50ICAgPSAtMTsgLy8gaW5kZW50IG9mIHRoZSBjdXJyZW50IGRkIGJsb2NrICgtMSBpZiB0aGVyZSBpc24ndCBhbnkpXG5cbiAgLy8gY2FuIGJlICdibG9ja3F1b3RlJywgJ2xpc3QnLCAncm9vdCcsICdwYXJhZ3JhcGgnIG9yICdyZWZlcmVuY2UnXG4gIC8vIHVzZWQgaW4gbGlzdHMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgaW50ZXJydXB0IGEgcGFyYWdyYXBoXG4gIHRoaXMucGFyZW50VHlwZSA9ICdyb290JztcblxuICB0aGlzLmxldmVsID0gMDtcblxuICAvLyByZW5kZXJlclxuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIC8vIENyZWF0ZSBjYWNoZXNcbiAgLy8gR2VuZXJhdGUgbWFya2Vycy5cbiAgcyA9IHRoaXMuc3JjO1xuICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcblxuICBmb3IgKHN0YXJ0ID0gcG9zID0gaW5kZW50ID0gb2Zmc2V0ID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgcG9zKyspIHtcbiAgICBjaCA9IHMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpbmRlbnRfZm91bmQpIHtcbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpbmRlbnQrKztcblxuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNCAtIG9mZnNldCAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlbnRfZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSB8fCBwb3MgPT09IGxlbiAtIDEpIHtcbiAgICAgIGlmIChjaCAhPT0gMHgwQSkgeyBwb3MrKzsgfVxuICAgICAgdGhpcy5iTWFya3MucHVzaChzdGFydCk7XG4gICAgICB0aGlzLmVNYXJrcy5wdXNoKHBvcyk7XG4gICAgICB0aGlzLnRTaGlmdC5wdXNoKGluZGVudCk7XG4gICAgICB0aGlzLnNDb3VudC5wdXNoKG9mZnNldCk7XG4gICAgICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICAgICAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIGZha2UgZW50cnkgdG8gc2ltcGxpZnkgY2FjaGUgYm91bmRzIGNoZWNrc1xuICB0aGlzLmJNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy5lTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMudFNoaWZ0LnB1c2goMCk7XG4gIHRoaXMuc0NvdW50LnB1c2goMCk7XG4gIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gIHRoaXMubGluZU1heCA9IHRoaXMuYk1hcmtzLmxlbmd0aCAtIDE7IC8vIGRvbid0IGNvdW50IGxhc3QgZmFrZSBsaW5lXG59XG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vL1xuU3RhdGVCbG9jay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG4gIHRva2VuLmJsb2NrID0gdHJ1ZTtcblxuICBpZiAobmVzdGluZyA8IDApIHsgdGhpcy5sZXZlbC0tOyB9XG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxuXG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShsaW5lKSB7XG4gIHJldHVybiB0aGlzLmJNYXJrc1tsaW5lXSArIHRoaXMudFNoaWZ0W2xpbmVdID49IHRoaXMuZU1hcmtzW2xpbmVdO1xufTtcblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXMgPSBmdW5jdGlvbiBza2lwRW1wdHlMaW5lcyhmcm9tKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMubGluZU1heDsgZnJvbSA8IG1heDsgZnJvbSsrKSB7XG4gICAgaWYgKHRoaXMuYk1hcmtzW2Zyb21dICsgdGhpcy50U2hpZnRbZnJvbV0gPCB0aGlzLmVNYXJrc1tmcm9tXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tO1xufTtcblxuLy8gU2tpcCBzcGFjZXMgZnJvbSBnaXZlbiBwb3NpdGlvbi5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXMgPSBmdW5jdGlvbiBza2lwU3BhY2VzKHBvcykge1xuICB2YXIgY2g7XG5cbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uIGluIHJldmVyc2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzQmFjayA9IGZ1bmN0aW9uIHNraXBTcGFjZXNCYWNrKHBvcywgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKCFpc1NwYWNlKHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgZnJvbSBnaXZlbiBwb3NpdGlvblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzID0gZnVuY3Rpb24gc2tpcENoYXJzKHBvcywgY29kZSkge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBpZiAodGhpcy5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBjb2RlKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyByZXZlcnNlIGZyb20gZ2l2ZW4gcG9zaXRpb24gLSAxXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnNCYWNrID0gZnVuY3Rpb24gc2tpcENoYXJzQmFjayhwb3MsIGNvZGUsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zOyB9XG5cbiAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgIGlmIChjb2RlICE9PSB0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBjdXQgbGluZXMgcmFuZ2UgZnJvbSBzb3VyY2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5nZXRMaW5lcyA9IGZ1bmN0aW9uIGdldExpbmVzKGJlZ2luLCBlbmQsIGluZGVudCwga2VlcExhc3RMRikge1xuICB2YXIgaSwgbGluZUluZGVudCwgY2gsIGZpcnN0LCBsYXN0LCBxdWV1ZSwgbGluZVN0YXJ0LFxuICAgICAgbGluZSA9IGJlZ2luO1xuXG4gIGlmIChiZWdpbiA+PSBlbmQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBxdWV1ZSA9IG5ldyBBcnJheShlbmQgLSBiZWdpbik7XG5cbiAgZm9yIChpID0gMDsgbGluZSA8IGVuZDsgbGluZSsrLCBpKyspIHtcbiAgICBsaW5lSW5kZW50ID0gMDtcbiAgICBsaW5lU3RhcnQgPSBmaXJzdCA9IHRoaXMuYk1hcmtzW2xpbmVdO1xuXG4gICAgaWYgKGxpbmUgKyAxIDwgZW5kIHx8IGtlZXBMYXN0TEYpIHtcbiAgICAgIC8vIE5vIG5lZWQgZm9yIGJvdW5kcyBjaGVjayBiZWNhdXNlIHdlIGhhdmUgZmFrZSBlbnRyeSBvbiB0YWlsLlxuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdO1xuICAgIH1cblxuICAgIHdoaWxlIChmaXJzdCA8IGxhc3QgJiYgbGluZUluZGVudCA8IGluZGVudCkge1xuICAgICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KGZpcnN0KTtcblxuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIGxpbmVJbmRlbnQgKz0gNCAtIChsaW5lSW5kZW50ICsgdGhpcy5ic0NvdW50W2xpbmVdKSAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0IC0gbGluZVN0YXJ0IDwgdGhpcy50U2hpZnRbbGluZV0pIHtcbiAgICAgICAgLy8gcGF0Y2hlZCB0U2hpZnQgbWFza2VkIGNoYXJhY3RlcnMgdG8gbG9vayBsaWtlIHNwYWNlcyAoYmxvY2txdW90ZXMsIGxpc3QgbWFya2VycylcbiAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0Kys7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVJbmRlbnQgPiBpbmRlbnQpIHtcbiAgICAgIC8vIHBhcnRpYWxseSBleHBhbmRpbmcgdGFicyBpbiBjb2RlIGJsb2NrcywgZS5nICdcXHRcXHRmb29iYXInXG4gICAgICAvLyB3aXRoIGluZGVudD0yIGJlY29tZXMgJyAgXFx0Zm9vYmFyJ1xuICAgICAgcXVldWVbaV0gPSBuZXcgQXJyYXkobGluZUluZGVudCAtIGluZGVudCArIDEpLmpvaW4oJyAnKSArIHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVbaV0gPSB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXVlLmpvaW4oJycpO1xufTtcblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVCbG9jay5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQmxvY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanMiLCIvLyBHRk0gdGFibGUsIG5vbi1zdGFuZGFyZFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBnZXRMaW5lKHN0YXRlLCBsaW5lKSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS5ibGtJbmRlbnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbGluZV07XG5cbiAgcmV0dXJuIHN0YXRlLnNyYy5zdWJzdHIocG9zLCBtYXggLSBwb3MpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkU3BsaXQoc3RyKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHBvcyA9IDAsXG4gICAgICBtYXggPSBzdHIubGVuZ3RoLFxuICAgICAgY2gsXG4gICAgICBlc2NhcGVzID0gMCxcbiAgICAgIGxhc3RQb3MgPSAwLFxuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlLFxuICAgICAgbGFzdEJhY2tUaWNrID0gMDtcblxuICBjaCAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBpZiAoY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgICBpZiAoYmFja1RpY2tlZCkge1xuICAgICAgICAvLyBtYWtlIFxcYCBjbG9zZSBjb2RlIHNlcXVlbmNlLCBidXQgbm90IG9wZW4gaXQ7XG4gICAgICAgIC8vIHRoZSByZWFzb24gaXM6IGBcXGAgaXMgY29ycmVjdCBjb2RlIGJsb2NrXG4gICAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVzICUgMiA9PT0gMCkge1xuICAgICAgICBiYWNrVGlja2VkID0gdHJ1ZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4N2MvKiB8ICovICYmIChlc2NhcGVzICUgMiA9PT0gMCkgJiYgIWJhY2tUaWNrZWQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcywgcG9zKSk7XG4gICAgICBsYXN0UG9zID0gcG9zICsgMTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4NWMvKiBcXCAqLykge1xuICAgICAgZXNjYXBlcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBlc2NhcGVzID0gMDtcbiAgICB9XG5cbiAgICBwb3MrKztcblxuICAgIC8vIElmIHRoZXJlIHdhcyBhbiB1bi1jbG9zZWQgYmFja3RpY2ssIGdvIGJhY2sgdG8ganVzdCBhZnRlclxuICAgIC8vIHRoZSBsYXN0IGJhY2t0aWNrLCBidXQgYXMgaWYgaXQgd2FzIGEgbm9ybWFsIGNoYXJhY3RlclxuICAgIGlmIChwb3MgPT09IG1heCAmJiBiYWNrVGlja2VkKSB7XG4gICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICBwb3MgPSBsYXN0QmFja1RpY2sgKyAxO1xuICAgIH1cblxuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgfVxuXG4gIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcykpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0YWJsZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsaW5lVGV4dCwgcG9zLCBpLCBuZXh0TGluZSwgY29sdW1ucywgY29sdW1uQ291bnQsIHRva2VuLFxuICAgICAgYWxpZ25zLCB0LCB0YWJsZUxpbmVzLCB0Ym9keUxpbmVzO1xuXG4gIC8vIHNob3VsZCBoYXZlIGF0IGxlYXN0IHR3byBsaW5lc1xuICBpZiAoc3RhcnRMaW5lICsgMiA+IGVuZExpbmUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzZWNvbmQgbGluZSBzaG91bGQgYmUgJ3wnLCAnLScsICc6JyxcbiAgLy8gYW5kIG5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQgYnV0IHNwYWNlcztcbiAgLy8gYmFzaWNhbGx5LCB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIC9eWy06fF1bLTp8XFxzXSokLyByZWdleHBcblxuICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgaWYgKHBvcyA+PSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8gJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSArIDEpO1xuXG4gIGNvbHVtbnMgPSBsaW5lVGV4dC5zcGxpdCgnfCcpO1xuICBhbGlnbnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0ID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgaWYgKCF0KSB7XG4gICAgICAvLyBhbGxvdyBlbXB0eSBjb2x1bW5zIGJlZm9yZSBhbmQgYWZ0ZXIgdGFibGUsIGJ1dCBub3QgaW4gYmV0d2VlbiBjb2x1bW5zO1xuICAgICAgLy8gZS5nLiBhbGxvdyBgIHwtLS18IGAsIGRpc2FsbG93IGAgLS0tfHwtLS0gYFxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gY29sdW1ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAxKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8gPyAnY2VudGVyJyA6ICdyaWdodCcpO1xuICAgIH0gZWxzZSBpZiAodC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2goJ2xlZnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ25zLnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lKS50cmltKCk7XG4gIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAvLyBoZWFkZXIgcm93IHdpbGwgZGVmaW5lIGFuIGFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBlbnRpcmUgdGFibGUsXG4gIC8vIGFuZCBhbGlnbiByb3cgc2hvdWxkbid0IGJlIHNtYWxsZXIgdGhhbiB0aGF0ICh0aGUgcmVzdCBvZiB0aGUgcm93cyBjYW4pXG4gIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gIGlmIChjb2x1bW5Db3VudCA+IGFsaWducy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RhYmxlX29wZW4nLCAndGFibGUnLCAxKTtcbiAgdG9rZW4ubWFwID0gdGFibGVMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfb3BlbicsICd0aGVhZCcsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfb3BlbicsICd0aCcsIDEpO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcbiAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICB0b2tlbi5hdHRycyAgPSBbIFsgJ3N0eWxlJywgJ3RleHQtYWxpZ246JyArIGFsaWduc1tpXSBdIF07XG4gICAgfVxuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCAgPSBjb2x1bW5zW2ldLnRyaW0oKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfY2xvc2UnLCAndGgnLCAtMSk7XG4gIH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfY2xvc2UnLCAndGhlYWQnLCAtMSk7XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGJvZHlfb3BlbicsICd0Ym9keScsIDEpO1xuICB0b2tlbi5tYXAgPSB0Ym9keUxpbmVzID0gWyBzdGFydExpbmUgKyAyLCAwIF07XG5cbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDI7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIG5leHRMaW5lKS50cmltKCk7XG4gICAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ3wnKSA9PT0gLTEpIHsgYnJlYWs7IH1cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrOyB9XG4gICAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAgIHRva2VuID0gc3RhdGUucHVzaCgndHJfb3BlbicsICd0cicsIDEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX29wZW4nLCAndGQnLCAxKTtcbiAgICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgICAgfVxuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXSA/IGNvbHVtbnNbaV0udHJpbSgpIDogJyc7XG4gICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX2Nsb3NlJywgJ3RkJywgLTEpO1xuICAgIH1cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX2Nsb3NlJywgJ3RyJywgLTEpO1xuICB9XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGJvZHlfY2xvc2UnLCAndGJvZHknLCAtMSk7XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGFibGVfY2xvc2UnLCAndGFibGUnLCAtMSk7XG5cbiAgdGFibGVMaW5lc1sxXSA9IHRib2R5TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svdGFibGUuanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9jayhzdGF0ZSkge1xuICB2YXIgdG9rZW47XG5cbiAgaWYgKHN0YXRlLmlubGluZU1vZGUpIHtcbiAgICB0b2tlbiAgICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyAwLCAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubWQuYmxvY2sucGFyc2Uoc3RhdGUuc3JjLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5saW5lKHN0YXRlKSB7XG4gIHZhciB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsIHRvaywgaSwgbDtcblxuICAvLyBQYXJzZSBpbmxpbmVzXG4gIGZvciAoaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdG9rID0gdG9rZW5zW2ldO1xuICAgIGlmICh0b2sudHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHN0YXRlLm1kLmlubGluZS5wYXJzZSh0b2suY29udGVudCwgc3RhdGUubWQsIHN0YXRlLmVudiwgdG9rLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCIvLyBSZXBsYWNlIGxpbmstbGlrZSB0ZXh0cyB3aXRoIGxpbmsgbm9kZXMuXG4vL1xuLy8gQ3VycmVudGx5IHJlc3RyaWN0ZWQgYnkgYG1kLnZhbGlkYXRlTGluaygpYCB0byBodHRwL2h0dHBzL2Z0cFxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXJyYXlSZXBsYWNlQXQgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5hcnJheVJlcGxhY2VBdDtcblxuXG5mdW5jdGlvbiBpc0xpbmtPcGVuKHN0cikge1xuICByZXR1cm4gL148YVs+XFxzXS9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzTGlua0Nsb3NlKHN0cikge1xuICByZXR1cm4gL148XFwvYVxccyo+L2kudGVzdChzdHIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua2lmeShzdGF0ZSkge1xuICB2YXIgaSwgaiwgbCwgdG9rZW5zLCB0b2tlbiwgY3VycmVudFRva2VuLCBub2RlcywgbG4sIHRleHQsIHBvcywgbGFzdFBvcyxcbiAgICAgIGxldmVsLCBodG1sTGlua0xldmVsLCB1cmwsIGZ1bGxVcmwsIHVybFRleHQsXG4gICAgICBibG9ja1Rva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIGxpbmtzO1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5saW5raWZ5KSB7IHJldHVybjsgfVxuXG4gIGZvciAoaiA9IDAsIGwgPSBibG9ja1Rva2Vucy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIXN0YXRlLm1kLmxpbmtpZnkucHJldGVzdChibG9ja1Rva2Vuc1tqXS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdG9rZW5zID0gYmxvY2tUb2tlbnNbal0uY2hpbGRyZW47XG5cbiAgICBodG1sTGlua0xldmVsID0gMDtcblxuICAgIC8vIFdlIHNjYW4gZnJvbSB0aGUgZW5kLCB0byBrZWVwIHBvc2l0aW9uIHdoZW4gbmV3IHRhZ3MgYWRkZWQuXG4gICAgLy8gVXNlIHJldmVyc2VkIGxvZ2ljIGluIGxpbmtzIHN0YXJ0L2VuZCBtYXRjaFxuICAgIGZvciAoaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY3VycmVudFRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgbWFya2Rvd24gbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgd2hpbGUgKHRva2Vuc1tpXS5sZXZlbCAhPT0gY3VycmVudFRva2VuLmxldmVsICYmIHRva2Vuc1tpXS50eXBlICE9PSAnbGlua19vcGVuJykge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBjb250ZW50IG9mIGh0bWwgdGFnIGxpbmtzXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICdodG1sX2lubGluZScpIHtcbiAgICAgICAgaWYgKGlzTGlua09wZW4oY3VycmVudFRva2VuLmNvbnRlbnQpICYmIGh0bWxMaW5rTGV2ZWwgPiAwKSB7XG4gICAgICAgICAgaHRtbExpbmtMZXZlbC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpbmtDbG9zZShjdXJyZW50VG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChodG1sTGlua0xldmVsID4gMCkgeyBjb250aW51ZTsgfVxuXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBzdGF0ZS5tZC5saW5raWZ5LnRlc3QoY3VycmVudFRva2VuLmNvbnRlbnQpKSB7XG5cbiAgICAgICAgdGV4dCA9IGN1cnJlbnRUb2tlbi5jb250ZW50O1xuICAgICAgICBsaW5rcyA9IHN0YXRlLm1kLmxpbmtpZnkubWF0Y2godGV4dCk7XG5cbiAgICAgICAgLy8gTm93IHNwbGl0IHN0cmluZyB0byBub2Rlc1xuICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICBsZXZlbCA9IGN1cnJlbnRUb2tlbi5sZXZlbDtcbiAgICAgICAgbGFzdFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsbiA9IDA7IGxuIDwgbGlua3MubGVuZ3RoOyBsbisrKSB7XG5cbiAgICAgICAgICB1cmwgPSBsaW5rc1tsbl0udXJsO1xuICAgICAgICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIHVybFRleHQgPSBsaW5rc1tsbl0udGV4dDtcblxuICAgICAgICAgIC8vIExpbmtpZmllciBtaWdodCBzZW5kIHJhdyBob3N0bmFtZXMgbGlrZSBcImV4YW1wbGUuY29tXCIsIHdoZXJlIHVybFxuICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoIGRvbWFpbiBuYW1lLiBTbyB3ZSBwcmVwZW5kIGh0dHA6Ly8gaW4gdGhvc2UgY2FzZXMsXG4gICAgICAgICAgLy8gYW5kIHJlbW92ZSBpdCBhZnRlcndhcmRzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKCFsaW5rc1tsbl0uc2NoZW1hKSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoJ2h0dHA6Ly8nICsgdXJsVGV4dCkucmVwbGFjZSgvXmh0dHA6XFwvXFwvLywgJycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlua3NbbG5dLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KHVybFRleHQpKSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoJ21haWx0bzonICsgdXJsVGV4dCkucmVwbGFjZSgvXm1haWx0bzovLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmxUZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3MgPSBsaW5rc1tsbl0uaW5kZXg7XG5cbiAgICAgICAgICBpZiAocG9zID4gbGFzdFBvcykge1xuICAgICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MsIHBvcyk7XG4gICAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgICAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWwrKztcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgID0gJ2xpbmtpZnknO1xuICAgICAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB1cmxUZXh0O1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gLS1sZXZlbDtcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgID0gJ2xpbmtpZnknO1xuICAgICAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICBsYXN0UG9zID0gbGlua3NbbG5dLmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFBvcyA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dC5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNlIGN1cnJlbnQgbm9kZVxuICAgICAgICBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbiA9IHRva2VucyA9IGFycmF5UmVwbGFjZUF0KHRva2VucywgaSwgbm9kZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMiLCIvLyBOb3JtYWxpemUgaW5wdXQgc3RyaW5nXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgTkVXTElORVNfUkUgID0gL1xccltcXG5cXHUwMDg1XT98W1xcdTI0MjRcXHUyMDI4XFx1MDA4NV0vZztcbnZhciBOVUxMX1JFICAgICAgPSAvXFx1MDAwMC9nO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5saW5lKHN0YXRlKSB7XG4gIHZhciBzdHI7XG5cbiAgLy8gTm9ybWFsaXplIG5ld2xpbmVzXG4gIHN0ciA9IHN0YXRlLnNyYy5yZXBsYWNlKE5FV0xJTkVTX1JFLCAnXFxuJyk7XG5cbiAgLy8gUmVwbGFjZSBOVUxMIGNoYXJhY3RlcnNcbiAgc3RyID0gc3RyLnJlcGxhY2UoTlVMTF9SRSwgJ1xcdUZGRkQnKTtcblxuICBzdGF0ZS5zcmMgPSBzdHI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwiLy8gU2ltcGxlIHR5cG9ncmFwaHljIHJlcGxhY2VtZW50c1xuLy9cbi8vIChjKSAoQykg4oaSIMKpXG4vLyAodG0pIChUTSkg4oaSIOKEolxuLy8gKHIpIChSKSDihpIgwq5cbi8vICstIOKGkiDCsVxuLy8gKHApIChQKSAtPiDCp1xuLy8gLi4uIOKGkiDigKYgKGFsc28gPy4uLi4g4oaSID8uLiwgIS4uLi4g4oaSICEuLilcbi8vID8/Pz8/Pz8/IOKGkiA/Pz8sICEhISEhIOKGkiAhISEsIGAsLGAg4oaSIGAsYFxuLy8gLS0g4oaSICZuZGFzaDssIC0tLSDihpIgJm1kYXNoO1xuLy9cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzpcbi8vIC0gZnJhY3Rpb25hbHMgMS8yLCAxLzQsIDMvNCAtPiDCvSwgwrwsIMK+XG4vLyAtIG1pbHRpcGxpY2F0aW9uIDIgeCA0IC0+IDIgw5cgNFxuXG52YXIgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS87XG5cbi8vIFdvcmthcm91bmQgZm9yIHBoYW50b21qcyAtIG5lZWQgcmVnZXggd2l0aG91dCAvZyBmbGFnLFxuLy8gb3Igcm9vdCBjaGVjayB3aWxsIGZhaWwgZXZlcnkgc2Vjb25kIHRpbWVcbnZhciBTQ09QRURfQUJCUl9URVNUX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaTtcblxudmFyIFNDT1BFRF9BQkJSX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaWc7XG52YXIgU0NPUEVEX0FCQlIgPSB7XG4gIGM6ICfCqScsXG4gIHI6ICfCricsXG4gIHA6ICfCpycsXG4gIHRtOiAn4oSiJ1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBuYW1lKSB7XG4gIHJldHVybiBTQ09QRURfQUJCUltuYW1lLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlX3Njb3BlZChpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudC5yZXBsYWNlKFNDT1BFRF9BQkJSX1JFLCByZXBsYWNlRm4pO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9yYXJlKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIGlmIChSQVJFX1JFLnRlc3QodG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy0vZywgJ8KxJylcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4sIC4uLiwgLi4uLi4uLiAtPiDigKZcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0ID8uLi4uLiAmICEuLi4uLiAtPiA/Li4gJiAhLi5cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcLnsyLH0vZywgJ+KApicpLnJlcGxhY2UoLyhbPyFdKeKApi9nLCAnJDEuLicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oWz8hXSl7NCx9L2csICckMSQxJDEnKS5yZXBsYWNlKC8sezIsfS9nLCAnLCcpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLV0pLS0tKFteLV18JCkvbWcsICckMVxcdTIwMTQkMicpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFxccyktLShcXHN8JCkvbWcsICckMVxcdTIwMTMkMicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1cXHNdKS0tKFteLVxcc118JCkvbWcsICckMVxcdTIwMTMkMicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWU7IH1cblxuICAgIGlmIChTQ09QRURfQUJCUl9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2Vfc2NvcGVkKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpZiAoUkFSRV9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICByZXBsYWNlX3JhcmUoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwiLy8gQ29udmVydCBzdHJhaWdodCBxdW90YXRpb24gbWFya3MgdG8gdHlwb2dyYXBoaWMgb25lc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xuXG52YXIgUVVPVEVfVEVTVF9SRSA9IC9bJ1wiXS87XG52YXIgUVVPVEVfUkUgPSAvWydcIl0vZztcbnZhciBBUE9TVFJPUEhFID0gJ1xcdTIwMTknOyAvKiDigJkgKi9cblxuXG5mdW5jdGlvbiByZXBsYWNlQXQoc3RyLCBpbmRleCwgY2gpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaW5kZXgpICsgY2ggKyBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NfaW5saW5lcyh0b2tlbnMsIHN0YXRlKSB7XG4gIHZhciBpLCB0b2tlbiwgdGV4dCwgdCwgcG9zLCBtYXgsIHRoaXNMZXZlbCwgaXRlbSwgbGFzdENoYXIsIG5leHRDaGFyLFxuICAgICAgaXNMYXN0UHVuY3RDaGFyLCBpc05leHRQdW5jdENoYXIsIGlzTGFzdFdoaXRlU3BhY2UsIGlzTmV4dFdoaXRlU3BhY2UsXG4gICAgICBjYW5PcGVuLCBjYW5DbG9zZSwgaiwgaXNTaW5nbGUsIHN0YWNrLCBvcGVuUXVvdGUsIGNsb3NlUXVvdGU7XG5cbiAgc3RhY2sgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICB0aGlzTGV2ZWwgPSB0b2tlbnNbaV0ubGV2ZWw7XG5cbiAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDw9IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgIH1cbiAgICBzdGFjay5sZW5ndGggPSBqICsgMTtcblxuICAgIGlmICh0b2tlbi50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgIHBvcyA9IDA7XG4gICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAvKmVzbGludCBuby1sYWJlbHM6MCxibG9jay1zY29wZWQtdmFyOjAqL1xuICAgIE9VVEVSOlxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIFFVT1RFX1JFLmxhc3RJbmRleCA9IHBvcztcbiAgICAgIHQgPSBRVU9URV9SRS5leGVjKHRleHQpO1xuICAgICAgaWYgKCF0KSB7IGJyZWFrOyB9XG5cbiAgICAgIGNhbk9wZW4gPSBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBwb3MgPSB0LmluZGV4ICsgMTtcbiAgICAgIGlzU2luZ2xlID0gKHRbMF0gPT09IFwiJ1wiKTtcblxuICAgICAgLy8gRmluZCBwcmV2aW91cyBjaGFyYWN0ZXIsXG4gICAgICAvLyBkZWZhdWx0IHRvIHNwYWNlIGlmIGl0J3MgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgLy9cbiAgICAgIGxhc3RDaGFyID0gMHgyMDtcblxuICAgICAgaWYgKHQuaW5kZXggLSAxID49IDApIHtcbiAgICAgICAgbGFzdENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQodC5pbmRleCAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBuZXh0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbmV4dENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIG5leHRDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICAgICAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gICAgICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcblxuICAgICAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gMHgyMiAvKiBcIiAqLyAmJiB0WzBdID09PSAnXCInKSB7XG4gICAgICAgIGlmIChsYXN0Q2hhciA+PSAweDMwIC8qIDAgKi8gJiYgbGFzdENoYXIgPD0gMHgzOSAvKiA5ICovKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiAxXCJcIiAtIGNvdW50IGZpcnN0IHF1b3RlIGFzIGFuIGluY2hcbiAgICAgICAgICBjYW5DbG9zZSA9IGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3BlbiAmJiBjYW5DbG9zZSkge1xuICAgICAgICAvLyB0cmVhdCB0aGlzIGFzIHRoZSBtaWRkbGUgb2YgdGhlIHdvcmRcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICBjYW5DbG9zZSA9IGlzTmV4dFB1bmN0Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xuICAgICAgICAvLyBtaWRkbGUgb2Ygd29yZFxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNsb3NpbmcgcXVvdGUsIHJld2luZCB0aGUgc3RhY2sgdG8gZ2V0IGEgbWF0Y2hcbiAgICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG4gICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDwgdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgICAgICAgaWYgKGl0ZW0uc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG5cbiAgICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1syXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMF07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0b2tlbi5jb250ZW50ICpiZWZvcmUqIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LFxuICAgICAgICAgICAgLy8gYmVjYXVzZSwgaWYgdGhleSBhcmUgcG9pbnRpbmcgYXQgdGhlIHNhbWUgdG9rZW4sIHJlcGxhY2VBdFxuICAgICAgICAgICAgLy8gY291bGQgbWVzcyB1cCBpbmRpY2VzIHdoZW4gcXVvdGUgbGVuZ3RoICE9IDFcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgY2xvc2VRdW90ZSk7XG4gICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdChcbiAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsIGl0ZW0ucG9zLCBvcGVuUXVvdGUpO1xuXG4gICAgICAgICAgICBwb3MgKz0gY2xvc2VRdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW4gPT09IGkpIHsgcG9zICs9IG9wZW5RdW90ZS5sZW5ndGggLSAxOyB9XG5cbiAgICAgICAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICAgICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGo7XG4gICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXG4gICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQ2xvc2UgJiYgaXNTaW5nbGUpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNtYXJ0cXVvdGVzKHN0YXRlKSB7XG4gIC8qZXNsaW50IG1heC1kZXB0aDowKi9cbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIVFVT1RFX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvY2Vzc19pbmxpbmVzKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuLCBzdGF0ZSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qcyIsIi8vIENvcmUgc3RhdGUgb2JqZWN0XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xuXG5cbmZ1bmN0aW9uIFN0YXRlQ29yZShzcmMsIG1kLCBlbnYpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLmlubGluZU1vZGUgPSBmYWxzZTtcbiAgdGhpcy5tZCA9IG1kOyAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxufVxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGNvcmUgcnVsZXNcblN0YXRlQ29yZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCIvLyBQcm9jZXNzIGF1dG9saW5rcyAnPHByb3RvY29sOi4uLj4nXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKmVzbGludCBtYXgtbGVuOjAqL1xudmFyIEVNQUlMX1JFICAgID0gL148KFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopPi87XG52YXIgQVVUT0xJTktfUkUgPSAvXjwoW2EtekEtWl1bYS16QS1aMC05Ky5cXC1dezEsMzF9KTooW148PlxceDAwLVxceDIwXSopPi87XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdXRvbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciB0YWlsLCBsaW5rTWF0Y2gsIGVtYWlsTWF0Y2gsIHVybCwgZnVsbFVybCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHRhaWwgPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTtcblxuICBpZiAodGFpbC5pbmRleE9mKCc+JykgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChBVVRPTElOS19SRS50ZXN0KHRhaWwpKSB7XG4gICAgbGlua01hdGNoID0gdGFpbC5tYXRjaChBVVRPTElOS19SRSk7XG5cbiAgICB1cmwgPSBsaW5rTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGxpbmtNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRU1BSUxfUkUudGVzdCh0YWlsKSkge1xuICAgIGVtYWlsTWF0Y2ggPSB0YWlsLm1hdGNoKEVNQUlMX1JFKTtcblxuICAgIHVybCA9IGVtYWlsTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKCdtYWlsdG86JyArIHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGVtYWlsTWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanMiLCIvLyBQYXJzZSBiYWNrdGlja3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhY2t0aWNrKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHN0YXJ0LCBtYXgsIG1hcmtlciwgbWF0Y2hTdGFydCwgbWF0Y2hFbmQsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zLFxuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHg2MC8qIGAgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc3RhcnQgPSBwb3M7XG4gIHBvcysrO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDYwLyogYCAqLykgeyBwb3MrKzsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKTtcblxuICBtYXRjaFN0YXJ0ID0gbWF0Y2hFbmQgPSBwb3M7XG5cbiAgd2hpbGUgKChtYXRjaFN0YXJ0ID0gc3RhdGUuc3JjLmluZGV4T2YoJ2AnLCBtYXRjaEVuZCkpICE9PSAtMSkge1xuICAgIG1hdGNoRW5kID0gbWF0Y2hTdGFydCArIDE7XG5cbiAgICB3aGlsZSAobWF0Y2hFbmQgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQobWF0Y2hFbmQpID09PSAweDYwLyogYCAqLykgeyBtYXRjaEVuZCsrOyB9XG5cbiAgICBpZiAobWF0Y2hFbmQgLSBtYXRjaFN0YXJ0ID09PSBtYXJrZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnY29kZV9pbmxpbmUnLCAnY29kZScsIDApO1xuICAgICAgICB0b2tlbi5tYXJrdXAgID0gbWFya2VyO1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF0Y2hTdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bIFxcbl0rL2csICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBtYXRjaEVuZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gbWFya2VyOyB9XG4gIHN0YXRlLnBvcyArPSBtYXJrZXIubGVuZ3RoO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIi8vIEZvciBlYWNoIG9wZW5pbmcgZW1waGFzaXMtbGlrZSBtYXJrZXIgZmluZCBhIG1hdGNoaW5nIGNsb3Npbmcgb25lXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua19wYWlycyhzdGF0ZSkge1xuICB2YXIgaSwgaiwgbGFzdERlbGltLCBjdXJyRGVsaW0sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGxhc3REZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoIWxhc3REZWxpbS5jbG9zZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaiA9IGkgLSBsYXN0RGVsaW0uanVtcCAtIDE7XG5cbiAgICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgICBjdXJyRGVsaW0gPSBkZWxpbWl0ZXJzW2pdO1xuXG4gICAgICBpZiAoY3VyckRlbGltLm9wZW4gJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubWFya2VyID09PSBsYXN0RGVsaW0ubWFya2VyICYmXG4gICAgICAgICAgY3VyckRlbGltLmVuZCA8IDAgJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubGV2ZWwgPT09IGxhc3REZWxpbS5sZXZlbCkge1xuXG4gICAgICAgIC8vIHR5cGVvZnMgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggcGx1Z2luc1xuICAgICAgICB2YXIgb2RkX21hdGNoID0gKGN1cnJEZWxpbS5jbG9zZSB8fCBsYXN0RGVsaW0ub3BlbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyRGVsaW0ubGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxhc3REZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VyckRlbGltLmxlbmd0aCArIGxhc3REZWxpbS5sZW5ndGgpICUgMyA9PT0gMDtcblxuICAgICAgICBpZiAoIW9kZF9tYXRjaCkge1xuICAgICAgICAgIGxhc3REZWxpbS5qdW1wID0gaSAtIGo7XG4gICAgICAgICAgbGFzdERlbGltLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kICA9IGk7XG4gICAgICAgICAgY3VyckRlbGltLmp1bXAgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGogLT0gY3VyckRlbGltLmp1bXAgKyAxO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qcyIsIi8vIFByb2Nlc3MgaHRtbCBlbnRpdHkgLSAmIzEyMzssICYjeEFGOywgJnF1b3Q7LCAuLi5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW50aXRpZXMgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vZW50aXRpZXMnKTtcbnZhciBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmhhcztcbnZhciBpc1ZhbGlkRW50aXR5Q29kZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzVmFsaWRFbnRpdHlDb2RlO1xudmFyIGZyb21Db2RlUG9pbnQgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuZnJvbUNvZGVQb2ludDtcblxuXG52YXIgRElHSVRBTF9SRSA9IC9eJiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpOy9pO1xudmFyIE5BTUVEX1JFICAgPSAvXiYoW2Etel1bYS16MC05XXsxLDMxfSk7L2k7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbnRpdHkoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIGNvZGUsIG1hdGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyNi8qICYgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDEgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuXG4gICAgaWYgKGNoID09PSAweDIzIC8qICMgKi8pIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goRElHSVRBTF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICBjb2RlID0gbWF0Y2hbMV1bMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID8gcGFyc2VJbnQobWF0Y2hbMV0uc2xpY2UoMSksIDE2KSA6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgc3RhdGUucGVuZGluZyArPSBpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSA/IGZyb21Db2RlUG9pbnQoY29kZSkgOiBmcm9tQ29kZVBvaW50KDB4RkZGRCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goTkFNRURfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChoYXMoZW50aXRpZXMsIG1hdGNoWzFdKSkge1xuICAgICAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gZW50aXRpZXNbbWF0Y2hbMV1dOyB9XG4gICAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJyYnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VudGl0eS5qcyIsIi8vIFByb2NlZXNzIGVzY2FwZWQgY2hhcnMgYW5kIGhhcmRicmVha3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cbnZhciBFU0NBUEVEID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHsgRVNDQVBFRC5wdXNoKDApOyB9XG5cbidcXFxcIVwiIyQlJlxcJygpKissLi86Ozw9Pj9AW11eX2B7fH1+LSdcbiAgLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaCkgeyBFU0NBUEVEW2NoLmNoYXJDb2RlQXQoMCldID0gMTsgfSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVDLyogXFwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zKys7XG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCA8IDI1NiAmJiBFU0NBUEVEW2NoXSAhPT0gMCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbcG9zXTsgfVxuICAgICAgc3RhdGUucG9zICs9IDI7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICAgIC8vIHNraXAgbGVhZGluZyB3aGl0ZXNwYWNlcyBmcm9tIG5leHQgbGluZVxuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvcyA9IHBvcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJ1xcXFwnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5qcyIsIi8vIFByb2Nlc3MgaHRtbCB0YWdzXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgSFRNTF9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfVEFHX1JFO1xuXG5cbmZ1bmN0aW9uIGlzTGV0dGVyKGNoKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIHZhciBsYyA9IGNoIHwgMHgyMDsgLy8gdG8gbG93ZXIgY2FzZVxuICByZXR1cm4gKGxjID49IDB4NjEvKiBhICovKSAmJiAobGMgPD0gMHg3YS8qIHogKi8pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9pbmxpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIG1hdGNoLCBtYXgsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIENoZWNrIHN0YXJ0XG4gIG1heCA9IHN0YXRlLnBvc01heDtcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovIHx8XG4gICAgICBwb3MgKyAyID49IG1heCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFF1aWNrIGZhaWwgb24gc2Vjb25kIGNoYXJcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgaWYgKGNoICE9PSAweDIxLyogISAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YvKiA/ICovICYmXG4gICAgICBjaCAhPT0gMHgyRi8qIC8gKi8gJiZcbiAgICAgICFpc0xldHRlcihjaCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKEhUTUxfVEFHX1JFKTtcbiAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzIiwiLy8gUHJvY2VzcyAhW2ltYWdlXSg8c3JjPiBcInRpdGxlXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltYWdlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlZixcbiAgICAgIHJlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICB0b2tlbnMsXG4gICAgICBzdGFydCxcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHgyMS8qICEgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDI7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuXG4gICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKFxuICAgICAgY29udGVudCxcbiAgICAgIHN0YXRlLm1kLFxuICAgICAgc3RhdGUuZW52LFxuICAgICAgdG9rZW5zID0gW11cbiAgICApO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbWFnZScsICdpbWcnLCAwKTtcbiAgICB0b2tlbi5hdHRycyAgICA9IGF0dHJzID0gWyBbICdzcmMnLCBocmVmIF0sIFsgJ2FsdCcsICcnIF0gXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qcyIsIi8vIFByb2Nlc3MgW2xpbmtdKDx0bz4gXCJzdHVmZlwiKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVzLFxuICAgICAgcmVmLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMTtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MsIHRydWUpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gbWlnaHQgaGF2ZSBmb3VuZCBhIHZhbGlkIHNob3J0Y3V0IGxpbmssIGRpc2FibGUgcmVmZXJlbmNlIHBhcnNpbmdcbiAgICBwYXJzZVJlZmVyZW5jZSA9IGZhbHNlO1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICAvLyBwYXJzaW5nIGEgdmFsaWQgc2hvcnRjdXQgbGluayBmYWlsZWQsIGZhbGxiYWNrIHRvIHJlZmVyZW5jZVxuICAgICAgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwYXJzZVJlZmVyZW5jZSkge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnBvcyA9IGxhYmVsU3RhcnQ7XG4gICAgc3RhdGUucG9zTWF4ID0gbGFiZWxFbmQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgIHRva2VuLmF0dHJzICA9IGF0dHJzID0gWyBbICdocmVmJywgaHJlZiBdIF07XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBhdHRycy5wdXNoKFsgJ3RpdGxlJywgdGl0bGUgXSk7XG4gICAgfVxuXG4gICAgc3RhdGUubWQuaW5saW5lLnRva2VuaXplKHN0YXRlKTtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanMiLCIvLyBQcm9jZWVzcyAnXFxuJ1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5ld2xpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG1heCwgbWF4LCBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEvKiBcXG4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG1heCA9IHN0YXRlLnBlbmRpbmcubGVuZ3RoIC0gMTtcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vICcgIFxcbicgLT4gaGFyZGJyZWFrXG4gIC8vIExvb2t1cCBpbiBwZW5kaW5nIGNoYXJzIGlzIGJhZCBwcmFjdGljZSEgRG9uJ3QgY29weSB0byBvdGhlciBydWxlcyFcbiAgLy8gUGVuZGluZyBzdHJpbmcgaXMgc3RvcmVkIGluIGNvbmNhdCBtb2RlLCBpbmRleGVkIGxvb2t1cHMgd2lsbCBjYXVzZVxuICAvLyBjb252ZXJ0aW9uIHRvIGZsYXQgbW9kZS5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAocG1heCA+PSAwICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4KSA9PT0gMHgyMCkge1xuICAgICAgaWYgKHBtYXggPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCAtIDEpID09PSAweDIwKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnJlcGxhY2UoLyArJC8sICcnKTtcbiAgICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApO1xuICAgIH1cbiAgfVxuXG4gIHBvcysrO1xuXG4gIC8vIHNraXAgaGVhZGluZyBzcGFjZXMgZm9yIG5leHQgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4ICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHsgcG9zKys7IH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qcyIsIi8vIElubGluZSBwYXJzZXIgc3RhdGVcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUb2tlbiAgICAgICAgICA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xuXG5cbmZ1bmN0aW9uIFN0YXRlSW5saW5lKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy5tZCA9IG1kO1xuICB0aGlzLnRva2VucyA9IG91dFRva2VucztcblxuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMucG9zTWF4ID0gdGhpcy5zcmMubGVuZ3RoO1xuICB0aGlzLmxldmVsID0gMDtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHRoaXMucGVuZGluZ0xldmVsID0gMDtcblxuICB0aGlzLmNhY2hlID0ge307ICAgICAgICAvLyBTdG9yZXMgeyBzdGFydDogZW5kIH0gcGFpcnMuIFVzZWZ1bCBmb3IgYmFja3RyYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGltaXphdGlvbiBvZiBwYWlycyBwYXJzZSAoZW1waGFzaXMsIHN0cmlrZXMpLlxuXG4gIHRoaXMuZGVsaW1pdGVycyA9IFtdOyAgIC8vIEVtcGhhc2lzLWxpa2UgZGVsaW1pdGVyc1xufVxuXG5cbi8vIEZsdXNoIHBlbmRpbmcgdGV4dFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKCd0ZXh0JywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ID0gdGhpcy5wZW5kaW5nO1xuICB0b2tlbi5sZXZlbCA9IHRoaXMucGVuZGluZ0xldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vIElmIHBlbmRpbmcgdGV4dCBleGlzdHMgLSBmbHVzaCBpdCBhcyB0ZXh0IHRva2VuXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICB0aGlzLnB1c2hQZW5kaW5nKCk7XG4gIH1cblxuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcblxuICBpZiAobmVzdGluZyA8IDApIHsgdGhpcy5sZXZlbC0tOyB9XG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxuXG4gIHRoaXMucGVuZGluZ0xldmVsID0gdGhpcy5sZXZlbDtcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gU2NhbiBhIHNlcXVlbmNlIG9mIGVtcGhhc2lzLWxpa2UgbWFya2VycywgYW5kIGRldGVybWluZSB3aGV0aGVyXG4vLyBpdCBjYW4gc3RhcnQgYW4gZW1waGFzaXMgc2VxdWVuY2Ugb3IgZW5kIGFuIGVtcGhhc2lzIHNlcXVlbmNlLlxuLy9cbi8vICAtIHN0YXJ0IC0gcG9zaXRpb24gdG8gc2NhbiBmcm9tIChpdCBzaG91bGQgcG9pbnQgYXQgYSB2YWxpZCBtYXJrZXIpO1xuLy8gIC0gY2FuU3BsaXRXb3JkIC0gZGV0ZXJtaW5lIGlmIHRoZXNlIG1hcmtlcnMgY2FuIGJlIGZvdW5kIGluc2lkZSBhIHdvcmRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuc2NhbkRlbGltcyA9IGZ1bmN0aW9uIChzdGFydCwgY2FuU3BsaXRXb3JkKSB7XG4gIHZhciBwb3MgPSBzdGFydCwgbGFzdENoYXIsIG5leHRDaGFyLCBjb3VudCwgY2FuX29wZW4sIGNhbl9jbG9zZSxcbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UsIGlzTGFzdFB1bmN0Q2hhcixcbiAgICAgIGlzTmV4dFdoaXRlU3BhY2UsIGlzTmV4dFB1bmN0Q2hhcixcbiAgICAgIGxlZnRfZmxhbmtpbmcgPSB0cnVlLFxuICAgICAgcmlnaHRfZmxhbmtpbmcgPSB0cnVlLFxuICAgICAgbWF4ID0gdGhpcy5wb3NNYXgsXG4gICAgICBtYXJrZXIgPSB0aGlzLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICAvLyB0cmVhdCBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXG4gIGxhc3RDaGFyID0gc3RhcnQgPiAwID8gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCAtIDEpIDogMHgyMDtcblxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gbWFya2VyKSB7IHBvcysrOyB9XG5cbiAgY291bnQgPSBwb3MgLSBzdGFydDtcblxuICAvLyB0cmVhdCBlbmQgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXG4gIG5leHRDaGFyID0gcG9zIDwgbWF4ID8gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpIDogMHgyMDtcblxuICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xuXG4gIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcblxuICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgIGxlZnRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcbiAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgIGxlZnRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY2FuU3BsaXRXb3JkKSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZyAgJiYgKCFyaWdodF9mbGFua2luZyB8fCBpc0xhc3RQdW5jdENoYXIpO1xuICAgIGNhbl9jbG9zZSA9IHJpZ2h0X2ZsYW5raW5nICYmICghbGVmdF9mbGFua2luZyAgfHwgaXNOZXh0UHVuY3RDaGFyKTtcbiAgfSBlbHNlIHtcbiAgICBjYW5fb3BlbiAgPSBsZWZ0X2ZsYW5raW5nO1xuICAgIGNhbl9jbG9zZSA9IHJpZ2h0X2ZsYW5raW5nO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjYW5fb3BlbjogIGNhbl9vcGVuLFxuICAgIGNhbl9jbG9zZTogY2FuX2Nsb3NlLFxuICAgIGxlbmd0aDogICAgY291bnRcbiAgfTtcbn07XG5cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUlubGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLmpzIiwiLy8gU2tpcCB0ZXh0IGNoYXJhY3RlcnMgZm9yIHRleHQgdG9rZW4sIHBsYWNlIHRob3NlIHRvIHBlbmRpbmcgYnVmZmVyXG4vLyBhbmQgaW5jcmVtZW50IGN1cnJlbnQgcG9zXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBSdWxlIHRvIHNraXAgcHVyZSB0ZXh0XG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xuXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cblxuLy8gISEhISBEb24ndCBjb25mdXNlIHdpdGggXCJNYXJrZG93biBBU0NJSSBQdW5jdHVhdGlvblwiIGNoYXJzXG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgwQS8qIFxcbiAqLzpcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcblxuICB3aGlsZSAocG9zIDwgc3RhdGUucG9zTWF4ICYmICFpc1Rlcm1pbmF0b3JDaGFyKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zLCBwb3MpOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24sIGZvciBtZW1vcnkuXG4vL1xuLy8gSXQgY29zdHMgMTAlIG9mIHBlcmZvcm1hbmNlLCBidXQgYWxsb3dzIGV4dGVuZCB0ZXJtaW5hdG9ycyBsaXN0LCBpZiBwbGFjZSBpdFxuLy8gdG8gYFBhcmNlcklubGluZWAgcHJvcGVydHkuIFByb2JhYmx5LCB3aWxsIHN3aXRjaCB0byBpdCBzb21ldGltZSwgc3VjaFxuLy8gZmxleGliaWxpdHkgcmVxdWlyZWQuXG5cbi8qXG52YXIgVEVSTUlOQVRPUl9SRSA9IC9bXFxuISMkJSYqK1xcLTo8PT5AW1xcXFxcXF1eX2B7fX5dLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGlkeCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLnNlYXJjaChURVJNSU5BVE9SX1JFKTtcblxuICAvLyBmaXJzdCBjaGFyIGlzIHRlcm1pbmF0b3IgLT4gZW1wdHkgdGV4dFxuICBpZiAoaWR4ID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vIHRlcm1pbmF0b3IgLT4gdGV4dCB0aWxsIGVuZCBvZiBzdHJpbmdcbiAgaWYgKGlkeCA8IDApIHtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MpOyB9XG4gICAgc3RhdGUucG9zID0gc3RhdGUuc3JjLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgaWR4KTsgfVxuXG4gIHN0YXRlLnBvcyArPSBpZHg7XG5cbiAgcmV0dXJuIHRydWU7XG59OyovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCIvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGludG8gb25lLCBhbmQgcmUtY2FsY3VsYXRlIGFsbCB0b2tlbiBsZXZlbHNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0X2NvbGxhcHNlKHN0YXRlKSB7XG4gIHZhciBjdXJyLCBsYXN0LFxuICAgICAgbGV2ZWwgPSAwLFxuICAgICAgdG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbWF4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBmb3IgKGN1cnIgPSBsYXN0ID0gMDsgY3VyciA8IG1heDsgY3VycisrKSB7XG4gICAgLy8gcmUtY2FsY3VsYXRlIGxldmVsc1xuICAgIGxldmVsICs9IHRva2Vuc1tjdXJyXS5uZXN0aW5nO1xuICAgIHRva2Vuc1tjdXJyXS5sZXZlbCA9IGxldmVsO1xuXG4gICAgaWYgKHRva2Vuc1tjdXJyXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgY3VyciArIDEgPCBtYXggJiZcbiAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS50eXBlID09PSAndGV4dCcpIHtcblxuICAgICAgLy8gY29sbGFwc2UgdHdvIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgIHRva2Vuc1tjdXJyICsgMV0uY29udGVudCA9IHRva2Vuc1tjdXJyXS5jb250ZW50ICsgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkgeyB0b2tlbnNbbGFzdF0gPSB0b2tlbnNbY3Vycl07IH1cblxuICAgICAgbGFzdCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyICE9PSBsYXN0KSB7XG4gICAgdG9rZW5zLmxlbmd0aCA9IGxhc3Q7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbnZhciBkZWNvZGVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgY2FjaGUucHVzaChjaCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gZXhjbHVkZS5jaGFyQ29kZUF0KGkpO1xuICAgIGNhY2hlW2NoXSA9ICclJyArICgnMCcgKyBjaC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIERlY29kZSBwZXJjZW50LWVuY29kZWQgc3RyaW5nLlxuLy9cbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGV4Y2x1ZGUpIHtcbiAgdmFyIGNhY2hlO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICBleGNsdWRlID0gZGVjb2RlLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oJVthLWYwLTldezJ9KSsvZ2ksIGZ1bmN0aW9uKHNlcSkge1xuICAgIHZhciBpLCBsLCBiMSwgYjIsIGIzLCBiNCwgY2hyLFxuICAgICAgICByZXN1bHQgPSAnJztcblxuICAgIGZvciAoaSA9IDAsIGwgPSBzZXEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICBiMSA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMSwgaSArIDMpLCAxNik7XG5cbiAgICAgIGlmIChiMSA8IDB4ODApIHtcbiAgICAgICAgcmVzdWx0ICs9IGNhY2hlW2IxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEUwKSA9PT0gMHhDMCAmJiAoaSArIDMgPCBsKSkge1xuICAgICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCA2KSAmIDB4N0MwKSB8IChiMiAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGMCkgPT09IDB4RTAgJiYgKGkgKyA2IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxMikgJiAweEYwMDApIHwgKChiMiA8PCA2KSAmIDB4RkMwKSB8IChiMyAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODAwIHx8IChjaHIgPj0gMHhEODAwICYmIGNociA8PSAweERGRkYpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEY4KSA9PT0gMHhGMCAmJiAoaSArIDkgPCBsKSkge1xuICAgICAgICAvLyAxMTExMTB4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcbiAgICAgICAgYjQgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEwLCBpICsgMTIpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwICYmIChiNCAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxOCkgJiAweDFDMDAwMCkgfCAoKGIyIDw8IDEyKSAmIDB4M0YwMDApIHwgKChiMyA8PCA2KSAmIDB4RkMwKSB8IChiNCAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4MTAwMDAgfHwgY2hyID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociAtPSAweDEwMDAwO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKGNociA+PiAxMCksIDB4REMwMCArIChjaHIgJiAweDNGRikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gJ1xcdWZmZmQnO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG5cbmRlY29kZS5kZWZhdWx0Q2hhcnMgICA9ICc7Lz86QCY9KyQsIyc7XG5kZWNvZGUuY29tcG9uZW50Q2hhcnMgPSAnJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2RlY29kZS5qcyIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBlbmNvZGVDYWNoZSA9IHt9O1xuXG5cbi8vIENyZWF0ZSBhIGxvb2t1cCBhcnJheSB3aGVyZSBhbnl0aGluZyBidXQgY2hhcmFjdGVycyBpbiBgY2hhcnNgIHN0cmluZ1xuLy8gYW5kIGFscGhhbnVtZXJpYyBjaGFycyBpcyBwZXJjZW50LWVuY29kZWQuXG4vL1xuZnVuY3Rpb24gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuXG4gICAgaWYgKC9eWzAtOWEtel0kL2kudGVzdChjaCkpIHtcbiAgICAgIC8vIGFsd2F5cyBhbGxvdyB1bmVuY29kZWQgYWxwaGFudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgIGNhY2hlLnB1c2goY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5wdXNoKCclJyArICgnMCcgKyBpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMikpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGVbZXhjbHVkZS5jaGFyQ29kZUF0KGkpXSA9IGV4Y2x1ZGVbaV07XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59XG5cblxuLy8gRW5jb2RlIHVuc2FmZSBjaGFyYWN0ZXJzIHdpdGggcGVyY2VudC1lbmNvZGluZywgc2tpcHBpbmcgYWxyZWFkeVxuLy8gZW5jb2RlZCBzZXF1ZW5jZXMuXG4vL1xuLy8gIC0gc3RyaW5nICAgICAgIC0gc3RyaW5nIHRvIGVuY29kZVxuLy8gIC0gZXhjbHVkZSAgICAgIC0gbGlzdCBvZiBjaGFyYWN0ZXJzIHRvIGlnbm9yZSAoaW4gYWRkaXRpb24gdG8gYS16QS1aMC05KVxuLy8gIC0ga2VlcEVzY2FwZWQgIC0gZG9uJ3QgZW5jb2RlICclJyBpbiBhIGNvcnJlY3QgZXNjYXBlIHNlcXVlbmNlIChkZWZhdWx0OiB0cnVlKVxuLy9cbmZ1bmN0aW9uIGVuY29kZShzdHJpbmcsIGV4Y2x1ZGUsIGtlZXBFc2NhcGVkKSB7XG4gIHZhciBpLCBsLCBjb2RlLCBuZXh0Q29kZSwgY2FjaGUsXG4gICAgICByZXN1bHQgPSAnJztcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZW5jb2RlKHN0cmluZywga2VlcEVzY2FwZWQpXG4gICAga2VlcEVzY2FwZWQgID0gZXhjbHVkZTtcbiAgICBleGNsdWRlID0gZW5jb2RlLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2VlcEVzY2FwZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAga2VlcEVzY2FwZWQgPSB0cnVlO1xuICB9XG5cbiAgY2FjaGUgPSBnZXRFbmNvZGVDYWNoZShleGNsdWRlKTtcblxuICBmb3IgKGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChrZWVwRXNjYXBlZCAmJiBjb2RlID09PSAweDI1IC8qICUgKi8gJiYgaSArIDIgPCBsKSB7XG4gICAgICBpZiAoL15bMC05YS1mXXsyfSQvaS50ZXN0KHN0cmluZy5zbGljZShpICsgMSwgaSArIDMpKSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5nLnNsaWNlKGksIGkgKyAzKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA8IDEyOCkge1xuICAgICAgcmVzdWx0ICs9IGNhY2hlW2NvZGVdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhERkZGKSB7XG4gICAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERCRkYgJiYgaSArIDEgPCBsKSB7XG4gICAgICAgIG5leHRDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICBpZiAobmV4dENvZGUgPj0gMHhEQzAwICYmIG5leHRDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldICsgc3RyaW5nW2kgKyAxXSk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJyVFRiVCRiVCRCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5lbmNvZGUuZGVmYXVsdENoYXJzICAgPSBcIjsvPzpAJj0rJCwtXy4hfionKCkjXCI7XG5lbmNvZGUuY29tcG9uZW50Q2hhcnMgPSBcIi1fLiF+KicoKVwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZW5jb2RlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXQodXJsKSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICByZXN1bHQgKz0gdXJsLnByb3RvY29sIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNsYXNoZXMgPyAnLy8nIDogJyc7XG4gIHJlc3VsdCArPSB1cmwuYXV0aCA/IHVybC5hdXRoICsgJ0AnIDogJyc7XG5cbiAgaWYgKHVybC5ob3N0bmFtZSAmJiB1cmwuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIC8vIGlwdjYgYWRkcmVzc1xuICAgIHJlc3VsdCArPSAnWycgKyB1cmwuaG9zdG5hbWUgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IHVybC5ob3N0bmFtZSB8fCAnJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwucG9ydCA/ICc6JyArIHVybC5wb3J0IDogJyc7XG4gIHJlc3VsdCArPSB1cmwucGF0aG5hbWUgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2VhcmNoIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLmhhc2ggfHwgJyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9mb3JtYXQuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQ2hhbmdlcyBmcm9tIGpveWVudC9ub2RlOlxuLy9cbi8vIDEuIE5vIGxlYWRpbmcgc2xhc2ggaW4gcGF0aHMsXG4vLyAgICBlLmcuIGluIGB1cmwucGFyc2UoJ2h0dHA6Ly9mb28/YmFyJylgIHBhdGhuYW1lIGlzIGBgLCBub3QgYC9gXG4vL1xuLy8gMi4gQmFja3NsYXNoZXMgYXJlIG5vdCByZXBsYWNlZCB3aXRoIHNsYXNoZXMsXG4vLyAgICBzbyBgaHR0cDpcXFxcZXhhbXBsZS5vcmdcXGAgaXMgdHJlYXRlZCBsaWtlIGEgcmVsYXRpdmUgcGF0aFxuLy9cbi8vIDMuIFRyYWlsaW5nIGNvbG9uIGlzIHRyZWF0ZWQgbGlrZSBhIHBhcnQgb2YgdGhlIHBhdGgsXG4vLyAgICBpLmUuIGluIGBodHRwOi8vZXhhbXBsZS5vcmc6Zm9vYCBwYXRobmFtZSBpcyBgOmZvb2Bcbi8vXG4vLyA0LiBOb3RoaW5nIGlzIFVSTC1lbmNvZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LFxuLy8gICAgKGluIGpveWVudC9ub2RlIHNvbWUgY2hhcnMgaW4gYXV0aCBhbmQgcGF0aHMgYXJlIGVuY29kZWQpXG4vL1xuLy8gNS4gYHVybC5wYXJzZSgpYCBkb2VzIG5vdCBoYXZlIGBwYXJzZVF1ZXJ5U3RyaW5nYCBhcmd1bWVudFxuLy9cbi8vIDYuIFJlbW92ZWQgZXh0cmFuZW91cyByZXN1bHQgcHJvcGVydGllczogYGhvc3RgLCBgcGF0aGAsIGBxdWVyeWAsIGV0Yy4sXG4vLyAgICB3aGljaCBjYW4gYmUgY29uc3RydWN0ZWQgdXNpbmcgb3RoZXIgcGFydHMgb2YgdGhlIHVybC5cbi8vXG5cblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsgJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnIF0sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsgJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJyBdLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbICdcXCcnIF0uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbICclJywgJy8nLCAnPycsICc7JywgJyMnIF0uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsgJy8nLCAnPycsICcjJyBdLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2NyaXB0LXVybCAqL1xuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNjcmlwdC11cmwgKi9cblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICB2YXIgaSwgbCwgbG93ZXJQcm90bywgaGVjLCBzbGFzaGVzLFxuICAgICAgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAocmVzdFtob3N0RW5kIC0gMV0gPT09ICc6JykgeyBob3N0RW5kLS07IH1cbiAgICB2YXIgaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KGhvc3QpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oaG9zdCkge1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxQYXJzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL3BhcnNlLmpzIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXHhBRFxcdTA2MDAtXFx1MDYwNVxcdTA2MUNcXHUwNkREXFx1MDcwRlxcdTA4RTJcXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDY0XFx1MjA2Ni1cXHUyMDZGXFx1RkVGRlxcdUZGRjktXFx1RkZGQl18XFx1RDgwNFxcdURDQkR8XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQW55ID0gcmVxdWlyZSgnLi9wcm9wZXJ0aWVzL0FueS9yZWdleCcpO1xuZXhwb3J0cy5DYyAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKTtcbmV4cG9ydHMuQ2YgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NmL3JlZ2V4Jyk7XG5leHBvcnRzLlAgICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5leHBvcnRzLlogICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9aL3JlZ2V4Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJBYWN1dGVcIjogXCLDgVwiLFxuXHRcImFhY3V0ZVwiOiBcIsOhXCIsXG5cdFwiQWJyZXZlXCI6IFwixIJcIixcblx0XCJhYnJldmVcIjogXCLEg1wiLFxuXHRcImFjXCI6IFwi4oi+XCIsXG5cdFwiYWNkXCI6IFwi4oi/XCIsXG5cdFwiYWNFXCI6IFwi4oi+zLNcIixcblx0XCJBY2lyY1wiOiBcIsOCXCIsXG5cdFwiYWNpcmNcIjogXCLDolwiLFxuXHRcImFjdXRlXCI6IFwiwrRcIixcblx0XCJBY3lcIjogXCLQkFwiLFxuXHRcImFjeVwiOiBcItCwXCIsXG5cdFwiQUVsaWdcIjogXCLDhlwiLFxuXHRcImFlbGlnXCI6IFwiw6ZcIixcblx0XCJhZlwiOiBcIuKBoVwiLFxuXHRcIkFmclwiOiBcIvCdlIRcIixcblx0XCJhZnJcIjogXCLwnZSeXCIsXG5cdFwiQWdyYXZlXCI6IFwiw4BcIixcblx0XCJhZ3JhdmVcIjogXCLDoFwiLFxuXHRcImFsZWZzeW1cIjogXCLihLVcIixcblx0XCJhbGVwaFwiOiBcIuKEtVwiLFxuXHRcIkFscGhhXCI6IFwizpFcIixcblx0XCJhbHBoYVwiOiBcIs6xXCIsXG5cdFwiQW1hY3JcIjogXCLEgFwiLFxuXHRcImFtYWNyXCI6IFwixIFcIixcblx0XCJhbWFsZ1wiOiBcIuKov1wiLFxuXHRcImFtcFwiOiBcIiZcIixcblx0XCJBTVBcIjogXCImXCIsXG5cdFwiYW5kYW5kXCI6IFwi4qmVXCIsXG5cdFwiQW5kXCI6IFwi4qmTXCIsXG5cdFwiYW5kXCI6IFwi4oinXCIsXG5cdFwiYW5kZFwiOiBcIuKpnFwiLFxuXHRcImFuZHNsb3BlXCI6IFwi4qmYXCIsXG5cdFwiYW5kdlwiOiBcIuKpmlwiLFxuXHRcImFuZ1wiOiBcIuKIoFwiLFxuXHRcImFuZ2VcIjogXCLipqRcIixcblx0XCJhbmdsZVwiOiBcIuKIoFwiLFxuXHRcImFuZ21zZGFhXCI6IFwi4qaoXCIsXG5cdFwiYW5nbXNkYWJcIjogXCLipqlcIixcblx0XCJhbmdtc2RhY1wiOiBcIuKmqlwiLFxuXHRcImFuZ21zZGFkXCI6IFwi4qarXCIsXG5cdFwiYW5nbXNkYWVcIjogXCLipqxcIixcblx0XCJhbmdtc2RhZlwiOiBcIuKmrVwiLFxuXHRcImFuZ21zZGFnXCI6IFwi4qauXCIsXG5cdFwiYW5nbXNkYWhcIjogXCLipq9cIixcblx0XCJhbmdtc2RcIjogXCLiiKFcIixcblx0XCJhbmdydFwiOiBcIuKIn1wiLFxuXHRcImFuZ3J0dmJcIjogXCLiir5cIixcblx0XCJhbmdydHZiZFwiOiBcIuKmnVwiLFxuXHRcImFuZ3NwaFwiOiBcIuKIolwiLFxuXHRcImFuZ3N0XCI6IFwiw4VcIixcblx0XCJhbmd6YXJyXCI6IFwi4o28XCIsXG5cdFwiQW9nb25cIjogXCLEhFwiLFxuXHRcImFvZ29uXCI6IFwixIVcIixcblx0XCJBb3BmXCI6IFwi8J2UuFwiLFxuXHRcImFvcGZcIjogXCLwnZWSXCIsXG5cdFwiYXBhY2lyXCI6IFwi4qmvXCIsXG5cdFwiYXBcIjogXCLiiYhcIixcblx0XCJhcEVcIjogXCLiqbBcIixcblx0XCJhcGVcIjogXCLiiYpcIixcblx0XCJhcGlkXCI6IFwi4omLXCIsXG5cdFwiYXBvc1wiOiBcIidcIixcblx0XCJBcHBseUZ1bmN0aW9uXCI6IFwi4oGhXCIsXG5cdFwiYXBwcm94XCI6IFwi4omIXCIsXG5cdFwiYXBwcm94ZXFcIjogXCLiiYpcIixcblx0XCJBcmluZ1wiOiBcIsOFXCIsXG5cdFwiYXJpbmdcIjogXCLDpVwiLFxuXHRcIkFzY3JcIjogXCLwnZKcXCIsXG5cdFwiYXNjclwiOiBcIvCdkrZcIixcblx0XCJBc3NpZ25cIjogXCLiiZRcIixcblx0XCJhc3RcIjogXCIqXCIsXG5cdFwiYXN5bXBcIjogXCLiiYhcIixcblx0XCJhc3ltcGVxXCI6IFwi4omNXCIsXG5cdFwiQXRpbGRlXCI6IFwiw4NcIixcblx0XCJhdGlsZGVcIjogXCLDo1wiLFxuXHRcIkF1bWxcIjogXCLDhFwiLFxuXHRcImF1bWxcIjogXCLDpFwiLFxuXHRcImF3Y29uaW50XCI6IFwi4oizXCIsXG5cdFwiYXdpbnRcIjogXCLiqJFcIixcblx0XCJiYWNrY29uZ1wiOiBcIuKJjFwiLFxuXHRcImJhY2tlcHNpbG9uXCI6IFwiz7ZcIixcblx0XCJiYWNrcHJpbWVcIjogXCLigLVcIixcblx0XCJiYWNrc2ltXCI6IFwi4oi9XCIsXG5cdFwiYmFja3NpbWVxXCI6IFwi4ouNXCIsXG5cdFwiQmFja3NsYXNoXCI6IFwi4oiWXCIsXG5cdFwiQmFydlwiOiBcIuKrp1wiLFxuXHRcImJhcnZlZVwiOiBcIuKKvVwiLFxuXHRcImJhcndlZFwiOiBcIuKMhVwiLFxuXHRcIkJhcndlZFwiOiBcIuKMhlwiLFxuXHRcImJhcndlZGdlXCI6IFwi4oyFXCIsXG5cdFwiYmJya1wiOiBcIuKOtVwiLFxuXHRcImJicmt0YnJrXCI6IFwi4o62XCIsXG5cdFwiYmNvbmdcIjogXCLiiYxcIixcblx0XCJCY3lcIjogXCLQkVwiLFxuXHRcImJjeVwiOiBcItCxXCIsXG5cdFwiYmRxdW9cIjogXCLigJ5cIixcblx0XCJiZWNhdXNcIjogXCLiiLVcIixcblx0XCJiZWNhdXNlXCI6IFwi4oi1XCIsXG5cdFwiQmVjYXVzZVwiOiBcIuKItVwiLFxuXHRcImJlbXB0eXZcIjogXCLiprBcIixcblx0XCJiZXBzaVwiOiBcIs+2XCIsXG5cdFwiYmVybm91XCI6IFwi4oSsXCIsXG5cdFwiQmVybm91bGxpc1wiOiBcIuKErFwiLFxuXHRcIkJldGFcIjogXCLOklwiLFxuXHRcImJldGFcIjogXCLOslwiLFxuXHRcImJldGhcIjogXCLihLZcIixcblx0XCJiZXR3ZWVuXCI6IFwi4omsXCIsXG5cdFwiQmZyXCI6IFwi8J2UhVwiLFxuXHRcImJmclwiOiBcIvCdlJ9cIixcblx0XCJiaWdjYXBcIjogXCLii4JcIixcblx0XCJiaWdjaXJjXCI6IFwi4pevXCIsXG5cdFwiYmlnY3VwXCI6IFwi4ouDXCIsXG5cdFwiYmlnb2RvdFwiOiBcIuKogFwiLFxuXHRcImJpZ29wbHVzXCI6IFwi4qiBXCIsXG5cdFwiYmlnb3RpbWVzXCI6IFwi4qiCXCIsXG5cdFwiYmlnc3FjdXBcIjogXCLiqIZcIixcblx0XCJiaWdzdGFyXCI6IFwi4piFXCIsXG5cdFwiYmlndHJpYW5nbGVkb3duXCI6IFwi4pa9XCIsXG5cdFwiYmlndHJpYW5nbGV1cFwiOiBcIuKWs1wiLFxuXHRcImJpZ3VwbHVzXCI6IFwi4qiEXCIsXG5cdFwiYmlndmVlXCI6IFwi4ouBXCIsXG5cdFwiYmlnd2VkZ2VcIjogXCLii4BcIixcblx0XCJia2Fyb3dcIjogXCLipI1cIixcblx0XCJibGFja2xvemVuZ2VcIjogXCLip6tcIixcblx0XCJibGFja3NxdWFyZVwiOiBcIuKWqlwiLFxuXHRcImJsYWNrdHJpYW5nbGVcIjogXCLilrRcIixcblx0XCJibGFja3RyaWFuZ2xlZG93blwiOiBcIuKWvlwiLFxuXHRcImJsYWNrdHJpYW5nbGVsZWZ0XCI6IFwi4peCXCIsXG5cdFwiYmxhY2t0cmlhbmdsZXJpZ2h0XCI6IFwi4pa4XCIsXG5cdFwiYmxhbmtcIjogXCLikKNcIixcblx0XCJibGsxMlwiOiBcIuKWklwiLFxuXHRcImJsazE0XCI6IFwi4paRXCIsXG5cdFwiYmxrMzRcIjogXCLilpNcIixcblx0XCJibG9ja1wiOiBcIuKWiFwiLFxuXHRcImJuZVwiOiBcIj3ig6VcIixcblx0XCJibmVxdWl2XCI6IFwi4omh4oOlXCIsXG5cdFwiYk5vdFwiOiBcIuKrrVwiLFxuXHRcImJub3RcIjogXCLijJBcIixcblx0XCJCb3BmXCI6IFwi8J2UuVwiLFxuXHRcImJvcGZcIjogXCLwnZWTXCIsXG5cdFwiYm90XCI6IFwi4oqlXCIsXG5cdFwiYm90dG9tXCI6IFwi4oqlXCIsXG5cdFwiYm93dGllXCI6IFwi4ouIXCIsXG5cdFwiYm94Ym94XCI6IFwi4qeJXCIsXG5cdFwiYm94ZGxcIjogXCLilJBcIixcblx0XCJib3hkTFwiOiBcIuKVlVwiLFxuXHRcImJveERsXCI6IFwi4pWWXCIsXG5cdFwiYm94RExcIjogXCLilZdcIixcblx0XCJib3hkclwiOiBcIuKUjFwiLFxuXHRcImJveGRSXCI6IFwi4pWSXCIsXG5cdFwiYm94RHJcIjogXCLilZNcIixcblx0XCJib3hEUlwiOiBcIuKVlFwiLFxuXHRcImJveGhcIjogXCLilIBcIixcblx0XCJib3hIXCI6IFwi4pWQXCIsXG5cdFwiYm94aGRcIjogXCLilKxcIixcblx0XCJib3hIZFwiOiBcIuKVpFwiLFxuXHRcImJveGhEXCI6IFwi4pWlXCIsXG5cdFwiYm94SERcIjogXCLilaZcIixcblx0XCJib3hodVwiOiBcIuKUtFwiLFxuXHRcImJveEh1XCI6IFwi4pWnXCIsXG5cdFwiYm94aFVcIjogXCLilahcIixcblx0XCJib3hIVVwiOiBcIuKVqVwiLFxuXHRcImJveG1pbnVzXCI6IFwi4oqfXCIsXG5cdFwiYm94cGx1c1wiOiBcIuKKnlwiLFxuXHRcImJveHRpbWVzXCI6IFwi4oqgXCIsXG5cdFwiYm94dWxcIjogXCLilJhcIixcblx0XCJib3h1TFwiOiBcIuKVm1wiLFxuXHRcImJveFVsXCI6IFwi4pWcXCIsXG5cdFwiYm94VUxcIjogXCLilZ1cIixcblx0XCJib3h1clwiOiBcIuKUlFwiLFxuXHRcImJveHVSXCI6IFwi4pWYXCIsXG5cdFwiYm94VXJcIjogXCLilZlcIixcblx0XCJib3hVUlwiOiBcIuKVmlwiLFxuXHRcImJveHZcIjogXCLilIJcIixcblx0XCJib3hWXCI6IFwi4pWRXCIsXG5cdFwiYm94dmhcIjogXCLilLxcIixcblx0XCJib3h2SFwiOiBcIuKVqlwiLFxuXHRcImJveFZoXCI6IFwi4pWrXCIsXG5cdFwiYm94VkhcIjogXCLilaxcIixcblx0XCJib3h2bFwiOiBcIuKUpFwiLFxuXHRcImJveHZMXCI6IFwi4pWhXCIsXG5cdFwiYm94VmxcIjogXCLilaJcIixcblx0XCJib3hWTFwiOiBcIuKVo1wiLFxuXHRcImJveHZyXCI6IFwi4pScXCIsXG5cdFwiYm94dlJcIjogXCLilZ5cIixcblx0XCJib3hWclwiOiBcIuKVn1wiLFxuXHRcImJveFZSXCI6IFwi4pWgXCIsXG5cdFwiYnByaW1lXCI6IFwi4oC1XCIsXG5cdFwiYnJldmVcIjogXCLLmFwiLFxuXHRcIkJyZXZlXCI6IFwiy5hcIixcblx0XCJicnZiYXJcIjogXCLCplwiLFxuXHRcImJzY3JcIjogXCLwnZK3XCIsXG5cdFwiQnNjclwiOiBcIuKErFwiLFxuXHRcImJzZW1pXCI6IFwi4oGPXCIsXG5cdFwiYnNpbVwiOiBcIuKIvVwiLFxuXHRcImJzaW1lXCI6IFwi4ouNXCIsXG5cdFwiYnNvbGJcIjogXCLip4VcIixcblx0XCJic29sXCI6IFwiXFxcXFwiLFxuXHRcImJzb2xoc3ViXCI6IFwi4p+IXCIsXG5cdFwiYnVsbFwiOiBcIuKAolwiLFxuXHRcImJ1bGxldFwiOiBcIuKAolwiLFxuXHRcImJ1bXBcIjogXCLiiY5cIixcblx0XCJidW1wRVwiOiBcIuKqrlwiLFxuXHRcImJ1bXBlXCI6IFwi4omPXCIsXG5cdFwiQnVtcGVxXCI6IFwi4omOXCIsXG5cdFwiYnVtcGVxXCI6IFwi4omPXCIsXG5cdFwiQ2FjdXRlXCI6IFwixIZcIixcblx0XCJjYWN1dGVcIjogXCLEh1wiLFxuXHRcImNhcGFuZFwiOiBcIuKphFwiLFxuXHRcImNhcGJyY3VwXCI6IFwi4qmJXCIsXG5cdFwiY2FwY2FwXCI6IFwi4qmLXCIsXG5cdFwiY2FwXCI6IFwi4oipXCIsXG5cdFwiQ2FwXCI6IFwi4ouSXCIsXG5cdFwiY2FwY3VwXCI6IFwi4qmHXCIsXG5cdFwiY2FwZG90XCI6IFwi4qmAXCIsXG5cdFwiQ2FwaXRhbERpZmZlcmVudGlhbERcIjogXCLihYVcIixcblx0XCJjYXBzXCI6IFwi4oip77iAXCIsXG5cdFwiY2FyZXRcIjogXCLigYFcIixcblx0XCJjYXJvblwiOiBcIsuHXCIsXG5cdFwiQ2F5bGV5c1wiOiBcIuKErVwiLFxuXHRcImNjYXBzXCI6IFwi4qmNXCIsXG5cdFwiQ2Nhcm9uXCI6IFwixIxcIixcblx0XCJjY2Fyb25cIjogXCLEjVwiLFxuXHRcIkNjZWRpbFwiOiBcIsOHXCIsXG5cdFwiY2NlZGlsXCI6IFwiw6dcIixcblx0XCJDY2lyY1wiOiBcIsSIXCIsXG5cdFwiY2NpcmNcIjogXCLEiVwiLFxuXHRcIkNjb25pbnRcIjogXCLiiLBcIixcblx0XCJjY3Vwc1wiOiBcIuKpjFwiLFxuXHRcImNjdXBzc21cIjogXCLiqZBcIixcblx0XCJDZG90XCI6IFwixIpcIixcblx0XCJjZG90XCI6IFwixItcIixcblx0XCJjZWRpbFwiOiBcIsK4XCIsXG5cdFwiQ2VkaWxsYVwiOiBcIsK4XCIsXG5cdFwiY2VtcHR5dlwiOiBcIuKmslwiLFxuXHRcImNlbnRcIjogXCLColwiLFxuXHRcImNlbnRlcmRvdFwiOiBcIsK3XCIsXG5cdFwiQ2VudGVyRG90XCI6IFwiwrdcIixcblx0XCJjZnJcIjogXCLwnZSgXCIsXG5cdFwiQ2ZyXCI6IFwi4oStXCIsXG5cdFwiQ0hjeVwiOiBcItCnXCIsXG5cdFwiY2hjeVwiOiBcItGHXCIsXG5cdFwiY2hlY2tcIjogXCLinJNcIixcblx0XCJjaGVja21hcmtcIjogXCLinJNcIixcblx0XCJDaGlcIjogXCLOp1wiLFxuXHRcImNoaVwiOiBcIs+HXCIsXG5cdFwiY2lyY1wiOiBcIsuGXCIsXG5cdFwiY2lyY2VxXCI6IFwi4omXXCIsXG5cdFwiY2lyY2xlYXJyb3dsZWZ0XCI6IFwi4oa6XCIsXG5cdFwiY2lyY2xlYXJyb3dyaWdodFwiOiBcIuKGu1wiLFxuXHRcImNpcmNsZWRhc3RcIjogXCLiiptcIixcblx0XCJjaXJjbGVkY2lyY1wiOiBcIuKKmlwiLFxuXHRcImNpcmNsZWRkYXNoXCI6IFwi4oqdXCIsXG5cdFwiQ2lyY2xlRG90XCI6IFwi4oqZXCIsXG5cdFwiY2lyY2xlZFJcIjogXCLCrlwiLFxuXHRcImNpcmNsZWRTXCI6IFwi4pOIXCIsXG5cdFwiQ2lyY2xlTWludXNcIjogXCLiipZcIixcblx0XCJDaXJjbGVQbHVzXCI6IFwi4oqVXCIsXG5cdFwiQ2lyY2xlVGltZXNcIjogXCLiipdcIixcblx0XCJjaXJcIjogXCLil4tcIixcblx0XCJjaXJFXCI6IFwi4qeDXCIsXG5cdFwiY2lyZVwiOiBcIuKJl1wiLFxuXHRcImNpcmZuaW50XCI6IFwi4qiQXCIsXG5cdFwiY2lybWlkXCI6IFwi4quvXCIsXG5cdFwiY2lyc2NpclwiOiBcIuKnglwiLFxuXHRcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOiBcIuKIslwiLFxuXHRcIkNsb3NlQ3VybHlEb3VibGVRdW90ZVwiOiBcIuKAnVwiLFxuXHRcIkNsb3NlQ3VybHlRdW90ZVwiOiBcIuKAmVwiLFxuXHRcImNsdWJzXCI6IFwi4pmjXCIsXG5cdFwiY2x1YnN1aXRcIjogXCLimaNcIixcblx0XCJjb2xvblwiOiBcIjpcIixcblx0XCJDb2xvblwiOiBcIuKIt1wiLFxuXHRcIkNvbG9uZVwiOiBcIuKptFwiLFxuXHRcImNvbG9uZVwiOiBcIuKJlFwiLFxuXHRcImNvbG9uZXFcIjogXCLiiZRcIixcblx0XCJjb21tYVwiOiBcIixcIixcblx0XCJjb21tYXRcIjogXCJAXCIsXG5cdFwiY29tcFwiOiBcIuKIgVwiLFxuXHRcImNvbXBmblwiOiBcIuKImFwiLFxuXHRcImNvbXBsZW1lbnRcIjogXCLiiIFcIixcblx0XCJjb21wbGV4ZXNcIjogXCLihIJcIixcblx0XCJjb25nXCI6IFwi4omFXCIsXG5cdFwiY29uZ2RvdFwiOiBcIuKprVwiLFxuXHRcIkNvbmdydWVudFwiOiBcIuKJoVwiLFxuXHRcImNvbmludFwiOiBcIuKIrlwiLFxuXHRcIkNvbmludFwiOiBcIuKIr1wiLFxuXHRcIkNvbnRvdXJJbnRlZ3JhbFwiOiBcIuKIrlwiLFxuXHRcImNvcGZcIjogXCLwnZWUXCIsXG5cdFwiQ29wZlwiOiBcIuKEglwiLFxuXHRcImNvcHJvZFwiOiBcIuKIkFwiLFxuXHRcIkNvcHJvZHVjdFwiOiBcIuKIkFwiLFxuXHRcImNvcHlcIjogXCLCqVwiLFxuXHRcIkNPUFlcIjogXCLCqVwiLFxuXHRcImNvcHlzclwiOiBcIuKEl1wiLFxuXHRcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjogXCLiiLNcIixcblx0XCJjcmFyclwiOiBcIuKGtVwiLFxuXHRcImNyb3NzXCI6IFwi4pyXXCIsXG5cdFwiQ3Jvc3NcIjogXCLiqK9cIixcblx0XCJDc2NyXCI6IFwi8J2SnlwiLFxuXHRcImNzY3JcIjogXCLwnZK4XCIsXG5cdFwiY3N1YlwiOiBcIuKrj1wiLFxuXHRcImNzdWJlXCI6IFwi4quRXCIsXG5cdFwiY3N1cFwiOiBcIuKrkFwiLFxuXHRcImNzdXBlXCI6IFwi4quSXCIsXG5cdFwiY3Rkb3RcIjogXCLii69cIixcblx0XCJjdWRhcnJsXCI6IFwi4qS4XCIsXG5cdFwiY3VkYXJyclwiOiBcIuKktVwiLFxuXHRcImN1ZXByXCI6IFwi4oueXCIsXG5cdFwiY3Vlc2NcIjogXCLii59cIixcblx0XCJjdWxhcnJcIjogXCLihrZcIixcblx0XCJjdWxhcnJwXCI6IFwi4qS9XCIsXG5cdFwiY3VwYnJjYXBcIjogXCLiqYhcIixcblx0XCJjdXBjYXBcIjogXCLiqYZcIixcblx0XCJDdXBDYXBcIjogXCLiiY1cIixcblx0XCJjdXBcIjogXCLiiKpcIixcblx0XCJDdXBcIjogXCLii5NcIixcblx0XCJjdXBjdXBcIjogXCLiqYpcIixcblx0XCJjdXBkb3RcIjogXCLiio1cIixcblx0XCJjdXBvclwiOiBcIuKphVwiLFxuXHRcImN1cHNcIjogXCLiiKrvuIBcIixcblx0XCJjdXJhcnJcIjogXCLihrdcIixcblx0XCJjdXJhcnJtXCI6IFwi4qS8XCIsXG5cdFwiY3VybHllcXByZWNcIjogXCLii55cIixcblx0XCJjdXJseWVxc3VjY1wiOiBcIuKLn1wiLFxuXHRcImN1cmx5dmVlXCI6IFwi4ouOXCIsXG5cdFwiY3VybHl3ZWRnZVwiOiBcIuKLj1wiLFxuXHRcImN1cnJlblwiOiBcIsKkXCIsXG5cdFwiY3VydmVhcnJvd2xlZnRcIjogXCLihrZcIixcblx0XCJjdXJ2ZWFycm93cmlnaHRcIjogXCLihrdcIixcblx0XCJjdXZlZVwiOiBcIuKLjlwiLFxuXHRcImN1d2VkXCI6IFwi4ouPXCIsXG5cdFwiY3djb25pbnRcIjogXCLiiLJcIixcblx0XCJjd2ludFwiOiBcIuKIsVwiLFxuXHRcImN5bGN0eVwiOiBcIuKMrVwiLFxuXHRcImRhZ2dlclwiOiBcIuKAoFwiLFxuXHRcIkRhZ2dlclwiOiBcIuKAoVwiLFxuXHRcImRhbGV0aFwiOiBcIuKEuFwiLFxuXHRcImRhcnJcIjogXCLihpNcIixcblx0XCJEYXJyXCI6IFwi4oahXCIsXG5cdFwiZEFyclwiOiBcIuKHk1wiLFxuXHRcImRhc2hcIjogXCLigJBcIixcblx0XCJEYXNodlwiOiBcIuKrpFwiLFxuXHRcImRhc2h2XCI6IFwi4oqjXCIsXG5cdFwiZGJrYXJvd1wiOiBcIuKkj1wiLFxuXHRcImRibGFjXCI6IFwiy51cIixcblx0XCJEY2Fyb25cIjogXCLEjlwiLFxuXHRcImRjYXJvblwiOiBcIsSPXCIsXG5cdFwiRGN5XCI6IFwi0JRcIixcblx0XCJkY3lcIjogXCLQtFwiLFxuXHRcImRkYWdnZXJcIjogXCLigKFcIixcblx0XCJkZGFyclwiOiBcIuKHilwiLFxuXHRcIkREXCI6IFwi4oWFXCIsXG5cdFwiZGRcIjogXCLihYZcIixcblx0XCJERG90cmFoZFwiOiBcIuKkkVwiLFxuXHRcImRkb3RzZXFcIjogXCLiqbdcIixcblx0XCJkZWdcIjogXCLCsFwiLFxuXHRcIkRlbFwiOiBcIuKIh1wiLFxuXHRcIkRlbHRhXCI6IFwizpRcIixcblx0XCJkZWx0YVwiOiBcIs60XCIsXG5cdFwiZGVtcHR5dlwiOiBcIuKmsVwiLFxuXHRcImRmaXNodFwiOiBcIuKlv1wiLFxuXHRcIkRmclwiOiBcIvCdlIdcIixcblx0XCJkZnJcIjogXCLwnZShXCIsXG5cdFwiZEhhclwiOiBcIuKlpVwiLFxuXHRcImRoYXJsXCI6IFwi4oeDXCIsXG5cdFwiZGhhcnJcIjogXCLih4JcIixcblx0XCJEaWFjcml0aWNhbEFjdXRlXCI6IFwiwrRcIixcblx0XCJEaWFjcml0aWNhbERvdFwiOiBcIsuZXCIsXG5cdFwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZVwiOiBcIsudXCIsXG5cdFwiRGlhY3JpdGljYWxHcmF2ZVwiOiBcImBcIixcblx0XCJEaWFjcml0aWNhbFRpbGRlXCI6IFwiy5xcIixcblx0XCJkaWFtXCI6IFwi4ouEXCIsXG5cdFwiZGlhbW9uZFwiOiBcIuKLhFwiLFxuXHRcIkRpYW1vbmRcIjogXCLii4RcIixcblx0XCJkaWFtb25kc3VpdFwiOiBcIuKZplwiLFxuXHRcImRpYW1zXCI6IFwi4pmmXCIsXG5cdFwiZGllXCI6IFwiwqhcIixcblx0XCJEaWZmZXJlbnRpYWxEXCI6IFwi4oWGXCIsXG5cdFwiZGlnYW1tYVwiOiBcIs+dXCIsXG5cdFwiZGlzaW5cIjogXCLii7JcIixcblx0XCJkaXZcIjogXCLDt1wiLFxuXHRcImRpdmlkZVwiOiBcIsO3XCIsXG5cdFwiZGl2aWRlb250aW1lc1wiOiBcIuKLh1wiLFxuXHRcImRpdm9ueFwiOiBcIuKLh1wiLFxuXHRcIkRKY3lcIjogXCLQglwiLFxuXHRcImRqY3lcIjogXCLRklwiLFxuXHRcImRsY29yblwiOiBcIuKMnlwiLFxuXHRcImRsY3JvcFwiOiBcIuKMjVwiLFxuXHRcImRvbGxhclwiOiBcIiRcIixcblx0XCJEb3BmXCI6IFwi8J2Uu1wiLFxuXHRcImRvcGZcIjogXCLwnZWVXCIsXG5cdFwiRG90XCI6IFwiwqhcIixcblx0XCJkb3RcIjogXCLLmVwiLFxuXHRcIkRvdERvdFwiOiBcIuKDnFwiLFxuXHRcImRvdGVxXCI6IFwi4omQXCIsXG5cdFwiZG90ZXFkb3RcIjogXCLiiZFcIixcblx0XCJEb3RFcXVhbFwiOiBcIuKJkFwiLFxuXHRcImRvdG1pbnVzXCI6IFwi4oi4XCIsXG5cdFwiZG90cGx1c1wiOiBcIuKIlFwiLFxuXHRcImRvdHNxdWFyZVwiOiBcIuKKoVwiLFxuXHRcImRvdWJsZWJhcndlZGdlXCI6IFwi4oyGXCIsXG5cdFwiRG91YmxlQ29udG91ckludGVncmFsXCI6IFwi4oivXCIsXG5cdFwiRG91YmxlRG90XCI6IFwiwqhcIixcblx0XCJEb3VibGVEb3duQXJyb3dcIjogXCLih5NcIixcblx0XCJEb3VibGVMZWZ0QXJyb3dcIjogXCLih5BcIixcblx0XCJEb3VibGVMZWZ0UmlnaHRBcnJvd1wiOiBcIuKHlFwiLFxuXHRcIkRvdWJsZUxlZnRUZWVcIjogXCLiq6RcIixcblx0XCJEb3VibGVMb25nTGVmdEFycm93XCI6IFwi4p+4XCIsXG5cdFwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93XCI6IFwi4p+6XCIsXG5cdFwiRG91YmxlTG9uZ1JpZ2h0QXJyb3dcIjogXCLin7lcIixcblx0XCJEb3VibGVSaWdodEFycm93XCI6IFwi4oeSXCIsXG5cdFwiRG91YmxlUmlnaHRUZWVcIjogXCLiiqhcIixcblx0XCJEb3VibGVVcEFycm93XCI6IFwi4oeRXCIsXG5cdFwiRG91YmxlVXBEb3duQXJyb3dcIjogXCLih5VcIixcblx0XCJEb3VibGVWZXJ0aWNhbEJhclwiOiBcIuKIpVwiLFxuXHRcIkRvd25BcnJvd0JhclwiOiBcIuKkk1wiLFxuXHRcImRvd25hcnJvd1wiOiBcIuKGk1wiLFxuXHRcIkRvd25BcnJvd1wiOiBcIuKGk1wiLFxuXHRcIkRvd25hcnJvd1wiOiBcIuKHk1wiLFxuXHRcIkRvd25BcnJvd1VwQXJyb3dcIjogXCLih7VcIixcblx0XCJEb3duQnJldmVcIjogXCLMkVwiLFxuXHRcImRvd25kb3duYXJyb3dzXCI6IFwi4oeKXCIsXG5cdFwiZG93bmhhcnBvb25sZWZ0XCI6IFwi4oeDXCIsXG5cdFwiZG93bmhhcnBvb25yaWdodFwiOiBcIuKHglwiLFxuXHRcIkRvd25MZWZ0UmlnaHRWZWN0b3JcIjogXCLipZBcIixcblx0XCJEb3duTGVmdFRlZVZlY3RvclwiOiBcIuKlnlwiLFxuXHRcIkRvd25MZWZ0VmVjdG9yQmFyXCI6IFwi4qWWXCIsXG5cdFwiRG93bkxlZnRWZWN0b3JcIjogXCLihr1cIixcblx0XCJEb3duUmlnaHRUZWVWZWN0b3JcIjogXCLipZ9cIixcblx0XCJEb3duUmlnaHRWZWN0b3JCYXJcIjogXCLipZdcIixcblx0XCJEb3duUmlnaHRWZWN0b3JcIjogXCLih4FcIixcblx0XCJEb3duVGVlQXJyb3dcIjogXCLihqdcIixcblx0XCJEb3duVGVlXCI6IFwi4oqkXCIsXG5cdFwiZHJia2Fyb3dcIjogXCLipJBcIixcblx0XCJkcmNvcm5cIjogXCLijJ9cIixcblx0XCJkcmNyb3BcIjogXCLijIxcIixcblx0XCJEc2NyXCI6IFwi8J2Sn1wiLFxuXHRcImRzY3JcIjogXCLwnZK5XCIsXG5cdFwiRFNjeVwiOiBcItCFXCIsXG5cdFwiZHNjeVwiOiBcItGVXCIsXG5cdFwiZHNvbFwiOiBcIuKntlwiLFxuXHRcIkRzdHJva1wiOiBcIsSQXCIsXG5cdFwiZHN0cm9rXCI6IFwixJFcIixcblx0XCJkdGRvdFwiOiBcIuKLsVwiLFxuXHRcImR0cmlcIjogXCLilr9cIixcblx0XCJkdHJpZlwiOiBcIuKWvlwiLFxuXHRcImR1YXJyXCI6IFwi4oe1XCIsXG5cdFwiZHVoYXJcIjogXCLipa9cIixcblx0XCJkd2FuZ2xlXCI6IFwi4qamXCIsXG5cdFwiRFpjeVwiOiBcItCPXCIsXG5cdFwiZHpjeVwiOiBcItGfXCIsXG5cdFwiZHppZ3JhcnJcIjogXCLin79cIixcblx0XCJFYWN1dGVcIjogXCLDiVwiLFxuXHRcImVhY3V0ZVwiOiBcIsOpXCIsXG5cdFwiZWFzdGVyXCI6IFwi4qmuXCIsXG5cdFwiRWNhcm9uXCI6IFwixJpcIixcblx0XCJlY2Fyb25cIjogXCLEm1wiLFxuXHRcIkVjaXJjXCI6IFwiw4pcIixcblx0XCJlY2lyY1wiOiBcIsOqXCIsXG5cdFwiZWNpclwiOiBcIuKJllwiLFxuXHRcImVjb2xvblwiOiBcIuKJlVwiLFxuXHRcIkVjeVwiOiBcItCtXCIsXG5cdFwiZWN5XCI6IFwi0Y1cIixcblx0XCJlRERvdFwiOiBcIuKpt1wiLFxuXHRcIkVkb3RcIjogXCLEllwiLFxuXHRcImVkb3RcIjogXCLEl1wiLFxuXHRcImVEb3RcIjogXCLiiZFcIixcblx0XCJlZVwiOiBcIuKFh1wiLFxuXHRcImVmRG90XCI6IFwi4omSXCIsXG5cdFwiRWZyXCI6IFwi8J2UiFwiLFxuXHRcImVmclwiOiBcIvCdlKJcIixcblx0XCJlZ1wiOiBcIuKqmlwiLFxuXHRcIkVncmF2ZVwiOiBcIsOIXCIsXG5cdFwiZWdyYXZlXCI6IFwiw6hcIixcblx0XCJlZ3NcIjogXCLiqpZcIixcblx0XCJlZ3Nkb3RcIjogXCLiqphcIixcblx0XCJlbFwiOiBcIuKqmVwiLFxuXHRcIkVsZW1lbnRcIjogXCLiiIhcIixcblx0XCJlbGludGVyc1wiOiBcIuKPp1wiLFxuXHRcImVsbFwiOiBcIuKEk1wiLFxuXHRcImVsc1wiOiBcIuKqlVwiLFxuXHRcImVsc2RvdFwiOiBcIuKql1wiLFxuXHRcIkVtYWNyXCI6IFwixJJcIixcblx0XCJlbWFjclwiOiBcIsSTXCIsXG5cdFwiZW1wdHlcIjogXCLiiIVcIixcblx0XCJlbXB0eXNldFwiOiBcIuKIhVwiLFxuXHRcIkVtcHR5U21hbGxTcXVhcmVcIjogXCLil7tcIixcblx0XCJlbXB0eXZcIjogXCLiiIVcIixcblx0XCJFbXB0eVZlcnlTbWFsbFNxdWFyZVwiOiBcIuKWq1wiLFxuXHRcImVtc3AxM1wiOiBcIuKAhFwiLFxuXHRcImVtc3AxNFwiOiBcIuKAhVwiLFxuXHRcImVtc3BcIjogXCLigINcIixcblx0XCJFTkdcIjogXCLFilwiLFxuXHRcImVuZ1wiOiBcIsWLXCIsXG5cdFwiZW5zcFwiOiBcIuKAglwiLFxuXHRcIkVvZ29uXCI6IFwixJhcIixcblx0XCJlb2dvblwiOiBcIsSZXCIsXG5cdFwiRW9wZlwiOiBcIvCdlLxcIixcblx0XCJlb3BmXCI6IFwi8J2VllwiLFxuXHRcImVwYXJcIjogXCLii5VcIixcblx0XCJlcGFyc2xcIjogXCLip6NcIixcblx0XCJlcGx1c1wiOiBcIuKpsVwiLFxuXHRcImVwc2lcIjogXCLOtVwiLFxuXHRcIkVwc2lsb25cIjogXCLOlVwiLFxuXHRcImVwc2lsb25cIjogXCLOtVwiLFxuXHRcImVwc2l2XCI6IFwiz7VcIixcblx0XCJlcWNpcmNcIjogXCLiiZZcIixcblx0XCJlcWNvbG9uXCI6IFwi4omVXCIsXG5cdFwiZXFzaW1cIjogXCLiiYJcIixcblx0XCJlcXNsYW50Z3RyXCI6IFwi4qqWXCIsXG5cdFwiZXFzbGFudGxlc3NcIjogXCLiqpVcIixcblx0XCJFcXVhbFwiOiBcIuKptVwiLFxuXHRcImVxdWFsc1wiOiBcIj1cIixcblx0XCJFcXVhbFRpbGRlXCI6IFwi4omCXCIsXG5cdFwiZXF1ZXN0XCI6IFwi4omfXCIsXG5cdFwiRXF1aWxpYnJpdW1cIjogXCLih4xcIixcblx0XCJlcXVpdlwiOiBcIuKJoVwiLFxuXHRcImVxdWl2RERcIjogXCLiqbhcIixcblx0XCJlcXZwYXJzbFwiOiBcIuKnpVwiLFxuXHRcImVyYXJyXCI6IFwi4qWxXCIsXG5cdFwiZXJEb3RcIjogXCLiiZNcIixcblx0XCJlc2NyXCI6IFwi4oSvXCIsXG5cdFwiRXNjclwiOiBcIuKEsFwiLFxuXHRcImVzZG90XCI6IFwi4omQXCIsXG5cdFwiRXNpbVwiOiBcIuKps1wiLFxuXHRcImVzaW1cIjogXCLiiYJcIixcblx0XCJFdGFcIjogXCLOl1wiLFxuXHRcImV0YVwiOiBcIs63XCIsXG5cdFwiRVRIXCI6IFwiw5BcIixcblx0XCJldGhcIjogXCLDsFwiLFxuXHRcIkV1bWxcIjogXCLDi1wiLFxuXHRcImV1bWxcIjogXCLDq1wiLFxuXHRcImV1cm9cIjogXCLigqxcIixcblx0XCJleGNsXCI6IFwiIVwiLFxuXHRcImV4aXN0XCI6IFwi4oiDXCIsXG5cdFwiRXhpc3RzXCI6IFwi4oiDXCIsXG5cdFwiZXhwZWN0YXRpb25cIjogXCLihLBcIixcblx0XCJleHBvbmVudGlhbGVcIjogXCLihYdcIixcblx0XCJFeHBvbmVudGlhbEVcIjogXCLihYdcIixcblx0XCJmYWxsaW5nZG90c2VxXCI6IFwi4omSXCIsXG5cdFwiRmN5XCI6IFwi0KRcIixcblx0XCJmY3lcIjogXCLRhFwiLFxuXHRcImZlbWFsZVwiOiBcIuKZgFwiLFxuXHRcImZmaWxpZ1wiOiBcIu+sg1wiLFxuXHRcImZmbGlnXCI6IFwi76yAXCIsXG5cdFwiZmZsbGlnXCI6IFwi76yEXCIsXG5cdFwiRmZyXCI6IFwi8J2UiVwiLFxuXHRcImZmclwiOiBcIvCdlKNcIixcblx0XCJmaWxpZ1wiOiBcIu+sgVwiLFxuXHRcIkZpbGxlZFNtYWxsU3F1YXJlXCI6IFwi4pe8XCIsXG5cdFwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlXCI6IFwi4paqXCIsXG5cdFwiZmpsaWdcIjogXCJmalwiLFxuXHRcImZsYXRcIjogXCLima1cIixcblx0XCJmbGxpZ1wiOiBcIu+sglwiLFxuXHRcImZsdG5zXCI6IFwi4paxXCIsXG5cdFwiZm5vZlwiOiBcIsaSXCIsXG5cdFwiRm9wZlwiOiBcIvCdlL1cIixcblx0XCJmb3BmXCI6IFwi8J2Vl1wiLFxuXHRcImZvcmFsbFwiOiBcIuKIgFwiLFxuXHRcIkZvckFsbFwiOiBcIuKIgFwiLFxuXHRcImZvcmtcIjogXCLii5RcIixcblx0XCJmb3JrdlwiOiBcIuKrmVwiLFxuXHRcIkZvdXJpZXJ0cmZcIjogXCLihLFcIixcblx0XCJmcGFydGludFwiOiBcIuKojVwiLFxuXHRcImZyYWMxMlwiOiBcIsK9XCIsXG5cdFwiZnJhYzEzXCI6IFwi4oWTXCIsXG5cdFwiZnJhYzE0XCI6IFwiwrxcIixcblx0XCJmcmFjMTVcIjogXCLihZVcIixcblx0XCJmcmFjMTZcIjogXCLihZlcIixcblx0XCJmcmFjMThcIjogXCLihZtcIixcblx0XCJmcmFjMjNcIjogXCLihZRcIixcblx0XCJmcmFjMjVcIjogXCLihZZcIixcblx0XCJmcmFjMzRcIjogXCLCvlwiLFxuXHRcImZyYWMzNVwiOiBcIuKFl1wiLFxuXHRcImZyYWMzOFwiOiBcIuKFnFwiLFxuXHRcImZyYWM0NVwiOiBcIuKFmFwiLFxuXHRcImZyYWM1NlwiOiBcIuKFmlwiLFxuXHRcImZyYWM1OFwiOiBcIuKFnVwiLFxuXHRcImZyYWM3OFwiOiBcIuKFnlwiLFxuXHRcImZyYXNsXCI6IFwi4oGEXCIsXG5cdFwiZnJvd25cIjogXCLijKJcIixcblx0XCJmc2NyXCI6IFwi8J2Su1wiLFxuXHRcIkZzY3JcIjogXCLihLFcIixcblx0XCJnYWN1dGVcIjogXCLHtVwiLFxuXHRcIkdhbW1hXCI6IFwizpNcIixcblx0XCJnYW1tYVwiOiBcIs6zXCIsXG5cdFwiR2FtbWFkXCI6IFwiz5xcIixcblx0XCJnYW1tYWRcIjogXCLPnVwiLFxuXHRcImdhcFwiOiBcIuKqhlwiLFxuXHRcIkdicmV2ZVwiOiBcIsSeXCIsXG5cdFwiZ2JyZXZlXCI6IFwixJ9cIixcblx0XCJHY2VkaWxcIjogXCLEolwiLFxuXHRcIkdjaXJjXCI6IFwixJxcIixcblx0XCJnY2lyY1wiOiBcIsSdXCIsXG5cdFwiR2N5XCI6IFwi0JNcIixcblx0XCJnY3lcIjogXCLQs1wiLFxuXHRcIkdkb3RcIjogXCLEoFwiLFxuXHRcImdkb3RcIjogXCLEoVwiLFxuXHRcImdlXCI6IFwi4omlXCIsXG5cdFwiZ0VcIjogXCLiiadcIixcblx0XCJnRWxcIjogXCLiqoxcIixcblx0XCJnZWxcIjogXCLii5tcIixcblx0XCJnZXFcIjogXCLiiaVcIixcblx0XCJnZXFxXCI6IFwi4omnXCIsXG5cdFwiZ2Vxc2xhbnRcIjogXCLiqb5cIixcblx0XCJnZXNjY1wiOiBcIuKqqVwiLFxuXHRcImdlc1wiOiBcIuKpvlwiLFxuXHRcImdlc2RvdFwiOiBcIuKqgFwiLFxuXHRcImdlc2RvdG9cIjogXCLiqoJcIixcblx0XCJnZXNkb3RvbFwiOiBcIuKqhFwiLFxuXHRcImdlc2xcIjogXCLii5vvuIBcIixcblx0XCJnZXNsZXNcIjogXCLiqpRcIixcblx0XCJHZnJcIjogXCLwnZSKXCIsXG5cdFwiZ2ZyXCI6IFwi8J2UpFwiLFxuXHRcImdnXCI6IFwi4omrXCIsXG5cdFwiR2dcIjogXCLii5lcIixcblx0XCJnZ2dcIjogXCLii5lcIixcblx0XCJnaW1lbFwiOiBcIuKEt1wiLFxuXHRcIkdKY3lcIjogXCLQg1wiLFxuXHRcImdqY3lcIjogXCLRk1wiLFxuXHRcImdsYVwiOiBcIuKqpVwiLFxuXHRcImdsXCI6IFwi4om3XCIsXG5cdFwiZ2xFXCI6IFwi4qqSXCIsXG5cdFwiZ2xqXCI6IFwi4qqkXCIsXG5cdFwiZ25hcFwiOiBcIuKqilwiLFxuXHRcImduYXBwcm94XCI6IFwi4qqKXCIsXG5cdFwiZ25lXCI6IFwi4qqIXCIsXG5cdFwiZ25FXCI6IFwi4ompXCIsXG5cdFwiZ25lcVwiOiBcIuKqiFwiLFxuXHRcImduZXFxXCI6IFwi4ompXCIsXG5cdFwiZ25zaW1cIjogXCLii6dcIixcblx0XCJHb3BmXCI6IFwi8J2UvlwiLFxuXHRcImdvcGZcIjogXCLwnZWYXCIsXG5cdFwiZ3JhdmVcIjogXCJgXCIsXG5cdFwiR3JlYXRlckVxdWFsXCI6IFwi4omlXCIsXG5cdFwiR3JlYXRlckVxdWFsTGVzc1wiOiBcIuKLm1wiLFxuXHRcIkdyZWF0ZXJGdWxsRXF1YWxcIjogXCLiiadcIixcblx0XCJHcmVhdGVyR3JlYXRlclwiOiBcIuKqolwiLFxuXHRcIkdyZWF0ZXJMZXNzXCI6IFwi4om3XCIsXG5cdFwiR3JlYXRlclNsYW50RXF1YWxcIjogXCLiqb5cIixcblx0XCJHcmVhdGVyVGlsZGVcIjogXCLiibNcIixcblx0XCJHc2NyXCI6IFwi8J2SolwiLFxuXHRcImdzY3JcIjogXCLihIpcIixcblx0XCJnc2ltXCI6IFwi4omzXCIsXG5cdFwiZ3NpbWVcIjogXCLiqo5cIixcblx0XCJnc2ltbFwiOiBcIuKqkFwiLFxuXHRcImd0Y2NcIjogXCLiqqdcIixcblx0XCJndGNpclwiOiBcIuKpulwiLFxuXHRcImd0XCI6IFwiPlwiLFxuXHRcIkdUXCI6IFwiPlwiLFxuXHRcIkd0XCI6IFwi4omrXCIsXG5cdFwiZ3Rkb3RcIjogXCLii5dcIixcblx0XCJndGxQYXJcIjogXCLippVcIixcblx0XCJndHF1ZXN0XCI6IFwi4qm8XCIsXG5cdFwiZ3RyYXBwcm94XCI6IFwi4qqGXCIsXG5cdFwiZ3RyYXJyXCI6IFwi4qW4XCIsXG5cdFwiZ3RyZG90XCI6IFwi4ouXXCIsXG5cdFwiZ3RyZXFsZXNzXCI6IFwi4oubXCIsXG5cdFwiZ3RyZXFxbGVzc1wiOiBcIuKqjFwiLFxuXHRcImd0cmxlc3NcIjogXCLiibdcIixcblx0XCJndHJzaW1cIjogXCLiibNcIixcblx0XCJndmVydG5lcXFcIjogXCLiianvuIBcIixcblx0XCJndm5FXCI6IFwi4omp77iAXCIsXG5cdFwiSGFjZWtcIjogXCLLh1wiLFxuXHRcImhhaXJzcFwiOiBcIuKAilwiLFxuXHRcImhhbGZcIjogXCLCvVwiLFxuXHRcImhhbWlsdFwiOiBcIuKEi1wiLFxuXHRcIkhBUkRjeVwiOiBcItCqXCIsXG5cdFwiaGFyZGN5XCI6IFwi0YpcIixcblx0XCJoYXJyY2lyXCI6IFwi4qWIXCIsXG5cdFwiaGFyclwiOiBcIuKGlFwiLFxuXHRcImhBcnJcIjogXCLih5RcIixcblx0XCJoYXJyd1wiOiBcIuKGrVwiLFxuXHRcIkhhdFwiOiBcIl5cIixcblx0XCJoYmFyXCI6IFwi4oSPXCIsXG5cdFwiSGNpcmNcIjogXCLEpFwiLFxuXHRcImhjaXJjXCI6IFwixKVcIixcblx0XCJoZWFydHNcIjogXCLimaVcIixcblx0XCJoZWFydHN1aXRcIjogXCLimaVcIixcblx0XCJoZWxsaXBcIjogXCLigKZcIixcblx0XCJoZXJjb25cIjogXCLiirlcIixcblx0XCJoZnJcIjogXCLwnZSlXCIsXG5cdFwiSGZyXCI6IFwi4oSMXCIsXG5cdFwiSGlsYmVydFNwYWNlXCI6IFwi4oSLXCIsXG5cdFwiaGtzZWFyb3dcIjogXCLipKVcIixcblx0XCJoa3N3YXJvd1wiOiBcIuKkplwiLFxuXHRcImhvYXJyXCI6IFwi4oe/XCIsXG5cdFwiaG9tdGh0XCI6IFwi4oi7XCIsXG5cdFwiaG9va2xlZnRhcnJvd1wiOiBcIuKGqVwiLFxuXHRcImhvb2tyaWdodGFycm93XCI6IFwi4oaqXCIsXG5cdFwiaG9wZlwiOiBcIvCdlZlcIixcblx0XCJIb3BmXCI6IFwi4oSNXCIsXG5cdFwiaG9yYmFyXCI6IFwi4oCVXCIsXG5cdFwiSG9yaXpvbnRhbExpbmVcIjogXCLilIBcIixcblx0XCJoc2NyXCI6IFwi8J2SvVwiLFxuXHRcIkhzY3JcIjogXCLihItcIixcblx0XCJoc2xhc2hcIjogXCLihI9cIixcblx0XCJIc3Ryb2tcIjogXCLEplwiLFxuXHRcImhzdHJva1wiOiBcIsSnXCIsXG5cdFwiSHVtcERvd25IdW1wXCI6IFwi4omOXCIsXG5cdFwiSHVtcEVxdWFsXCI6IFwi4omPXCIsXG5cdFwiaHlidWxsXCI6IFwi4oGDXCIsXG5cdFwiaHlwaGVuXCI6IFwi4oCQXCIsXG5cdFwiSWFjdXRlXCI6IFwiw41cIixcblx0XCJpYWN1dGVcIjogXCLDrVwiLFxuXHRcImljXCI6IFwi4oGjXCIsXG5cdFwiSWNpcmNcIjogXCLDjlwiLFxuXHRcImljaXJjXCI6IFwiw65cIixcblx0XCJJY3lcIjogXCLQmFwiLFxuXHRcImljeVwiOiBcItC4XCIsXG5cdFwiSWRvdFwiOiBcIsSwXCIsXG5cdFwiSUVjeVwiOiBcItCVXCIsXG5cdFwiaWVjeVwiOiBcItC1XCIsXG5cdFwiaWV4Y2xcIjogXCLCoVwiLFxuXHRcImlmZlwiOiBcIuKHlFwiLFxuXHRcImlmclwiOiBcIvCdlKZcIixcblx0XCJJZnJcIjogXCLihJFcIixcblx0XCJJZ3JhdmVcIjogXCLDjFwiLFxuXHRcImlncmF2ZVwiOiBcIsOsXCIsXG5cdFwiaWlcIjogXCLihYhcIixcblx0XCJpaWlpbnRcIjogXCLiqIxcIixcblx0XCJpaWludFwiOiBcIuKIrVwiLFxuXHRcImlpbmZpblwiOiBcIuKnnFwiLFxuXHRcImlpb3RhXCI6IFwi4oSpXCIsXG5cdFwiSUpsaWdcIjogXCLEslwiLFxuXHRcImlqbGlnXCI6IFwixLNcIixcblx0XCJJbWFjclwiOiBcIsSqXCIsXG5cdFwiaW1hY3JcIjogXCLEq1wiLFxuXHRcImltYWdlXCI6IFwi4oSRXCIsXG5cdFwiSW1hZ2luYXJ5SVwiOiBcIuKFiFwiLFxuXHRcImltYWdsaW5lXCI6IFwi4oSQXCIsXG5cdFwiaW1hZ3BhcnRcIjogXCLihJFcIixcblx0XCJpbWF0aFwiOiBcIsSxXCIsXG5cdFwiSW1cIjogXCLihJFcIixcblx0XCJpbW9mXCI6IFwi4oq3XCIsXG5cdFwiaW1wZWRcIjogXCLGtVwiLFxuXHRcIkltcGxpZXNcIjogXCLih5JcIixcblx0XCJpbmNhcmVcIjogXCLihIVcIixcblx0XCJpblwiOiBcIuKIiFwiLFxuXHRcImluZmluXCI6IFwi4oieXCIsXG5cdFwiaW5maW50aWVcIjogXCLip51cIixcblx0XCJpbm9kb3RcIjogXCLEsVwiLFxuXHRcImludGNhbFwiOiBcIuKKulwiLFxuXHRcImludFwiOiBcIuKIq1wiLFxuXHRcIkludFwiOiBcIuKIrFwiLFxuXHRcImludGVnZXJzXCI6IFwi4oSkXCIsXG5cdFwiSW50ZWdyYWxcIjogXCLiiKtcIixcblx0XCJpbnRlcmNhbFwiOiBcIuKKulwiLFxuXHRcIkludGVyc2VjdGlvblwiOiBcIuKLglwiLFxuXHRcImludGxhcmhrXCI6IFwi4qiXXCIsXG5cdFwiaW50cHJvZFwiOiBcIuKovFwiLFxuXHRcIkludmlzaWJsZUNvbW1hXCI6IFwi4oGjXCIsXG5cdFwiSW52aXNpYmxlVGltZXNcIjogXCLigaJcIixcblx0XCJJT2N5XCI6IFwi0IFcIixcblx0XCJpb2N5XCI6IFwi0ZFcIixcblx0XCJJb2dvblwiOiBcIsSuXCIsXG5cdFwiaW9nb25cIjogXCLEr1wiLFxuXHRcIklvcGZcIjogXCLwnZWAXCIsXG5cdFwiaW9wZlwiOiBcIvCdlZpcIixcblx0XCJJb3RhXCI6IFwizplcIixcblx0XCJpb3RhXCI6IFwizrlcIixcblx0XCJpcHJvZFwiOiBcIuKovFwiLFxuXHRcImlxdWVzdFwiOiBcIsK/XCIsXG5cdFwiaXNjclwiOiBcIvCdkr5cIixcblx0XCJJc2NyXCI6IFwi4oSQXCIsXG5cdFwiaXNpblwiOiBcIuKIiFwiLFxuXHRcImlzaW5kb3RcIjogXCLii7VcIixcblx0XCJpc2luRVwiOiBcIuKLuVwiLFxuXHRcImlzaW5zXCI6IFwi4ou0XCIsXG5cdFwiaXNpbnN2XCI6IFwi4ouzXCIsXG5cdFwiaXNpbnZcIjogXCLiiIhcIixcblx0XCJpdFwiOiBcIuKBolwiLFxuXHRcIkl0aWxkZVwiOiBcIsSoXCIsXG5cdFwiaXRpbGRlXCI6IFwixKlcIixcblx0XCJJdWtjeVwiOiBcItCGXCIsXG5cdFwiaXVrY3lcIjogXCLRllwiLFxuXHRcIkl1bWxcIjogXCLDj1wiLFxuXHRcIml1bWxcIjogXCLDr1wiLFxuXHRcIkpjaXJjXCI6IFwixLRcIixcblx0XCJqY2lyY1wiOiBcIsS1XCIsXG5cdFwiSmN5XCI6IFwi0JlcIixcblx0XCJqY3lcIjogXCLQuVwiLFxuXHRcIkpmclwiOiBcIvCdlI1cIixcblx0XCJqZnJcIjogXCLwnZSnXCIsXG5cdFwiam1hdGhcIjogXCLIt1wiLFxuXHRcIkpvcGZcIjogXCLwnZWBXCIsXG5cdFwiam9wZlwiOiBcIvCdlZtcIixcblx0XCJKc2NyXCI6IFwi8J2SpVwiLFxuXHRcImpzY3JcIjogXCLwnZK/XCIsXG5cdFwiSnNlcmN5XCI6IFwi0IhcIixcblx0XCJqc2VyY3lcIjogXCLRmFwiLFxuXHRcIkp1a2N5XCI6IFwi0IRcIixcblx0XCJqdWtjeVwiOiBcItGUXCIsXG5cdFwiS2FwcGFcIjogXCLOmlwiLFxuXHRcImthcHBhXCI6IFwizrpcIixcblx0XCJrYXBwYXZcIjogXCLPsFwiLFxuXHRcIktjZWRpbFwiOiBcIsS2XCIsXG5cdFwia2NlZGlsXCI6IFwixLdcIixcblx0XCJLY3lcIjogXCLQmlwiLFxuXHRcImtjeVwiOiBcItC6XCIsXG5cdFwiS2ZyXCI6IFwi8J2UjlwiLFxuXHRcImtmclwiOiBcIvCdlKhcIixcblx0XCJrZ3JlZW5cIjogXCLEuFwiLFxuXHRcIktIY3lcIjogXCLQpVwiLFxuXHRcImtoY3lcIjogXCLRhVwiLFxuXHRcIktKY3lcIjogXCLQjFwiLFxuXHRcImtqY3lcIjogXCLRnFwiLFxuXHRcIktvcGZcIjogXCLwnZWCXCIsXG5cdFwia29wZlwiOiBcIvCdlZxcIixcblx0XCJLc2NyXCI6IFwi8J2SplwiLFxuXHRcImtzY3JcIjogXCLwnZOAXCIsXG5cdFwibEFhcnJcIjogXCLih5pcIixcblx0XCJMYWN1dGVcIjogXCLEuVwiLFxuXHRcImxhY3V0ZVwiOiBcIsS6XCIsXG5cdFwibGFlbXB0eXZcIjogXCLiprRcIixcblx0XCJsYWdyYW5cIjogXCLihJJcIixcblx0XCJMYW1iZGFcIjogXCLOm1wiLFxuXHRcImxhbWJkYVwiOiBcIs67XCIsXG5cdFwibGFuZ1wiOiBcIuKfqFwiLFxuXHRcIkxhbmdcIjogXCLin6pcIixcblx0XCJsYW5nZFwiOiBcIuKmkVwiLFxuXHRcImxhbmdsZVwiOiBcIuKfqFwiLFxuXHRcImxhcFwiOiBcIuKqhVwiLFxuXHRcIkxhcGxhY2V0cmZcIjogXCLihJJcIixcblx0XCJsYXF1b1wiOiBcIsKrXCIsXG5cdFwibGFycmJcIjogXCLih6RcIixcblx0XCJsYXJyYmZzXCI6IFwi4qSfXCIsXG5cdFwibGFyclwiOiBcIuKGkFwiLFxuXHRcIkxhcnJcIjogXCLihp5cIixcblx0XCJsQXJyXCI6IFwi4oeQXCIsXG5cdFwibGFycmZzXCI6IFwi4qSdXCIsXG5cdFwibGFycmhrXCI6IFwi4oapXCIsXG5cdFwibGFycmxwXCI6IFwi4oarXCIsXG5cdFwibGFycnBsXCI6IFwi4qS5XCIsXG5cdFwibGFycnNpbVwiOiBcIuKls1wiLFxuXHRcImxhcnJ0bFwiOiBcIuKGolwiLFxuXHRcImxhdGFpbFwiOiBcIuKkmVwiLFxuXHRcImxBdGFpbFwiOiBcIuKkm1wiLFxuXHRcImxhdFwiOiBcIuKqq1wiLFxuXHRcImxhdGVcIjogXCLiqq1cIixcblx0XCJsYXRlc1wiOiBcIuKqre+4gFwiLFxuXHRcImxiYXJyXCI6IFwi4qSMXCIsXG5cdFwibEJhcnJcIjogXCLipI5cIixcblx0XCJsYmJya1wiOiBcIuKdslwiLFxuXHRcImxicmFjZVwiOiBcIntcIixcblx0XCJsYnJhY2tcIjogXCJbXCIsXG5cdFwibGJya2VcIjogXCLipotcIixcblx0XCJsYnJrc2xkXCI6IFwi4qaPXCIsXG5cdFwibGJya3NsdVwiOiBcIuKmjVwiLFxuXHRcIkxjYXJvblwiOiBcIsS9XCIsXG5cdFwibGNhcm9uXCI6IFwixL5cIixcblx0XCJMY2VkaWxcIjogXCLEu1wiLFxuXHRcImxjZWRpbFwiOiBcIsS8XCIsXG5cdFwibGNlaWxcIjogXCLijIhcIixcblx0XCJsY3ViXCI6IFwie1wiLFxuXHRcIkxjeVwiOiBcItCbXCIsXG5cdFwibGN5XCI6IFwi0LtcIixcblx0XCJsZGNhXCI6IFwi4qS2XCIsXG5cdFwibGRxdW9cIjogXCLigJxcIixcblx0XCJsZHF1b3JcIjogXCLigJ5cIixcblx0XCJsZHJkaGFyXCI6IFwi4qWnXCIsXG5cdFwibGRydXNoYXJcIjogXCLipYtcIixcblx0XCJsZHNoXCI6IFwi4oayXCIsXG5cdFwibGVcIjogXCLiiaRcIixcblx0XCJsRVwiOiBcIuKJplwiLFxuXHRcIkxlZnRBbmdsZUJyYWNrZXRcIjogXCLin6hcIixcblx0XCJMZWZ0QXJyb3dCYXJcIjogXCLih6RcIixcblx0XCJsZWZ0YXJyb3dcIjogXCLihpBcIixcblx0XCJMZWZ0QXJyb3dcIjogXCLihpBcIixcblx0XCJMZWZ0YXJyb3dcIjogXCLih5BcIixcblx0XCJMZWZ0QXJyb3dSaWdodEFycm93XCI6IFwi4oeGXCIsXG5cdFwibGVmdGFycm93dGFpbFwiOiBcIuKGolwiLFxuXHRcIkxlZnRDZWlsaW5nXCI6IFwi4oyIXCIsXG5cdFwiTGVmdERvdWJsZUJyYWNrZXRcIjogXCLin6ZcIixcblx0XCJMZWZ0RG93blRlZVZlY3RvclwiOiBcIuKloVwiLFxuXHRcIkxlZnREb3duVmVjdG9yQmFyXCI6IFwi4qWZXCIsXG5cdFwiTGVmdERvd25WZWN0b3JcIjogXCLih4NcIixcblx0XCJMZWZ0Rmxvb3JcIjogXCLijIpcIixcblx0XCJsZWZ0aGFycG9vbmRvd25cIjogXCLihr1cIixcblx0XCJsZWZ0aGFycG9vbnVwXCI6IFwi4oa8XCIsXG5cdFwibGVmdGxlZnRhcnJvd3NcIjogXCLih4dcIixcblx0XCJsZWZ0cmlnaHRhcnJvd1wiOiBcIuKGlFwiLFxuXHRcIkxlZnRSaWdodEFycm93XCI6IFwi4oaUXCIsXG5cdFwiTGVmdHJpZ2h0YXJyb3dcIjogXCLih5RcIixcblx0XCJsZWZ0cmlnaHRhcnJvd3NcIjogXCLih4ZcIixcblx0XCJsZWZ0cmlnaHRoYXJwb29uc1wiOiBcIuKHi1wiLFxuXHRcImxlZnRyaWdodHNxdWlnYXJyb3dcIjogXCLihq1cIixcblx0XCJMZWZ0UmlnaHRWZWN0b3JcIjogXCLipY5cIixcblx0XCJMZWZ0VGVlQXJyb3dcIjogXCLihqRcIixcblx0XCJMZWZ0VGVlXCI6IFwi4oqjXCIsXG5cdFwiTGVmdFRlZVZlY3RvclwiOiBcIuKlmlwiLFxuXHRcImxlZnR0aHJlZXRpbWVzXCI6IFwi4ouLXCIsXG5cdFwiTGVmdFRyaWFuZ2xlQmFyXCI6IFwi4qePXCIsXG5cdFwiTGVmdFRyaWFuZ2xlXCI6IFwi4oqyXCIsXG5cdFwiTGVmdFRyaWFuZ2xlRXF1YWxcIjogXCLiirRcIixcblx0XCJMZWZ0VXBEb3duVmVjdG9yXCI6IFwi4qWRXCIsXG5cdFwiTGVmdFVwVGVlVmVjdG9yXCI6IFwi4qWgXCIsXG5cdFwiTGVmdFVwVmVjdG9yQmFyXCI6IFwi4qWYXCIsXG5cdFwiTGVmdFVwVmVjdG9yXCI6IFwi4oa/XCIsXG5cdFwiTGVmdFZlY3RvckJhclwiOiBcIuKlklwiLFxuXHRcIkxlZnRWZWN0b3JcIjogXCLihrxcIixcblx0XCJsRWdcIjogXCLiqotcIixcblx0XCJsZWdcIjogXCLii5pcIixcblx0XCJsZXFcIjogXCLiiaRcIixcblx0XCJsZXFxXCI6IFwi4ommXCIsXG5cdFwibGVxc2xhbnRcIjogXCLiqb1cIixcblx0XCJsZXNjY1wiOiBcIuKqqFwiLFxuXHRcImxlc1wiOiBcIuKpvVwiLFxuXHRcImxlc2RvdFwiOiBcIuKpv1wiLFxuXHRcImxlc2RvdG9cIjogXCLiqoFcIixcblx0XCJsZXNkb3RvclwiOiBcIuKqg1wiLFxuXHRcImxlc2dcIjogXCLii5rvuIBcIixcblx0XCJsZXNnZXNcIjogXCLiqpNcIixcblx0XCJsZXNzYXBwcm94XCI6IFwi4qqFXCIsXG5cdFwibGVzc2RvdFwiOiBcIuKLllwiLFxuXHRcImxlc3NlcWd0clwiOiBcIuKLmlwiLFxuXHRcImxlc3NlcXFndHJcIjogXCLiqotcIixcblx0XCJMZXNzRXF1YWxHcmVhdGVyXCI6IFwi4ouaXCIsXG5cdFwiTGVzc0Z1bGxFcXVhbFwiOiBcIuKJplwiLFxuXHRcIkxlc3NHcmVhdGVyXCI6IFwi4om2XCIsXG5cdFwibGVzc2d0clwiOiBcIuKJtlwiLFxuXHRcIkxlc3NMZXNzXCI6IFwi4qqhXCIsXG5cdFwibGVzc3NpbVwiOiBcIuKJslwiLFxuXHRcIkxlc3NTbGFudEVxdWFsXCI6IFwi4qm9XCIsXG5cdFwiTGVzc1RpbGRlXCI6IFwi4omyXCIsXG5cdFwibGZpc2h0XCI6IFwi4qW8XCIsXG5cdFwibGZsb29yXCI6IFwi4oyKXCIsXG5cdFwiTGZyXCI6IFwi8J2Uj1wiLFxuXHRcImxmclwiOiBcIvCdlKlcIixcblx0XCJsZ1wiOiBcIuKJtlwiLFxuXHRcImxnRVwiOiBcIuKqkVwiLFxuXHRcImxIYXJcIjogXCLipaJcIixcblx0XCJsaGFyZFwiOiBcIuKGvVwiLFxuXHRcImxoYXJ1XCI6IFwi4oa8XCIsXG5cdFwibGhhcnVsXCI6IFwi4qWqXCIsXG5cdFwibGhibGtcIjogXCLiloRcIixcblx0XCJMSmN5XCI6IFwi0IlcIixcblx0XCJsamN5XCI6IFwi0ZlcIixcblx0XCJsbGFyclwiOiBcIuKHh1wiLFxuXHRcImxsXCI6IFwi4omqXCIsXG5cdFwiTGxcIjogXCLii5hcIixcblx0XCJsbGNvcm5lclwiOiBcIuKMnlwiLFxuXHRcIkxsZWZ0YXJyb3dcIjogXCLih5pcIixcblx0XCJsbGhhcmRcIjogXCLipatcIixcblx0XCJsbHRyaVwiOiBcIuKXulwiLFxuXHRcIkxtaWRvdFwiOiBcIsS/XCIsXG5cdFwibG1pZG90XCI6IFwixYBcIixcblx0XCJsbW91c3RhY2hlXCI6IFwi4o6wXCIsXG5cdFwibG1vdXN0XCI6IFwi4o6wXCIsXG5cdFwibG5hcFwiOiBcIuKqiVwiLFxuXHRcImxuYXBwcm94XCI6IFwi4qqJXCIsXG5cdFwibG5lXCI6IFwi4qqHXCIsXG5cdFwibG5FXCI6IFwi4omoXCIsXG5cdFwibG5lcVwiOiBcIuKqh1wiLFxuXHRcImxuZXFxXCI6IFwi4omoXCIsXG5cdFwibG5zaW1cIjogXCLii6ZcIixcblx0XCJsb2FuZ1wiOiBcIuKfrFwiLFxuXHRcImxvYXJyXCI6IFwi4oe9XCIsXG5cdFwibG9icmtcIjogXCLin6ZcIixcblx0XCJsb25nbGVmdGFycm93XCI6IFwi4p+1XCIsXG5cdFwiTG9uZ0xlZnRBcnJvd1wiOiBcIuKftVwiLFxuXHRcIkxvbmdsZWZ0YXJyb3dcIjogXCLin7hcIixcblx0XCJsb25nbGVmdHJpZ2h0YXJyb3dcIjogXCLin7dcIixcblx0XCJMb25nTGVmdFJpZ2h0QXJyb3dcIjogXCLin7dcIixcblx0XCJMb25nbGVmdHJpZ2h0YXJyb3dcIjogXCLin7pcIixcblx0XCJsb25nbWFwc3RvXCI6IFwi4p+8XCIsXG5cdFwibG9uZ3JpZ2h0YXJyb3dcIjogXCLin7ZcIixcblx0XCJMb25nUmlnaHRBcnJvd1wiOiBcIuKftlwiLFxuXHRcIkxvbmdyaWdodGFycm93XCI6IFwi4p+5XCIsXG5cdFwibG9vcGFycm93bGVmdFwiOiBcIuKGq1wiLFxuXHRcImxvb3BhcnJvd3JpZ2h0XCI6IFwi4oasXCIsXG5cdFwibG9wYXJcIjogXCLipoVcIixcblx0XCJMb3BmXCI6IFwi8J2Vg1wiLFxuXHRcImxvcGZcIjogXCLwnZWdXCIsXG5cdFwibG9wbHVzXCI6IFwi4qitXCIsXG5cdFwibG90aW1lc1wiOiBcIuKotFwiLFxuXHRcImxvd2FzdFwiOiBcIuKIl1wiLFxuXHRcImxvd2JhclwiOiBcIl9cIixcblx0XCJMb3dlckxlZnRBcnJvd1wiOiBcIuKGmVwiLFxuXHRcIkxvd2VyUmlnaHRBcnJvd1wiOiBcIuKGmFwiLFxuXHRcImxvelwiOiBcIuKXilwiLFxuXHRcImxvemVuZ2VcIjogXCLil4pcIixcblx0XCJsb3pmXCI6IFwi4qerXCIsXG5cdFwibHBhclwiOiBcIihcIixcblx0XCJscGFybHRcIjogXCLippNcIixcblx0XCJscmFyclwiOiBcIuKHhlwiLFxuXHRcImxyY29ybmVyXCI6IFwi4oyfXCIsXG5cdFwibHJoYXJcIjogXCLih4tcIixcblx0XCJscmhhcmRcIjogXCLipa1cIixcblx0XCJscm1cIjogXCLigI5cIixcblx0XCJscnRyaVwiOiBcIuKKv1wiLFxuXHRcImxzYXF1b1wiOiBcIuKAuVwiLFxuXHRcImxzY3JcIjogXCLwnZOBXCIsXG5cdFwiTHNjclwiOiBcIuKEklwiLFxuXHRcImxzaFwiOiBcIuKGsFwiLFxuXHRcIkxzaFwiOiBcIuKGsFwiLFxuXHRcImxzaW1cIjogXCLiibJcIixcblx0XCJsc2ltZVwiOiBcIuKqjVwiLFxuXHRcImxzaW1nXCI6IFwi4qqPXCIsXG5cdFwibHNxYlwiOiBcIltcIixcblx0XCJsc3F1b1wiOiBcIuKAmFwiLFxuXHRcImxzcXVvclwiOiBcIuKAmlwiLFxuXHRcIkxzdHJva1wiOiBcIsWBXCIsXG5cdFwibHN0cm9rXCI6IFwixYJcIixcblx0XCJsdGNjXCI6IFwi4qqmXCIsXG5cdFwibHRjaXJcIjogXCLiqblcIixcblx0XCJsdFwiOiBcIjxcIixcblx0XCJMVFwiOiBcIjxcIixcblx0XCJMdFwiOiBcIuKJqlwiLFxuXHRcImx0ZG90XCI6IFwi4ouWXCIsXG5cdFwibHRocmVlXCI6IFwi4ouLXCIsXG5cdFwibHRpbWVzXCI6IFwi4ouJXCIsXG5cdFwibHRsYXJyXCI6IFwi4qW2XCIsXG5cdFwibHRxdWVzdFwiOiBcIuKpu1wiLFxuXHRcImx0cmlcIjogXCLil4NcIixcblx0XCJsdHJpZVwiOiBcIuKKtFwiLFxuXHRcImx0cmlmXCI6IFwi4peCXCIsXG5cdFwibHRyUGFyXCI6IFwi4qaWXCIsXG5cdFwibHVyZHNoYXJcIjogXCLipYpcIixcblx0XCJsdXJ1aGFyXCI6IFwi4qWmXCIsXG5cdFwibHZlcnRuZXFxXCI6IFwi4omo77iAXCIsXG5cdFwibHZuRVwiOiBcIuKJqO+4gFwiLFxuXHRcIm1hY3JcIjogXCLCr1wiLFxuXHRcIm1hbGVcIjogXCLimYJcIixcblx0XCJtYWx0XCI6IFwi4pygXCIsXG5cdFwibWFsdGVzZVwiOiBcIuKcoFwiLFxuXHRcIk1hcFwiOiBcIuKkhVwiLFxuXHRcIm1hcFwiOiBcIuKGplwiLFxuXHRcIm1hcHN0b1wiOiBcIuKGplwiLFxuXHRcIm1hcHN0b2Rvd25cIjogXCLihqdcIixcblx0XCJtYXBzdG9sZWZ0XCI6IFwi4oakXCIsXG5cdFwibWFwc3RvdXBcIjogXCLihqVcIixcblx0XCJtYXJrZXJcIjogXCLilq5cIixcblx0XCJtY29tbWFcIjogXCLiqKlcIixcblx0XCJNY3lcIjogXCLQnFwiLFxuXHRcIm1jeVwiOiBcItC8XCIsXG5cdFwibWRhc2hcIjogXCLigJRcIixcblx0XCJtRERvdFwiOiBcIuKIulwiLFxuXHRcIm1lYXN1cmVkYW5nbGVcIjogXCLiiKFcIixcblx0XCJNZWRpdW1TcGFjZVwiOiBcIuKBn1wiLFxuXHRcIk1lbGxpbnRyZlwiOiBcIuKEs1wiLFxuXHRcIk1mclwiOiBcIvCdlJBcIixcblx0XCJtZnJcIjogXCLwnZSqXCIsXG5cdFwibWhvXCI6IFwi4oSnXCIsXG5cdFwibWljcm9cIjogXCLCtVwiLFxuXHRcIm1pZGFzdFwiOiBcIipcIixcblx0XCJtaWRjaXJcIjogXCLiq7BcIixcblx0XCJtaWRcIjogXCLiiKNcIixcblx0XCJtaWRkb3RcIjogXCLCt1wiLFxuXHRcIm1pbnVzYlwiOiBcIuKKn1wiLFxuXHRcIm1pbnVzXCI6IFwi4oiSXCIsXG5cdFwibWludXNkXCI6IFwi4oi4XCIsXG5cdFwibWludXNkdVwiOiBcIuKoqlwiLFxuXHRcIk1pbnVzUGx1c1wiOiBcIuKIk1wiLFxuXHRcIm1sY3BcIjogXCLiq5tcIixcblx0XCJtbGRyXCI6IFwi4oCmXCIsXG5cdFwibW5wbHVzXCI6IFwi4oiTXCIsXG5cdFwibW9kZWxzXCI6IFwi4oqnXCIsXG5cdFwiTW9wZlwiOiBcIvCdlYRcIixcblx0XCJtb3BmXCI6IFwi8J2VnlwiLFxuXHRcIm1wXCI6IFwi4oiTXCIsXG5cdFwibXNjclwiOiBcIvCdk4JcIixcblx0XCJNc2NyXCI6IFwi4oSzXCIsXG5cdFwibXN0cG9zXCI6IFwi4oi+XCIsXG5cdFwiTXVcIjogXCLOnFwiLFxuXHRcIm11XCI6IFwizrxcIixcblx0XCJtdWx0aW1hcFwiOiBcIuKKuFwiLFxuXHRcIm11bWFwXCI6IFwi4oq4XCIsXG5cdFwibmFibGFcIjogXCLiiIdcIixcblx0XCJOYWN1dGVcIjogXCLFg1wiLFxuXHRcIm5hY3V0ZVwiOiBcIsWEXCIsXG5cdFwibmFuZ1wiOiBcIuKIoOKDklwiLFxuXHRcIm5hcFwiOiBcIuKJiVwiLFxuXHRcIm5hcEVcIjogXCLiqbDMuFwiLFxuXHRcIm5hcGlkXCI6IFwi4omLzLhcIixcblx0XCJuYXBvc1wiOiBcIsWJXCIsXG5cdFwibmFwcHJveFwiOiBcIuKJiVwiLFxuXHRcIm5hdHVyYWxcIjogXCLima5cIixcblx0XCJuYXR1cmFsc1wiOiBcIuKElVwiLFxuXHRcIm5hdHVyXCI6IFwi4pmuXCIsXG5cdFwibmJzcFwiOiBcIsKgXCIsXG5cdFwibmJ1bXBcIjogXCLiiY7MuFwiLFxuXHRcIm5idW1wZVwiOiBcIuKJj8y4XCIsXG5cdFwibmNhcFwiOiBcIuKpg1wiLFxuXHRcIk5jYXJvblwiOiBcIsWHXCIsXG5cdFwibmNhcm9uXCI6IFwixYhcIixcblx0XCJOY2VkaWxcIjogXCLFhVwiLFxuXHRcIm5jZWRpbFwiOiBcIsWGXCIsXG5cdFwibmNvbmdcIjogXCLiiYdcIixcblx0XCJuY29uZ2RvdFwiOiBcIuKprcy4XCIsXG5cdFwibmN1cFwiOiBcIuKpglwiLFxuXHRcIk5jeVwiOiBcItCdXCIsXG5cdFwibmN5XCI6IFwi0L1cIixcblx0XCJuZGFzaFwiOiBcIuKAk1wiLFxuXHRcIm5lYXJoa1wiOiBcIuKkpFwiLFxuXHRcIm5lYXJyXCI6IFwi4oaXXCIsXG5cdFwibmVBcnJcIjogXCLih5dcIixcblx0XCJuZWFycm93XCI6IFwi4oaXXCIsXG5cdFwibmVcIjogXCLiiaBcIixcblx0XCJuZWRvdFwiOiBcIuKJkMy4XCIsXG5cdFwiTmVnYXRpdmVNZWRpdW1TcGFjZVwiOiBcIuKAi1wiLFxuXHRcIk5lZ2F0aXZlVGhpY2tTcGFjZVwiOiBcIuKAi1wiLFxuXHRcIk5lZ2F0aXZlVGhpblNwYWNlXCI6IFwi4oCLXCIsXG5cdFwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlXCI6IFwi4oCLXCIsXG5cdFwibmVxdWl2XCI6IFwi4omiXCIsXG5cdFwibmVzZWFyXCI6IFwi4qSoXCIsXG5cdFwibmVzaW1cIjogXCLiiYLMuFwiLFxuXHRcIk5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6IFwi4omrXCIsXG5cdFwiTmVzdGVkTGVzc0xlc3NcIjogXCLiiapcIixcblx0XCJOZXdMaW5lXCI6IFwiXFxuXCIsXG5cdFwibmV4aXN0XCI6IFwi4oiEXCIsXG5cdFwibmV4aXN0c1wiOiBcIuKIhFwiLFxuXHRcIk5mclwiOiBcIvCdlJFcIixcblx0XCJuZnJcIjogXCLwnZSrXCIsXG5cdFwibmdFXCI6IFwi4omnzLhcIixcblx0XCJuZ2VcIjogXCLiibFcIixcblx0XCJuZ2VxXCI6IFwi4omxXCIsXG5cdFwibmdlcXFcIjogXCLiiafMuFwiLFxuXHRcIm5nZXFzbGFudFwiOiBcIuKpvsy4XCIsXG5cdFwibmdlc1wiOiBcIuKpvsy4XCIsXG5cdFwibkdnXCI6IFwi4ouZzLhcIixcblx0XCJuZ3NpbVwiOiBcIuKJtVwiLFxuXHRcIm5HdFwiOiBcIuKJq+KDklwiLFxuXHRcIm5ndFwiOiBcIuKJr1wiLFxuXHRcIm5ndHJcIjogXCLiia9cIixcblx0XCJuR3R2XCI6IFwi4omrzLhcIixcblx0XCJuaGFyclwiOiBcIuKGrlwiLFxuXHRcIm5oQXJyXCI6IFwi4oeOXCIsXG5cdFwibmhwYXJcIjogXCLiq7JcIixcblx0XCJuaVwiOiBcIuKIi1wiLFxuXHRcIm5pc1wiOiBcIuKLvFwiLFxuXHRcIm5pc2RcIjogXCLii7pcIixcblx0XCJuaXZcIjogXCLiiItcIixcblx0XCJOSmN5XCI6IFwi0IpcIixcblx0XCJuamN5XCI6IFwi0ZpcIixcblx0XCJubGFyclwiOiBcIuKGmlwiLFxuXHRcIm5sQXJyXCI6IFwi4oeNXCIsXG5cdFwibmxkclwiOiBcIuKApVwiLFxuXHRcIm5sRVwiOiBcIuKJpsy4XCIsXG5cdFwibmxlXCI6IFwi4omwXCIsXG5cdFwibmxlZnRhcnJvd1wiOiBcIuKGmlwiLFxuXHRcIm5MZWZ0YXJyb3dcIjogXCLih41cIixcblx0XCJubGVmdHJpZ2h0YXJyb3dcIjogXCLihq5cIixcblx0XCJuTGVmdHJpZ2h0YXJyb3dcIjogXCLih45cIixcblx0XCJubGVxXCI6IFwi4omwXCIsXG5cdFwibmxlcXFcIjogXCLiiabMuFwiLFxuXHRcIm5sZXFzbGFudFwiOiBcIuKpvcy4XCIsXG5cdFwibmxlc1wiOiBcIuKpvcy4XCIsXG5cdFwibmxlc3NcIjogXCLiia5cIixcblx0XCJuTGxcIjogXCLii5jMuFwiLFxuXHRcIm5sc2ltXCI6IFwi4om0XCIsXG5cdFwibkx0XCI6IFwi4omq4oOSXCIsXG5cdFwibmx0XCI6IFwi4omuXCIsXG5cdFwibmx0cmlcIjogXCLii6pcIixcblx0XCJubHRyaWVcIjogXCLii6xcIixcblx0XCJuTHR2XCI6IFwi4omqzLhcIixcblx0XCJubWlkXCI6IFwi4oikXCIsXG5cdFwiTm9CcmVha1wiOiBcIuKBoFwiLFxuXHRcIk5vbkJyZWFraW5nU3BhY2VcIjogXCLCoFwiLFxuXHRcIm5vcGZcIjogXCLwnZWfXCIsXG5cdFwiTm9wZlwiOiBcIuKElVwiLFxuXHRcIk5vdFwiOiBcIuKrrFwiLFxuXHRcIm5vdFwiOiBcIsKsXCIsXG5cdFwiTm90Q29uZ3J1ZW50XCI6IFwi4omiXCIsXG5cdFwiTm90Q3VwQ2FwXCI6IFwi4omtXCIsXG5cdFwiTm90RG91YmxlVmVydGljYWxCYXJcIjogXCLiiKZcIixcblx0XCJOb3RFbGVtZW50XCI6IFwi4oiJXCIsXG5cdFwiTm90RXF1YWxcIjogXCLiiaBcIixcblx0XCJOb3RFcXVhbFRpbGRlXCI6IFwi4omCzLhcIixcblx0XCJOb3RFeGlzdHNcIjogXCLiiIRcIixcblx0XCJOb3RHcmVhdGVyXCI6IFwi4omvXCIsXG5cdFwiTm90R3JlYXRlckVxdWFsXCI6IFwi4omxXCIsXG5cdFwiTm90R3JlYXRlckZ1bGxFcXVhbFwiOiBcIuKJp8y4XCIsXG5cdFwiTm90R3JlYXRlckdyZWF0ZXJcIjogXCLiiavMuFwiLFxuXHRcIk5vdEdyZWF0ZXJMZXNzXCI6IFwi4om5XCIsXG5cdFwiTm90R3JlYXRlclNsYW50RXF1YWxcIjogXCLiqb7MuFwiLFxuXHRcIk5vdEdyZWF0ZXJUaWxkZVwiOiBcIuKJtVwiLFxuXHRcIk5vdEh1bXBEb3duSHVtcFwiOiBcIuKJjsy4XCIsXG5cdFwiTm90SHVtcEVxdWFsXCI6IFwi4omPzLhcIixcblx0XCJub3RpblwiOiBcIuKIiVwiLFxuXHRcIm5vdGluZG90XCI6IFwi4ou1zLhcIixcblx0XCJub3RpbkVcIjogXCLii7nMuFwiLFxuXHRcIm5vdGludmFcIjogXCLiiIlcIixcblx0XCJub3RpbnZiXCI6IFwi4ou3XCIsXG5cdFwibm90aW52Y1wiOiBcIuKLtlwiLFxuXHRcIk5vdExlZnRUcmlhbmdsZUJhclwiOiBcIuKnj8y4XCIsXG5cdFwiTm90TGVmdFRyaWFuZ2xlXCI6IFwi4ouqXCIsXG5cdFwiTm90TGVmdFRyaWFuZ2xlRXF1YWxcIjogXCLii6xcIixcblx0XCJOb3RMZXNzXCI6IFwi4omuXCIsXG5cdFwiTm90TGVzc0VxdWFsXCI6IFwi4omwXCIsXG5cdFwiTm90TGVzc0dyZWF0ZXJcIjogXCLiibhcIixcblx0XCJOb3RMZXNzTGVzc1wiOiBcIuKJqsy4XCIsXG5cdFwiTm90TGVzc1NsYW50RXF1YWxcIjogXCLiqb3MuFwiLFxuXHRcIk5vdExlc3NUaWxkZVwiOiBcIuKJtFwiLFxuXHRcIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6IFwi4qqizLhcIixcblx0XCJOb3ROZXN0ZWRMZXNzTGVzc1wiOiBcIuKqocy4XCIsXG5cdFwibm90bmlcIjogXCLiiIxcIixcblx0XCJub3RuaXZhXCI6IFwi4oiMXCIsXG5cdFwibm90bml2YlwiOiBcIuKLvlwiLFxuXHRcIm5vdG5pdmNcIjogXCLii71cIixcblx0XCJOb3RQcmVjZWRlc1wiOiBcIuKKgFwiLFxuXHRcIk5vdFByZWNlZGVzRXF1YWxcIjogXCLiqq/MuFwiLFxuXHRcIk5vdFByZWNlZGVzU2xhbnRFcXVhbFwiOiBcIuKLoFwiLFxuXHRcIk5vdFJldmVyc2VFbGVtZW50XCI6IFwi4oiMXCIsXG5cdFwiTm90UmlnaHRUcmlhbmdsZUJhclwiOiBcIuKnkMy4XCIsXG5cdFwiTm90UmlnaHRUcmlhbmdsZVwiOiBcIuKLq1wiLFxuXHRcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbFwiOiBcIuKLrVwiLFxuXHRcIk5vdFNxdWFyZVN1YnNldFwiOiBcIuKKj8y4XCIsXG5cdFwiTm90U3F1YXJlU3Vic2V0RXF1YWxcIjogXCLii6JcIixcblx0XCJOb3RTcXVhcmVTdXBlcnNldFwiOiBcIuKKkMy4XCIsXG5cdFwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbFwiOiBcIuKLo1wiLFxuXHRcIk5vdFN1YnNldFwiOiBcIuKKguKDklwiLFxuXHRcIk5vdFN1YnNldEVxdWFsXCI6IFwi4oqIXCIsXG5cdFwiTm90U3VjY2VlZHNcIjogXCLiioFcIixcblx0XCJOb3RTdWNjZWVkc0VxdWFsXCI6IFwi4qqwzLhcIixcblx0XCJOb3RTdWNjZWVkc1NsYW50RXF1YWxcIjogXCLii6FcIixcblx0XCJOb3RTdWNjZWVkc1RpbGRlXCI6IFwi4om/zLhcIixcblx0XCJOb3RTdXBlcnNldFwiOiBcIuKKg+KDklwiLFxuXHRcIk5vdFN1cGVyc2V0RXF1YWxcIjogXCLiiolcIixcblx0XCJOb3RUaWxkZVwiOiBcIuKJgVwiLFxuXHRcIk5vdFRpbGRlRXF1YWxcIjogXCLiiYRcIixcblx0XCJOb3RUaWxkZUZ1bGxFcXVhbFwiOiBcIuKJh1wiLFxuXHRcIk5vdFRpbGRlVGlsZGVcIjogXCLiiYlcIixcblx0XCJOb3RWZXJ0aWNhbEJhclwiOiBcIuKIpFwiLFxuXHRcIm5wYXJhbGxlbFwiOiBcIuKIplwiLFxuXHRcIm5wYXJcIjogXCLiiKZcIixcblx0XCJucGFyc2xcIjogXCLiq73ig6VcIixcblx0XCJucGFydFwiOiBcIuKIgsy4XCIsXG5cdFwibnBvbGludFwiOiBcIuKolFwiLFxuXHRcIm5wclwiOiBcIuKKgFwiLFxuXHRcIm5wcmN1ZVwiOiBcIuKLoFwiLFxuXHRcIm5wcmVjXCI6IFwi4oqAXCIsXG5cdFwibnByZWNlcVwiOiBcIuKqr8y4XCIsXG5cdFwibnByZVwiOiBcIuKqr8y4XCIsXG5cdFwibnJhcnJjXCI6IFwi4qSzzLhcIixcblx0XCJucmFyclwiOiBcIuKGm1wiLFxuXHRcIm5yQXJyXCI6IFwi4oePXCIsXG5cdFwibnJhcnJ3XCI6IFwi4oadzLhcIixcblx0XCJucmlnaHRhcnJvd1wiOiBcIuKGm1wiLFxuXHRcIm5SaWdodGFycm93XCI6IFwi4oePXCIsXG5cdFwibnJ0cmlcIjogXCLii6tcIixcblx0XCJucnRyaWVcIjogXCLii61cIixcblx0XCJuc2NcIjogXCLiioFcIixcblx0XCJuc2NjdWVcIjogXCLii6FcIixcblx0XCJuc2NlXCI6IFwi4qqwzLhcIixcblx0XCJOc2NyXCI6IFwi8J2SqVwiLFxuXHRcIm5zY3JcIjogXCLwnZODXCIsXG5cdFwibnNob3J0bWlkXCI6IFwi4oikXCIsXG5cdFwibnNob3J0cGFyYWxsZWxcIjogXCLiiKZcIixcblx0XCJuc2ltXCI6IFwi4omBXCIsXG5cdFwibnNpbWVcIjogXCLiiYRcIixcblx0XCJuc2ltZXFcIjogXCLiiYRcIixcblx0XCJuc21pZFwiOiBcIuKIpFwiLFxuXHRcIm5zcGFyXCI6IFwi4oimXCIsXG5cdFwibnNxc3ViZVwiOiBcIuKLolwiLFxuXHRcIm5zcXN1cGVcIjogXCLii6NcIixcblx0XCJuc3ViXCI6IFwi4oqEXCIsXG5cdFwibnN1YkVcIjogXCLiq4XMuFwiLFxuXHRcIm5zdWJlXCI6IFwi4oqIXCIsXG5cdFwibnN1YnNldFwiOiBcIuKKguKDklwiLFxuXHRcIm5zdWJzZXRlcVwiOiBcIuKKiFwiLFxuXHRcIm5zdWJzZXRlcXFcIjogXCLiq4XMuFwiLFxuXHRcIm5zdWNjXCI6IFwi4oqBXCIsXG5cdFwibnN1Y2NlcVwiOiBcIuKqsMy4XCIsXG5cdFwibnN1cFwiOiBcIuKKhVwiLFxuXHRcIm5zdXBFXCI6IFwi4quGzLhcIixcblx0XCJuc3VwZVwiOiBcIuKKiVwiLFxuXHRcIm5zdXBzZXRcIjogXCLiioPig5JcIixcblx0XCJuc3Vwc2V0ZXFcIjogXCLiiolcIixcblx0XCJuc3Vwc2V0ZXFxXCI6IFwi4quGzLhcIixcblx0XCJudGdsXCI6IFwi4om5XCIsXG5cdFwiTnRpbGRlXCI6IFwiw5FcIixcblx0XCJudGlsZGVcIjogXCLDsVwiLFxuXHRcIm50bGdcIjogXCLiibhcIixcblx0XCJudHJpYW5nbGVsZWZ0XCI6IFwi4ouqXCIsXG5cdFwibnRyaWFuZ2xlbGVmdGVxXCI6IFwi4ousXCIsXG5cdFwibnRyaWFuZ2xlcmlnaHRcIjogXCLii6tcIixcblx0XCJudHJpYW5nbGVyaWdodGVxXCI6IFwi4outXCIsXG5cdFwiTnVcIjogXCLOnVwiLFxuXHRcIm51XCI6IFwizr1cIixcblx0XCJudW1cIjogXCIjXCIsXG5cdFwibnVtZXJvXCI6IFwi4oSWXCIsXG5cdFwibnVtc3BcIjogXCLigIdcIixcblx0XCJudmFwXCI6IFwi4omN4oOSXCIsXG5cdFwibnZkYXNoXCI6IFwi4oqsXCIsXG5cdFwibnZEYXNoXCI6IFwi4oqtXCIsXG5cdFwiblZkYXNoXCI6IFwi4oquXCIsXG5cdFwiblZEYXNoXCI6IFwi4oqvXCIsXG5cdFwibnZnZVwiOiBcIuKJpeKDklwiLFxuXHRcIm52Z3RcIjogXCI+4oOSXCIsXG5cdFwibnZIYXJyXCI6IFwi4qSEXCIsXG5cdFwibnZpbmZpblwiOiBcIuKnnlwiLFxuXHRcIm52bEFyclwiOiBcIuKkglwiLFxuXHRcIm52bGVcIjogXCLiiaTig5JcIixcblx0XCJudmx0XCI6IFwiPOKDklwiLFxuXHRcIm52bHRyaWVcIjogXCLiirTig5JcIixcblx0XCJudnJBcnJcIjogXCLipINcIixcblx0XCJudnJ0cmllXCI6IFwi4oq14oOSXCIsXG5cdFwibnZzaW1cIjogXCLiiLzig5JcIixcblx0XCJud2FyaGtcIjogXCLipKNcIixcblx0XCJud2FyclwiOiBcIuKGllwiLFxuXHRcIm53QXJyXCI6IFwi4oeWXCIsXG5cdFwibndhcnJvd1wiOiBcIuKGllwiLFxuXHRcIm53bmVhclwiOiBcIuKkp1wiLFxuXHRcIk9hY3V0ZVwiOiBcIsOTXCIsXG5cdFwib2FjdXRlXCI6IFwiw7NcIixcblx0XCJvYXN0XCI6IFwi4oqbXCIsXG5cdFwiT2NpcmNcIjogXCLDlFwiLFxuXHRcIm9jaXJjXCI6IFwiw7RcIixcblx0XCJvY2lyXCI6IFwi4oqaXCIsXG5cdFwiT2N5XCI6IFwi0J5cIixcblx0XCJvY3lcIjogXCLQvlwiLFxuXHRcIm9kYXNoXCI6IFwi4oqdXCIsXG5cdFwiT2RibGFjXCI6IFwixZBcIixcblx0XCJvZGJsYWNcIjogXCLFkVwiLFxuXHRcIm9kaXZcIjogXCLiqLhcIixcblx0XCJvZG90XCI6IFwi4oqZXCIsXG5cdFwib2Rzb2xkXCI6IFwi4qa8XCIsXG5cdFwiT0VsaWdcIjogXCLFklwiLFxuXHRcIm9lbGlnXCI6IFwixZNcIixcblx0XCJvZmNpclwiOiBcIuKmv1wiLFxuXHRcIk9mclwiOiBcIvCdlJJcIixcblx0XCJvZnJcIjogXCLwnZSsXCIsXG5cdFwib2dvblwiOiBcIsubXCIsXG5cdFwiT2dyYXZlXCI6IFwiw5JcIixcblx0XCJvZ3JhdmVcIjogXCLDslwiLFxuXHRcIm9ndFwiOiBcIuKngVwiLFxuXHRcIm9oYmFyXCI6IFwi4qa1XCIsXG5cdFwib2htXCI6IFwizqlcIixcblx0XCJvaW50XCI6IFwi4oiuXCIsXG5cdFwib2xhcnJcIjogXCLihrpcIixcblx0XCJvbGNpclwiOiBcIuKmvlwiLFxuXHRcIm9sY3Jvc3NcIjogXCLiprtcIixcblx0XCJvbGluZVwiOiBcIuKAvlwiLFxuXHRcIm9sdFwiOiBcIuKngFwiLFxuXHRcIk9tYWNyXCI6IFwixYxcIixcblx0XCJvbWFjclwiOiBcIsWNXCIsXG5cdFwiT21lZ2FcIjogXCLOqVwiLFxuXHRcIm9tZWdhXCI6IFwiz4lcIixcblx0XCJPbWljcm9uXCI6IFwizp9cIixcblx0XCJvbWljcm9uXCI6IFwizr9cIixcblx0XCJvbWlkXCI6IFwi4qa2XCIsXG5cdFwib21pbnVzXCI6IFwi4oqWXCIsXG5cdFwiT29wZlwiOiBcIvCdlYZcIixcblx0XCJvb3BmXCI6IFwi8J2VoFwiLFxuXHRcIm9wYXJcIjogXCLiprdcIixcblx0XCJPcGVuQ3VybHlEb3VibGVRdW90ZVwiOiBcIuKAnFwiLFxuXHRcIk9wZW5DdXJseVF1b3RlXCI6IFwi4oCYXCIsXG5cdFwib3BlcnBcIjogXCLiprlcIixcblx0XCJvcGx1c1wiOiBcIuKKlVwiLFxuXHRcIm9yYXJyXCI6IFwi4oa7XCIsXG5cdFwiT3JcIjogXCLiqZRcIixcblx0XCJvclwiOiBcIuKIqFwiLFxuXHRcIm9yZFwiOiBcIuKpnVwiLFxuXHRcIm9yZGVyXCI6IFwi4oS0XCIsXG5cdFwib3JkZXJvZlwiOiBcIuKEtFwiLFxuXHRcIm9yZGZcIjogXCLCqlwiLFxuXHRcIm9yZG1cIjogXCLCulwiLFxuXHRcIm9yaWdvZlwiOiBcIuKKtlwiLFxuXHRcIm9yb3JcIjogXCLiqZZcIixcblx0XCJvcnNsb3BlXCI6IFwi4qmXXCIsXG5cdFwib3J2XCI6IFwi4qmbXCIsXG5cdFwib1NcIjogXCLik4hcIixcblx0XCJPc2NyXCI6IFwi8J2SqlwiLFxuXHRcIm9zY3JcIjogXCLihLRcIixcblx0XCJPc2xhc2hcIjogXCLDmFwiLFxuXHRcIm9zbGFzaFwiOiBcIsO4XCIsXG5cdFwib3NvbFwiOiBcIuKKmFwiLFxuXHRcIk90aWxkZVwiOiBcIsOVXCIsXG5cdFwib3RpbGRlXCI6IFwiw7VcIixcblx0XCJvdGltZXNhc1wiOiBcIuKotlwiLFxuXHRcIk90aW1lc1wiOiBcIuKot1wiLFxuXHRcIm90aW1lc1wiOiBcIuKKl1wiLFxuXHRcIk91bWxcIjogXCLDllwiLFxuXHRcIm91bWxcIjogXCLDtlwiLFxuXHRcIm92YmFyXCI6IFwi4oy9XCIsXG5cdFwiT3ZlckJhclwiOiBcIuKAvlwiLFxuXHRcIk92ZXJCcmFjZVwiOiBcIuKPnlwiLFxuXHRcIk92ZXJCcmFja2V0XCI6IFwi4o60XCIsXG5cdFwiT3ZlclBhcmVudGhlc2lzXCI6IFwi4o+cXCIsXG5cdFwicGFyYVwiOiBcIsK2XCIsXG5cdFwicGFyYWxsZWxcIjogXCLiiKVcIixcblx0XCJwYXJcIjogXCLiiKVcIixcblx0XCJwYXJzaW1cIjogXCLiq7NcIixcblx0XCJwYXJzbFwiOiBcIuKrvVwiLFxuXHRcInBhcnRcIjogXCLiiIJcIixcblx0XCJQYXJ0aWFsRFwiOiBcIuKIglwiLFxuXHRcIlBjeVwiOiBcItCfXCIsXG5cdFwicGN5XCI6IFwi0L9cIixcblx0XCJwZXJjbnRcIjogXCIlXCIsXG5cdFwicGVyaW9kXCI6IFwiLlwiLFxuXHRcInBlcm1pbFwiOiBcIuKAsFwiLFxuXHRcInBlcnBcIjogXCLiiqVcIixcblx0XCJwZXJ0ZW5rXCI6IFwi4oCxXCIsXG5cdFwiUGZyXCI6IFwi8J2Uk1wiLFxuXHRcInBmclwiOiBcIvCdlK1cIixcblx0XCJQaGlcIjogXCLOplwiLFxuXHRcInBoaVwiOiBcIs+GXCIsXG5cdFwicGhpdlwiOiBcIs+VXCIsXG5cdFwicGhtbWF0XCI6IFwi4oSzXCIsXG5cdFwicGhvbmVcIjogXCLimI5cIixcblx0XCJQaVwiOiBcIs6gXCIsXG5cdFwicGlcIjogXCLPgFwiLFxuXHRcInBpdGNoZm9ya1wiOiBcIuKLlFwiLFxuXHRcInBpdlwiOiBcIs+WXCIsXG5cdFwicGxhbmNrXCI6IFwi4oSPXCIsXG5cdFwicGxhbmNraFwiOiBcIuKEjlwiLFxuXHRcInBsYW5rdlwiOiBcIuKEj1wiLFxuXHRcInBsdXNhY2lyXCI6IFwi4qijXCIsXG5cdFwicGx1c2JcIjogXCLiip5cIixcblx0XCJwbHVzY2lyXCI6IFwi4qiiXCIsXG5cdFwicGx1c1wiOiBcIitcIixcblx0XCJwbHVzZG9cIjogXCLiiJRcIixcblx0XCJwbHVzZHVcIjogXCLiqKVcIixcblx0XCJwbHVzZVwiOiBcIuKpslwiLFxuXHRcIlBsdXNNaW51c1wiOiBcIsKxXCIsXG5cdFwicGx1c21uXCI6IFwiwrFcIixcblx0XCJwbHVzc2ltXCI6IFwi4qimXCIsXG5cdFwicGx1c3R3b1wiOiBcIuKop1wiLFxuXHRcInBtXCI6IFwiwrFcIixcblx0XCJQb2luY2FyZXBsYW5lXCI6IFwi4oSMXCIsXG5cdFwicG9pbnRpbnRcIjogXCLiqJVcIixcblx0XCJwb3BmXCI6IFwi8J2VoVwiLFxuXHRcIlBvcGZcIjogXCLihJlcIixcblx0XCJwb3VuZFwiOiBcIsKjXCIsXG5cdFwicHJhcFwiOiBcIuKqt1wiLFxuXHRcIlByXCI6IFwi4qq7XCIsXG5cdFwicHJcIjogXCLiibpcIixcblx0XCJwcmN1ZVwiOiBcIuKJvFwiLFxuXHRcInByZWNhcHByb3hcIjogXCLiqrdcIixcblx0XCJwcmVjXCI6IFwi4om6XCIsXG5cdFwicHJlY2N1cmx5ZXFcIjogXCLiibxcIixcblx0XCJQcmVjZWRlc1wiOiBcIuKJulwiLFxuXHRcIlByZWNlZGVzRXF1YWxcIjogXCLiqq9cIixcblx0XCJQcmVjZWRlc1NsYW50RXF1YWxcIjogXCLiibxcIixcblx0XCJQcmVjZWRlc1RpbGRlXCI6IFwi4om+XCIsXG5cdFwicHJlY2VxXCI6IFwi4qqvXCIsXG5cdFwicHJlY25hcHByb3hcIjogXCLiqrlcIixcblx0XCJwcmVjbmVxcVwiOiBcIuKqtVwiLFxuXHRcInByZWNuc2ltXCI6IFwi4ouoXCIsXG5cdFwicHJlXCI6IFwi4qqvXCIsXG5cdFwicHJFXCI6IFwi4qqzXCIsXG5cdFwicHJlY3NpbVwiOiBcIuKJvlwiLFxuXHRcInByaW1lXCI6IFwi4oCyXCIsXG5cdFwiUHJpbWVcIjogXCLigLNcIixcblx0XCJwcmltZXNcIjogXCLihJlcIixcblx0XCJwcm5hcFwiOiBcIuKquVwiLFxuXHRcInBybkVcIjogXCLiqrVcIixcblx0XCJwcm5zaW1cIjogXCLii6hcIixcblx0XCJwcm9kXCI6IFwi4oiPXCIsXG5cdFwiUHJvZHVjdFwiOiBcIuKIj1wiLFxuXHRcInByb2ZhbGFyXCI6IFwi4oyuXCIsXG5cdFwicHJvZmxpbmVcIjogXCLijJJcIixcblx0XCJwcm9mc3VyZlwiOiBcIuKMk1wiLFxuXHRcInByb3BcIjogXCLiiJ1cIixcblx0XCJQcm9wb3J0aW9uYWxcIjogXCLiiJ1cIixcblx0XCJQcm9wb3J0aW9uXCI6IFwi4oi3XCIsXG5cdFwicHJvcHRvXCI6IFwi4oidXCIsXG5cdFwicHJzaW1cIjogXCLiib5cIixcblx0XCJwcnVyZWxcIjogXCLiirBcIixcblx0XCJQc2NyXCI6IFwi8J2Sq1wiLFxuXHRcInBzY3JcIjogXCLwnZOFXCIsXG5cdFwiUHNpXCI6IFwizqhcIixcblx0XCJwc2lcIjogXCLPiFwiLFxuXHRcInB1bmNzcFwiOiBcIuKAiFwiLFxuXHRcIlFmclwiOiBcIvCdlJRcIixcblx0XCJxZnJcIjogXCLwnZSuXCIsXG5cdFwicWludFwiOiBcIuKojFwiLFxuXHRcInFvcGZcIjogXCLwnZWiXCIsXG5cdFwiUW9wZlwiOiBcIuKEmlwiLFxuXHRcInFwcmltZVwiOiBcIuKBl1wiLFxuXHRcIlFzY3JcIjogXCLwnZKsXCIsXG5cdFwicXNjclwiOiBcIvCdk4ZcIixcblx0XCJxdWF0ZXJuaW9uc1wiOiBcIuKEjVwiLFxuXHRcInF1YXRpbnRcIjogXCLiqJZcIixcblx0XCJxdWVzdFwiOiBcIj9cIixcblx0XCJxdWVzdGVxXCI6IFwi4omfXCIsXG5cdFwicXVvdFwiOiBcIlxcXCJcIixcblx0XCJRVU9UXCI6IFwiXFxcIlwiLFxuXHRcInJBYXJyXCI6IFwi4oebXCIsXG5cdFwicmFjZVwiOiBcIuKIvcyxXCIsXG5cdFwiUmFjdXRlXCI6IFwixZRcIixcblx0XCJyYWN1dGVcIjogXCLFlVwiLFxuXHRcInJhZGljXCI6IFwi4oiaXCIsXG5cdFwicmFlbXB0eXZcIjogXCLiprNcIixcblx0XCJyYW5nXCI6IFwi4p+pXCIsXG5cdFwiUmFuZ1wiOiBcIuKfq1wiLFxuXHRcInJhbmdkXCI6IFwi4qaSXCIsXG5cdFwicmFuZ2VcIjogXCLipqVcIixcblx0XCJyYW5nbGVcIjogXCLin6lcIixcblx0XCJyYXF1b1wiOiBcIsK7XCIsXG5cdFwicmFycmFwXCI6IFwi4qW1XCIsXG5cdFwicmFycmJcIjogXCLih6VcIixcblx0XCJyYXJyYmZzXCI6IFwi4qSgXCIsXG5cdFwicmFycmNcIjogXCLipLNcIixcblx0XCJyYXJyXCI6IFwi4oaSXCIsXG5cdFwiUmFyclwiOiBcIuKGoFwiLFxuXHRcInJBcnJcIjogXCLih5JcIixcblx0XCJyYXJyZnNcIjogXCLipJ5cIixcblx0XCJyYXJyaGtcIjogXCLihqpcIixcblx0XCJyYXJybHBcIjogXCLihqxcIixcblx0XCJyYXJycGxcIjogXCLipYVcIixcblx0XCJyYXJyc2ltXCI6IFwi4qW0XCIsXG5cdFwiUmFycnRsXCI6IFwi4qSWXCIsXG5cdFwicmFycnRsXCI6IFwi4oajXCIsXG5cdFwicmFycndcIjogXCLihp1cIixcblx0XCJyYXRhaWxcIjogXCLipJpcIixcblx0XCJyQXRhaWxcIjogXCLipJxcIixcblx0XCJyYXRpb1wiOiBcIuKItlwiLFxuXHRcInJhdGlvbmFsc1wiOiBcIuKEmlwiLFxuXHRcInJiYXJyXCI6IFwi4qSNXCIsXG5cdFwickJhcnJcIjogXCLipI9cIixcblx0XCJSQmFyclwiOiBcIuKkkFwiLFxuXHRcInJiYnJrXCI6IFwi4p2zXCIsXG5cdFwicmJyYWNlXCI6IFwifVwiLFxuXHRcInJicmFja1wiOiBcIl1cIixcblx0XCJyYnJrZVwiOiBcIuKmjFwiLFxuXHRcInJicmtzbGRcIjogXCLipo5cIixcblx0XCJyYnJrc2x1XCI6IFwi4qaQXCIsXG5cdFwiUmNhcm9uXCI6IFwixZhcIixcblx0XCJyY2Fyb25cIjogXCLFmVwiLFxuXHRcIlJjZWRpbFwiOiBcIsWWXCIsXG5cdFwicmNlZGlsXCI6IFwixZdcIixcblx0XCJyY2VpbFwiOiBcIuKMiVwiLFxuXHRcInJjdWJcIjogXCJ9XCIsXG5cdFwiUmN5XCI6IFwi0KBcIixcblx0XCJyY3lcIjogXCLRgFwiLFxuXHRcInJkY2FcIjogXCLipLdcIixcblx0XCJyZGxkaGFyXCI6IFwi4qWpXCIsXG5cdFwicmRxdW9cIjogXCLigJ1cIixcblx0XCJyZHF1b3JcIjogXCLigJ1cIixcblx0XCJyZHNoXCI6IFwi4oazXCIsXG5cdFwicmVhbFwiOiBcIuKEnFwiLFxuXHRcInJlYWxpbmVcIjogXCLihJtcIixcblx0XCJyZWFscGFydFwiOiBcIuKEnFwiLFxuXHRcInJlYWxzXCI6IFwi4oSdXCIsXG5cdFwiUmVcIjogXCLihJxcIixcblx0XCJyZWN0XCI6IFwi4patXCIsXG5cdFwicmVnXCI6IFwiwq5cIixcblx0XCJSRUdcIjogXCLCrlwiLFxuXHRcIlJldmVyc2VFbGVtZW50XCI6IFwi4oiLXCIsXG5cdFwiUmV2ZXJzZUVxdWlsaWJyaXVtXCI6IFwi4oeLXCIsXG5cdFwiUmV2ZXJzZVVwRXF1aWxpYnJpdW1cIjogXCLipa9cIixcblx0XCJyZmlzaHRcIjogXCLipb1cIixcblx0XCJyZmxvb3JcIjogXCLijItcIixcblx0XCJyZnJcIjogXCLwnZSvXCIsXG5cdFwiUmZyXCI6IFwi4oScXCIsXG5cdFwickhhclwiOiBcIuKlpFwiLFxuXHRcInJoYXJkXCI6IFwi4oeBXCIsXG5cdFwicmhhcnVcIjogXCLih4BcIixcblx0XCJyaGFydWxcIjogXCLipaxcIixcblx0XCJSaG9cIjogXCLOoVwiLFxuXHRcInJob1wiOiBcIs+BXCIsXG5cdFwicmhvdlwiOiBcIs+xXCIsXG5cdFwiUmlnaHRBbmdsZUJyYWNrZXRcIjogXCLin6lcIixcblx0XCJSaWdodEFycm93QmFyXCI6IFwi4oelXCIsXG5cdFwicmlnaHRhcnJvd1wiOiBcIuKGklwiLFxuXHRcIlJpZ2h0QXJyb3dcIjogXCLihpJcIixcblx0XCJSaWdodGFycm93XCI6IFwi4oeSXCIsXG5cdFwiUmlnaHRBcnJvd0xlZnRBcnJvd1wiOiBcIuKHhFwiLFxuXHRcInJpZ2h0YXJyb3d0YWlsXCI6IFwi4oajXCIsXG5cdFwiUmlnaHRDZWlsaW5nXCI6IFwi4oyJXCIsXG5cdFwiUmlnaHREb3VibGVCcmFja2V0XCI6IFwi4p+nXCIsXG5cdFwiUmlnaHREb3duVGVlVmVjdG9yXCI6IFwi4qWdXCIsXG5cdFwiUmlnaHREb3duVmVjdG9yQmFyXCI6IFwi4qWVXCIsXG5cdFwiUmlnaHREb3duVmVjdG9yXCI6IFwi4oeCXCIsXG5cdFwiUmlnaHRGbG9vclwiOiBcIuKMi1wiLFxuXHRcInJpZ2h0aGFycG9vbmRvd25cIjogXCLih4FcIixcblx0XCJyaWdodGhhcnBvb251cFwiOiBcIuKHgFwiLFxuXHRcInJpZ2h0bGVmdGFycm93c1wiOiBcIuKHhFwiLFxuXHRcInJpZ2h0bGVmdGhhcnBvb25zXCI6IFwi4oeMXCIsXG5cdFwicmlnaHRyaWdodGFycm93c1wiOiBcIuKHiVwiLFxuXHRcInJpZ2h0c3F1aWdhcnJvd1wiOiBcIuKGnVwiLFxuXHRcIlJpZ2h0VGVlQXJyb3dcIjogXCLihqZcIixcblx0XCJSaWdodFRlZVwiOiBcIuKKolwiLFxuXHRcIlJpZ2h0VGVlVmVjdG9yXCI6IFwi4qWbXCIsXG5cdFwicmlnaHR0aHJlZXRpbWVzXCI6IFwi4ouMXCIsXG5cdFwiUmlnaHRUcmlhbmdsZUJhclwiOiBcIuKnkFwiLFxuXHRcIlJpZ2h0VHJpYW5nbGVcIjogXCLiirNcIixcblx0XCJSaWdodFRyaWFuZ2xlRXF1YWxcIjogXCLiirVcIixcblx0XCJSaWdodFVwRG93blZlY3RvclwiOiBcIuKlj1wiLFxuXHRcIlJpZ2h0VXBUZWVWZWN0b3JcIjogXCLipZxcIixcblx0XCJSaWdodFVwVmVjdG9yQmFyXCI6IFwi4qWUXCIsXG5cdFwiUmlnaHRVcFZlY3RvclwiOiBcIuKGvlwiLFxuXHRcIlJpZ2h0VmVjdG9yQmFyXCI6IFwi4qWTXCIsXG5cdFwiUmlnaHRWZWN0b3JcIjogXCLih4BcIixcblx0XCJyaW5nXCI6IFwiy5pcIixcblx0XCJyaXNpbmdkb3RzZXFcIjogXCLiiZNcIixcblx0XCJybGFyclwiOiBcIuKHhFwiLFxuXHRcInJsaGFyXCI6IFwi4oeMXCIsXG5cdFwicmxtXCI6IFwi4oCPXCIsXG5cdFwicm1vdXN0YWNoZVwiOiBcIuKOsVwiLFxuXHRcInJtb3VzdFwiOiBcIuKOsVwiLFxuXHRcInJubWlkXCI6IFwi4quuXCIsXG5cdFwicm9hbmdcIjogXCLin61cIixcblx0XCJyb2FyclwiOiBcIuKHvlwiLFxuXHRcInJvYnJrXCI6IFwi4p+nXCIsXG5cdFwicm9wYXJcIjogXCLipoZcIixcblx0XCJyb3BmXCI6IFwi8J2Vo1wiLFxuXHRcIlJvcGZcIjogXCLihJ1cIixcblx0XCJyb3BsdXNcIjogXCLiqK5cIixcblx0XCJyb3RpbWVzXCI6IFwi4qi1XCIsXG5cdFwiUm91bmRJbXBsaWVzXCI6IFwi4qWwXCIsXG5cdFwicnBhclwiOiBcIilcIixcblx0XCJycGFyZ3RcIjogXCLippRcIixcblx0XCJycHBvbGludFwiOiBcIuKoklwiLFxuXHRcInJyYXJyXCI6IFwi4oeJXCIsXG5cdFwiUnJpZ2h0YXJyb3dcIjogXCLih5tcIixcblx0XCJyc2FxdW9cIjogXCLigLpcIixcblx0XCJyc2NyXCI6IFwi8J2Th1wiLFxuXHRcIlJzY3JcIjogXCLihJtcIixcblx0XCJyc2hcIjogXCLihrFcIixcblx0XCJSc2hcIjogXCLihrFcIixcblx0XCJyc3FiXCI6IFwiXVwiLFxuXHRcInJzcXVvXCI6IFwi4oCZXCIsXG5cdFwicnNxdW9yXCI6IFwi4oCZXCIsXG5cdFwicnRocmVlXCI6IFwi4ouMXCIsXG5cdFwicnRpbWVzXCI6IFwi4ouKXCIsXG5cdFwicnRyaVwiOiBcIuKWuVwiLFxuXHRcInJ0cmllXCI6IFwi4oq1XCIsXG5cdFwicnRyaWZcIjogXCLilrhcIixcblx0XCJydHJpbHRyaVwiOiBcIuKnjlwiLFxuXHRcIlJ1bGVEZWxheWVkXCI6IFwi4qe0XCIsXG5cdFwicnVsdWhhclwiOiBcIuKlqFwiLFxuXHRcInJ4XCI6IFwi4oSeXCIsXG5cdFwiU2FjdXRlXCI6IFwixZpcIixcblx0XCJzYWN1dGVcIjogXCLFm1wiLFxuXHRcInNicXVvXCI6IFwi4oCaXCIsXG5cdFwic2NhcFwiOiBcIuKquFwiLFxuXHRcIlNjYXJvblwiOiBcIsWgXCIsXG5cdFwic2Nhcm9uXCI6IFwixaFcIixcblx0XCJTY1wiOiBcIuKqvFwiLFxuXHRcInNjXCI6IFwi4om7XCIsXG5cdFwic2NjdWVcIjogXCLiib1cIixcblx0XCJzY2VcIjogXCLiqrBcIixcblx0XCJzY0VcIjogXCLiqrRcIixcblx0XCJTY2VkaWxcIjogXCLFnlwiLFxuXHRcInNjZWRpbFwiOiBcIsWfXCIsXG5cdFwiU2NpcmNcIjogXCLFnFwiLFxuXHRcInNjaXJjXCI6IFwixZ1cIixcblx0XCJzY25hcFwiOiBcIuKqulwiLFxuXHRcInNjbkVcIjogXCLiqrZcIixcblx0XCJzY25zaW1cIjogXCLii6lcIixcblx0XCJzY3BvbGludFwiOiBcIuKok1wiLFxuXHRcInNjc2ltXCI6IFwi4om/XCIsXG5cdFwiU2N5XCI6IFwi0KFcIixcblx0XCJzY3lcIjogXCLRgVwiLFxuXHRcInNkb3RiXCI6IFwi4oqhXCIsXG5cdFwic2RvdFwiOiBcIuKLhVwiLFxuXHRcInNkb3RlXCI6IFwi4qmmXCIsXG5cdFwic2VhcmhrXCI6IFwi4qSlXCIsXG5cdFwic2VhcnJcIjogXCLihphcIixcblx0XCJzZUFyclwiOiBcIuKHmFwiLFxuXHRcInNlYXJyb3dcIjogXCLihphcIixcblx0XCJzZWN0XCI6IFwiwqdcIixcblx0XCJzZW1pXCI6IFwiO1wiLFxuXHRcInNlc3dhclwiOiBcIuKkqVwiLFxuXHRcInNldG1pbnVzXCI6IFwi4oiWXCIsXG5cdFwic2V0bW5cIjogXCLiiJZcIixcblx0XCJzZXh0XCI6IFwi4py2XCIsXG5cdFwiU2ZyXCI6IFwi8J2UllwiLFxuXHRcInNmclwiOiBcIvCdlLBcIixcblx0XCJzZnJvd25cIjogXCLijKJcIixcblx0XCJzaGFycFwiOiBcIuKZr1wiLFxuXHRcIlNIQ0hjeVwiOiBcItCpXCIsXG5cdFwic2hjaGN5XCI6IFwi0YlcIixcblx0XCJTSGN5XCI6IFwi0KhcIixcblx0XCJzaGN5XCI6IFwi0YhcIixcblx0XCJTaG9ydERvd25BcnJvd1wiOiBcIuKGk1wiLFxuXHRcIlNob3J0TGVmdEFycm93XCI6IFwi4oaQXCIsXG5cdFwic2hvcnRtaWRcIjogXCLiiKNcIixcblx0XCJzaG9ydHBhcmFsbGVsXCI6IFwi4oilXCIsXG5cdFwiU2hvcnRSaWdodEFycm93XCI6IFwi4oaSXCIsXG5cdFwiU2hvcnRVcEFycm93XCI6IFwi4oaRXCIsXG5cdFwic2h5XCI6IFwiwq1cIixcblx0XCJTaWdtYVwiOiBcIs6jXCIsXG5cdFwic2lnbWFcIjogXCLPg1wiLFxuXHRcInNpZ21hZlwiOiBcIs+CXCIsXG5cdFwic2lnbWF2XCI6IFwiz4JcIixcblx0XCJzaW1cIjogXCLiiLxcIixcblx0XCJzaW1kb3RcIjogXCLiqapcIixcblx0XCJzaW1lXCI6IFwi4omDXCIsXG5cdFwic2ltZXFcIjogXCLiiYNcIixcblx0XCJzaW1nXCI6IFwi4qqeXCIsXG5cdFwic2ltZ0VcIjogXCLiqqBcIixcblx0XCJzaW1sXCI6IFwi4qqdXCIsXG5cdFwic2ltbEVcIjogXCLiqp9cIixcblx0XCJzaW1uZVwiOiBcIuKJhlwiLFxuXHRcInNpbXBsdXNcIjogXCLiqKRcIixcblx0XCJzaW1yYXJyXCI6IFwi4qWyXCIsXG5cdFwic2xhcnJcIjogXCLihpBcIixcblx0XCJTbWFsbENpcmNsZVwiOiBcIuKImFwiLFxuXHRcInNtYWxsc2V0bWludXNcIjogXCLiiJZcIixcblx0XCJzbWFzaHBcIjogXCLiqLNcIixcblx0XCJzbWVwYXJzbFwiOiBcIuKnpFwiLFxuXHRcInNtaWRcIjogXCLiiKNcIixcblx0XCJzbWlsZVwiOiBcIuKMo1wiLFxuXHRcInNtdFwiOiBcIuKqqlwiLFxuXHRcInNtdGVcIjogXCLiqqxcIixcblx0XCJzbXRlc1wiOiBcIuKqrO+4gFwiLFxuXHRcIlNPRlRjeVwiOiBcItCsXCIsXG5cdFwic29mdGN5XCI6IFwi0YxcIixcblx0XCJzb2xiYXJcIjogXCLijL9cIixcblx0XCJzb2xiXCI6IFwi4qeEXCIsXG5cdFwic29sXCI6IFwiL1wiLFxuXHRcIlNvcGZcIjogXCLwnZWKXCIsXG5cdFwic29wZlwiOiBcIvCdlaRcIixcblx0XCJzcGFkZXNcIjogXCLimaBcIixcblx0XCJzcGFkZXN1aXRcIjogXCLimaBcIixcblx0XCJzcGFyXCI6IFwi4oilXCIsXG5cdFwic3FjYXBcIjogXCLiipNcIixcblx0XCJzcWNhcHNcIjogXCLiipPvuIBcIixcblx0XCJzcWN1cFwiOiBcIuKKlFwiLFxuXHRcInNxY3Vwc1wiOiBcIuKKlO+4gFwiLFxuXHRcIlNxcnRcIjogXCLiiJpcIixcblx0XCJzcXN1YlwiOiBcIuKKj1wiLFxuXHRcInNxc3ViZVwiOiBcIuKKkVwiLFxuXHRcInNxc3Vic2V0XCI6IFwi4oqPXCIsXG5cdFwic3FzdWJzZXRlcVwiOiBcIuKKkVwiLFxuXHRcInNxc3VwXCI6IFwi4oqQXCIsXG5cdFwic3FzdXBlXCI6IFwi4oqSXCIsXG5cdFwic3FzdXBzZXRcIjogXCLiipBcIixcblx0XCJzcXN1cHNldGVxXCI6IFwi4oqSXCIsXG5cdFwic3F1YXJlXCI6IFwi4pahXCIsXG5cdFwiU3F1YXJlXCI6IFwi4pahXCIsXG5cdFwiU3F1YXJlSW50ZXJzZWN0aW9uXCI6IFwi4oqTXCIsXG5cdFwiU3F1YXJlU3Vic2V0XCI6IFwi4oqPXCIsXG5cdFwiU3F1YXJlU3Vic2V0RXF1YWxcIjogXCLiipFcIixcblx0XCJTcXVhcmVTdXBlcnNldFwiOiBcIuKKkFwiLFxuXHRcIlNxdWFyZVN1cGVyc2V0RXF1YWxcIjogXCLiipJcIixcblx0XCJTcXVhcmVVbmlvblwiOiBcIuKKlFwiLFxuXHRcInNxdWFyZlwiOiBcIuKWqlwiLFxuXHRcInNxdVwiOiBcIuKWoVwiLFxuXHRcInNxdWZcIjogXCLilqpcIixcblx0XCJzcmFyclwiOiBcIuKGklwiLFxuXHRcIlNzY3JcIjogXCLwnZKuXCIsXG5cdFwic3NjclwiOiBcIvCdk4hcIixcblx0XCJzc2V0bW5cIjogXCLiiJZcIixcblx0XCJzc21pbGVcIjogXCLijKNcIixcblx0XCJzc3RhcmZcIjogXCLii4ZcIixcblx0XCJTdGFyXCI6IFwi4ouGXCIsXG5cdFwic3RhclwiOiBcIuKYhlwiLFxuXHRcInN0YXJmXCI6IFwi4piFXCIsXG5cdFwic3RyYWlnaHRlcHNpbG9uXCI6IFwiz7VcIixcblx0XCJzdHJhaWdodHBoaVwiOiBcIs+VXCIsXG5cdFwic3RybnNcIjogXCLCr1wiLFxuXHRcInN1YlwiOiBcIuKKglwiLFxuXHRcIlN1YlwiOiBcIuKLkFwiLFxuXHRcInN1YmRvdFwiOiBcIuKqvVwiLFxuXHRcInN1YkVcIjogXCLiq4VcIixcblx0XCJzdWJlXCI6IFwi4oqGXCIsXG5cdFwic3ViZWRvdFwiOiBcIuKrg1wiLFxuXHRcInN1Ym11bHRcIjogXCLiq4FcIixcblx0XCJzdWJuRVwiOiBcIuKri1wiLFxuXHRcInN1Ym5lXCI6IFwi4oqKXCIsXG5cdFwic3VicGx1c1wiOiBcIuKqv1wiLFxuXHRcInN1YnJhcnJcIjogXCLipblcIixcblx0XCJzdWJzZXRcIjogXCLiioJcIixcblx0XCJTdWJzZXRcIjogXCLii5BcIixcblx0XCJzdWJzZXRlcVwiOiBcIuKKhlwiLFxuXHRcInN1YnNldGVxcVwiOiBcIuKrhVwiLFxuXHRcIlN1YnNldEVxdWFsXCI6IFwi4oqGXCIsXG5cdFwic3Vic2V0bmVxXCI6IFwi4oqKXCIsXG5cdFwic3Vic2V0bmVxcVwiOiBcIuKri1wiLFxuXHRcInN1YnNpbVwiOiBcIuKrh1wiLFxuXHRcInN1YnN1YlwiOiBcIuKrlVwiLFxuXHRcInN1YnN1cFwiOiBcIuKrk1wiLFxuXHRcInN1Y2NhcHByb3hcIjogXCLiqrhcIixcblx0XCJzdWNjXCI6IFwi4om7XCIsXG5cdFwic3VjY2N1cmx5ZXFcIjogXCLiib1cIixcblx0XCJTdWNjZWVkc1wiOiBcIuKJu1wiLFxuXHRcIlN1Y2NlZWRzRXF1YWxcIjogXCLiqrBcIixcblx0XCJTdWNjZWVkc1NsYW50RXF1YWxcIjogXCLiib1cIixcblx0XCJTdWNjZWVkc1RpbGRlXCI6IFwi4om/XCIsXG5cdFwic3VjY2VxXCI6IFwi4qqwXCIsXG5cdFwic3VjY25hcHByb3hcIjogXCLiqrpcIixcblx0XCJzdWNjbmVxcVwiOiBcIuKqtlwiLFxuXHRcInN1Y2Nuc2ltXCI6IFwi4oupXCIsXG5cdFwic3VjY3NpbVwiOiBcIuKJv1wiLFxuXHRcIlN1Y2hUaGF0XCI6IFwi4oiLXCIsXG5cdFwic3VtXCI6IFwi4oiRXCIsXG5cdFwiU3VtXCI6IFwi4oiRXCIsXG5cdFwic3VuZ1wiOiBcIuKZqlwiLFxuXHRcInN1cDFcIjogXCLCuVwiLFxuXHRcInN1cDJcIjogXCLCslwiLFxuXHRcInN1cDNcIjogXCLCs1wiLFxuXHRcInN1cFwiOiBcIuKKg1wiLFxuXHRcIlN1cFwiOiBcIuKLkVwiLFxuXHRcInN1cGRvdFwiOiBcIuKqvlwiLFxuXHRcInN1cGRzdWJcIjogXCLiq5hcIixcblx0XCJzdXBFXCI6IFwi4quGXCIsXG5cdFwic3VwZVwiOiBcIuKKh1wiLFxuXHRcInN1cGVkb3RcIjogXCLiq4RcIixcblx0XCJTdXBlcnNldFwiOiBcIuKKg1wiLFxuXHRcIlN1cGVyc2V0RXF1YWxcIjogXCLiiodcIixcblx0XCJzdXBoc29sXCI6IFwi4p+JXCIsXG5cdFwic3VwaHN1YlwiOiBcIuKrl1wiLFxuXHRcInN1cGxhcnJcIjogXCLipbtcIixcblx0XCJzdXBtdWx0XCI6IFwi4quCXCIsXG5cdFwic3VwbkVcIjogXCLiq4xcIixcblx0XCJzdXBuZVwiOiBcIuKKi1wiLFxuXHRcInN1cHBsdXNcIjogXCLiq4BcIixcblx0XCJzdXBzZXRcIjogXCLiioNcIixcblx0XCJTdXBzZXRcIjogXCLii5FcIixcblx0XCJzdXBzZXRlcVwiOiBcIuKKh1wiLFxuXHRcInN1cHNldGVxcVwiOiBcIuKrhlwiLFxuXHRcInN1cHNldG5lcVwiOiBcIuKKi1wiLFxuXHRcInN1cHNldG5lcXFcIjogXCLiq4xcIixcblx0XCJzdXBzaW1cIjogXCLiq4hcIixcblx0XCJzdXBzdWJcIjogXCLiq5RcIixcblx0XCJzdXBzdXBcIjogXCLiq5ZcIixcblx0XCJzd2FyaGtcIjogXCLipKZcIixcblx0XCJzd2FyclwiOiBcIuKGmVwiLFxuXHRcInN3QXJyXCI6IFwi4oeZXCIsXG5cdFwic3dhcnJvd1wiOiBcIuKGmVwiLFxuXHRcInN3bndhclwiOiBcIuKkqlwiLFxuXHRcInN6bGlnXCI6IFwiw59cIixcblx0XCJUYWJcIjogXCJcXHRcIixcblx0XCJ0YXJnZXRcIjogXCLijJZcIixcblx0XCJUYXVcIjogXCLOpFwiLFxuXHRcInRhdVwiOiBcIs+EXCIsXG5cdFwidGJya1wiOiBcIuKOtFwiLFxuXHRcIlRjYXJvblwiOiBcIsWkXCIsXG5cdFwidGNhcm9uXCI6IFwixaVcIixcblx0XCJUY2VkaWxcIjogXCLFolwiLFxuXHRcInRjZWRpbFwiOiBcIsWjXCIsXG5cdFwiVGN5XCI6IFwi0KJcIixcblx0XCJ0Y3lcIjogXCLRglwiLFxuXHRcInRkb3RcIjogXCLig5tcIixcblx0XCJ0ZWxyZWNcIjogXCLijJVcIixcblx0XCJUZnJcIjogXCLwnZSXXCIsXG5cdFwidGZyXCI6IFwi8J2UsVwiLFxuXHRcInRoZXJlNFwiOiBcIuKItFwiLFxuXHRcInRoZXJlZm9yZVwiOiBcIuKItFwiLFxuXHRcIlRoZXJlZm9yZVwiOiBcIuKItFwiLFxuXHRcIlRoZXRhXCI6IFwizphcIixcblx0XCJ0aGV0YVwiOiBcIs64XCIsXG5cdFwidGhldGFzeW1cIjogXCLPkVwiLFxuXHRcInRoZXRhdlwiOiBcIs+RXCIsXG5cdFwidGhpY2thcHByb3hcIjogXCLiiYhcIixcblx0XCJ0aGlja3NpbVwiOiBcIuKIvFwiLFxuXHRcIlRoaWNrU3BhY2VcIjogXCLigZ/igIpcIixcblx0XCJUaGluU3BhY2VcIjogXCLigIlcIixcblx0XCJ0aGluc3BcIjogXCLigIlcIixcblx0XCJ0aGthcFwiOiBcIuKJiFwiLFxuXHRcInRoa3NpbVwiOiBcIuKIvFwiLFxuXHRcIlRIT1JOXCI6IFwiw55cIixcblx0XCJ0aG9yblwiOiBcIsO+XCIsXG5cdFwidGlsZGVcIjogXCLLnFwiLFxuXHRcIlRpbGRlXCI6IFwi4oi8XCIsXG5cdFwiVGlsZGVFcXVhbFwiOiBcIuKJg1wiLFxuXHRcIlRpbGRlRnVsbEVxdWFsXCI6IFwi4omFXCIsXG5cdFwiVGlsZGVUaWxkZVwiOiBcIuKJiFwiLFxuXHRcInRpbWVzYmFyXCI6IFwi4qixXCIsXG5cdFwidGltZXNiXCI6IFwi4oqgXCIsXG5cdFwidGltZXNcIjogXCLDl1wiLFxuXHRcInRpbWVzZFwiOiBcIuKosFwiLFxuXHRcInRpbnRcIjogXCLiiK1cIixcblx0XCJ0b2VhXCI6IFwi4qSoXCIsXG5cdFwidG9wYm90XCI6IFwi4oy2XCIsXG5cdFwidG9wY2lyXCI6IFwi4quxXCIsXG5cdFwidG9wXCI6IFwi4oqkXCIsXG5cdFwiVG9wZlwiOiBcIvCdlYtcIixcblx0XCJ0b3BmXCI6IFwi8J2VpVwiLFxuXHRcInRvcGZvcmtcIjogXCLiq5pcIixcblx0XCJ0b3NhXCI6IFwi4qSpXCIsXG5cdFwidHByaW1lXCI6IFwi4oC0XCIsXG5cdFwidHJhZGVcIjogXCLihKJcIixcblx0XCJUUkFERVwiOiBcIuKEolwiLFxuXHRcInRyaWFuZ2xlXCI6IFwi4pa1XCIsXG5cdFwidHJpYW5nbGVkb3duXCI6IFwi4pa/XCIsXG5cdFwidHJpYW5nbGVsZWZ0XCI6IFwi4peDXCIsXG5cdFwidHJpYW5nbGVsZWZ0ZXFcIjogXCLiirRcIixcblx0XCJ0cmlhbmdsZXFcIjogXCLiiZxcIixcblx0XCJ0cmlhbmdsZXJpZ2h0XCI6IFwi4pa5XCIsXG5cdFwidHJpYW5nbGVyaWdodGVxXCI6IFwi4oq1XCIsXG5cdFwidHJpZG90XCI6IFwi4pesXCIsXG5cdFwidHJpZVwiOiBcIuKJnFwiLFxuXHRcInRyaW1pbnVzXCI6IFwi4qi6XCIsXG5cdFwiVHJpcGxlRG90XCI6IFwi4oObXCIsXG5cdFwidHJpcGx1c1wiOiBcIuKouVwiLFxuXHRcInRyaXNiXCI6IFwi4qeNXCIsXG5cdFwidHJpdGltZVwiOiBcIuKou1wiLFxuXHRcInRycGV6aXVtXCI6IFwi4o+iXCIsXG5cdFwiVHNjclwiOiBcIvCdkq9cIixcblx0XCJ0c2NyXCI6IFwi8J2TiVwiLFxuXHRcIlRTY3lcIjogXCLQplwiLFxuXHRcInRzY3lcIjogXCLRhlwiLFxuXHRcIlRTSGN5XCI6IFwi0ItcIixcblx0XCJ0c2hjeVwiOiBcItGbXCIsXG5cdFwiVHN0cm9rXCI6IFwixaZcIixcblx0XCJ0c3Ryb2tcIjogXCLFp1wiLFxuXHRcInR3aXh0XCI6IFwi4omsXCIsXG5cdFwidHdvaGVhZGxlZnRhcnJvd1wiOiBcIuKGnlwiLFxuXHRcInR3b2hlYWRyaWdodGFycm93XCI6IFwi4oagXCIsXG5cdFwiVWFjdXRlXCI6IFwiw5pcIixcblx0XCJ1YWN1dGVcIjogXCLDulwiLFxuXHRcInVhcnJcIjogXCLihpFcIixcblx0XCJVYXJyXCI6IFwi4oafXCIsXG5cdFwidUFyclwiOiBcIuKHkVwiLFxuXHRcIlVhcnJvY2lyXCI6IFwi4qWJXCIsXG5cdFwiVWJyY3lcIjogXCLQjlwiLFxuXHRcInVicmN5XCI6IFwi0Z5cIixcblx0XCJVYnJldmVcIjogXCLFrFwiLFxuXHRcInVicmV2ZVwiOiBcIsWtXCIsXG5cdFwiVWNpcmNcIjogXCLDm1wiLFxuXHRcInVjaXJjXCI6IFwiw7tcIixcblx0XCJVY3lcIjogXCLQo1wiLFxuXHRcInVjeVwiOiBcItGDXCIsXG5cdFwidWRhcnJcIjogXCLih4VcIixcblx0XCJVZGJsYWNcIjogXCLFsFwiLFxuXHRcInVkYmxhY1wiOiBcIsWxXCIsXG5cdFwidWRoYXJcIjogXCLipa5cIixcblx0XCJ1ZmlzaHRcIjogXCLipb5cIixcblx0XCJVZnJcIjogXCLwnZSYXCIsXG5cdFwidWZyXCI6IFwi8J2UslwiLFxuXHRcIlVncmF2ZVwiOiBcIsOZXCIsXG5cdFwidWdyYXZlXCI6IFwiw7lcIixcblx0XCJ1SGFyXCI6IFwi4qWjXCIsXG5cdFwidWhhcmxcIjogXCLihr9cIixcblx0XCJ1aGFyclwiOiBcIuKGvlwiLFxuXHRcInVoYmxrXCI6IFwi4paAXCIsXG5cdFwidWxjb3JuXCI6IFwi4oycXCIsXG5cdFwidWxjb3JuZXJcIjogXCLijJxcIixcblx0XCJ1bGNyb3BcIjogXCLijI9cIixcblx0XCJ1bHRyaVwiOiBcIuKXuFwiLFxuXHRcIlVtYWNyXCI6IFwixapcIixcblx0XCJ1bWFjclwiOiBcIsWrXCIsXG5cdFwidW1sXCI6IFwiwqhcIixcblx0XCJVbmRlckJhclwiOiBcIl9cIixcblx0XCJVbmRlckJyYWNlXCI6IFwi4o+fXCIsXG5cdFwiVW5kZXJCcmFja2V0XCI6IFwi4o61XCIsXG5cdFwiVW5kZXJQYXJlbnRoZXNpc1wiOiBcIuKPnVwiLFxuXHRcIlVuaW9uXCI6IFwi4ouDXCIsXG5cdFwiVW5pb25QbHVzXCI6IFwi4oqOXCIsXG5cdFwiVW9nb25cIjogXCLFslwiLFxuXHRcInVvZ29uXCI6IFwixbNcIixcblx0XCJVb3BmXCI6IFwi8J2VjFwiLFxuXHRcInVvcGZcIjogXCLwnZWmXCIsXG5cdFwiVXBBcnJvd0JhclwiOiBcIuKkklwiLFxuXHRcInVwYXJyb3dcIjogXCLihpFcIixcblx0XCJVcEFycm93XCI6IFwi4oaRXCIsXG5cdFwiVXBhcnJvd1wiOiBcIuKHkVwiLFxuXHRcIlVwQXJyb3dEb3duQXJyb3dcIjogXCLih4VcIixcblx0XCJ1cGRvd25hcnJvd1wiOiBcIuKGlVwiLFxuXHRcIlVwRG93bkFycm93XCI6IFwi4oaVXCIsXG5cdFwiVXBkb3duYXJyb3dcIjogXCLih5VcIixcblx0XCJVcEVxdWlsaWJyaXVtXCI6IFwi4qWuXCIsXG5cdFwidXBoYXJwb29ubGVmdFwiOiBcIuKGv1wiLFxuXHRcInVwaGFycG9vbnJpZ2h0XCI6IFwi4oa+XCIsXG5cdFwidXBsdXNcIjogXCLiio5cIixcblx0XCJVcHBlckxlZnRBcnJvd1wiOiBcIuKGllwiLFxuXHRcIlVwcGVyUmlnaHRBcnJvd1wiOiBcIuKGl1wiLFxuXHRcInVwc2lcIjogXCLPhVwiLFxuXHRcIlVwc2lcIjogXCLPklwiLFxuXHRcInVwc2loXCI6IFwiz5JcIixcblx0XCJVcHNpbG9uXCI6IFwizqVcIixcblx0XCJ1cHNpbG9uXCI6IFwiz4VcIixcblx0XCJVcFRlZUFycm93XCI6IFwi4oalXCIsXG5cdFwiVXBUZWVcIjogXCLiiqVcIixcblx0XCJ1cHVwYXJyb3dzXCI6IFwi4oeIXCIsXG5cdFwidXJjb3JuXCI6IFwi4oydXCIsXG5cdFwidXJjb3JuZXJcIjogXCLijJ1cIixcblx0XCJ1cmNyb3BcIjogXCLijI5cIixcblx0XCJVcmluZ1wiOiBcIsWuXCIsXG5cdFwidXJpbmdcIjogXCLFr1wiLFxuXHRcInVydHJpXCI6IFwi4pe5XCIsXG5cdFwiVXNjclwiOiBcIvCdkrBcIixcblx0XCJ1c2NyXCI6IFwi8J2TilwiLFxuXHRcInV0ZG90XCI6IFwi4ouwXCIsXG5cdFwiVXRpbGRlXCI6IFwixahcIixcblx0XCJ1dGlsZGVcIjogXCLFqVwiLFxuXHRcInV0cmlcIjogXCLilrVcIixcblx0XCJ1dHJpZlwiOiBcIuKWtFwiLFxuXHRcInV1YXJyXCI6IFwi4oeIXCIsXG5cdFwiVXVtbFwiOiBcIsOcXCIsXG5cdFwidXVtbFwiOiBcIsO8XCIsXG5cdFwidXdhbmdsZVwiOiBcIuKmp1wiLFxuXHRcInZhbmdydFwiOiBcIuKmnFwiLFxuXHRcInZhcmVwc2lsb25cIjogXCLPtVwiLFxuXHRcInZhcmthcHBhXCI6IFwiz7BcIixcblx0XCJ2YXJub3RoaW5nXCI6IFwi4oiFXCIsXG5cdFwidmFycGhpXCI6IFwiz5VcIixcblx0XCJ2YXJwaVwiOiBcIs+WXCIsXG5cdFwidmFycHJvcHRvXCI6IFwi4oidXCIsXG5cdFwidmFyclwiOiBcIuKGlVwiLFxuXHRcInZBcnJcIjogXCLih5VcIixcblx0XCJ2YXJyaG9cIjogXCLPsVwiLFxuXHRcInZhcnNpZ21hXCI6IFwiz4JcIixcblx0XCJ2YXJzdWJzZXRuZXFcIjogXCLiiorvuIBcIixcblx0XCJ2YXJzdWJzZXRuZXFxXCI6IFwi4quL77iAXCIsXG5cdFwidmFyc3Vwc2V0bmVxXCI6IFwi4oqL77iAXCIsXG5cdFwidmFyc3Vwc2V0bmVxcVwiOiBcIuKrjO+4gFwiLFxuXHRcInZhcnRoZXRhXCI6IFwiz5FcIixcblx0XCJ2YXJ0cmlhbmdsZWxlZnRcIjogXCLiirJcIixcblx0XCJ2YXJ0cmlhbmdsZXJpZ2h0XCI6IFwi4oqzXCIsXG5cdFwidkJhclwiOiBcIuKrqFwiLFxuXHRcIlZiYXJcIjogXCLiq6tcIixcblx0XCJ2QmFydlwiOiBcIuKrqVwiLFxuXHRcIlZjeVwiOiBcItCSXCIsXG5cdFwidmN5XCI6IFwi0LJcIixcblx0XCJ2ZGFzaFwiOiBcIuKKolwiLFxuXHRcInZEYXNoXCI6IFwi4oqoXCIsXG5cdFwiVmRhc2hcIjogXCLiiqlcIixcblx0XCJWRGFzaFwiOiBcIuKKq1wiLFxuXHRcIlZkYXNobFwiOiBcIuKrplwiLFxuXHRcInZlZWJhclwiOiBcIuKKu1wiLFxuXHRcInZlZVwiOiBcIuKIqFwiLFxuXHRcIlZlZVwiOiBcIuKLgVwiLFxuXHRcInZlZWVxXCI6IFwi4omaXCIsXG5cdFwidmVsbGlwXCI6IFwi4ouuXCIsXG5cdFwidmVyYmFyXCI6IFwifFwiLFxuXHRcIlZlcmJhclwiOiBcIuKAllwiLFxuXHRcInZlcnRcIjogXCJ8XCIsXG5cdFwiVmVydFwiOiBcIuKAllwiLFxuXHRcIlZlcnRpY2FsQmFyXCI6IFwi4oijXCIsXG5cdFwiVmVydGljYWxMaW5lXCI6IFwifFwiLFxuXHRcIlZlcnRpY2FsU2VwYXJhdG9yXCI6IFwi4p2YXCIsXG5cdFwiVmVydGljYWxUaWxkZVwiOiBcIuKJgFwiLFxuXHRcIlZlcnlUaGluU3BhY2VcIjogXCLigIpcIixcblx0XCJWZnJcIjogXCLwnZSZXCIsXG5cdFwidmZyXCI6IFwi8J2Us1wiLFxuXHRcInZsdHJpXCI6IFwi4oqyXCIsXG5cdFwidm5zdWJcIjogXCLiioLig5JcIixcblx0XCJ2bnN1cFwiOiBcIuKKg+KDklwiLFxuXHRcIlZvcGZcIjogXCLwnZWNXCIsXG5cdFwidm9wZlwiOiBcIvCdladcIixcblx0XCJ2cHJvcFwiOiBcIuKInVwiLFxuXHRcInZydHJpXCI6IFwi4oqzXCIsXG5cdFwiVnNjclwiOiBcIvCdkrFcIixcblx0XCJ2c2NyXCI6IFwi8J2Ti1wiLFxuXHRcInZzdWJuRVwiOiBcIuKri++4gFwiLFxuXHRcInZzdWJuZVwiOiBcIuKKiu+4gFwiLFxuXHRcInZzdXBuRVwiOiBcIuKrjO+4gFwiLFxuXHRcInZzdXBuZVwiOiBcIuKKi++4gFwiLFxuXHRcIlZ2ZGFzaFwiOiBcIuKKqlwiLFxuXHRcInZ6aWd6YWdcIjogXCLipppcIixcblx0XCJXY2lyY1wiOiBcIsW0XCIsXG5cdFwid2NpcmNcIjogXCLFtVwiLFxuXHRcIndlZGJhclwiOiBcIuKpn1wiLFxuXHRcIndlZGdlXCI6IFwi4oinXCIsXG5cdFwiV2VkZ2VcIjogXCLii4BcIixcblx0XCJ3ZWRnZXFcIjogXCLiiZlcIixcblx0XCJ3ZWllcnBcIjogXCLihJhcIixcblx0XCJXZnJcIjogXCLwnZSaXCIsXG5cdFwid2ZyXCI6IFwi8J2UtFwiLFxuXHRcIldvcGZcIjogXCLwnZWOXCIsXG5cdFwid29wZlwiOiBcIvCdlahcIixcblx0XCJ3cFwiOiBcIuKEmFwiLFxuXHRcIndyXCI6IFwi4omAXCIsXG5cdFwid3JlYXRoXCI6IFwi4omAXCIsXG5cdFwiV3NjclwiOiBcIvCdkrJcIixcblx0XCJ3c2NyXCI6IFwi8J2TjFwiLFxuXHRcInhjYXBcIjogXCLii4JcIixcblx0XCJ4Y2lyY1wiOiBcIuKXr1wiLFxuXHRcInhjdXBcIjogXCLii4NcIixcblx0XCJ4ZHRyaVwiOiBcIuKWvVwiLFxuXHRcIlhmclwiOiBcIvCdlJtcIixcblx0XCJ4ZnJcIjogXCLwnZS1XCIsXG5cdFwieGhhcnJcIjogXCLin7dcIixcblx0XCJ4aEFyclwiOiBcIuKfulwiLFxuXHRcIlhpXCI6IFwizp5cIixcblx0XCJ4aVwiOiBcIs6+XCIsXG5cdFwieGxhcnJcIjogXCLin7VcIixcblx0XCJ4bEFyclwiOiBcIuKfuFwiLFxuXHRcInhtYXBcIjogXCLin7xcIixcblx0XCJ4bmlzXCI6IFwi4ou7XCIsXG5cdFwieG9kb3RcIjogXCLiqIBcIixcblx0XCJYb3BmXCI6IFwi8J2Vj1wiLFxuXHRcInhvcGZcIjogXCLwnZWpXCIsXG5cdFwieG9wbHVzXCI6IFwi4qiBXCIsXG5cdFwieG90aW1lXCI6IFwi4qiCXCIsXG5cdFwieHJhcnJcIjogXCLin7ZcIixcblx0XCJ4ckFyclwiOiBcIuKfuVwiLFxuXHRcIlhzY3JcIjogXCLwnZKzXCIsXG5cdFwieHNjclwiOiBcIvCdk41cIixcblx0XCJ4c3FjdXBcIjogXCLiqIZcIixcblx0XCJ4dXBsdXNcIjogXCLiqIRcIixcblx0XCJ4dXRyaVwiOiBcIuKWs1wiLFxuXHRcInh2ZWVcIjogXCLii4FcIixcblx0XCJ4d2VkZ2VcIjogXCLii4BcIixcblx0XCJZYWN1dGVcIjogXCLDnVwiLFxuXHRcInlhY3V0ZVwiOiBcIsO9XCIsXG5cdFwiWUFjeVwiOiBcItCvXCIsXG5cdFwieWFjeVwiOiBcItGPXCIsXG5cdFwiWWNpcmNcIjogXCLFtlwiLFxuXHRcInljaXJjXCI6IFwixbdcIixcblx0XCJZY3lcIjogXCLQq1wiLFxuXHRcInljeVwiOiBcItGLXCIsXG5cdFwieWVuXCI6IFwiwqVcIixcblx0XCJZZnJcIjogXCLwnZScXCIsXG5cdFwieWZyXCI6IFwi8J2UtlwiLFxuXHRcIllJY3lcIjogXCLQh1wiLFxuXHRcInlpY3lcIjogXCLRl1wiLFxuXHRcIllvcGZcIjogXCLwnZWQXCIsXG5cdFwieW9wZlwiOiBcIvCdlapcIixcblx0XCJZc2NyXCI6IFwi8J2StFwiLFxuXHRcInlzY3JcIjogXCLwnZOOXCIsXG5cdFwiWVVjeVwiOiBcItCuXCIsXG5cdFwieXVjeVwiOiBcItGOXCIsXG5cdFwieXVtbFwiOiBcIsO/XCIsXG5cdFwiWXVtbFwiOiBcIsW4XCIsXG5cdFwiWmFjdXRlXCI6IFwixblcIixcblx0XCJ6YWN1dGVcIjogXCLFulwiLFxuXHRcIlpjYXJvblwiOiBcIsW9XCIsXG5cdFwiemNhcm9uXCI6IFwixb5cIixcblx0XCJaY3lcIjogXCLQl1wiLFxuXHRcInpjeVwiOiBcItC3XCIsXG5cdFwiWmRvdFwiOiBcIsW7XCIsXG5cdFwiemRvdFwiOiBcIsW8XCIsXG5cdFwiemVldHJmXCI6IFwi4oSoXCIsXG5cdFwiWmVyb1dpZHRoU3BhY2VcIjogXCLigItcIixcblx0XCJaZXRhXCI6IFwizpZcIixcblx0XCJ6ZXRhXCI6IFwizrZcIixcblx0XCJ6ZnJcIjogXCLwnZS3XCIsXG5cdFwiWmZyXCI6IFwi4oSoXCIsXG5cdFwiWkhjeVwiOiBcItCWXCIsXG5cdFwiemhjeVwiOiBcItC2XCIsXG5cdFwiemlncmFyclwiOiBcIuKHnVwiLFxuXHRcInpvcGZcIjogXCLwnZWrXCIsXG5cdFwiWm9wZlwiOiBcIuKEpFwiLFxuXHRcIlpzY3JcIjogXCLwnZK1XCIsXG5cdFwienNjclwiOiBcIvCdk49cIixcblx0XCJ6d2pcIjogXCLigI1cIixcblx0XCJ6d25qXCI6IFwi4oCMXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgdm5vZGUuc3RhdGUuc3BhbiA9IHZub2RlLmF0dHJzLnNwYW47XG4gICAgdm5vZGUuc3RhdGUuY2xzID0gdm5vZGUuYXR0cnMuY2xzO1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtgbWRsLWNlbGwgbWRsLWNlbGwtLSR7dm5vZGUuc3RhdGUuc3Bhbn0tY29sICR7dm5vZGUuc3RhdGUuY2xzfWB9PlxuICAgICAge3Zub2RlLmF0dHJzLmlubmVyfVxuICAgIDwvZGl2PlxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL2NlbGwuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9saWJzL2NvbXBvbmVudHMvc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gICAgdm5vZGUuc3RhdGUub25pbnB1dCA9IHYgPT4ge1xuICAgICAgdm5vZGUuc3RhdGUubW9kZWwuZGF0YS5ib2R5ID0gdjtcbiAgICB9O1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSA8dGV4dGFyZWFcbiAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRleHRhcmVhfVxuICAgICAgb25pbnB1dD17bS53aXRoQXR0cigndmFsdWUnLCB2bm9kZS5zdGF0ZS5vbmlucHV0KX0+XG4gICAgICAgIHt2bm9kZS5zdGF0ZS5tb2RlbC5kYXRhLmJvZHl9XG4gICAgPC90ZXh0YXJlYT5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17Nn0gY2xzPXtgJHtzdHlsZXMuZWRpdG9yfSAke3N0eWxlcy5lZGl0b3JMZWZ0U2lkZX1gfSBpbm5lcj17aW5uZXJ9IC8+XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL2VkaXRvci5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9jZWxsLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgcmV0dXJuIDxDZWxsIHNwYW49ezZ9IGNscz17YCR7c3R5bGVzLmVkaXRvcn0gJHtzdHlsZXMuZWRpdG9yUmlnaHRTaWRlfWB9XG4gICAgICAgICAgICAgICAgIGlubmVyPXttLnRydXN0KHZub2RlLmF0dHJzLmJvZHkpfSAvPlxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL3ByZXZpZXcuanMiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMuY3NzJztcbmltcG9ydCBDZWxsIGZyb20gJy4vY2VsbC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgdm5vZGUuc3RhdGUubW9kZWwgPSB2bm9kZS5hdHRycy5tb2RlbDtcbiAgfSxcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPSdtZGwtYnV0dG9uIG1kbC1qcy1idXR0b24gbWRsLWJ1dHRvbi0tcmFpc2VkIG1kbC1idXR0b24tLWNvbG9yZWQnXG4gICAgICBvbmNsaWNrPXt2bm9kZS5zdGF0ZS5tb2RlbC5zYXZlfT5cbiAgICAgIHNhdmVcbiAgICA8L2J1dHRvbj5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGNscz17c3R5bGVzLnNhdmVCdXR0b259IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvY29tcG9uZW50cy9zYXZlLmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gICAgdm5vZGUuc3RhdGUub25jaGFuZ2UgPSB2ID0+IHtcbiAgICAgIHZub2RlLnN0YXRlLm1vZGVsLmRhdGEudGFncyA9IHYuc3BsaXQoJywnKTtcbiAgICB9O1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSA8aW5wdXQgdHlwZT0ndGV4dCcgY2xhc3NOYW1lPXtzdHlsZXMudGFnc31cbiAgICAgIG9uY2hhbmdlPXttLndpdGhBdHRyKCd2YWx1ZScsIHZub2RlLnN0YXRlLm9uY2hhbmFnZSl9XG4gICAgICB2YWx1ZT17dm5vZGUuc3RhdGUubW9kZWwuZGF0YS50YWdzLmpvaW4oJywnKX1cbiAgICAvPlxuICAgIHJldHVybiA8Q2VsbCBzcGFuPXsxMn0gaW5uZXI9e2lubmVyfSAvPlxuICB9XG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL3RhZ3MuanMiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBDZWxsIGZyb20gJy4vY2VsbC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgdm5vZGUuc3RhdGUubW9kZWwgPSB2bm9kZS5hdHRycy5tb2RlbDtcbiAgICB2bm9kZS5zdGF0ZS5vbmNoYW5nZSA9IHYgPT4ge1xuICAgICAgdm5vZGUuc3RhdGUubW9kZWwuZGF0YS50aXRsZSA9IHY7XG4gICAgfTtcbiAgfSxcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gPGlucHV0IHR5cGU9J3RleHQnIGNsYXNzTmFtZT17c3R5bGVzLnRpdGxlfVxuICAgICAgb25jaGFuZ2U9e20ud2l0aEF0dHIoJ3ZhbHVlJywgdm5vZGUuc3RhdGUub25jaGFuZ2UpfVxuICAgICAgdmFsdWU9e3Zub2RlLnN0YXRlLm1vZGVsLmRhdGEudGl0bGV9XG4gICAgLz5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9saWJzL2NvbXBvbmVudHMvdGl0bGUuanMiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9iYXNlNjQtanMvaW5kZXguanMiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9idWZmZXIvaW5kZXguanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCkge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgdmFyIGJhc2U2NCA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG4gIHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaWVlZTc1NC9pbmRleC5qcyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaXNhcnJheS9pbmRleC5qcyIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2ZpeFVybHMuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuWmVXM0hJd2FfQldJR1cweVpKaTVHe3dpZHRoOjEwMCU7Zm9udC1zaXplOjI0cHQ7cGFkZGluZy1sZWZ0OjEwcHh9Llpjc2FadmNvZjB0eFdkZXFpa0NHWnt3aWR0aDoxMDAlO2ZvbnQtc2l6ZToxOHB0O3BhZGRpbmctbGVmdDoxMHB4fS5fMW91YXNqNjQ2TTdpOW9Ldy0wUV81NXtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlO2hlaWdodDpjYWxjKDEwMCUgLSAyMzBweCl9Ll8yTUxXUjhXX3BIZk5Ca0JtcDBuaTA4e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JhY2tncm91bmQ6I2ZjZmNmYztwYWRkaW5nOjEwcHg7b3ZlcmZsb3c6YXV0bztoZWlnaHQ6MTAwJX0uR0pZb25TSExPWFpKaFBTVXdaZHZie2xlZnQ6MH0udV9SU3l2QkxEN2IwWjEyaHBLOEQ0e2xlZnQ6NTAlO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uXzJnQXRnbTlvQURPclpZdDF1ZG1jSlJ7dGV4dC1hbGlnbjpyaWdodDttYXJnaW4tdG9wOjE1cHh9Ll8zTkJiSXI0V2xIeVVRYzI5WVc2YlNYe3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7cmVzaXplOm5vbmU7YmFja2dyb3VuZC1jb2xvcjojZmNmY2ZjO2JvcmRlcjpub25lO2ZvbnQtc2l6ZToxMHB0fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInRpdGxlXCI6IFwiWmVXM0hJd2FfQldJR1cweVpKaTVHXCIsXG5cdFwidGFnc1wiOiBcIlpjc2FadmNvZjB0eFdkZXFpa0NHWlwiLFxuXHRcImVkaXRvcldyYXBcIjogXCJfMW91YXNqNjQ2TTdpOW9Ldy0wUV81NVwiLFxuXHRcImVkaXRvclwiOiBcIl8yTUxXUjhXX3BIZk5Ca0JtcDBuaTA4XCIsXG5cdFwiZWRpdG9yTGVmdFNpZGVcIjogXCJHSllvblNITE9YWkpoUFNVd1pkdmJcIixcblx0XCJlZGl0b3JSaWdodFNpZGVcIjogXCJ1X1JTeXZCTEQ3YjBaMTJocEs4RDRcIixcblx0XCJzYXZlQnV0dG9uXCI6IFwiXzJnQXRnbTlvQURPclpZdDF1ZG1jSlJcIixcblx0XCJ0ZXh0YXJlYVwiOiBcIl8zTkJiSXI0V2xIeVVRYzI5WVc2YlNYXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9jc3MtbG9hZGVyP3tcIm1vZHVsZXNcIjp0cnVlLFwibWluaW1pemVcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZX0hLi4vbGlicy9jb21wb25lbnRzL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHRcdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0XHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyIFxuXHRcdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHRcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRcdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcblx0fSksXG5cdGdldEVsZW1lbnQgPSAoZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdFx0fTtcblx0fSkoZnVuY3Rpb24gKHN0eWxlVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3R5bGVUYXJnZXQpXG5cdH0pLFxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW10sXG5cdGZpeFVybHMgPSByZXF1aXJlKFwiLi9maXhVcmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRJbnRvID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblx0aWYgKCFzdHlsZVRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgc3R5bGVUYXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHRzdHlsZVRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0c3R5bGVUYXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhzdHlsZUVsZW1lbnQsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGF0dGFjaFRhZ0F0dHJzKGxpbmtFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUYWdBdHRycyhlbGVtZW50LCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKiBJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscyl7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcblxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuXzJZcktFbXJ1U1hxLUxZOEhUOWdqY0F7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtoZWlnaHQ6Y2FsYygxMDAlIC0gMjMwcHgpfS5fM0w1TkVCODRLeFBmbHhCWnZleXNkZHt0ZXh0LWFsaWduOnJpZ2h0O21hcmdpbi10b3A6MTVweH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJlZGl0b3JXcmFwXCI6IFwiXzJZcktFbXJ1U1hxLUxZOEhUOWdqY0FcIixcblx0XCJzYXZlQnV0dG9uXCI6IFwiXzNMNU5FQjg0S3hQZmx4Qlp2ZXlzZGRcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2Nzcy1sb2FkZXI/e1wibW9kdWxlc1wiOnRydWUsXCJtaW5pbWl6ZVwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlfSEuL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEtMSEuL3N0eWxlcy5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEtMSEuL3N0eWxlcy5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==