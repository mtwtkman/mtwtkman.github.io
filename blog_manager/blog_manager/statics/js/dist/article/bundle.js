/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 20);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Utilities
//


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(9);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(7);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(13);
exports.lib.ucmicro = __webpack_require__(90);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

;(function () {
	"use strict";

	function Vnode(tag, key, attrs0, children, text, dom) {
		return { tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false };
	}
	Vnode.normalize = function (node) {
		if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined);
		if (node != null && (typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined);
		return node;
	};
	Vnode.normalizeChildren = function normalizeChildren(children) {
		for (var i = 0; i < children.length; i++) {
			children[i] = Vnode.normalize(children[i]);
		}
		return children;
	};
	var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
	var selectorCache = {};
	var hasOwn = {}.hasOwnProperty;
	function compileSelector(selector) {
		var match,
		    tag = "div",
		    classes = [],
		    attrs = {};
		while (match = selectorParser.exec(selector)) {
			var type = match[1],
			    value = match[2];
			if (type === "" && value !== "") tag = value;else if (type === "#") attrs.id = value;else if (type === ".") classes.push(value);else if (match[3][0] === "[") {
				var attrValue = match[6];
				if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
				if (match[4] === "class") classes.push(attrValue);else attrs[match[4]] = attrValue || true;
			}
		}
		if (classes.length > 0) attrs.className = classes.join(" ");
		return selectorCache[selector] = { tag: tag, attrs: attrs };
	}
	function execSelector(state, attrs, children) {
		var hasAttrs = false,
		    childList,
		    text;
		var className = attrs.className || attrs.class;
		for (var key in state.attrs) {
			if (hasOwn.call(state.attrs, key)) {
				attrs[key] = state.attrs[key];
			}
		}
		if (className !== undefined) {
			if (attrs.class !== undefined) {
				attrs.class = undefined;
				attrs.className = className;
			}
			if (state.attrs.className != null) {
				attrs.className = state.attrs.className + " " + className;
			}
		}
		for (var key in attrs) {
			if (hasOwn.call(attrs, key) && key !== "key") {
				hasAttrs = true;
				break;
			}
		}
		if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
			text = children[0].children;
		} else {
			childList = children;
		}
		return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text);
	}
	function hyperscript(selector) {
		// Because sloppy mode sucks
		var attrs = arguments[1],
		    start = 2,
		    children;
		if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
			throw Error("The selector must be either a string or a component.");
		}
		if (typeof selector === "string") {
			var cached = selectorCache[selector] || compileSelector(selector);
		}
		if (attrs == null) {
			attrs = {};
		} else if ((typeof attrs === "undefined" ? "undefined" : _typeof(attrs)) !== "object" || attrs.tag != null || Array.isArray(attrs)) {
			attrs = {};
			start = 1;
		}
		if (arguments.length === start + 1) {
			children = arguments[start];
			if (!Array.isArray(children)) children = [children];
		} else {
			children = [];
			while (start < arguments.length) {
				children.push(arguments[start++]);
			}
		}
		var normalized = Vnode.normalizeChildren(children);
		if (typeof selector === "string") {
			return execSelector(cached, attrs, normalized);
		} else {
			return Vnode(selector, attrs.key, attrs, normalized);
		}
	}
	hyperscript.trust = function (html) {
		if (html == null) html = "";
		return Vnode("<", undefined, undefined, html, undefined, undefined);
	};
	hyperscript.fragment = function (attrs1, children) {
		return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined);
	};
	var m = hyperscript;
	/** @constructor */
	var PromisePolyfill = function PromisePolyfill(executor) {
		if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`");
		if (typeof executor !== "function") throw new TypeError("executor must be a function");
		var self = this,
		    resolvers = [],
		    rejectors = [],
		    resolveCurrent = handler(resolvers, true),
		    rejectCurrent = handler(rejectors, false);
		var instance = self._instance = { resolvers: resolvers, rejectors: rejectors };
		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function handler(list, shouldAbsorb) {
			return function execute(value) {
				var then;
				try {
					if (shouldAbsorb && value != null && ((typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
						if (value === self) throw new TypeError("Promise can't be resolved w/ itself");
						executeOnce(then.bind(value));
					} else {
						callAsync(function () {
							if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value);
							for (var i = 0; i < list.length; i++) {
								list[i](value);
							}resolvers.length = 0, rejectors.length = 0;
							instance.state = shouldAbsorb;
							instance.retry = function () {
								execute(value);
							};
						});
					}
				} catch (e) {
					rejectCurrent(e);
				}
			};
		}
		function executeOnce(then) {
			var runs = 0;
			function run(fn) {
				return function (value) {
					if (runs++ > 0) return;
					fn(value);
				};
			}
			var onerror = run(rejectCurrent);
			try {
				then(run(resolveCurrent), onerror);
			} catch (e) {
				onerror(e);
			}
		}
		executeOnce(executor);
	};
	PromisePolyfill.prototype.then = function (onFulfilled, onRejection) {
		var self = this,
		    instance = self._instance;
		function handle(callback, list, next, state) {
			list.push(function (value) {
				if (typeof callback !== "function") next(value);else try {
					resolveNext(callback(value));
				} catch (e) {
					if (rejectNext) rejectNext(e);
				}
			});
			if (typeof instance.retry === "function" && state === instance.state) instance.retry();
		}
		var resolveNext, rejectNext;
		var promise = new PromisePolyfill(function (resolve, reject) {
			resolveNext = resolve, rejectNext = reject;
		});
		handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
		return promise;
	};
	PromisePolyfill.prototype.catch = function (onRejection) {
		return this.then(null, onRejection);
	};
	PromisePolyfill.resolve = function (value) {
		if (value instanceof PromisePolyfill) return value;
		return new PromisePolyfill(function (resolve) {
			resolve(value);
		});
	};
	PromisePolyfill.reject = function (value) {
		return new PromisePolyfill(function (resolve, reject) {
			reject(value);
		});
	};
	PromisePolyfill.all = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			var total = list.length,
			    count = 0,
			    values = [];
			if (list.length === 0) resolve([]);else for (var i = 0; i < list.length; i++) {
				(function (i) {
					function consume(value) {
						count++;
						values[i] = value;
						if (count === total) resolve(values);
					}
					if (list[i] != null && (_typeof(list[i]) === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
						list[i].then(consume, reject);
					} else consume(list[i]);
				})(i);
			}
		});
	};
	PromisePolyfill.race = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			for (var i = 0; i < list.length; i++) {
				list[i].then(resolve, reject);
			}
		});
	};
	if (typeof window !== "undefined") {
		if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill;
		var PromisePolyfill = window.Promise;
	} else if (typeof global !== "undefined") {
		if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill;
		var PromisePolyfill = global.Promise;
	} else {}
	var buildQueryString = function buildQueryString(object) {
		if (Object.prototype.toString.call(object) !== "[object Object]") return "";
		var args = [];
		for (var key0 in object) {
			destructure(key0, object[key0]);
		}
		return args.join("&");
		function destructure(key0, value) {
			if (Array.isArray(value)) {
				for (var i = 0; i < value.length; i++) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else if (Object.prototype.toString.call(value) === "[object Object]") {
				for (var i in value) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
		}
	};
	var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i");
	var _8 = function _8($window, Promise) {
		var callbackCount = 0;
		var oncompletion;
		function setCompletionCallback(callback) {
			oncompletion = callback;
		}
		function finalizer() {
			var count = 0;
			function complete() {
				if (--count === 0 && typeof oncompletion === "function") oncompletion();
			}
			return function finalize(promise0) {
				var then0 = promise0.then;
				promise0.then = function () {
					count++;
					var next = then0.apply(promise0, arguments);
					next.then(complete, function (e) {
						complete();
						if (count === 0) throw e;
					});
					return finalize(next);
				};
				return promise0;
			};
		}
		function normalize(args, extra) {
			if (typeof args === "string") {
				var url = args;
				args = extra || {};
				if (args.url == null) args.url = url;
			}
			return args;
		}
		function request(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				if (args.method == null) args.method = "GET";
				args.method = args.method.toUpperCase();
				var useBody = args.method === "GET" || args.method === "TRACE" ? false : typeof args.useBody === "boolean" ? args.useBody : true;
				if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function (value) {
					return value;
				} : JSON.stringify;
				if (typeof args.deserialize !== "function") args.deserialize = deserialize;
				if (typeof args.extract !== "function") args.extract = extract;
				args.url = interpolate(args.url, args.data);
				if (useBody) args.data = args.serialize(args.data);else args.url = assemble(args.url, args.data);
				var xhr = new $window.XMLHttpRequest(),
				    aborted = false,
				    _abort = xhr.abort;
				xhr.abort = function abort() {
					aborted = true;
					_abort.call(xhr);
				};
				xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);
				if (args.serialize === JSON.stringify && useBody) {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
				}
				if (args.deserialize === deserialize) {
					xhr.setRequestHeader("Accept", "application/json, text/*");
				}
				if (args.withCredentials) xhr.withCredentials = args.withCredentials;
				for (var key in args.headers) {
					if ({}.hasOwnProperty.call(args.headers, key)) {
						xhr.setRequestHeader(key, args.headers[key]);
					}
				}if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr;
				xhr.onreadystatechange = function () {
					// Don't throw errors on xhr.abort().
					if (aborted) return;
					if (xhr.readyState === 4) {
						try {
							var response = args.extract !== extract ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args));
							if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
								resolve(cast(args.type, response));
							} else {
								var error = new Error(xhr.responseText);
								for (var key in response) {
									error[key] = response[key];
								}reject(error);
							}
						} catch (e) {
							reject(e);
						}
					}
				};
				if (useBody && args.data != null) xhr.send(args.data);else xhr.send();
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function jsonp(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
				var script = $window.document.createElement("script");
				$window[callbackName] = function (data) {
					script.parentNode.removeChild(script);
					resolve(cast(args.type, data));
					delete $window[callbackName];
				};
				script.onerror = function () {
					script.parentNode.removeChild(script);
					reject(new Error("JSONP request failed"));
					delete $window[callbackName];
				};
				if (args.data == null) args.data = {};
				args.url = interpolate(args.url, args.data);
				args.data[args.callbackKey || "callback"] = callbackName;
				script.src = assemble(args.url, args.data);
				$window.document.documentElement.appendChild(script);
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function interpolate(url, data) {
			if (data == null) return url;
			var tokens = url.match(/:[^\/]+/gi) || [];
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1);
				if (data[key] != null) {
					url = url.replace(tokens[i], data[key]);
				}
			}
			return url;
		}
		function assemble(url, data) {
			var querystring = buildQueryString(data);
			if (querystring !== "") {
				var prefix = url.indexOf("?") < 0 ? "?" : "&";
				url += prefix + querystring;
			}
			return url;
		}
		function deserialize(data) {
			try {
				return data !== "" ? JSON.parse(data) : null;
			} catch (e) {
				throw new Error(data);
			}
		}
		function extract(xhr) {
			return xhr.responseText;
		}
		function cast(type0, data) {
			if (typeof type0 === "function") {
				if (Array.isArray(data)) {
					for (var i = 0; i < data.length; i++) {
						data[i] = new type0(data[i]);
					}
				} else return new type0(data);
			}
			return data;
		}
		return { request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback };
	};
	var requestService = _8(window, PromisePolyfill);
	var coreRenderer = function coreRenderer($window) {
		var $doc = $window.document;
		var $emptyFragment = $doc.createDocumentFragment();
		var onevent;
		function setEventCallback(callback) {
			return onevent = callback;
		}
		//create
		function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					createNode(parent, vnode, hooks, ns, nextSibling);
				}
			}
		}
		function createNode(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			if (typeof tag === "string") {
				vnode.state = {};
				if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
				switch (tag) {
					case "#":
						return createText(parent, vnode, nextSibling);
					case "<":
						return createHTML(parent, vnode, nextSibling);
					case "[":
						return createFragment(parent, vnode, hooks, ns, nextSibling);
					default:
						return createElement(parent, vnode, hooks, ns, nextSibling);
				}
			} else return createComponent(parent, vnode, hooks, ns, nextSibling);
		}
		function createText(parent, vnode, nextSibling) {
			vnode.dom = $doc.createTextNode(vnode.children);
			insertNode(parent, vnode.dom, nextSibling);
			return vnode.dom;
		}
		function createHTML(parent, vnode, nextSibling) {
			var match1 = vnode.children.match(/^\s*?<(\w+)/im) || [];
			var parent1 = { caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup" }[match1[1]] || "div";
			var temp = $doc.createElement(parent1);
			temp.innerHTML = vnode.children;
			vnode.dom = temp.firstChild;
			vnode.domSize = temp.childNodes.length;
			var fragment = $doc.createDocumentFragment();
			var child;
			while (child = temp.firstChild) {
				fragment.appendChild(child);
			}
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createFragment(parent, vnode, hooks, ns, nextSibling) {
			var fragment = $doc.createDocumentFragment();
			if (vnode.children != null) {
				var children = vnode.children;
				createNodes(fragment, children, 0, children.length, hooks, null, ns);
			}
			vnode.dom = fragment.firstChild;
			vnode.domSize = fragment.childNodes.length;
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createElement(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			var attrs2 = vnode.attrs;
			var is = attrs2 && attrs2.is;
			var element = ns ? is ? $doc.createElementNS(ns, tag, { is: is }) : $doc.createElementNS(ns, tag) : is ? $doc.createElement(tag, { is: is }) : $doc.createElement(tag);
			vnode.dom = element;
			if (attrs2 != null) {
				setAttrs(vnode, attrs2, ns);
			}
			insertNode(parent, element, nextSibling);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else {
				if (vnode.text != null) {
					if (vnode.text !== "") element.textContent = vnode.text;else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				}
				if (vnode.children != null) {
					var children = vnode.children;
					createNodes(element, children, 0, children.length, hooks, null, ns);
					setLateAttrs(vnode);
				}
			}
			return element;
		}
		function initComponent(vnode, hooks) {
			var sentinel;
			if (typeof vnode.tag.view === "function") {
				vnode.state = Object.create(vnode.tag);
				sentinel = vnode.state.view;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
			} else {
				vnode.state = void 0;
				sentinel = vnode.tag;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
				vnode.state = vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function" ? new vnode.tag(vnode) : vnode.tag(vnode);
			}
			vnode._state = vnode.state;
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
			initLifecycle(vnode._state, vnode, hooks);
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
			sentinel.$$reentrantLock$$ = null;
		}
		function createComponent(parent, vnode, hooks, ns, nextSibling) {
			initComponent(vnode, hooks);
			if (vnode.instance != null) {
				var element = createNode(parent, vnode.instance, hooks, ns, nextSibling);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
				insertNode(parent, element, nextSibling);
				return element;
			} else {
				vnode.domSize = 0;
				return $emptyFragment;
			}
		}
		//update
		function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
			if (old === vnodes || old == null && vnodes == null) return;else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined);else if (vnodes == null) removeNodes(old, 0, old.length, vnodes);else {
				if (old.length === vnodes.length) {
					var isUnkeyed = false;
					for (var i = 0; i < vnodes.length; i++) {
						if (vnodes[i] != null && old[i] != null) {
							isUnkeyed = vnodes[i].key == null && old[i].key == null;
							break;
						}
					}
					if (isUnkeyed) {
						for (var i = 0; i < old.length; i++) {
							if (old[i] === vnodes[i]) continue;else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling));else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes);else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns);
						}
						return;
					}
				}
				recycling = recycling || isRecyclable(old, vnodes);
				if (recycling) {
					var pool = old.pool;
					old = old.concat(old.pool);
				}
				var oldStart = 0,
				    start = 0,
				    oldEnd = old.length - 1,
				    end = vnodes.length - 1,
				    map;
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldStart],
					    v = vnodes[start];
					if (o === v && !recycling) oldStart++, start++;else if (o == null) oldStart++;else if (v == null) start++;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldStart >= old.length - pool.length || pool == null && recycling;
						oldStart++, start++;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
					} else {
						var o = old[oldEnd];
						if (o === v && !recycling) oldEnd--, start++;else if (o == null) oldEnd--;else if (v == null) start++;else if (o.key === v.key) {
							var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
							updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
							if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling));
							oldEnd--, start++;
						} else break;
					}
				}
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldEnd],
					    v = vnodes[end];
					if (o === v && !recycling) oldEnd--, end--;else if (o == null) oldEnd--;else if (v == null) end--;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
						if (o.dom != null) nextSibling = o.dom;
						oldEnd--, end--;
					} else {
						if (!map) map = getKeyMap(old, oldEnd);
						if (v != null) {
							var oldIndex = map[v.key];
							if (oldIndex != null) {
								var movable = old[oldIndex];
								var shouldRecycle = pool != null && oldIndex >= old.length - pool.length || pool == null && recycling;
								updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns);
								insertNode(parent, toFragment(movable), nextSibling);
								old[oldIndex].skip = true;
								if (movable.dom != null) nextSibling = movable.dom;
							} else {
								var dom = createNode(parent, v, hooks, undefined, nextSibling);
								nextSibling = dom;
							}
						}
						end--;
					}
					if (end < start) break;
				}
				createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
				removeNodes(old, oldStart, oldEnd + 1, vnodes);
			}
		}
		function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			var oldTag = old.tag,
			    tag = vnode.tag;
			if (oldTag === tag) {
				vnode.state = old.state;
				vnode._state = old._state;
				vnode.events = old.events;
				if (!recycling && shouldNotUpdate(vnode, old)) return;
				if (typeof oldTag === "string") {
					if (vnode.attrs != null) {
						if (recycling) {
							vnode.state = {};
							initLifecycle(vnode.attrs, vnode, hooks);
						} else updateLifecycle(vnode.attrs, vnode, hooks);
					}
					switch (oldTag) {
						case "#":
							updateText(old, vnode);break;
						case "<":
							updateHTML(parent, old, vnode, nextSibling);break;
						case "[":
							updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns);break;
						default:
							updateElement(old, vnode, recycling, hooks, ns);
					}
				} else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns);
			} else {
				removeNode(old, null);
				createNode(parent, vnode, hooks, ns, nextSibling);
			}
		}
		function updateText(old, vnode) {
			if (old.children.toString() !== vnode.children.toString()) {
				old.dom.nodeValue = vnode.children;
			}
			vnode.dom = old.dom;
		}
		function updateHTML(parent, old, vnode, nextSibling) {
			if (old.children !== vnode.children) {
				toFragment(old);
				createHTML(parent, vnode, nextSibling);
			} else vnode.dom = old.dom, vnode.domSize = old.domSize;
		}
		function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
			updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns);
			var domSize = 0,
			    children = vnode.children;
			vnode.dom = null;
			if (children != null) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i];
					if (child != null && child.dom != null) {
						if (vnode.dom == null) vnode.dom = child.dom;
						domSize += child.domSize || 1;
					}
				}
				if (domSize !== 1) vnode.domSize = domSize;
			}
		}
		function updateElement(old, vnode, recycling, hooks, ns) {
			var element = vnode.dom = old.dom;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			if (vnode.tag === "textarea") {
				if (vnode.attrs == null) vnode.attrs = {};
				if (vnode.text != null) {
					vnode.attrs.value = vnode.text; //FIXME handle0 multiple children
					vnode.text = undefined;
				}
			}
			updateAttrs(vnode, old.attrs, vnode.attrs, ns);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else if (old.text != null && vnode.text != null && vnode.text !== "") {
				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text;
			} else {
				if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)];
				if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns);
			}
		}
		function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			if (recycling) {
				initComponent(vnode, hooks);
			} else {
				vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
				if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
				if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);
				updateLifecycle(vnode._state, vnode, hooks);
			}
			if (vnode.instance != null) {
				if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.instance.domSize;
			} else if (old.instance != null) {
				removeNode(old.instance, null);
				vnode.dom = undefined;
				vnode.domSize = 0;
			} else {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
			}
		}
		function isRecyclable(old, vnodes) {
			if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
				var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0;
				var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0;
				var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0;
				if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
					return true;
				}
			}
			return false;
		}
		function getKeyMap(vnodes, end) {
			var map = {},
			    i = 0;
			for (var i = 0; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					var key2 = vnode.key;
					if (key2 != null) map[key2] = i;
				}
			}
			return map;
		}
		function toFragment(vnode) {
			var count0 = vnode.domSize;
			if (count0 != null || vnode.dom == null) {
				var fragment = $doc.createDocumentFragment();
				if (count0 > 0) {
					var dom = vnode.dom;
					while (--count0) {
						fragment.appendChild(dom.nextSibling);
					}fragment.insertBefore(dom, fragment.firstChild);
				}
				return fragment;
			} else return vnode.dom;
		}
		function getNextSibling(vnodes, i, nextSibling) {
			for (; i < vnodes.length; i++) {
				if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom;
			}
			return nextSibling;
		}
		function insertNode(parent, dom, nextSibling) {
			if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling);else parent.appendChild(dom);
		}
		function setContentEditable(vnode) {
			var children = vnode.children;
			if (children != null && children.length === 1 && children[0].tag === "<") {
				var content = children[0].children;
				if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;
			} else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted");
		}
		//remove
		function removeNodes(vnodes, start, end, context) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					if (vnode.skip) vnode.skip = false;else removeNode(vnode, context);
				}
			}
		}
		function removeNode(vnode, context) {
			var expected = 1,
			    called = 0;
			if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
				var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
				var result = vnode._state.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			continuation();
			function continuation() {
				if (++called === expected) {
					onremove(vnode);
					if (vnode.dom) {
						var count0 = vnode.domSize || 1;
						if (count0 > 1) {
							var dom = vnode.dom;
							while (--count0) {
								removeNodeFromDOM(dom.nextSibling);
							}
						}
						removeNodeFromDOM(vnode.dom);
						if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") {
							//TODO test custom elements
							if (!context.pool) context.pool = [vnode];else context.pool.push(vnode);
						}
					}
				}
			}
		}
		function removeNodeFromDOM(node) {
			var parent = node.parentNode;
			if (parent != null) parent.removeChild(node);
		}
		function onremove(vnode) {
			if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode);
			if (vnode.instance != null) onremove(vnode.instance);else {
				var children = vnode.children;
				if (Array.isArray(children)) {
					for (var i = 0; i < children.length; i++) {
						var child = children[i];
						if (child != null) onremove(child);
					}
				}
			}
		}
		//attrs2
		function setAttrs(vnode, attrs2, ns) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, null, attrs2[key2], ns);
			}
		}
		function setAttr(vnode, key2, old, value, ns) {
			var element = vnode.dom;
			if (key2 === "key" || key2 === "is" || old === value && !isFormAttribute(vnode, key2) && (typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return;
			var nsLastIndex = key2.indexOf(":");
			if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
				element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value);
			} else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value);else if (key2 === "style") updateStyle(element, old, value);else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if (vnode.tag === "input" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && key2 === "value" && vnode.dom.value == value) return;
				// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
				if (vnode.tag === "input" && key2 === "type") {
					element.setAttribute(key2, value);
					return;
				}
				element[key2] = value;
			} else {
				if (typeof value === "boolean") {
					if (value) element.setAttribute(key2, "");else element.removeAttribute(key2);
				} else element.setAttribute(key2 === "className" ? "class" : key2, value);
			}
		}
		function setLateAttrs(vnode) {
			var attrs2 = vnode.attrs;
			if (vnode.tag === "select" && attrs2 != null) {
				if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined);
				if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined);
			}
		}
		function updateAttrs(vnode, old, attrs2, ns) {
			if (attrs2 != null) {
				for (var key2 in attrs2) {
					setAttr(vnode, key2, old && old[key2], attrs2[key2], ns);
				}
			}
			if (old != null) {
				for (var key2 in old) {
					if (attrs2 == null || !(key2 in attrs2)) {
						if (key2 === "className") key2 = "class";
						if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined);else if (key2 !== "key") vnode.dom.removeAttribute(key2);
					}
				}
			}
		}
		function isFormAttribute(vnode, attr) {
			return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement;
		}
		function isLifecycleMethod(attr) {
			return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate";
		}
		function isAttribute(attr) {
			return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"; // || attr === "type"
		}
		function isCustomElement(vnode) {
			return vnode.attrs.is || vnode.tag.indexOf("-") > -1;
		}
		function hasIntegrationMethods(source) {
			return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove);
		}
		//style
		function updateStyle(element, old, style) {
			if (old === style) element.style.cssText = "", old = null;
			if (style == null) element.style.cssText = "";else if (typeof style === "string") element.style.cssText = style;else {
				if (typeof old === "string") element.style.cssText = "";
				for (var key2 in style) {
					element.style[key2] = style[key2];
				}
				if (old != null && typeof old !== "string") {
					for (var key2 in old) {
						if (!(key2 in style)) element.style[key2] = "";
					}
				}
			}
		}
		//event
		function updateEvent(vnode, key2, value) {
			var element = vnode.dom;
			var callback = typeof onevent !== "function" ? value : function (e) {
				var result = value.call(element, e);
				onevent.call(element, e);
				return result;
			};
			if (key2 in element) element[key2] = typeof value === "function" ? callback : null;else {
				var eventName = key2.slice(2);
				if (vnode.events === undefined) vnode.events = {};
				if (vnode.events[key2] === callback) return;
				if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false);
				if (typeof value === "function") {
					vnode.events[key2] = callback;
					element.addEventListener(eventName, vnode.events[key2], false);
				}
			}
		}
		//lifecycle
		function initLifecycle(source, vnode, hooks) {
			if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode);
			if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode));
		}
		function updateLifecycle(source, vnode, hooks) {
			if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode));
		}
		function shouldNotUpdate(vnode, old) {
			var forceVnodeUpdate, forceComponentUpdate;
			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old);
			if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
				vnode.instance = old.instance;
				return true;
			}
			return false;
		}
		function render(dom, vnodes) {
			if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");
			var hooks = [];
			var active = $doc.activeElement;
			// First time0 rendering into a node clears it out
			if (dom.vnodes == null) dom.textContent = "";
			if (!Array.isArray(vnodes)) vnodes = [vnodes];
			updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined);
			dom.vnodes = vnodes;
			for (var i = 0; i < hooks.length; i++) {
				hooks[i]();
			}if ($doc.activeElement !== active) active.focus();
		}
		return { render: render, setEventCallback: setEventCallback };
	};
	function throttle(callback) {
		//60fps translates to 16.6ms, round it down since setTimeout requires int
		var time = 16;
		var last = 0,
		    pending = null;
		var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout;
		return function () {
			var now = Date.now();
			if (last === 0 || now - last >= time) {
				last = now;
				callback();
			} else if (pending === null) {
				pending = timeout(function () {
					pending = null;
					callback();
					last = Date.now();
				}, time - (now - last));
			}
		};
	}
	var _11 = function _11($window) {
		var renderService = coreRenderer($window);
		renderService.setEventCallback(function (e) {
			if (e.redraw !== false) redraw();
		});
		var callbacks = [];
		function subscribe(key1, callback) {
			unsubscribe(key1);
			callbacks.push(key1, throttle(callback));
		}
		function unsubscribe(key1) {
			var index = callbacks.indexOf(key1);
			if (index > -1) callbacks.splice(index, 2);
		}
		function redraw() {
			for (var i = 1; i < callbacks.length; i += 2) {
				callbacks[i]();
			}
		}
		return { subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render };
	};
	var redrawService = _11(window);
	requestService.setCompletionCallback(redrawService.redraw);
	var _16 = function _16(redrawService0) {
		return function (root, component) {
			if (component === null) {
				redrawService0.render(root, []);
				redrawService0.unsubscribe(root);
				return;
			}

			if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode");

			var run0 = function run0() {
				redrawService0.render(root, Vnode(component));
			};
			redrawService0.subscribe(root, run0);
			redrawService0.redraw();
		};
	};
	m.mount = _16(redrawService);
	var Promise = PromisePolyfill;
	var parseQueryString = function parseQueryString(string) {
		if (string === "" || string == null) return {};
		if (string.charAt(0) === "?") string = string.slice(1);
		var entries = string.split("&"),
		    data0 = {},
		    counters = {};
		for (var i = 0; i < entries.length; i++) {
			var entry = entries[i].split("=");
			var key5 = decodeURIComponent(entry[0]);
			var value = entry.length === 2 ? decodeURIComponent(entry[1]) : "";
			if (value === "true") value = true;else if (value === "false") value = false;
			var levels = key5.split(/\]\[?|\[/);
			var cursor = data0;
			if (key5.indexOf("[") > -1) levels.pop();
			for (var j = 0; j < levels.length; j++) {
				var level = levels[j],
				    nextLevel = levels[j + 1];
				var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
				var isValue = j === levels.length - 1;
				if (level === "") {
					var key5 = levels.slice(0, j).join();
					if (counters[key5] == null) counters[key5] = 0;
					level = counters[key5]++;
				}
				if (cursor[level] == null) {
					cursor[level] = isValue ? value : isNumber ? [] : {};
				}
				cursor = cursor[level];
			}
		}
		return data0;
	};
	var coreRouter = function coreRouter($window) {
		var supportsPushState = typeof $window.history.pushState === "function";
		var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function normalize1(fragment0) {
			var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent);
			if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data;
			return data;
		}
		var asyncId;
		function debounceAsync(callback0) {
			return function () {
				if (asyncId != null) return;
				asyncId = callAsync0(function () {
					asyncId = null;
					callback0();
				});
			};
		}
		function parsePath(path, queryData, hashData) {
			var queryIndex = path.indexOf("?");
			var hashIndex = path.indexOf("#");
			var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length;
			if (queryIndex > -1) {
				var queryEnd = hashIndex > -1 ? hashIndex : path.length;
				var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd));
				for (var key4 in queryParams) {
					queryData[key4] = queryParams[key4];
				}
			}
			if (hashIndex > -1) {
				var hashParams = parseQueryString(path.slice(hashIndex + 1));
				for (var key4 in hashParams) {
					hashData[key4] = hashParams[key4];
				}
			}
			return path.slice(0, pathEnd);
		}
		var router = { prefix: "#!" };
		router.getPath = function () {
			var type2 = router.prefix.charAt(0);
			switch (type2) {
				case "#":
					return normalize1("hash").slice(router.prefix.length);
				case "?":
					return normalize1("search").slice(router.prefix.length) + normalize1("hash");
				default:
					return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash");
			}
		};
		router.setPath = function (path, data, options) {
			var queryData = {},
			    hashData = {};
			path = parsePath(path, queryData, hashData);
			if (data != null) {
				for (var key4 in data) {
					queryData[key4] = data[key4];
				}path = path.replace(/:([^\/]+)/g, function (match2, token) {
					delete queryData[token];
					return data[token];
				});
			}
			var query = buildQueryString(queryData);
			if (query) path += "?" + query;
			var hash = buildQueryString(hashData);
			if (hash) path += "#" + hash;
			if (supportsPushState) {
				var state = options ? options.state : null;
				var title = options ? options.title : null;
				$window.onpopstate();
				if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path);else $window.history.pushState(state, title, router.prefix + path);
			} else $window.location.href = router.prefix + path;
		};
		router.defineRoutes = function (routes, resolve, reject) {
			function resolveRoute() {
				var path = router.getPath();
				var params = {};
				var pathname = parsePath(path, params, params);
				var state = $window.history.state;
				if (state != null) {
					for (var k in state) {
						params[k] = state[k];
					}
				}
				for (var route0 in routes) {
					var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");
					if (matcher.test(pathname)) {
						pathname.replace(matcher, function () {
							var keys = route0.match(/:[^\/]+/g) || [];
							var values = [].slice.call(arguments, 1, -2);
							for (var i = 0; i < keys.length; i++) {
								params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i]);
							}
							resolve(routes[route0], params, path, route0);
						});
						return;
					}
				}
				reject(path, params);
			}
			if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute);else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute;
			resolveRoute();
		};
		return router;
	};
	var _20 = function _20($window, redrawService0) {
		var routeService = coreRouter($window);
		var identity = function identity(v) {
			return v;
		};
		var render1, component, attrs3, currentPath, _lastUpdate;
		var route = function route(root, defaultRoute, routes) {
			if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined");
			var run1 = function run1() {
				if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)));
			};
			var bail = function bail(path) {
				if (path !== defaultRoute) routeService.setPath(defaultRoute, null, { replace: true });else throw new Error("Could not resolve default route " + defaultRoute);
			};
			routeService.defineRoutes(routes, function (payload, params, path) {
				var update = _lastUpdate = function lastUpdate(routeResolver, comp) {
					if (update !== _lastUpdate) return;
					component = comp != null && (typeof comp.view === "function" || typeof comp === "function") ? comp : "div";
					attrs3 = params, currentPath = path, _lastUpdate = null;
					render1 = (routeResolver.render || identity).bind(routeResolver);
					run1();
				};
				if (payload.view || typeof payload === "function") update({}, payload);else {
					if (payload.onmatch) {
						Promise.resolve(payload.onmatch(params, path)).then(function (resolved) {
							update(payload, resolved);
						}, bail);
					} else update(payload, "div");
				}
			}, bail);
			redrawService0.subscribe(root, run1);
		};
		route.set = function (path, data, options) {
			if (_lastUpdate != null) options = { replace: true };
			_lastUpdate = null;
			routeService.setPath(path, data, options);
		};
		route.get = function () {
			return currentPath;
		};
		route.prefix = function (prefix0) {
			routeService.prefix = prefix0;
		};
		route.link = function (vnode1) {
			vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href);
			vnode1.dom.onclick = function (e) {
				if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return;
				e.preventDefault();
				e.redraw = false;
				var href = this.getAttribute("href");
				if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length);
				route.set(href, undefined, undefined);
			};
		};
		route.param = function (key3) {
			if (typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3];
			return attrs3;
		};
		return route;
	};
	m.route = _20(window, redrawService);
	m.withAttr = function (attrName, callback1, context) {
		return function (e) {
			callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName));
		};
	};
	var _28 = coreRenderer(window);
	m.render = _28.render;
	m.redraw = redrawService.redraw;
	m.request = requestService.request;
	m.jsonp = requestService.jsonp;
	m.parseQueryString = parseQueryString;
	m.buildQueryString = buildQueryString;
	m.version = "1.1.1";
	m.vnode = Vnode;
	if (true) module["exports"] = m;else window.m = m;
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(88).setImmediate, __webpack_require__(4)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.span = vnode.attrs.span;
    vnode.state.cls = vnode.attrs.cls || '';
  },
  view: function view(vnode) {
    return (0, _mithril2.default)(
      'div',
      { className: 'mdl-cell mdl-cell--' + vnode.state.span + '-col ' + vnode.state.cls },
      vnode.attrs.inner
    );
  }
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(93);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(17)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/


/**
 * new Ruler()
 **/

function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typorgapher replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Token class



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/

function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30).Buffer))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML5 entities map: { name -> utf16string }
//


/*eslint quotes:0*/

module.exports = __webpack_require__(94);

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = '';
      state.tokens[delimiters[startDelim.end - 1].token].content = '';
      i++;
    }
  }
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ~~strike through~~
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports.encode = __webpack_require__(81);
module.exports.decode = __webpack_require__(80);
module.exports.format = __webpack_require__(82);
module.exports.parse = __webpack_require__(83);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(87);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 18 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(95);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

var _title = __webpack_require__(26);

var _title2 = _interopRequireDefault(_title);

var _tags = __webpack_require__(25);

var _tags2 = _interopRequireDefault(_tags);

var _slug = __webpack_require__(24);

var _slug2 = _interopRequireDefault(_slug);

var _editor = __webpack_require__(21);

var _editor2 = _interopRequireDefault(_editor);

var _preview = __webpack_require__(22);

var _preview2 = _interopRequireDefault(_preview);

var _save = __webpack_require__(23);

var _save2 = _interopRequireDefault(_save);

var _article = __webpack_require__(27);

var _article2 = _interopRequireDefault(_article);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var model = new _article2.default();

exports.default = {
  oninit: function oninit(vnode) {
    model.fetch();
  },
  view: function view(vnode) {
    if (model.fetched) {
      return (0, _mithril2.default)(
        'div',
        { className: 'mdl-grid' },
        (0, _mithril2.default)(_title2.default, { model: model }),
        (0, _mithril2.default)(_slug2.default, { model: model }),
        (0, _mithril2.default)(_tags2.default, { model: model }),
        (0, _mithril2.default)(
          'div',
          { className: _styles2.default.editorWrap },
          (0, _mithril2.default)(_editor2.default, { key: 'editor', model: model }),
          (0, _mithril2.default)(_preview2.default, { key: 'preview', body: model.mdBody() })
        ),
        (0, _mithril2.default)(_save2.default, { model: model, onclick: model.update.bind(model) })
      );
    }
    return (0, _mithril2.default)(
      'div',
      null,
      '\u30C7\u30FC\u30BF\u53D6\u5F97\u4E2D...'
    );
  }
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _component = __webpack_require__(19);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_mithril2.default.mount(document.getElementById('main'), _component2.default);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.oninput = function (v) {
      vnode.state.model.data.body = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'textarea',
      {
        className: _styles2.default.textarea,
        oninput: _mithril2.default.withAttr('value', vnode.state.oninput) },
      vnode.state.model.data.body
    );
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorLeftSide, inner: inner });
  }
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(vnode) {
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorRightSide,
      inner: _mithril2.default.trust(vnode.attrs.body) });
  }
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onclick = vnode.attrs.onclick;
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'button',
      {
        className: 'mdl-button mdl-js-button mdl-button--raised mdl-button--colored',
        onclick: vnode.state.onclick },
      'save'
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, cls: _styles2.default.saveButton, inner: inner });
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.slug = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'label',
      null,
      'URL',
      (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.slug,
        onchange: _mithril2.default.withAttr('value', vnode.state.onchange),
        value: vnode.state.model.data.slug
      })
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.tags = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'label',
      null,
      '\u30BF\u30B0',
      (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.tags,
        onchange: _mithril2.default.withAttr('value', vnode.state.onchange),
        value: vnode.state.model.data.tags
      })
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.title = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'label',
      null,
      '\u30BF\u30A4\u30C8\u30EB',
      (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.title,
        onchange: _mithril2.default.withAttr('value', vnode.state.onchange),
        value: vnode.state.model.data.title
      })
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _request = __webpack_require__(28);

var _request2 = _interopRequireDefault(_request);

var _markdownIt = __webpack_require__(35);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var md = new _markdownIt2.default();

var Model = function () {
  function Model(data) {
    _classCallCheck(this, Model);

    this.data = data || {
      title: '',
      body: '',
      slug: '',
      publish: false,
      tags: '',
      date: null
    };
    this.fetched = false;
    this.resourcesUrl = '/api/articles';
    this.resourceUrl = this.resourcesUrl + '/' + location.href.split('/').slice(4).join('/');
  }

  _createClass(Model, [{
    key: 'fetch',
    value: function fetch() {
      var _this = this;

      return (0, _request2.default)('GET', this.resourceUrl).then(function (response) {
        _this.fetched = true;
        _this.data = response;
      });
    }
  }, {
    key: 'create',
    value: function create() {
      var _this2 = this;

      return (0, _request2.default)('POST', this.resourcesUrl, this.data).then(function (response) {
        _this2.data = response;
      });
    }
  }, {
    key: 'update',
    value: function update() {
      var _this3 = this;

      return (0, _request2.default)('PUT', this.resourceUrl, this.data).then(function (response) {
        _this3.data = response;
      });
    }
  }, {
    key: 'delete',
    value: function _delete() {
      var _this4 = this;

      return (0, _request2.default)('DELETE', this.resourceUrl).then(function (response) {
        _this4.data = null;
      });
    }
  }, {
    key: 'mdBody',
    value: function mdBody() {
      return md.render(this.data.body);
    }
  }]);

  return Model;
}();

exports.default = Model;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (method, url, data) {
  return _mithril2.default.request({ method: method, url: url, data: data, deserialize: JSON.parse });
};

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(29);
var ieee754 = __webpack_require__(31);
var isArray = __webpack_require__(32);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//

function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(34)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(16).source;
  re.src_Cc = __webpack_require__(14).source;
  re.src_Z = __webpack_require__(15).source;
  re.src_P = __webpack_require__(7).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(41);

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Just a shortcut for bulk export


exports.parseLinkLabel = __webpack_require__(39);
exports.parseLinkDestination = __webpack_require__(38);
exports.parseLinkTitle = __webpack_require__(40);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link destination
//


var isSpace = __webpack_require__(0).isSpace;
var unescapeAll = __webpack_require__(0).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
        if (level > 1) {
          break;
        }
      }

    if (code === 0x29 /* ) */) {
        level--;
        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//


module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link title
//


var unescapeAll = __webpack_require__(0).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Main parser class



var utils = __webpack_require__(0);
var helpers = __webpack_require__(37);
var Renderer = __webpack_require__(48);
var ParserCore = __webpack_require__(43);
var ParserBlock = __webpack_require__(42);
var ParserInline = __webpack_require__(44);
var LinkifyIt = __webpack_require__(33);
var mdurl = __webpack_require__(13);
var punycode = __webpack_require__(85);

var config = {
  'default': __webpack_require__(46),
  zero: __webpack_require__(47),
  commonmark: __webpack_require__(45)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/


var Ruler = __webpack_require__(5);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(60), ['paragraph', 'reference']], ['code', __webpack_require__(50)], ['fence', __webpack_require__(51), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(49), ['paragraph', 'reference', 'list']], ['hr', __webpack_require__(53), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(56), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(58)], ['heading', __webpack_require__(52), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(55)], ['html_block', __webpack_require__(54), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(57)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(59);

module.exports = ParserBlock;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/


var Ruler = __webpack_require__(5);

var _rules = [['normalize', __webpack_require__(64)], ['block', __webpack_require__(61)], ['inline', __webpack_require__(62)], ['linkify', __webpack_require__(63)], ['replacements', __webpack_require__(65)], ['smartquotes', __webpack_require__(66)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(67);

module.exports = Core;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/


var Ruler = __webpack_require__(5);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(78)], ['newline', __webpack_require__(76)], ['escape', __webpack_require__(72)], ['backticks', __webpack_require__(69)], ['strikethrough', __webpack_require__(12).tokenize], ['emphasis', __webpack_require__(11).tokenize], ['link', __webpack_require__(75)], ['image', __webpack_require__(74)], ['autolink', __webpack_require__(68)], ['html_inline', __webpack_require__(73)], ['entity', __webpack_require__(71)]];

var _rules2 = [['balance_pairs', __webpack_require__(70)], ['strikethrough', __webpack_require__(12).postProcess], ['emphasis', __webpack_require__(11).postProcess], ['text_collapse', __webpack_require__(79)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(77);

module.exports = ParserInline;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// markdown-it default options



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign = __webpack_require__(0).assign;
var unescapeAll = __webpack_require__(0).unescapeAll;
var escapeHtml = __webpack_require__(0).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without mudofying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes



var isSpace = __webpack_require__(0).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      isOutdented,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    if (isOutdented) break;

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)



var isSpace = __webpack_require__(0).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule



var isSpace = __webpack_require__(0).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block



var block_names = __webpack_require__(36);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(10).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists



var isSpace = __webpack_require__(0).isSpace;

// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finilize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class



var Token = __webpack_require__(6);
var isSpace = __webpack_require__(0).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard



var isSpace = __webpack_require__(0).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//


var arrayReplaceAt = __webpack_require__(0).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Normalize input string



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographyc replacements
//
// (c) (C) → ©
// (tm) (TM) → ™
// (r) (R) → ®
// +- → ±
// (p) (P) -> §
// ... → … (also ?.... → ?.., !.... → !..)
// ???????? → ???, !!!!! → !!!, `,,` → `,`
// -- → &ndash;, --- → &mdash;
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//


var isWhiteSpace = __webpack_require__(0).isWhiteSpace;
var isPunctChar = __webpack_require__(0).isPunctChar;
var isMdAsciiPunct = __webpack_require__(0).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Core state object
//


var Token = __webpack_require__(6);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'



/*eslint max-len:0*/

var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// For each opening emphasis-like marker find a matching closing one
//


module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities = __webpack_require__(9);
var has = __webpack_require__(0).has;
var isValidEntityCode = __webpack_require__(0).isValidEntityCode;
var fromCodePoint = __webpack_require__(0).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess escaped chars and hardbreaks



var isSpace = __webpack_require__(0).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags



var HTML_TAG_RE = __webpack_require__(10).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ![image](<src> "title")



var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [link](<to> "stuff")



var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'



var isSpace = __webpack_require__(0).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state



var Token = __webpack_require__(6);
var isWhiteSpace = __webpack_require__(0).isWhiteSpace;
var isPunctChar = __webpack_require__(0).isPunctChar;
var isMdAsciiPunct = __webpack_require__(0).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Merge adjacent text nodes into one, and re-calculate all token levels
//


module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(18)) == 'object' && __webpack_require__(18)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(91)(module), __webpack_require__(4)))

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(84)))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(86);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Any = __webpack_require__(16);
exports.Cc = __webpack_require__(14);
exports.Cf = __webpack_require__(89);
exports.P = __webpack_require__(7);
exports.Z = __webpack_require__(15);

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(8)(undefined);
// imports


// module
exports.push([module.i, "._2YrKEmruSXq-LY8HT9gjcA{position:relative;width:100%;height:calc(100% - 230px)}._3L5NEB84KxPflxBZveysdd{text-align:right;margin-top:15px}", ""]);

// exports
exports.locals = {
	"editorWrap": "_2YrKEmruSXq-LY8HT9gjcA",
	"saveButton": "_3L5NEB84KxPflxBZveysdd"
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(8)(undefined);
// imports


// module
exports.push([module.i, ".ZeW3HIwa_BWIGW0yZJi5G{width:100%;font-size:24pt;padding-left:10px}.AAMENcndmo-o7IjjzQHRY,.ZcsaZvcof0txWdeqikCGZ{width:100%;font-size:18pt;padding-left:10px}._1ouasj646M7i9oKw-0Q_55{position:relative;width:100%;height:calc(100% - 230px)}._2MLWR8W_pHfNBkBmp0ni08{position:absolute;top:0;background:#fcfcfc;padding:10px;overflow:auto;height:100%}.GJYonSHLOXZJhPSUwZdvb{left:0}.u_RSyvBLD7b0Z12hpK8D4{left:50%;background-color:#fff}._2gAtgm9oADOrZYt1udmcJR{text-align:right;margin-top:15px}._3NBbIr4WlHyUQc29YW6bSX{width:100%;height:100%;resize:none;background-color:#fcfcfc;border:none;font-size:10pt}", ""]);

// exports
exports.locals = {
	"title": "ZeW3HIwa_BWIGW0yZJi5G",
	"tags": "ZcsaZvcof0txWdeqikCGZ",
	"slug": "AAMENcndmo-o7IjjzQHRY",
	"editorWrap": "_1ouasj646M7i9oKw-0Q_55",
	"editor": "_2MLWR8W_pHfNBkBmp0ni08",
	"editorLeftSide": "GJYonSHLOXZJhPSUwZdvb",
	"editorRightSide": "u_RSyvBLD7b0Z12hpK8D4",
	"saveButton": "_2gAtgm9oADOrZYt1udmcJR",
	"textarea": "_3NBbIr4WlHyUQc29YW6bSX"
};

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = {
	"Aacute": "Á",
	"aacute": "á",
	"Abreve": "Ă",
	"abreve": "ă",
	"ac": "∾",
	"acd": "∿",
	"acE": "∾̳",
	"Acirc": "Â",
	"acirc": "â",
	"acute": "´",
	"Acy": "А",
	"acy": "а",
	"AElig": "Æ",
	"aelig": "æ",
	"af": "⁡",
	"Afr": "𝔄",
	"afr": "𝔞",
	"Agrave": "À",
	"agrave": "à",
	"alefsym": "ℵ",
	"aleph": "ℵ",
	"Alpha": "Α",
	"alpha": "α",
	"Amacr": "Ā",
	"amacr": "ā",
	"amalg": "⨿",
	"amp": "&",
	"AMP": "&",
	"andand": "⩕",
	"And": "⩓",
	"and": "∧",
	"andd": "⩜",
	"andslope": "⩘",
	"andv": "⩚",
	"ang": "∠",
	"ange": "⦤",
	"angle": "∠",
	"angmsdaa": "⦨",
	"angmsdab": "⦩",
	"angmsdac": "⦪",
	"angmsdad": "⦫",
	"angmsdae": "⦬",
	"angmsdaf": "⦭",
	"angmsdag": "⦮",
	"angmsdah": "⦯",
	"angmsd": "∡",
	"angrt": "∟",
	"angrtvb": "⊾",
	"angrtvbd": "⦝",
	"angsph": "∢",
	"angst": "Å",
	"angzarr": "⍼",
	"Aogon": "Ą",
	"aogon": "ą",
	"Aopf": "𝔸",
	"aopf": "𝕒",
	"apacir": "⩯",
	"ap": "≈",
	"apE": "⩰",
	"ape": "≊",
	"apid": "≋",
	"apos": "'",
	"ApplyFunction": "⁡",
	"approx": "≈",
	"approxeq": "≊",
	"Aring": "Å",
	"aring": "å",
	"Ascr": "𝒜",
	"ascr": "𝒶",
	"Assign": "≔",
	"ast": "*",
	"asymp": "≈",
	"asympeq": "≍",
	"Atilde": "Ã",
	"atilde": "ã",
	"Auml": "Ä",
	"auml": "ä",
	"awconint": "∳",
	"awint": "⨑",
	"backcong": "≌",
	"backepsilon": "϶",
	"backprime": "‵",
	"backsim": "∽",
	"backsimeq": "⋍",
	"Backslash": "∖",
	"Barv": "⫧",
	"barvee": "⊽",
	"barwed": "⌅",
	"Barwed": "⌆",
	"barwedge": "⌅",
	"bbrk": "⎵",
	"bbrktbrk": "⎶",
	"bcong": "≌",
	"Bcy": "Б",
	"bcy": "б",
	"bdquo": "„",
	"becaus": "∵",
	"because": "∵",
	"Because": "∵",
	"bemptyv": "⦰",
	"bepsi": "϶",
	"bernou": "ℬ",
	"Bernoullis": "ℬ",
	"Beta": "Β",
	"beta": "β",
	"beth": "ℶ",
	"between": "≬",
	"Bfr": "𝔅",
	"bfr": "𝔟",
	"bigcap": "⋂",
	"bigcirc": "◯",
	"bigcup": "⋃",
	"bigodot": "⨀",
	"bigoplus": "⨁",
	"bigotimes": "⨂",
	"bigsqcup": "⨆",
	"bigstar": "★",
	"bigtriangledown": "▽",
	"bigtriangleup": "△",
	"biguplus": "⨄",
	"bigvee": "⋁",
	"bigwedge": "⋀",
	"bkarow": "⤍",
	"blacklozenge": "⧫",
	"blacksquare": "▪",
	"blacktriangle": "▴",
	"blacktriangledown": "▾",
	"blacktriangleleft": "◂",
	"blacktriangleright": "▸",
	"blank": "␣",
	"blk12": "▒",
	"blk14": "░",
	"blk34": "▓",
	"block": "█",
	"bne": "=⃥",
	"bnequiv": "≡⃥",
	"bNot": "⫭",
	"bnot": "⌐",
	"Bopf": "𝔹",
	"bopf": "𝕓",
	"bot": "⊥",
	"bottom": "⊥",
	"bowtie": "⋈",
	"boxbox": "⧉",
	"boxdl": "┐",
	"boxdL": "╕",
	"boxDl": "╖",
	"boxDL": "╗",
	"boxdr": "┌",
	"boxdR": "╒",
	"boxDr": "╓",
	"boxDR": "╔",
	"boxh": "─",
	"boxH": "═",
	"boxhd": "┬",
	"boxHd": "╤",
	"boxhD": "╥",
	"boxHD": "╦",
	"boxhu": "┴",
	"boxHu": "╧",
	"boxhU": "╨",
	"boxHU": "╩",
	"boxminus": "⊟",
	"boxplus": "⊞",
	"boxtimes": "⊠",
	"boxul": "┘",
	"boxuL": "╛",
	"boxUl": "╜",
	"boxUL": "╝",
	"boxur": "└",
	"boxuR": "╘",
	"boxUr": "╙",
	"boxUR": "╚",
	"boxv": "│",
	"boxV": "║",
	"boxvh": "┼",
	"boxvH": "╪",
	"boxVh": "╫",
	"boxVH": "╬",
	"boxvl": "┤",
	"boxvL": "╡",
	"boxVl": "╢",
	"boxVL": "╣",
	"boxvr": "├",
	"boxvR": "╞",
	"boxVr": "╟",
	"boxVR": "╠",
	"bprime": "‵",
	"breve": "˘",
	"Breve": "˘",
	"brvbar": "¦",
	"bscr": "𝒷",
	"Bscr": "ℬ",
	"bsemi": "⁏",
	"bsim": "∽",
	"bsime": "⋍",
	"bsolb": "⧅",
	"bsol": "\\",
	"bsolhsub": "⟈",
	"bull": "•",
	"bullet": "•",
	"bump": "≎",
	"bumpE": "⪮",
	"bumpe": "≏",
	"Bumpeq": "≎",
	"bumpeq": "≏",
	"Cacute": "Ć",
	"cacute": "ć",
	"capand": "⩄",
	"capbrcup": "⩉",
	"capcap": "⩋",
	"cap": "∩",
	"Cap": "⋒",
	"capcup": "⩇",
	"capdot": "⩀",
	"CapitalDifferentialD": "ⅅ",
	"caps": "∩︀",
	"caret": "⁁",
	"caron": "ˇ",
	"Cayleys": "ℭ",
	"ccaps": "⩍",
	"Ccaron": "Č",
	"ccaron": "č",
	"Ccedil": "Ç",
	"ccedil": "ç",
	"Ccirc": "Ĉ",
	"ccirc": "ĉ",
	"Cconint": "∰",
	"ccups": "⩌",
	"ccupssm": "⩐",
	"Cdot": "Ċ",
	"cdot": "ċ",
	"cedil": "¸",
	"Cedilla": "¸",
	"cemptyv": "⦲",
	"cent": "¢",
	"centerdot": "·",
	"CenterDot": "·",
	"cfr": "𝔠",
	"Cfr": "ℭ",
	"CHcy": "Ч",
	"chcy": "ч",
	"check": "✓",
	"checkmark": "✓",
	"Chi": "Χ",
	"chi": "χ",
	"circ": "ˆ",
	"circeq": "≗",
	"circlearrowleft": "↺",
	"circlearrowright": "↻",
	"circledast": "⊛",
	"circledcirc": "⊚",
	"circleddash": "⊝",
	"CircleDot": "⊙",
	"circledR": "®",
	"circledS": "Ⓢ",
	"CircleMinus": "⊖",
	"CirclePlus": "⊕",
	"CircleTimes": "⊗",
	"cir": "○",
	"cirE": "⧃",
	"cire": "≗",
	"cirfnint": "⨐",
	"cirmid": "⫯",
	"cirscir": "⧂",
	"ClockwiseContourIntegral": "∲",
	"CloseCurlyDoubleQuote": "”",
	"CloseCurlyQuote": "’",
	"clubs": "♣",
	"clubsuit": "♣",
	"colon": ":",
	"Colon": "∷",
	"Colone": "⩴",
	"colone": "≔",
	"coloneq": "≔",
	"comma": ",",
	"commat": "@",
	"comp": "∁",
	"compfn": "∘",
	"complement": "∁",
	"complexes": "ℂ",
	"cong": "≅",
	"congdot": "⩭",
	"Congruent": "≡",
	"conint": "∮",
	"Conint": "∯",
	"ContourIntegral": "∮",
	"copf": "𝕔",
	"Copf": "ℂ",
	"coprod": "∐",
	"Coproduct": "∐",
	"copy": "©",
	"COPY": "©",
	"copysr": "℗",
	"CounterClockwiseContourIntegral": "∳",
	"crarr": "↵",
	"cross": "✗",
	"Cross": "⨯",
	"Cscr": "𝒞",
	"cscr": "𝒸",
	"csub": "⫏",
	"csube": "⫑",
	"csup": "⫐",
	"csupe": "⫒",
	"ctdot": "⋯",
	"cudarrl": "⤸",
	"cudarrr": "⤵",
	"cuepr": "⋞",
	"cuesc": "⋟",
	"cularr": "↶",
	"cularrp": "⤽",
	"cupbrcap": "⩈",
	"cupcap": "⩆",
	"CupCap": "≍",
	"cup": "∪",
	"Cup": "⋓",
	"cupcup": "⩊",
	"cupdot": "⊍",
	"cupor": "⩅",
	"cups": "∪︀",
	"curarr": "↷",
	"curarrm": "⤼",
	"curlyeqprec": "⋞",
	"curlyeqsucc": "⋟",
	"curlyvee": "⋎",
	"curlywedge": "⋏",
	"curren": "¤",
	"curvearrowleft": "↶",
	"curvearrowright": "↷",
	"cuvee": "⋎",
	"cuwed": "⋏",
	"cwconint": "∲",
	"cwint": "∱",
	"cylcty": "⌭",
	"dagger": "†",
	"Dagger": "‡",
	"daleth": "ℸ",
	"darr": "↓",
	"Darr": "↡",
	"dArr": "⇓",
	"dash": "‐",
	"Dashv": "⫤",
	"dashv": "⊣",
	"dbkarow": "⤏",
	"dblac": "˝",
	"Dcaron": "Ď",
	"dcaron": "ď",
	"Dcy": "Д",
	"dcy": "д",
	"ddagger": "‡",
	"ddarr": "⇊",
	"DD": "ⅅ",
	"dd": "ⅆ",
	"DDotrahd": "⤑",
	"ddotseq": "⩷",
	"deg": "°",
	"Del": "∇",
	"Delta": "Δ",
	"delta": "δ",
	"demptyv": "⦱",
	"dfisht": "⥿",
	"Dfr": "𝔇",
	"dfr": "𝔡",
	"dHar": "⥥",
	"dharl": "⇃",
	"dharr": "⇂",
	"DiacriticalAcute": "´",
	"DiacriticalDot": "˙",
	"DiacriticalDoubleAcute": "˝",
	"DiacriticalGrave": "`",
	"DiacriticalTilde": "˜",
	"diam": "⋄",
	"diamond": "⋄",
	"Diamond": "⋄",
	"diamondsuit": "♦",
	"diams": "♦",
	"die": "¨",
	"DifferentialD": "ⅆ",
	"digamma": "ϝ",
	"disin": "⋲",
	"div": "÷",
	"divide": "÷",
	"divideontimes": "⋇",
	"divonx": "⋇",
	"DJcy": "Ђ",
	"djcy": "ђ",
	"dlcorn": "⌞",
	"dlcrop": "⌍",
	"dollar": "$",
	"Dopf": "𝔻",
	"dopf": "𝕕",
	"Dot": "¨",
	"dot": "˙",
	"DotDot": "⃜",
	"doteq": "≐",
	"doteqdot": "≑",
	"DotEqual": "≐",
	"dotminus": "∸",
	"dotplus": "∔",
	"dotsquare": "⊡",
	"doublebarwedge": "⌆",
	"DoubleContourIntegral": "∯",
	"DoubleDot": "¨",
	"DoubleDownArrow": "⇓",
	"DoubleLeftArrow": "⇐",
	"DoubleLeftRightArrow": "⇔",
	"DoubleLeftTee": "⫤",
	"DoubleLongLeftArrow": "⟸",
	"DoubleLongLeftRightArrow": "⟺",
	"DoubleLongRightArrow": "⟹",
	"DoubleRightArrow": "⇒",
	"DoubleRightTee": "⊨",
	"DoubleUpArrow": "⇑",
	"DoubleUpDownArrow": "⇕",
	"DoubleVerticalBar": "∥",
	"DownArrowBar": "⤓",
	"downarrow": "↓",
	"DownArrow": "↓",
	"Downarrow": "⇓",
	"DownArrowUpArrow": "⇵",
	"DownBreve": "̑",
	"downdownarrows": "⇊",
	"downharpoonleft": "⇃",
	"downharpoonright": "⇂",
	"DownLeftRightVector": "⥐",
	"DownLeftTeeVector": "⥞",
	"DownLeftVectorBar": "⥖",
	"DownLeftVector": "↽",
	"DownRightTeeVector": "⥟",
	"DownRightVectorBar": "⥗",
	"DownRightVector": "⇁",
	"DownTeeArrow": "↧",
	"DownTee": "⊤",
	"drbkarow": "⤐",
	"drcorn": "⌟",
	"drcrop": "⌌",
	"Dscr": "𝒟",
	"dscr": "𝒹",
	"DScy": "Ѕ",
	"dscy": "ѕ",
	"dsol": "⧶",
	"Dstrok": "Đ",
	"dstrok": "đ",
	"dtdot": "⋱",
	"dtri": "▿",
	"dtrif": "▾",
	"duarr": "⇵",
	"duhar": "⥯",
	"dwangle": "⦦",
	"DZcy": "Џ",
	"dzcy": "џ",
	"dzigrarr": "⟿",
	"Eacute": "É",
	"eacute": "é",
	"easter": "⩮",
	"Ecaron": "Ě",
	"ecaron": "ě",
	"Ecirc": "Ê",
	"ecirc": "ê",
	"ecir": "≖",
	"ecolon": "≕",
	"Ecy": "Э",
	"ecy": "э",
	"eDDot": "⩷",
	"Edot": "Ė",
	"edot": "ė",
	"eDot": "≑",
	"ee": "ⅇ",
	"efDot": "≒",
	"Efr": "𝔈",
	"efr": "𝔢",
	"eg": "⪚",
	"Egrave": "È",
	"egrave": "è",
	"egs": "⪖",
	"egsdot": "⪘",
	"el": "⪙",
	"Element": "∈",
	"elinters": "⏧",
	"ell": "ℓ",
	"els": "⪕",
	"elsdot": "⪗",
	"Emacr": "Ē",
	"emacr": "ē",
	"empty": "∅",
	"emptyset": "∅",
	"EmptySmallSquare": "◻",
	"emptyv": "∅",
	"EmptyVerySmallSquare": "▫",
	"emsp13": " ",
	"emsp14": " ",
	"emsp": " ",
	"ENG": "Ŋ",
	"eng": "ŋ",
	"ensp": " ",
	"Eogon": "Ę",
	"eogon": "ę",
	"Eopf": "𝔼",
	"eopf": "𝕖",
	"epar": "⋕",
	"eparsl": "⧣",
	"eplus": "⩱",
	"epsi": "ε",
	"Epsilon": "Ε",
	"epsilon": "ε",
	"epsiv": "ϵ",
	"eqcirc": "≖",
	"eqcolon": "≕",
	"eqsim": "≂",
	"eqslantgtr": "⪖",
	"eqslantless": "⪕",
	"Equal": "⩵",
	"equals": "=",
	"EqualTilde": "≂",
	"equest": "≟",
	"Equilibrium": "⇌",
	"equiv": "≡",
	"equivDD": "⩸",
	"eqvparsl": "⧥",
	"erarr": "⥱",
	"erDot": "≓",
	"escr": "ℯ",
	"Escr": "ℰ",
	"esdot": "≐",
	"Esim": "⩳",
	"esim": "≂",
	"Eta": "Η",
	"eta": "η",
	"ETH": "Ð",
	"eth": "ð",
	"Euml": "Ë",
	"euml": "ë",
	"euro": "€",
	"excl": "!",
	"exist": "∃",
	"Exists": "∃",
	"expectation": "ℰ",
	"exponentiale": "ⅇ",
	"ExponentialE": "ⅇ",
	"fallingdotseq": "≒",
	"Fcy": "Ф",
	"fcy": "ф",
	"female": "♀",
	"ffilig": "ﬃ",
	"fflig": "ﬀ",
	"ffllig": "ﬄ",
	"Ffr": "𝔉",
	"ffr": "𝔣",
	"filig": "ﬁ",
	"FilledSmallSquare": "◼",
	"FilledVerySmallSquare": "▪",
	"fjlig": "fj",
	"flat": "♭",
	"fllig": "ﬂ",
	"fltns": "▱",
	"fnof": "ƒ",
	"Fopf": "𝔽",
	"fopf": "𝕗",
	"forall": "∀",
	"ForAll": "∀",
	"fork": "⋔",
	"forkv": "⫙",
	"Fouriertrf": "ℱ",
	"fpartint": "⨍",
	"frac12": "½",
	"frac13": "⅓",
	"frac14": "¼",
	"frac15": "⅕",
	"frac16": "⅙",
	"frac18": "⅛",
	"frac23": "⅔",
	"frac25": "⅖",
	"frac34": "¾",
	"frac35": "⅗",
	"frac38": "⅜",
	"frac45": "⅘",
	"frac56": "⅚",
	"frac58": "⅝",
	"frac78": "⅞",
	"frasl": "⁄",
	"frown": "⌢",
	"fscr": "𝒻",
	"Fscr": "ℱ",
	"gacute": "ǵ",
	"Gamma": "Γ",
	"gamma": "γ",
	"Gammad": "Ϝ",
	"gammad": "ϝ",
	"gap": "⪆",
	"Gbreve": "Ğ",
	"gbreve": "ğ",
	"Gcedil": "Ģ",
	"Gcirc": "Ĝ",
	"gcirc": "ĝ",
	"Gcy": "Г",
	"gcy": "г",
	"Gdot": "Ġ",
	"gdot": "ġ",
	"ge": "≥",
	"gE": "≧",
	"gEl": "⪌",
	"gel": "⋛",
	"geq": "≥",
	"geqq": "≧",
	"geqslant": "⩾",
	"gescc": "⪩",
	"ges": "⩾",
	"gesdot": "⪀",
	"gesdoto": "⪂",
	"gesdotol": "⪄",
	"gesl": "⋛︀",
	"gesles": "⪔",
	"Gfr": "𝔊",
	"gfr": "𝔤",
	"gg": "≫",
	"Gg": "⋙",
	"ggg": "⋙",
	"gimel": "ℷ",
	"GJcy": "Ѓ",
	"gjcy": "ѓ",
	"gla": "⪥",
	"gl": "≷",
	"glE": "⪒",
	"glj": "⪤",
	"gnap": "⪊",
	"gnapprox": "⪊",
	"gne": "⪈",
	"gnE": "≩",
	"gneq": "⪈",
	"gneqq": "≩",
	"gnsim": "⋧",
	"Gopf": "𝔾",
	"gopf": "𝕘",
	"grave": "`",
	"GreaterEqual": "≥",
	"GreaterEqualLess": "⋛",
	"GreaterFullEqual": "≧",
	"GreaterGreater": "⪢",
	"GreaterLess": "≷",
	"GreaterSlantEqual": "⩾",
	"GreaterTilde": "≳",
	"Gscr": "𝒢",
	"gscr": "ℊ",
	"gsim": "≳",
	"gsime": "⪎",
	"gsiml": "⪐",
	"gtcc": "⪧",
	"gtcir": "⩺",
	"gt": ">",
	"GT": ">",
	"Gt": "≫",
	"gtdot": "⋗",
	"gtlPar": "⦕",
	"gtquest": "⩼",
	"gtrapprox": "⪆",
	"gtrarr": "⥸",
	"gtrdot": "⋗",
	"gtreqless": "⋛",
	"gtreqqless": "⪌",
	"gtrless": "≷",
	"gtrsim": "≳",
	"gvertneqq": "≩︀",
	"gvnE": "≩︀",
	"Hacek": "ˇ",
	"hairsp": " ",
	"half": "½",
	"hamilt": "ℋ",
	"HARDcy": "Ъ",
	"hardcy": "ъ",
	"harrcir": "⥈",
	"harr": "↔",
	"hArr": "⇔",
	"harrw": "↭",
	"Hat": "^",
	"hbar": "ℏ",
	"Hcirc": "Ĥ",
	"hcirc": "ĥ",
	"hearts": "♥",
	"heartsuit": "♥",
	"hellip": "…",
	"hercon": "⊹",
	"hfr": "𝔥",
	"Hfr": "ℌ",
	"HilbertSpace": "ℋ",
	"hksearow": "⤥",
	"hkswarow": "⤦",
	"hoarr": "⇿",
	"homtht": "∻",
	"hookleftarrow": "↩",
	"hookrightarrow": "↪",
	"hopf": "𝕙",
	"Hopf": "ℍ",
	"horbar": "―",
	"HorizontalLine": "─",
	"hscr": "𝒽",
	"Hscr": "ℋ",
	"hslash": "ℏ",
	"Hstrok": "Ħ",
	"hstrok": "ħ",
	"HumpDownHump": "≎",
	"HumpEqual": "≏",
	"hybull": "⁃",
	"hyphen": "‐",
	"Iacute": "Í",
	"iacute": "í",
	"ic": "⁣",
	"Icirc": "Î",
	"icirc": "î",
	"Icy": "И",
	"icy": "и",
	"Idot": "İ",
	"IEcy": "Е",
	"iecy": "е",
	"iexcl": "¡",
	"iff": "⇔",
	"ifr": "𝔦",
	"Ifr": "ℑ",
	"Igrave": "Ì",
	"igrave": "ì",
	"ii": "ⅈ",
	"iiiint": "⨌",
	"iiint": "∭",
	"iinfin": "⧜",
	"iiota": "℩",
	"IJlig": "Ĳ",
	"ijlig": "ĳ",
	"Imacr": "Ī",
	"imacr": "ī",
	"image": "ℑ",
	"ImaginaryI": "ⅈ",
	"imagline": "ℐ",
	"imagpart": "ℑ",
	"imath": "ı",
	"Im": "ℑ",
	"imof": "⊷",
	"imped": "Ƶ",
	"Implies": "⇒",
	"incare": "℅",
	"in": "∈",
	"infin": "∞",
	"infintie": "⧝",
	"inodot": "ı",
	"intcal": "⊺",
	"int": "∫",
	"Int": "∬",
	"integers": "ℤ",
	"Integral": "∫",
	"intercal": "⊺",
	"Intersection": "⋂",
	"intlarhk": "⨗",
	"intprod": "⨼",
	"InvisibleComma": "⁣",
	"InvisibleTimes": "⁢",
	"IOcy": "Ё",
	"iocy": "ё",
	"Iogon": "Į",
	"iogon": "į",
	"Iopf": "𝕀",
	"iopf": "𝕚",
	"Iota": "Ι",
	"iota": "ι",
	"iprod": "⨼",
	"iquest": "¿",
	"iscr": "𝒾",
	"Iscr": "ℐ",
	"isin": "∈",
	"isindot": "⋵",
	"isinE": "⋹",
	"isins": "⋴",
	"isinsv": "⋳",
	"isinv": "∈",
	"it": "⁢",
	"Itilde": "Ĩ",
	"itilde": "ĩ",
	"Iukcy": "І",
	"iukcy": "і",
	"Iuml": "Ï",
	"iuml": "ï",
	"Jcirc": "Ĵ",
	"jcirc": "ĵ",
	"Jcy": "Й",
	"jcy": "й",
	"Jfr": "𝔍",
	"jfr": "𝔧",
	"jmath": "ȷ",
	"Jopf": "𝕁",
	"jopf": "𝕛",
	"Jscr": "𝒥",
	"jscr": "𝒿",
	"Jsercy": "Ј",
	"jsercy": "ј",
	"Jukcy": "Є",
	"jukcy": "є",
	"Kappa": "Κ",
	"kappa": "κ",
	"kappav": "ϰ",
	"Kcedil": "Ķ",
	"kcedil": "ķ",
	"Kcy": "К",
	"kcy": "к",
	"Kfr": "𝔎",
	"kfr": "𝔨",
	"kgreen": "ĸ",
	"KHcy": "Х",
	"khcy": "х",
	"KJcy": "Ќ",
	"kjcy": "ќ",
	"Kopf": "𝕂",
	"kopf": "𝕜",
	"Kscr": "𝒦",
	"kscr": "𝓀",
	"lAarr": "⇚",
	"Lacute": "Ĺ",
	"lacute": "ĺ",
	"laemptyv": "⦴",
	"lagran": "ℒ",
	"Lambda": "Λ",
	"lambda": "λ",
	"lang": "⟨",
	"Lang": "⟪",
	"langd": "⦑",
	"langle": "⟨",
	"lap": "⪅",
	"Laplacetrf": "ℒ",
	"laquo": "«",
	"larrb": "⇤",
	"larrbfs": "⤟",
	"larr": "←",
	"Larr": "↞",
	"lArr": "⇐",
	"larrfs": "⤝",
	"larrhk": "↩",
	"larrlp": "↫",
	"larrpl": "⤹",
	"larrsim": "⥳",
	"larrtl": "↢",
	"latail": "⤙",
	"lAtail": "⤛",
	"lat": "⪫",
	"late": "⪭",
	"lates": "⪭︀",
	"lbarr": "⤌",
	"lBarr": "⤎",
	"lbbrk": "❲",
	"lbrace": "{",
	"lbrack": "[",
	"lbrke": "⦋",
	"lbrksld": "⦏",
	"lbrkslu": "⦍",
	"Lcaron": "Ľ",
	"lcaron": "ľ",
	"Lcedil": "Ļ",
	"lcedil": "ļ",
	"lceil": "⌈",
	"lcub": "{",
	"Lcy": "Л",
	"lcy": "л",
	"ldca": "⤶",
	"ldquo": "“",
	"ldquor": "„",
	"ldrdhar": "⥧",
	"ldrushar": "⥋",
	"ldsh": "↲",
	"le": "≤",
	"lE": "≦",
	"LeftAngleBracket": "⟨",
	"LeftArrowBar": "⇤",
	"leftarrow": "←",
	"LeftArrow": "←",
	"Leftarrow": "⇐",
	"LeftArrowRightArrow": "⇆",
	"leftarrowtail": "↢",
	"LeftCeiling": "⌈",
	"LeftDoubleBracket": "⟦",
	"LeftDownTeeVector": "⥡",
	"LeftDownVectorBar": "⥙",
	"LeftDownVector": "⇃",
	"LeftFloor": "⌊",
	"leftharpoondown": "↽",
	"leftharpoonup": "↼",
	"leftleftarrows": "⇇",
	"leftrightarrow": "↔",
	"LeftRightArrow": "↔",
	"Leftrightarrow": "⇔",
	"leftrightarrows": "⇆",
	"leftrightharpoons": "⇋",
	"leftrightsquigarrow": "↭",
	"LeftRightVector": "⥎",
	"LeftTeeArrow": "↤",
	"LeftTee": "⊣",
	"LeftTeeVector": "⥚",
	"leftthreetimes": "⋋",
	"LeftTriangleBar": "⧏",
	"LeftTriangle": "⊲",
	"LeftTriangleEqual": "⊴",
	"LeftUpDownVector": "⥑",
	"LeftUpTeeVector": "⥠",
	"LeftUpVectorBar": "⥘",
	"LeftUpVector": "↿",
	"LeftVectorBar": "⥒",
	"LeftVector": "↼",
	"lEg": "⪋",
	"leg": "⋚",
	"leq": "≤",
	"leqq": "≦",
	"leqslant": "⩽",
	"lescc": "⪨",
	"les": "⩽",
	"lesdot": "⩿",
	"lesdoto": "⪁",
	"lesdotor": "⪃",
	"lesg": "⋚︀",
	"lesges": "⪓",
	"lessapprox": "⪅",
	"lessdot": "⋖",
	"lesseqgtr": "⋚",
	"lesseqqgtr": "⪋",
	"LessEqualGreater": "⋚",
	"LessFullEqual": "≦",
	"LessGreater": "≶",
	"lessgtr": "≶",
	"LessLess": "⪡",
	"lesssim": "≲",
	"LessSlantEqual": "⩽",
	"LessTilde": "≲",
	"lfisht": "⥼",
	"lfloor": "⌊",
	"Lfr": "𝔏",
	"lfr": "𝔩",
	"lg": "≶",
	"lgE": "⪑",
	"lHar": "⥢",
	"lhard": "↽",
	"lharu": "↼",
	"lharul": "⥪",
	"lhblk": "▄",
	"LJcy": "Љ",
	"ljcy": "љ",
	"llarr": "⇇",
	"ll": "≪",
	"Ll": "⋘",
	"llcorner": "⌞",
	"Lleftarrow": "⇚",
	"llhard": "⥫",
	"lltri": "◺",
	"Lmidot": "Ŀ",
	"lmidot": "ŀ",
	"lmoustache": "⎰",
	"lmoust": "⎰",
	"lnap": "⪉",
	"lnapprox": "⪉",
	"lne": "⪇",
	"lnE": "≨",
	"lneq": "⪇",
	"lneqq": "≨",
	"lnsim": "⋦",
	"loang": "⟬",
	"loarr": "⇽",
	"lobrk": "⟦",
	"longleftarrow": "⟵",
	"LongLeftArrow": "⟵",
	"Longleftarrow": "⟸",
	"longleftrightarrow": "⟷",
	"LongLeftRightArrow": "⟷",
	"Longleftrightarrow": "⟺",
	"longmapsto": "⟼",
	"longrightarrow": "⟶",
	"LongRightArrow": "⟶",
	"Longrightarrow": "⟹",
	"looparrowleft": "↫",
	"looparrowright": "↬",
	"lopar": "⦅",
	"Lopf": "𝕃",
	"lopf": "𝕝",
	"loplus": "⨭",
	"lotimes": "⨴",
	"lowast": "∗",
	"lowbar": "_",
	"LowerLeftArrow": "↙",
	"LowerRightArrow": "↘",
	"loz": "◊",
	"lozenge": "◊",
	"lozf": "⧫",
	"lpar": "(",
	"lparlt": "⦓",
	"lrarr": "⇆",
	"lrcorner": "⌟",
	"lrhar": "⇋",
	"lrhard": "⥭",
	"lrm": "‎",
	"lrtri": "⊿",
	"lsaquo": "‹",
	"lscr": "𝓁",
	"Lscr": "ℒ",
	"lsh": "↰",
	"Lsh": "↰",
	"lsim": "≲",
	"lsime": "⪍",
	"lsimg": "⪏",
	"lsqb": "[",
	"lsquo": "‘",
	"lsquor": "‚",
	"Lstrok": "Ł",
	"lstrok": "ł",
	"ltcc": "⪦",
	"ltcir": "⩹",
	"lt": "<",
	"LT": "<",
	"Lt": "≪",
	"ltdot": "⋖",
	"lthree": "⋋",
	"ltimes": "⋉",
	"ltlarr": "⥶",
	"ltquest": "⩻",
	"ltri": "◃",
	"ltrie": "⊴",
	"ltrif": "◂",
	"ltrPar": "⦖",
	"lurdshar": "⥊",
	"luruhar": "⥦",
	"lvertneqq": "≨︀",
	"lvnE": "≨︀",
	"macr": "¯",
	"male": "♂",
	"malt": "✠",
	"maltese": "✠",
	"Map": "⤅",
	"map": "↦",
	"mapsto": "↦",
	"mapstodown": "↧",
	"mapstoleft": "↤",
	"mapstoup": "↥",
	"marker": "▮",
	"mcomma": "⨩",
	"Mcy": "М",
	"mcy": "м",
	"mdash": "—",
	"mDDot": "∺",
	"measuredangle": "∡",
	"MediumSpace": " ",
	"Mellintrf": "ℳ",
	"Mfr": "𝔐",
	"mfr": "𝔪",
	"mho": "℧",
	"micro": "µ",
	"midast": "*",
	"midcir": "⫰",
	"mid": "∣",
	"middot": "·",
	"minusb": "⊟",
	"minus": "−",
	"minusd": "∸",
	"minusdu": "⨪",
	"MinusPlus": "∓",
	"mlcp": "⫛",
	"mldr": "…",
	"mnplus": "∓",
	"models": "⊧",
	"Mopf": "𝕄",
	"mopf": "𝕞",
	"mp": "∓",
	"mscr": "𝓂",
	"Mscr": "ℳ",
	"mstpos": "∾",
	"Mu": "Μ",
	"mu": "μ",
	"multimap": "⊸",
	"mumap": "⊸",
	"nabla": "∇",
	"Nacute": "Ń",
	"nacute": "ń",
	"nang": "∠⃒",
	"nap": "≉",
	"napE": "⩰̸",
	"napid": "≋̸",
	"napos": "ŉ",
	"napprox": "≉",
	"natural": "♮",
	"naturals": "ℕ",
	"natur": "♮",
	"nbsp": " ",
	"nbump": "≎̸",
	"nbumpe": "≏̸",
	"ncap": "⩃",
	"Ncaron": "Ň",
	"ncaron": "ň",
	"Ncedil": "Ņ",
	"ncedil": "ņ",
	"ncong": "≇",
	"ncongdot": "⩭̸",
	"ncup": "⩂",
	"Ncy": "Н",
	"ncy": "н",
	"ndash": "–",
	"nearhk": "⤤",
	"nearr": "↗",
	"neArr": "⇗",
	"nearrow": "↗",
	"ne": "≠",
	"nedot": "≐̸",
	"NegativeMediumSpace": "​",
	"NegativeThickSpace": "​",
	"NegativeThinSpace": "​",
	"NegativeVeryThinSpace": "​",
	"nequiv": "≢",
	"nesear": "⤨",
	"nesim": "≂̸",
	"NestedGreaterGreater": "≫",
	"NestedLessLess": "≪",
	"NewLine": "\n",
	"nexist": "∄",
	"nexists": "∄",
	"Nfr": "𝔑",
	"nfr": "𝔫",
	"ngE": "≧̸",
	"nge": "≱",
	"ngeq": "≱",
	"ngeqq": "≧̸",
	"ngeqslant": "⩾̸",
	"nges": "⩾̸",
	"nGg": "⋙̸",
	"ngsim": "≵",
	"nGt": "≫⃒",
	"ngt": "≯",
	"ngtr": "≯",
	"nGtv": "≫̸",
	"nharr": "↮",
	"nhArr": "⇎",
	"nhpar": "⫲",
	"ni": "∋",
	"nis": "⋼",
	"nisd": "⋺",
	"niv": "∋",
	"NJcy": "Њ",
	"njcy": "њ",
	"nlarr": "↚",
	"nlArr": "⇍",
	"nldr": "‥",
	"nlE": "≦̸",
	"nle": "≰",
	"nleftarrow": "↚",
	"nLeftarrow": "⇍",
	"nleftrightarrow": "↮",
	"nLeftrightarrow": "⇎",
	"nleq": "≰",
	"nleqq": "≦̸",
	"nleqslant": "⩽̸",
	"nles": "⩽̸",
	"nless": "≮",
	"nLl": "⋘̸",
	"nlsim": "≴",
	"nLt": "≪⃒",
	"nlt": "≮",
	"nltri": "⋪",
	"nltrie": "⋬",
	"nLtv": "≪̸",
	"nmid": "∤",
	"NoBreak": "⁠",
	"NonBreakingSpace": " ",
	"nopf": "𝕟",
	"Nopf": "ℕ",
	"Not": "⫬",
	"not": "¬",
	"NotCongruent": "≢",
	"NotCupCap": "≭",
	"NotDoubleVerticalBar": "∦",
	"NotElement": "∉",
	"NotEqual": "≠",
	"NotEqualTilde": "≂̸",
	"NotExists": "∄",
	"NotGreater": "≯",
	"NotGreaterEqual": "≱",
	"NotGreaterFullEqual": "≧̸",
	"NotGreaterGreater": "≫̸",
	"NotGreaterLess": "≹",
	"NotGreaterSlantEqual": "⩾̸",
	"NotGreaterTilde": "≵",
	"NotHumpDownHump": "≎̸",
	"NotHumpEqual": "≏̸",
	"notin": "∉",
	"notindot": "⋵̸",
	"notinE": "⋹̸",
	"notinva": "∉",
	"notinvb": "⋷",
	"notinvc": "⋶",
	"NotLeftTriangleBar": "⧏̸",
	"NotLeftTriangle": "⋪",
	"NotLeftTriangleEqual": "⋬",
	"NotLess": "≮",
	"NotLessEqual": "≰",
	"NotLessGreater": "≸",
	"NotLessLess": "≪̸",
	"NotLessSlantEqual": "⩽̸",
	"NotLessTilde": "≴",
	"NotNestedGreaterGreater": "⪢̸",
	"NotNestedLessLess": "⪡̸",
	"notni": "∌",
	"notniva": "∌",
	"notnivb": "⋾",
	"notnivc": "⋽",
	"NotPrecedes": "⊀",
	"NotPrecedesEqual": "⪯̸",
	"NotPrecedesSlantEqual": "⋠",
	"NotReverseElement": "∌",
	"NotRightTriangleBar": "⧐̸",
	"NotRightTriangle": "⋫",
	"NotRightTriangleEqual": "⋭",
	"NotSquareSubset": "⊏̸",
	"NotSquareSubsetEqual": "⋢",
	"NotSquareSuperset": "⊐̸",
	"NotSquareSupersetEqual": "⋣",
	"NotSubset": "⊂⃒",
	"NotSubsetEqual": "⊈",
	"NotSucceeds": "⊁",
	"NotSucceedsEqual": "⪰̸",
	"NotSucceedsSlantEqual": "⋡",
	"NotSucceedsTilde": "≿̸",
	"NotSuperset": "⊃⃒",
	"NotSupersetEqual": "⊉",
	"NotTilde": "≁",
	"NotTildeEqual": "≄",
	"NotTildeFullEqual": "≇",
	"NotTildeTilde": "≉",
	"NotVerticalBar": "∤",
	"nparallel": "∦",
	"npar": "∦",
	"nparsl": "⫽⃥",
	"npart": "∂̸",
	"npolint": "⨔",
	"npr": "⊀",
	"nprcue": "⋠",
	"nprec": "⊀",
	"npreceq": "⪯̸",
	"npre": "⪯̸",
	"nrarrc": "⤳̸",
	"nrarr": "↛",
	"nrArr": "⇏",
	"nrarrw": "↝̸",
	"nrightarrow": "↛",
	"nRightarrow": "⇏",
	"nrtri": "⋫",
	"nrtrie": "⋭",
	"nsc": "⊁",
	"nsccue": "⋡",
	"nsce": "⪰̸",
	"Nscr": "𝒩",
	"nscr": "𝓃",
	"nshortmid": "∤",
	"nshortparallel": "∦",
	"nsim": "≁",
	"nsime": "≄",
	"nsimeq": "≄",
	"nsmid": "∤",
	"nspar": "∦",
	"nsqsube": "⋢",
	"nsqsupe": "⋣",
	"nsub": "⊄",
	"nsubE": "⫅̸",
	"nsube": "⊈",
	"nsubset": "⊂⃒",
	"nsubseteq": "⊈",
	"nsubseteqq": "⫅̸",
	"nsucc": "⊁",
	"nsucceq": "⪰̸",
	"nsup": "⊅",
	"nsupE": "⫆̸",
	"nsupe": "⊉",
	"nsupset": "⊃⃒",
	"nsupseteq": "⊉",
	"nsupseteqq": "⫆̸",
	"ntgl": "≹",
	"Ntilde": "Ñ",
	"ntilde": "ñ",
	"ntlg": "≸",
	"ntriangleleft": "⋪",
	"ntrianglelefteq": "⋬",
	"ntriangleright": "⋫",
	"ntrianglerighteq": "⋭",
	"Nu": "Ν",
	"nu": "ν",
	"num": "#",
	"numero": "№",
	"numsp": " ",
	"nvap": "≍⃒",
	"nvdash": "⊬",
	"nvDash": "⊭",
	"nVdash": "⊮",
	"nVDash": "⊯",
	"nvge": "≥⃒",
	"nvgt": ">⃒",
	"nvHarr": "⤄",
	"nvinfin": "⧞",
	"nvlArr": "⤂",
	"nvle": "≤⃒",
	"nvlt": "<⃒",
	"nvltrie": "⊴⃒",
	"nvrArr": "⤃",
	"nvrtrie": "⊵⃒",
	"nvsim": "∼⃒",
	"nwarhk": "⤣",
	"nwarr": "↖",
	"nwArr": "⇖",
	"nwarrow": "↖",
	"nwnear": "⤧",
	"Oacute": "Ó",
	"oacute": "ó",
	"oast": "⊛",
	"Ocirc": "Ô",
	"ocirc": "ô",
	"ocir": "⊚",
	"Ocy": "О",
	"ocy": "о",
	"odash": "⊝",
	"Odblac": "Ő",
	"odblac": "ő",
	"odiv": "⨸",
	"odot": "⊙",
	"odsold": "⦼",
	"OElig": "Œ",
	"oelig": "œ",
	"ofcir": "⦿",
	"Ofr": "𝔒",
	"ofr": "𝔬",
	"ogon": "˛",
	"Ograve": "Ò",
	"ograve": "ò",
	"ogt": "⧁",
	"ohbar": "⦵",
	"ohm": "Ω",
	"oint": "∮",
	"olarr": "↺",
	"olcir": "⦾",
	"olcross": "⦻",
	"oline": "‾",
	"olt": "⧀",
	"Omacr": "Ō",
	"omacr": "ō",
	"Omega": "Ω",
	"omega": "ω",
	"Omicron": "Ο",
	"omicron": "ο",
	"omid": "⦶",
	"ominus": "⊖",
	"Oopf": "𝕆",
	"oopf": "𝕠",
	"opar": "⦷",
	"OpenCurlyDoubleQuote": "“",
	"OpenCurlyQuote": "‘",
	"operp": "⦹",
	"oplus": "⊕",
	"orarr": "↻",
	"Or": "⩔",
	"or": "∨",
	"ord": "⩝",
	"order": "ℴ",
	"orderof": "ℴ",
	"ordf": "ª",
	"ordm": "º",
	"origof": "⊶",
	"oror": "⩖",
	"orslope": "⩗",
	"orv": "⩛",
	"oS": "Ⓢ",
	"Oscr": "𝒪",
	"oscr": "ℴ",
	"Oslash": "Ø",
	"oslash": "ø",
	"osol": "⊘",
	"Otilde": "Õ",
	"otilde": "õ",
	"otimesas": "⨶",
	"Otimes": "⨷",
	"otimes": "⊗",
	"Ouml": "Ö",
	"ouml": "ö",
	"ovbar": "⌽",
	"OverBar": "‾",
	"OverBrace": "⏞",
	"OverBracket": "⎴",
	"OverParenthesis": "⏜",
	"para": "¶",
	"parallel": "∥",
	"par": "∥",
	"parsim": "⫳",
	"parsl": "⫽",
	"part": "∂",
	"PartialD": "∂",
	"Pcy": "П",
	"pcy": "п",
	"percnt": "%",
	"period": ".",
	"permil": "‰",
	"perp": "⊥",
	"pertenk": "‱",
	"Pfr": "𝔓",
	"pfr": "𝔭",
	"Phi": "Φ",
	"phi": "φ",
	"phiv": "ϕ",
	"phmmat": "ℳ",
	"phone": "☎",
	"Pi": "Π",
	"pi": "π",
	"pitchfork": "⋔",
	"piv": "ϖ",
	"planck": "ℏ",
	"planckh": "ℎ",
	"plankv": "ℏ",
	"plusacir": "⨣",
	"plusb": "⊞",
	"pluscir": "⨢",
	"plus": "+",
	"plusdo": "∔",
	"plusdu": "⨥",
	"pluse": "⩲",
	"PlusMinus": "±",
	"plusmn": "±",
	"plussim": "⨦",
	"plustwo": "⨧",
	"pm": "±",
	"Poincareplane": "ℌ",
	"pointint": "⨕",
	"popf": "𝕡",
	"Popf": "ℙ",
	"pound": "£",
	"prap": "⪷",
	"Pr": "⪻",
	"pr": "≺",
	"prcue": "≼",
	"precapprox": "⪷",
	"prec": "≺",
	"preccurlyeq": "≼",
	"Precedes": "≺",
	"PrecedesEqual": "⪯",
	"PrecedesSlantEqual": "≼",
	"PrecedesTilde": "≾",
	"preceq": "⪯",
	"precnapprox": "⪹",
	"precneqq": "⪵",
	"precnsim": "⋨",
	"pre": "⪯",
	"prE": "⪳",
	"precsim": "≾",
	"prime": "′",
	"Prime": "″",
	"primes": "ℙ",
	"prnap": "⪹",
	"prnE": "⪵",
	"prnsim": "⋨",
	"prod": "∏",
	"Product": "∏",
	"profalar": "⌮",
	"profline": "⌒",
	"profsurf": "⌓",
	"prop": "∝",
	"Proportional": "∝",
	"Proportion": "∷",
	"propto": "∝",
	"prsim": "≾",
	"prurel": "⊰",
	"Pscr": "𝒫",
	"pscr": "𝓅",
	"Psi": "Ψ",
	"psi": "ψ",
	"puncsp": " ",
	"Qfr": "𝔔",
	"qfr": "𝔮",
	"qint": "⨌",
	"qopf": "𝕢",
	"Qopf": "ℚ",
	"qprime": "⁗",
	"Qscr": "𝒬",
	"qscr": "𝓆",
	"quaternions": "ℍ",
	"quatint": "⨖",
	"quest": "?",
	"questeq": "≟",
	"quot": "\"",
	"QUOT": "\"",
	"rAarr": "⇛",
	"race": "∽̱",
	"Racute": "Ŕ",
	"racute": "ŕ",
	"radic": "√",
	"raemptyv": "⦳",
	"rang": "⟩",
	"Rang": "⟫",
	"rangd": "⦒",
	"range": "⦥",
	"rangle": "⟩",
	"raquo": "»",
	"rarrap": "⥵",
	"rarrb": "⇥",
	"rarrbfs": "⤠",
	"rarrc": "⤳",
	"rarr": "→",
	"Rarr": "↠",
	"rArr": "⇒",
	"rarrfs": "⤞",
	"rarrhk": "↪",
	"rarrlp": "↬",
	"rarrpl": "⥅",
	"rarrsim": "⥴",
	"Rarrtl": "⤖",
	"rarrtl": "↣",
	"rarrw": "↝",
	"ratail": "⤚",
	"rAtail": "⤜",
	"ratio": "∶",
	"rationals": "ℚ",
	"rbarr": "⤍",
	"rBarr": "⤏",
	"RBarr": "⤐",
	"rbbrk": "❳",
	"rbrace": "}",
	"rbrack": "]",
	"rbrke": "⦌",
	"rbrksld": "⦎",
	"rbrkslu": "⦐",
	"Rcaron": "Ř",
	"rcaron": "ř",
	"Rcedil": "Ŗ",
	"rcedil": "ŗ",
	"rceil": "⌉",
	"rcub": "}",
	"Rcy": "Р",
	"rcy": "р",
	"rdca": "⤷",
	"rdldhar": "⥩",
	"rdquo": "”",
	"rdquor": "”",
	"rdsh": "↳",
	"real": "ℜ",
	"realine": "ℛ",
	"realpart": "ℜ",
	"reals": "ℝ",
	"Re": "ℜ",
	"rect": "▭",
	"reg": "®",
	"REG": "®",
	"ReverseElement": "∋",
	"ReverseEquilibrium": "⇋",
	"ReverseUpEquilibrium": "⥯",
	"rfisht": "⥽",
	"rfloor": "⌋",
	"rfr": "𝔯",
	"Rfr": "ℜ",
	"rHar": "⥤",
	"rhard": "⇁",
	"rharu": "⇀",
	"rharul": "⥬",
	"Rho": "Ρ",
	"rho": "ρ",
	"rhov": "ϱ",
	"RightAngleBracket": "⟩",
	"RightArrowBar": "⇥",
	"rightarrow": "→",
	"RightArrow": "→",
	"Rightarrow": "⇒",
	"RightArrowLeftArrow": "⇄",
	"rightarrowtail": "↣",
	"RightCeiling": "⌉",
	"RightDoubleBracket": "⟧",
	"RightDownTeeVector": "⥝",
	"RightDownVectorBar": "⥕",
	"RightDownVector": "⇂",
	"RightFloor": "⌋",
	"rightharpoondown": "⇁",
	"rightharpoonup": "⇀",
	"rightleftarrows": "⇄",
	"rightleftharpoons": "⇌",
	"rightrightarrows": "⇉",
	"rightsquigarrow": "↝",
	"RightTeeArrow": "↦",
	"RightTee": "⊢",
	"RightTeeVector": "⥛",
	"rightthreetimes": "⋌",
	"RightTriangleBar": "⧐",
	"RightTriangle": "⊳",
	"RightTriangleEqual": "⊵",
	"RightUpDownVector": "⥏",
	"RightUpTeeVector": "⥜",
	"RightUpVectorBar": "⥔",
	"RightUpVector": "↾",
	"RightVectorBar": "⥓",
	"RightVector": "⇀",
	"ring": "˚",
	"risingdotseq": "≓",
	"rlarr": "⇄",
	"rlhar": "⇌",
	"rlm": "‏",
	"rmoustache": "⎱",
	"rmoust": "⎱",
	"rnmid": "⫮",
	"roang": "⟭",
	"roarr": "⇾",
	"robrk": "⟧",
	"ropar": "⦆",
	"ropf": "𝕣",
	"Ropf": "ℝ",
	"roplus": "⨮",
	"rotimes": "⨵",
	"RoundImplies": "⥰",
	"rpar": ")",
	"rpargt": "⦔",
	"rppolint": "⨒",
	"rrarr": "⇉",
	"Rrightarrow": "⇛",
	"rsaquo": "›",
	"rscr": "𝓇",
	"Rscr": "ℛ",
	"rsh": "↱",
	"Rsh": "↱",
	"rsqb": "]",
	"rsquo": "’",
	"rsquor": "’",
	"rthree": "⋌",
	"rtimes": "⋊",
	"rtri": "▹",
	"rtrie": "⊵",
	"rtrif": "▸",
	"rtriltri": "⧎",
	"RuleDelayed": "⧴",
	"ruluhar": "⥨",
	"rx": "℞",
	"Sacute": "Ś",
	"sacute": "ś",
	"sbquo": "‚",
	"scap": "⪸",
	"Scaron": "Š",
	"scaron": "š",
	"Sc": "⪼",
	"sc": "≻",
	"sccue": "≽",
	"sce": "⪰",
	"scE": "⪴",
	"Scedil": "Ş",
	"scedil": "ş",
	"Scirc": "Ŝ",
	"scirc": "ŝ",
	"scnap": "⪺",
	"scnE": "⪶",
	"scnsim": "⋩",
	"scpolint": "⨓",
	"scsim": "≿",
	"Scy": "С",
	"scy": "с",
	"sdotb": "⊡",
	"sdot": "⋅",
	"sdote": "⩦",
	"searhk": "⤥",
	"searr": "↘",
	"seArr": "⇘",
	"searrow": "↘",
	"sect": "§",
	"semi": ";",
	"seswar": "⤩",
	"setminus": "∖",
	"setmn": "∖",
	"sext": "✶",
	"Sfr": "𝔖",
	"sfr": "𝔰",
	"sfrown": "⌢",
	"sharp": "♯",
	"SHCHcy": "Щ",
	"shchcy": "щ",
	"SHcy": "Ш",
	"shcy": "ш",
	"ShortDownArrow": "↓",
	"ShortLeftArrow": "←",
	"shortmid": "∣",
	"shortparallel": "∥",
	"ShortRightArrow": "→",
	"ShortUpArrow": "↑",
	"shy": "­",
	"Sigma": "Σ",
	"sigma": "σ",
	"sigmaf": "ς",
	"sigmav": "ς",
	"sim": "∼",
	"simdot": "⩪",
	"sime": "≃",
	"simeq": "≃",
	"simg": "⪞",
	"simgE": "⪠",
	"siml": "⪝",
	"simlE": "⪟",
	"simne": "≆",
	"simplus": "⨤",
	"simrarr": "⥲",
	"slarr": "←",
	"SmallCircle": "∘",
	"smallsetminus": "∖",
	"smashp": "⨳",
	"smeparsl": "⧤",
	"smid": "∣",
	"smile": "⌣",
	"smt": "⪪",
	"smte": "⪬",
	"smtes": "⪬︀",
	"SOFTcy": "Ь",
	"softcy": "ь",
	"solbar": "⌿",
	"solb": "⧄",
	"sol": "/",
	"Sopf": "𝕊",
	"sopf": "𝕤",
	"spades": "♠",
	"spadesuit": "♠",
	"spar": "∥",
	"sqcap": "⊓",
	"sqcaps": "⊓︀",
	"sqcup": "⊔",
	"sqcups": "⊔︀",
	"Sqrt": "√",
	"sqsub": "⊏",
	"sqsube": "⊑",
	"sqsubset": "⊏",
	"sqsubseteq": "⊑",
	"sqsup": "⊐",
	"sqsupe": "⊒",
	"sqsupset": "⊐",
	"sqsupseteq": "⊒",
	"square": "□",
	"Square": "□",
	"SquareIntersection": "⊓",
	"SquareSubset": "⊏",
	"SquareSubsetEqual": "⊑",
	"SquareSuperset": "⊐",
	"SquareSupersetEqual": "⊒",
	"SquareUnion": "⊔",
	"squarf": "▪",
	"squ": "□",
	"squf": "▪",
	"srarr": "→",
	"Sscr": "𝒮",
	"sscr": "𝓈",
	"ssetmn": "∖",
	"ssmile": "⌣",
	"sstarf": "⋆",
	"Star": "⋆",
	"star": "☆",
	"starf": "★",
	"straightepsilon": "ϵ",
	"straightphi": "ϕ",
	"strns": "¯",
	"sub": "⊂",
	"Sub": "⋐",
	"subdot": "⪽",
	"subE": "⫅",
	"sube": "⊆",
	"subedot": "⫃",
	"submult": "⫁",
	"subnE": "⫋",
	"subne": "⊊",
	"subplus": "⪿",
	"subrarr": "⥹",
	"subset": "⊂",
	"Subset": "⋐",
	"subseteq": "⊆",
	"subseteqq": "⫅",
	"SubsetEqual": "⊆",
	"subsetneq": "⊊",
	"subsetneqq": "⫋",
	"subsim": "⫇",
	"subsub": "⫕",
	"subsup": "⫓",
	"succapprox": "⪸",
	"succ": "≻",
	"succcurlyeq": "≽",
	"Succeeds": "≻",
	"SucceedsEqual": "⪰",
	"SucceedsSlantEqual": "≽",
	"SucceedsTilde": "≿",
	"succeq": "⪰",
	"succnapprox": "⪺",
	"succneqq": "⪶",
	"succnsim": "⋩",
	"succsim": "≿",
	"SuchThat": "∋",
	"sum": "∑",
	"Sum": "∑",
	"sung": "♪",
	"sup1": "¹",
	"sup2": "²",
	"sup3": "³",
	"sup": "⊃",
	"Sup": "⋑",
	"supdot": "⪾",
	"supdsub": "⫘",
	"supE": "⫆",
	"supe": "⊇",
	"supedot": "⫄",
	"Superset": "⊃",
	"SupersetEqual": "⊇",
	"suphsol": "⟉",
	"suphsub": "⫗",
	"suplarr": "⥻",
	"supmult": "⫂",
	"supnE": "⫌",
	"supne": "⊋",
	"supplus": "⫀",
	"supset": "⊃",
	"Supset": "⋑",
	"supseteq": "⊇",
	"supseteqq": "⫆",
	"supsetneq": "⊋",
	"supsetneqq": "⫌",
	"supsim": "⫈",
	"supsub": "⫔",
	"supsup": "⫖",
	"swarhk": "⤦",
	"swarr": "↙",
	"swArr": "⇙",
	"swarrow": "↙",
	"swnwar": "⤪",
	"szlig": "ß",
	"Tab": "\t",
	"target": "⌖",
	"Tau": "Τ",
	"tau": "τ",
	"tbrk": "⎴",
	"Tcaron": "Ť",
	"tcaron": "ť",
	"Tcedil": "Ţ",
	"tcedil": "ţ",
	"Tcy": "Т",
	"tcy": "т",
	"tdot": "⃛",
	"telrec": "⌕",
	"Tfr": "𝔗",
	"tfr": "𝔱",
	"there4": "∴",
	"therefore": "∴",
	"Therefore": "∴",
	"Theta": "Θ",
	"theta": "θ",
	"thetasym": "ϑ",
	"thetav": "ϑ",
	"thickapprox": "≈",
	"thicksim": "∼",
	"ThickSpace": "  ",
	"ThinSpace": " ",
	"thinsp": " ",
	"thkap": "≈",
	"thksim": "∼",
	"THORN": "Þ",
	"thorn": "þ",
	"tilde": "˜",
	"Tilde": "∼",
	"TildeEqual": "≃",
	"TildeFullEqual": "≅",
	"TildeTilde": "≈",
	"timesbar": "⨱",
	"timesb": "⊠",
	"times": "×",
	"timesd": "⨰",
	"tint": "∭",
	"toea": "⤨",
	"topbot": "⌶",
	"topcir": "⫱",
	"top": "⊤",
	"Topf": "𝕋",
	"topf": "𝕥",
	"topfork": "⫚",
	"tosa": "⤩",
	"tprime": "‴",
	"trade": "™",
	"TRADE": "™",
	"triangle": "▵",
	"triangledown": "▿",
	"triangleleft": "◃",
	"trianglelefteq": "⊴",
	"triangleq": "≜",
	"triangleright": "▹",
	"trianglerighteq": "⊵",
	"tridot": "◬",
	"trie": "≜",
	"triminus": "⨺",
	"TripleDot": "⃛",
	"triplus": "⨹",
	"trisb": "⧍",
	"tritime": "⨻",
	"trpezium": "⏢",
	"Tscr": "𝒯",
	"tscr": "𝓉",
	"TScy": "Ц",
	"tscy": "ц",
	"TSHcy": "Ћ",
	"tshcy": "ћ",
	"Tstrok": "Ŧ",
	"tstrok": "ŧ",
	"twixt": "≬",
	"twoheadleftarrow": "↞",
	"twoheadrightarrow": "↠",
	"Uacute": "Ú",
	"uacute": "ú",
	"uarr": "↑",
	"Uarr": "↟",
	"uArr": "⇑",
	"Uarrocir": "⥉",
	"Ubrcy": "Ў",
	"ubrcy": "ў",
	"Ubreve": "Ŭ",
	"ubreve": "ŭ",
	"Ucirc": "Û",
	"ucirc": "û",
	"Ucy": "У",
	"ucy": "у",
	"udarr": "⇅",
	"Udblac": "Ű",
	"udblac": "ű",
	"udhar": "⥮",
	"ufisht": "⥾",
	"Ufr": "𝔘",
	"ufr": "𝔲",
	"Ugrave": "Ù",
	"ugrave": "ù",
	"uHar": "⥣",
	"uharl": "↿",
	"uharr": "↾",
	"uhblk": "▀",
	"ulcorn": "⌜",
	"ulcorner": "⌜",
	"ulcrop": "⌏",
	"ultri": "◸",
	"Umacr": "Ū",
	"umacr": "ū",
	"uml": "¨",
	"UnderBar": "_",
	"UnderBrace": "⏟",
	"UnderBracket": "⎵",
	"UnderParenthesis": "⏝",
	"Union": "⋃",
	"UnionPlus": "⊎",
	"Uogon": "Ų",
	"uogon": "ų",
	"Uopf": "𝕌",
	"uopf": "𝕦",
	"UpArrowBar": "⤒",
	"uparrow": "↑",
	"UpArrow": "↑",
	"Uparrow": "⇑",
	"UpArrowDownArrow": "⇅",
	"updownarrow": "↕",
	"UpDownArrow": "↕",
	"Updownarrow": "⇕",
	"UpEquilibrium": "⥮",
	"upharpoonleft": "↿",
	"upharpoonright": "↾",
	"uplus": "⊎",
	"UpperLeftArrow": "↖",
	"UpperRightArrow": "↗",
	"upsi": "υ",
	"Upsi": "ϒ",
	"upsih": "ϒ",
	"Upsilon": "Υ",
	"upsilon": "υ",
	"UpTeeArrow": "↥",
	"UpTee": "⊥",
	"upuparrows": "⇈",
	"urcorn": "⌝",
	"urcorner": "⌝",
	"urcrop": "⌎",
	"Uring": "Ů",
	"uring": "ů",
	"urtri": "◹",
	"Uscr": "𝒰",
	"uscr": "𝓊",
	"utdot": "⋰",
	"Utilde": "Ũ",
	"utilde": "ũ",
	"utri": "▵",
	"utrif": "▴",
	"uuarr": "⇈",
	"Uuml": "Ü",
	"uuml": "ü",
	"uwangle": "⦧",
	"vangrt": "⦜",
	"varepsilon": "ϵ",
	"varkappa": "ϰ",
	"varnothing": "∅",
	"varphi": "ϕ",
	"varpi": "ϖ",
	"varpropto": "∝",
	"varr": "↕",
	"vArr": "⇕",
	"varrho": "ϱ",
	"varsigma": "ς",
	"varsubsetneq": "⊊︀",
	"varsubsetneqq": "⫋︀",
	"varsupsetneq": "⊋︀",
	"varsupsetneqq": "⫌︀",
	"vartheta": "ϑ",
	"vartriangleleft": "⊲",
	"vartriangleright": "⊳",
	"vBar": "⫨",
	"Vbar": "⫫",
	"vBarv": "⫩",
	"Vcy": "В",
	"vcy": "в",
	"vdash": "⊢",
	"vDash": "⊨",
	"Vdash": "⊩",
	"VDash": "⊫",
	"Vdashl": "⫦",
	"veebar": "⊻",
	"vee": "∨",
	"Vee": "⋁",
	"veeeq": "≚",
	"vellip": "⋮",
	"verbar": "|",
	"Verbar": "‖",
	"vert": "|",
	"Vert": "‖",
	"VerticalBar": "∣",
	"VerticalLine": "|",
	"VerticalSeparator": "❘",
	"VerticalTilde": "≀",
	"VeryThinSpace": " ",
	"Vfr": "𝔙",
	"vfr": "𝔳",
	"vltri": "⊲",
	"vnsub": "⊂⃒",
	"vnsup": "⊃⃒",
	"Vopf": "𝕍",
	"vopf": "𝕧",
	"vprop": "∝",
	"vrtri": "⊳",
	"Vscr": "𝒱",
	"vscr": "𝓋",
	"vsubnE": "⫋︀",
	"vsubne": "⊊︀",
	"vsupnE": "⫌︀",
	"vsupne": "⊋︀",
	"Vvdash": "⊪",
	"vzigzag": "⦚",
	"Wcirc": "Ŵ",
	"wcirc": "ŵ",
	"wedbar": "⩟",
	"wedge": "∧",
	"Wedge": "⋀",
	"wedgeq": "≙",
	"weierp": "℘",
	"Wfr": "𝔚",
	"wfr": "𝔴",
	"Wopf": "𝕎",
	"wopf": "𝕨",
	"wp": "℘",
	"wr": "≀",
	"wreath": "≀",
	"Wscr": "𝒲",
	"wscr": "𝓌",
	"xcap": "⋂",
	"xcirc": "◯",
	"xcup": "⋃",
	"xdtri": "▽",
	"Xfr": "𝔛",
	"xfr": "𝔵",
	"xharr": "⟷",
	"xhArr": "⟺",
	"Xi": "Ξ",
	"xi": "ξ",
	"xlarr": "⟵",
	"xlArr": "⟸",
	"xmap": "⟼",
	"xnis": "⋻",
	"xodot": "⨀",
	"Xopf": "𝕏",
	"xopf": "𝕩",
	"xoplus": "⨁",
	"xotime": "⨂",
	"xrarr": "⟶",
	"xrArr": "⟹",
	"Xscr": "𝒳",
	"xscr": "𝓍",
	"xsqcup": "⨆",
	"xuplus": "⨄",
	"xutri": "△",
	"xvee": "⋁",
	"xwedge": "⋀",
	"Yacute": "Ý",
	"yacute": "ý",
	"YAcy": "Я",
	"yacy": "я",
	"Ycirc": "Ŷ",
	"ycirc": "ŷ",
	"Ycy": "Ы",
	"ycy": "ы",
	"yen": "¥",
	"Yfr": "𝔜",
	"yfr": "𝔶",
	"YIcy": "Ї",
	"yicy": "ї",
	"Yopf": "𝕐",
	"yopf": "𝕪",
	"Yscr": "𝒴",
	"yscr": "𝓎",
	"YUcy": "Ю",
	"yucy": "ю",
	"yuml": "ÿ",
	"Yuml": "Ÿ",
	"Zacute": "Ź",
	"zacute": "ź",
	"Zcaron": "Ž",
	"zcaron": "ž",
	"Zcy": "З",
	"zcy": "з",
	"Zdot": "Ż",
	"zdot": "ż",
	"zeetrf": "ℨ",
	"ZeroWidthSpace": "​",
	"Zeta": "Ζ",
	"zeta": "ζ",
	"zfr": "𝔷",
	"Zfr": "ℨ",
	"ZHcy": "Ж",
	"zhcy": "ж",
	"zigrarr": "⇝",
	"zopf": "𝕫",
	"Zopf": "ℤ",
	"Zscr": "𝒵",
	"zscr": "𝓏",
	"zwj": "‍",
	"zwnj": "‌"
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(92);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(17)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTA3Y2QyNDVmNjUwOWRjYWQxMDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWl0aHJpbC9taXRocmlsLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvY2VsbC5qcyIsIndlYnBhY2s6Ly8vLi4vbGlicy9jb21wb25lbnRzL3N0eWxlcy5jc3M/MmJhYyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3Rva2VuLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2VudHJ5LmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvZWRpdG9yLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvcHJldmlldy5qcyIsIndlYnBhY2s6Ly8vLi4vbGlicy9jb21wb25lbnRzL3NhdmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvY29tcG9uZW50cy9zbHVnLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvdGFncy5qcyIsIndlYnBhY2s6Ly8vLi4vbGlicy9jb21wb25lbnRzL3RpdGxlLmpzIiwid2VicGFjazovLy8uLi9saWJzL21vZGVscy9hcnRpY2xlLmpzIiwid2VicGFjazovLy8uLi9saWJzL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2xpbmtpZnktaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2xpYi9yZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9ibG9jay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9saW5rLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3N0eWxlLWxvYWRlci9maXhVcmxzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvY29tcG9uZW50cy9zdHlsZXMuY3NzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uIiwid2VicGFjazovLy8uL3N0eWxlcy5jc3M/YTgxMyJdLCJuYW1lcyI6WyJfY2xhc3MiLCJvYmoiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1N0cmluZyIsIl9oYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiaGFzIiwib2JqZWN0Iiwia2V5IiwiYXNzaWduIiwic291cmNlcyIsIkFycmF5Iiwic2xpY2UiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwic291cmNlIiwiVHlwZUVycm9yIiwia2V5cyIsImFycmF5UmVwbGFjZUF0Iiwic3JjIiwicG9zIiwibmV3RWxlbWVudHMiLCJjb25jYXQiLCJpc1ZhbGlkRW50aXR5Q29kZSIsImMiLCJmcm9tQ29kZVBvaW50Iiwic3Vycm9nYXRlMSIsInN1cnJvZ2F0ZTIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVTkVTQ0FQRV9NRF9SRSIsIkVOVElUWV9SRSIsIlVORVNDQVBFX0FMTF9SRSIsIlJlZ0V4cCIsIkRJR0lUQUxfRU5USVRZX1RFU1RfUkUiLCJlbnRpdGllcyIsInJlcXVpcmUiLCJyZXBsYWNlRW50aXR5UGF0dGVybiIsIm1hdGNoIiwibmFtZSIsImNvZGUiLCJjaGFyQ29kZUF0IiwidGVzdCIsInRvTG93ZXJDYXNlIiwicGFyc2VJbnQiLCJ1bmVzY2FwZU1kIiwic3RyIiwiaW5kZXhPZiIsInJlcGxhY2UiLCJ1bmVzY2FwZUFsbCIsImVzY2FwZWQiLCJlbnRpdHkiLCJIVE1MX0VTQ0FQRV9URVNUX1JFIiwiSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSIsIkhUTUxfUkVQTEFDRU1FTlRTIiwicmVwbGFjZVVuc2FmZUNoYXIiLCJjaCIsImVzY2FwZUh0bWwiLCJSRUdFWFBfRVNDQVBFX1JFIiwiZXNjYXBlUkUiLCJpc1NwYWNlIiwiaXNXaGl0ZVNwYWNlIiwiVU5JQ09ERV9QVU5DVF9SRSIsImlzUHVuY3RDaGFyIiwiaXNNZEFzY2lpUHVuY3QiLCJub3JtYWxpemVSZWZlcmVuY2UiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJleHBvcnRzIiwibGliIiwibWR1cmwiLCJ1Y21pY3JvIiwiVm5vZGUiLCJ0YWciLCJhdHRyczAiLCJjaGlsZHJlbiIsInRleHQiLCJkb20iLCJhdHRycyIsImRvbVNpemUiLCJ1bmRlZmluZWQiLCJzdGF0ZSIsIl9zdGF0ZSIsImV2ZW50cyIsImluc3RhbmNlIiwic2tpcCIsIm5vcm1hbGl6ZSIsIm5vZGUiLCJpc0FycmF5Iiwibm9ybWFsaXplQ2hpbGRyZW4iLCJpIiwibGVuZ3RoIiwic2VsZWN0b3JQYXJzZXIiLCJzZWxlY3RvckNhY2hlIiwiaGFzT3duIiwiY29tcGlsZVNlbGVjdG9yIiwic2VsZWN0b3IiLCJjbGFzc2VzIiwiZXhlYyIsInR5cGUiLCJ2YWx1ZSIsImlkIiwicHVzaCIsImF0dHJWYWx1ZSIsImNsYXNzTmFtZSIsImpvaW4iLCJleGVjU2VsZWN0b3IiLCJoYXNBdHRycyIsImNoaWxkTGlzdCIsImNsYXNzIiwiaHlwZXJzY3JpcHQiLCJzdGFydCIsInZpZXciLCJFcnJvciIsImNhY2hlZCIsIm5vcm1hbGl6ZWQiLCJ0cnVzdCIsImh0bWwiLCJmcmFnbWVudCIsImF0dHJzMSIsIm0iLCJQcm9taXNlUG9seWZpbGwiLCJleGVjdXRvciIsInNlbGYiLCJyZXNvbHZlcnMiLCJyZWplY3RvcnMiLCJyZXNvbHZlQ3VycmVudCIsImhhbmRsZXIiLCJyZWplY3RDdXJyZW50IiwiX2luc3RhbmNlIiwiY2FsbEFzeW5jIiwic2V0SW1tZWRpYXRlIiwic2V0VGltZW91dCIsImxpc3QiLCJzaG91bGRBYnNvcmIiLCJleGVjdXRlIiwidGhlbiIsImV4ZWN1dGVPbmNlIiwiYmluZCIsImNvbnNvbGUiLCJlcnJvciIsInJldHJ5IiwiZSIsInJ1bnMiLCJydW4iLCJmbiIsIm9uZXJyb3IiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0aW9uIiwiaGFuZGxlIiwiY2FsbGJhY2siLCJuZXh0IiwicmVzb2x2ZU5leHQiLCJyZWplY3ROZXh0IiwicHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYXRjaCIsImFsbCIsInRvdGFsIiwiY291bnQiLCJ2YWx1ZXMiLCJjb25zdW1lIiwicmFjZSIsIndpbmRvdyIsIlByb21pc2UiLCJnbG9iYWwiLCJidWlsZFF1ZXJ5U3RyaW5nIiwiYXJncyIsImtleTAiLCJkZXN0cnVjdHVyZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkZJTEVfUFJPVE9DT0xfUkVHRVgiLCJfOCIsIiR3aW5kb3ciLCJjYWxsYmFja0NvdW50Iiwib25jb21wbGV0aW9uIiwic2V0Q29tcGxldGlvbkNhbGxiYWNrIiwiZmluYWxpemVyIiwiY29tcGxldGUiLCJmaW5hbGl6ZSIsInByb21pc2UwIiwidGhlbjAiLCJhcHBseSIsImV4dHJhIiwidXJsIiwicmVxdWVzdCIsIm1ldGhvZCIsInVzZUJvZHkiLCJzZXJpYWxpemUiLCJGb3JtRGF0YSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzZXJpYWxpemUiLCJleHRyYWN0IiwiaW50ZXJwb2xhdGUiLCJhc3NlbWJsZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiYWJvcnRlZCIsIl9hYm9ydCIsImFib3J0Iiwib3BlbiIsImFzeW5jIiwidXNlciIsInBhc3N3b3JkIiwic2V0UmVxdWVzdEhlYWRlciIsIndpdGhDcmVkZW50aWFscyIsImhlYWRlcnMiLCJjb25maWciLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJjYXN0IiwicmVzcG9uc2VUZXh0Iiwic2VuZCIsImJhY2tncm91bmQiLCJqc29ucCIsImNhbGxiYWNrTmFtZSIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsInNjcmlwdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNhbGxiYWNrS2V5IiwiZG9jdW1lbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJ0b2tlbnMiLCJxdWVyeXN0cmluZyIsInByZWZpeCIsInBhcnNlIiwidHlwZTAiLCJyZXF1ZXN0U2VydmljZSIsImNvcmVSZW5kZXJlciIsIiRkb2MiLCIkZW1wdHlGcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJvbmV2ZW50Iiwic2V0RXZlbnRDYWxsYmFjayIsImNyZWF0ZU5vZGVzIiwicGFyZW50Iiwidm5vZGVzIiwiZW5kIiwiaG9va3MiLCJuZXh0U2libGluZyIsIm5zIiwidm5vZGUiLCJjcmVhdGVOb2RlIiwiaW5pdExpZmVjeWNsZSIsImNyZWF0ZVRleHQiLCJjcmVhdGVIVE1MIiwiY3JlYXRlRnJhZ21lbnQiLCJjcmVhdGVDb21wb25lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImluc2VydE5vZGUiLCJtYXRjaDEiLCJwYXJlbnQxIiwiY2FwdGlvbiIsInRoZWFkIiwidGJvZHkiLCJ0Zm9vdCIsInRyIiwidGgiLCJ0ZCIsImNvbGdyb3VwIiwiY29sIiwidGVtcCIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwiY2hpbGQiLCJhdHRyczIiLCJpcyIsImVsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJzZXRBdHRycyIsImNvbnRlbnRlZGl0YWJsZSIsInNldENvbnRlbnRFZGl0YWJsZSIsInRleHRDb250ZW50Iiwic2V0TGF0ZUF0dHJzIiwiaW5pdENvbXBvbmVudCIsInNlbnRpbmVsIiwiY3JlYXRlIiwiJCRyZWVudHJhbnRMb2NrJCQiLCJ1cGRhdGVOb2RlcyIsIm9sZCIsInJlY3ljbGluZyIsInJlbW92ZU5vZGVzIiwiaXNVbmtleWVkIiwiZ2V0TmV4dFNpYmxpbmciLCJ1cGRhdGVOb2RlIiwiaXNSZWN5Y2xhYmxlIiwicG9vbCIsIm9sZFN0YXJ0Iiwib2xkRW5kIiwibWFwIiwibyIsInYiLCJzaG91bGRSZWN5Y2xlIiwidG9GcmFnbWVudCIsImdldEtleU1hcCIsIm9sZEluZGV4IiwibW92YWJsZSIsIm9sZFRhZyIsInNob3VsZE5vdFVwZGF0ZSIsInVwZGF0ZUxpZmVjeWNsZSIsInVwZGF0ZVRleHQiLCJ1cGRhdGVIVE1MIiwidXBkYXRlRnJhZ21lbnQiLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlQ29tcG9uZW50IiwicmVtb3ZlTm9kZSIsIm5vZGVWYWx1ZSIsInVwZGF0ZUF0dHJzIiwiYWJzIiwib2xkQ2hpbGRyZW5MZW5ndGgiLCJwb29sQ2hpbGRyZW5MZW5ndGgiLCJ2bm9kZXNDaGlsZHJlbkxlbmd0aCIsImtleTIiLCJjb3VudDAiLCJpbnNlcnRCZWZvcmUiLCJjb250ZW50IiwiY29udGV4dCIsImV4cGVjdGVkIiwiY2FsbGVkIiwib25iZWZvcmVyZW1vdmUiLCJyZXN1bHQiLCJjb250aW51YXRpb24iLCJvbnJlbW92ZSIsInJlbW92ZU5vZGVGcm9tRE9NIiwiaGFzSW50ZWdyYXRpb25NZXRob2RzIiwic2V0QXR0ciIsImlzRm9ybUF0dHJpYnV0ZSIsImlzTGlmZWN5Y2xlTWV0aG9kIiwibnNMYXN0SW5kZXgiLCJzdWJzdHIiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUV2ZW50IiwidXBkYXRlU3R5bGUiLCJpc0F0dHJpYnV0ZSIsImlzQ3VzdG9tRWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZWxlY3RlZEluZGV4IiwiYXR0ciIsIm9uY3JlYXRlIiwib251cGRhdGUiLCJzdHlsZSIsImNzc1RleHQiLCJldmVudE5hbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uaW5pdCIsImZvcmNlVm5vZGVVcGRhdGUiLCJmb3JjZUNvbXBvbmVudFVwZGF0ZSIsIm9uYmVmb3JldXBkYXRlIiwicmVuZGVyIiwiYWN0aXZlIiwiZm9jdXMiLCJ0aHJvdHRsZSIsInRpbWUiLCJsYXN0IiwicGVuZGluZyIsInRpbWVvdXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJub3ciLCJEYXRlIiwiXzExIiwicmVuZGVyU2VydmljZSIsInJlZHJhdyIsImNhbGxiYWNrcyIsInN1YnNjcmliZSIsImtleTEiLCJ1bnN1YnNjcmliZSIsImluZGV4Iiwic3BsaWNlIiwicmVkcmF3U2VydmljZSIsIl8xNiIsInJlZHJhd1NlcnZpY2UwIiwicm9vdCIsImNvbXBvbmVudCIsInJ1bjAiLCJtb3VudCIsInBhcnNlUXVlcnlTdHJpbmciLCJzdHJpbmciLCJjaGFyQXQiLCJlbnRyaWVzIiwic3BsaXQiLCJkYXRhMCIsImNvdW50ZXJzIiwiZW50cnkiLCJrZXk1IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwibGV2ZWxzIiwiY3Vyc29yIiwicG9wIiwiaiIsImxldmVsIiwibmV4dExldmVsIiwiaXNOdW1iZXIiLCJpc05hTiIsImlzVmFsdWUiLCJjb3JlUm91dGVyIiwic3VwcG9ydHNQdXNoU3RhdGUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiY2FsbEFzeW5jMCIsIm5vcm1hbGl6ZTEiLCJmcmFnbWVudDAiLCJsb2NhdGlvbiIsImFzeW5jSWQiLCJkZWJvdW5jZUFzeW5jIiwiY2FsbGJhY2swIiwicGFyc2VQYXRoIiwicGF0aCIsInF1ZXJ5RGF0YSIsImhhc2hEYXRhIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsInBhdGhFbmQiLCJxdWVyeUVuZCIsInF1ZXJ5UGFyYW1zIiwia2V5NCIsImhhc2hQYXJhbXMiLCJyb3V0ZXIiLCJnZXRQYXRoIiwidHlwZTIiLCJzZXRQYXRoIiwib3B0aW9ucyIsIm1hdGNoMiIsInRva2VuIiwicXVlcnkiLCJoYXNoIiwidGl0bGUiLCJvbnBvcHN0YXRlIiwicmVwbGFjZVN0YXRlIiwiaHJlZiIsImRlZmluZVJvdXRlcyIsInJvdXRlcyIsInJlc29sdmVSb3V0ZSIsInBhcmFtcyIsInBhdGhuYW1lIiwiayIsInJvdXRlMCIsIm1hdGNoZXIiLCJvbmhhc2hjaGFuZ2UiLCJfMjAiLCJyb3V0ZVNlcnZpY2UiLCJpZGVudGl0eSIsInJlbmRlcjEiLCJhdHRyczMiLCJjdXJyZW50UGF0aCIsImxhc3RVcGRhdGUiLCJyb3V0ZSIsImRlZmF1bHRSb3V0ZSIsInJ1bjEiLCJiYWlsIiwicGF5bG9hZCIsInVwZGF0ZSIsInJvdXRlUmVzb2x2ZXIiLCJjb21wIiwib25tYXRjaCIsInJlc29sdmVkIiwic2V0IiwiZ2V0IiwicHJlZml4MCIsImxpbmsiLCJ2bm9kZTEiLCJvbmNsaWNrIiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsIndoaWNoIiwicHJldmVudERlZmF1bHQiLCJnZXRBdHRyaWJ1dGUiLCJwYXJhbSIsImtleTMiLCJ3aXRoQXR0ciIsImF0dHJOYW1lIiwiY2FsbGJhY2sxIiwiY3VycmVudFRhcmdldCIsIl8yOCIsInZlcnNpb24iLCJtb2R1bGUiLCJzcGFuIiwiY2xzIiwiaW5uZXIiLCJnIiwiRnVuY3Rpb24iLCJldmFsIiwiUnVsZXIiLCJfX3J1bGVzX18iLCJfX2NhY2hlX18iLCJfX2ZpbmRfXyIsIl9fY29tcGlsZV9fIiwiY2hhaW5zIiwicnVsZSIsImVuYWJsZWQiLCJhbHQiLCJhbHROYW1lIiwiY2hhaW4iLCJhdCIsIm9wdCIsImJlZm9yZSIsImJlZm9yZU5hbWUiLCJydWxlTmFtZSIsImFmdGVyIiwiYWZ0ZXJOYW1lIiwiZW5hYmxlIiwiaWdub3JlSW52YWxpZCIsImlkeCIsImVuYWJsZU9ubHkiLCJkaXNhYmxlIiwiZ2V0UnVsZXMiLCJjaGFpbk5hbWUiLCJUb2tlbiIsIm5lc3RpbmciLCJtYXJrdXAiLCJpbmZvIiwibWV0YSIsImJsb2NrIiwiaGlkZGVuIiwiYXR0ckluZGV4IiwibGVuIiwiYXR0clB1c2giLCJhdHRyRGF0YSIsImF0dHJTZXQiLCJhdHRyR2V0IiwiYXR0ckpvaW4iLCJ1c2VTb3VyY2VNYXAiLCJpdGVtIiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImNzc01hcHBpbmciLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJCdWZmZXIiLCJhdHRyX25hbWUiLCJ1bnF1b3RlZCIsInNpbmdsZV9xdW90ZWQiLCJkb3VibGVfcXVvdGVkIiwiYXR0cl92YWx1ZSIsImF0dHJpYnV0ZSIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwiY29tbWVudCIsInByb2Nlc3NpbmciLCJkZWNsYXJhdGlvbiIsImNkYXRhIiwiSFRNTF9UQUdfUkUiLCJIVE1MX09QRU5fQ0xPU0VfVEFHX1JFIiwidG9rZW5pemUiLCJlbXBoYXNpcyIsInNpbGVudCIsInNjYW5uZWQiLCJtYXJrZXIiLCJzY2FuRGVsaW1zIiwiZGVsaW1pdGVycyIsImp1bXAiLCJjYW5fb3BlbiIsImNsb3NlIiwiY2FuX2Nsb3NlIiwicG9zdFByb2Nlc3MiLCJzdGFydERlbGltIiwiZW5kRGVsaW0iLCJpc1N0cm9uZyIsIm1heCIsInN0cmlrZXRocm91Z2giLCJsb25lTWFya2VycyIsImVuY29kZSIsImRlY29kZSIsImZvcm1hdCIsIm1vZGVsIiwiZmV0Y2giLCJmZXRjaGVkIiwiZWRpdG9yV3JhcCIsIm1kQm9keSIsImdldEVsZW1lbnRCeUlkIiwib25pbnB1dCIsImJvZHkiLCJ0ZXh0YXJlYSIsImVkaXRvciIsImVkaXRvckxlZnRTaWRlIiwiZWRpdG9yUmlnaHRTaWRlIiwic2F2ZUJ1dHRvbiIsIm9uY2hhbmdlIiwic2x1ZyIsInRhZ3MiLCJtZCIsIk1vZGVsIiwicHVibGlzaCIsImRhdGUiLCJyZXNvdXJjZXNVcmwiLCJyZXNvdXJjZVVybCIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJVaW50OEFycmF5IiwicGxhY2VIb2xkZXJzQ291bnQiLCJiNjQiLCJsIiwidG1wIiwicGxhY2VIb2xkZXJzIiwiYXJyIiwiTCIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJvdXRwdXQiLCJleHRyYUJ5dGVzIiwicGFydHMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsIl9fcHJvdG9fXyIsImZvbyIsInN1YmFycmF5IiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsIlJhbmdlRXJyb3IiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJmcm9tIiwicG9vbFNpemUiLCJfYXVnbWVudCIsIkFycmF5QnVmZmVyIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJTeW1ib2wiLCJzcGVjaWVzIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJhc3NlcnRTaXplIiwic2l6ZSIsImFsbG9jIiwiZmlsbCIsImVuY29kaW5nIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJ3cml0ZSIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImJ5dGVPZmZzZXQiLCJpc0J1ZmZlciIsImNvcHkiLCJidWZmZXIiLCJpc25hbiIsImIiLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwiYSIsIngiLCJ5IiwibWluIiwiYnVmIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsIm4iLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJlcXVhbHMiLCJpbnNwZWN0IiwidGFyZ2V0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwidmFsIiwiZGlyIiwiYXJyYXlJbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIm9mZnNldCIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsInJldCIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4IiwiZmxvb3IiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJkc3QiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsImQiLCJzIiwiTmFOIiwicnQiLCJsb2ciLCJMTjIiLCJpc09iamVjdCIsImlzUmVnRXhwIiwiaXNGdW5jdGlvbiIsImRlZmF1bHRPcHRpb25zIiwiZnV6enlMaW5rIiwiZnV6enlFbWFpbCIsImZ1enp5SVAiLCJpc09wdGlvbnNPYmoiLCJyZWR1Y2UiLCJhY2MiLCJkZWZhdWx0U2NoZW1hcyIsInZhbGlkYXRlIiwidGFpbCIsInJlIiwiaHR0cCIsInNyY19hdXRoIiwic3JjX2hvc3RfcG9ydF9zdHJpY3QiLCJzcmNfcGF0aCIsIm5vX2h0dHAiLCJzcmNfZG9tYWluIiwic3JjX2RvbWFpbl9yb290Iiwic3JjX3BvcnQiLCJzcmNfaG9zdF90ZXJtaW5hdG9yIiwibWFpbHRvIiwic3JjX2VtYWlsX25hbWUiLCJzcmNfaG9zdF9zdHJpY3QiLCJ0bGRzXzJjaF9zcmNfcmUiLCJ0bGRzX2RlZmF1bHQiLCJyZXNldFNjYW5DYWNoZSIsIl9faW5kZXhfXyIsIl9fdGV4dF9jYWNoZV9fIiwiY3JlYXRlVmFsaWRhdG9yIiwiY3JlYXRlTm9ybWFsaXplciIsImNvbXBpbGUiLCJfX29wdHNfXyIsInRsZHMiLCJfX3RsZHNfXyIsIm9uQ29tcGlsZSIsIl9fdGxkc19yZXBsYWNlZF9fIiwic3JjX3huIiwic3JjX3RsZHMiLCJ1bnRwbCIsInRwbCIsImVtYWlsX2Z1enp5IiwidHBsX2VtYWlsX2Z1enp5IiwibGlua19mdXp6eSIsInRwbF9saW5rX2Z1enp5IiwibGlua19ub19pcF9mdXp6eSIsInRwbF9saW5rX25vX2lwX2Z1enp5IiwiaG9zdF9mdXp6eV90ZXN0IiwidHBsX2hvc3RfZnV6enlfdGVzdCIsImFsaWFzZXMiLCJfX2NvbXBpbGVkX18iLCJzY2hlbWFFcnJvciIsIl9fc2NoZW1hc19fIiwiY29tcGlsZWQiLCJhbGlhcyIsInNsaXN0IiwiZmlsdGVyIiwic2NoZW1hX3Rlc3QiLCJzcmNfWlBDYyIsInNjaGVtYV9zZWFyY2giLCJwcmV0ZXN0IiwiTWF0Y2giLCJzaGlmdCIsIl9fbGFzdF9pbmRleF9fIiwic2NoZW1hIiwiX19zY2hlbWFfXyIsImxhc3RJbmRleCIsInJhdyIsImNyZWF0ZU1hdGNoIiwiTGlua2lmeUl0Iiwic2NoZW1hcyIsImFkZCIsImRlZmluaXRpb24iLCJtbCIsIm1lIiwidGxkX3BvcyIsImF0X3BvcyIsInRlc3RTY2hlbWFBdCIsInNlYXJjaCIsImtlZXBPbGQiLCJzb3J0IiwiZWwiLCJyZXZlcnNlIiwib3B0cyIsInNyY19BbnkiLCJzcmNfQ2MiLCJzcmNfWiIsInNyY19QIiwic3JjX1pDYyIsInRleHRfc2VwYXJhdG9ycyIsInNyY19wc2V1ZG9fbGV0dGVyIiwic3JjX2lwNCIsInNyY19ob3N0IiwidHBsX2hvc3RfZnV6enkiLCJ0cGxfaG9zdF9ub19pcF9mdXp6eSIsInRwbF9ob3N0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QiLCJwYXJzZUxpbmtMYWJlbCIsInBhcnNlTGlua0Rlc3RpbmF0aW9uIiwicGFyc2VMaW5rVGl0bGUiLCJsaW5lcyIsIm9rIiwiZGlzYWJsZU5lc3RlZCIsInByZXZQb3MiLCJsYWJlbEVuZCIsInBvc01heCIsIm9sZFBvcyIsImlubGluZSIsInNraXBUb2tlbiIsInV0aWxzIiwiaGVscGVycyIsIlJlbmRlcmVyIiwiUGFyc2VyQ29yZSIsIlBhcnNlckJsb2NrIiwiUGFyc2VySW5saW5lIiwicHVueWNvZGUiLCJ6ZXJvIiwiY29tbW9ubWFyayIsIkJBRF9QUk9UT19SRSIsIkdPT0RfREFUQV9SRSIsInZhbGlkYXRlTGluayIsIlJFQ09ERV9IT1NUTkFNRV9GT1IiLCJub3JtYWxpemVMaW5rIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInRvQVNDSUkiLCJlciIsIm5vcm1hbGl6ZUxpbmtUZXh0IiwidG9Vbmljb2RlIiwiTWFya2Rvd25JdCIsInByZXNldE5hbWUiLCJjb3JlIiwicmVuZGVyZXIiLCJsaW5raWZ5IiwiY29uZmlndXJlIiwicHJlc2V0cyIsImNvbXBvbmVudHMiLCJydWxlcyIsInJ1bGVyIiwicnVsZXMyIiwicnVsZXIyIiwibWlzc2VkIiwidXNlIiwicGx1Z2luIiwiZW52IiwiU3RhdGUiLCJwcm9jZXNzIiwicGFyc2VJbmxpbmUiLCJpbmxpbmVNb2RlIiwicmVuZGVySW5saW5lIiwiX3J1bGVzIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsImxpbmUiLCJoYXNFbXB0eUxpbmVzIiwibWF4TmVzdGluZyIsInNraXBFbXB0eUxpbmVzIiwic0NvdW50IiwiYmxrSW5kZW50IiwidGlnaHQiLCJpc0VtcHR5Iiwib3V0VG9rZW5zIiwibGluZU1heCIsIkNvcmUiLCJfcnVsZXMyIiwiY2FjaGUiLCJwdXNoUGVuZGluZyIsInhodG1sT3V0IiwiYnJlYWtzIiwibGFuZ1ByZWZpeCIsInR5cG9ncmFwaGVyIiwicXVvdGVzIiwiaGlnaGxpZ2h0IiwiZGVmYXVsdF9ydWxlcyIsImNvZGVfaW5saW5lIiwic2xmIiwicmVuZGVyQXR0cnMiLCJjb2RlX2Jsb2NrIiwiZmVuY2UiLCJsYW5nTmFtZSIsImhpZ2hsaWdodGVkIiwidG1wQXR0cnMiLCJ0bXBUb2tlbiIsImltYWdlIiwicmVuZGVySW5saW5lQXNUZXh0IiwicmVuZGVyVG9rZW4iLCJoYXJkYnJlYWsiLCJzb2Z0YnJlYWsiLCJodG1sX2Jsb2NrIiwiaHRtbF9pbmxpbmUiLCJuZXh0VG9rZW4iLCJuZWVkTGYiLCJibG9ja3F1b3RlIiwiYWRqdXN0VGFiIiwiaW5pdGlhbCIsImlzT3V0ZGVudGVkIiwibGFzdExpbmVFbXB0eSIsIm5leHRMaW5lIiwib2xkQk1hcmtzIiwib2xkQlNDb3VudCIsIm9sZEluZGVudCIsIm9sZFBhcmVudFR5cGUiLCJvbGRTQ291bnQiLCJvbGRUU2hpZnQiLCJzcGFjZUFmdGVyTWFya2VyIiwidGVybWluYXRlIiwidGVybWluYXRvclJ1bGVzIiwib2xkTGluZU1heCIsImJNYXJrcyIsInRTaGlmdCIsImVNYXJrcyIsImJzQ291bnQiLCJwYXJlbnRUeXBlIiwiZ2V0TGluZXMiLCJtZW0iLCJoYXZlRW5kTWFya2VyIiwic2tpcENoYXJzIiwic2tpcFNwYWNlcyIsImhlYWRpbmciLCJza2lwU3BhY2VzQmFjayIsInNraXBDaGFyc0JhY2siLCJociIsImNudCIsImJsb2NrX25hbWVzIiwiSFRNTF9TRVFVRU5DRVMiLCJsaW5lVGV4dCIsImxoZWFkaW5nIiwic2tpcEJ1bGxldExpc3RNYXJrZXIiLCJza2lwT3JkZXJlZExpc3RNYXJrZXIiLCJtYXJrVGlnaHRQYXJhZ3JhcGhzIiwiY29udGVudFN0YXJ0IiwiaW5kZW50IiwiaW5kZW50QWZ0ZXJNYXJrZXIiLCJpc09yZGVyZWQiLCJpdGVtTGluZXMiLCJsaXN0TGluZXMiLCJsaXN0VG9rSWR4IiwibWFya2VyQ2hhckNvZGUiLCJtYXJrZXJWYWx1ZSIsIm9sZExJbmRlbnQiLCJvbGRUaWdodCIsInBvc0FmdGVyTWFya2VyIiwicHJldkVtcHR5RW5kIiwiaXNUZXJtaW5hdGluZ1BhcmFncmFwaCIsInBhcmFncmFwaCIsInJlZmVyZW5jZSIsIl9lbmRMaW5lIiwiZGVzdEVuZFBvcyIsImRlc3RFbmRMaW5lTm8iLCJsYWJlbCIsInJlZmVyZW5jZXMiLCJTdGF0ZUJsb2NrIiwiaW5kZW50X2ZvdW5kIiwiZGRJbmRlbnQiLCJiZWdpbiIsImtlZXBMYXN0TEYiLCJsaW5lSW5kZW50IiwiZmlyc3QiLCJxdWV1ZSIsImxpbmVTdGFydCIsImdldExpbmUiLCJlc2NhcGVkU3BsaXQiLCJlc2NhcGVzIiwibGFzdFBvcyIsImJhY2tUaWNrZWQiLCJsYXN0QmFja1RpY2siLCJzdWJzdHJpbmciLCJ0YWJsZSIsImNvbHVtbnMiLCJjb2x1bW5Db3VudCIsImFsaWducyIsInQiLCJ0YWJsZUxpbmVzIiwidGJvZHlMaW5lcyIsInRvayIsImlzTGlua09wZW4iLCJpc0xpbmtDbG9zZSIsImN1cnJlbnRUb2tlbiIsIm5vZGVzIiwibG4iLCJodG1sTGlua0xldmVsIiwiZnVsbFVybCIsInVybFRleHQiLCJibG9ja1Rva2VucyIsImxpbmtzIiwiTkVXTElORVNfUkUiLCJOVUxMX1JFIiwiUkFSRV9SRSIsIlNDT1BFRF9BQkJSX1RFU1RfUkUiLCJTQ09QRURfQUJCUl9SRSIsIlNDT1BFRF9BQkJSIiwiciIsInAiLCJ0bSIsInJlcGxhY2VGbiIsInJlcGxhY2Vfc2NvcGVkIiwiaW5saW5lVG9rZW5zIiwiaW5zaWRlX2F1dG9saW5rIiwicmVwbGFjZV9yYXJlIiwiYmxrSWR4IiwiUVVPVEVfVEVTVF9SRSIsIlFVT1RFX1JFIiwiQVBPU1RST1BIRSIsInJlcGxhY2VBdCIsInByb2Nlc3NfaW5saW5lcyIsInRoaXNMZXZlbCIsImxhc3RDaGFyIiwibmV4dENoYXIiLCJpc0xhc3RQdW5jdENoYXIiLCJpc05leHRQdW5jdENoYXIiLCJpc0xhc3RXaGl0ZVNwYWNlIiwiaXNOZXh0V2hpdGVTcGFjZSIsImNhbk9wZW4iLCJjYW5DbG9zZSIsImlzU2luZ2xlIiwic3RhY2siLCJvcGVuUXVvdGUiLCJjbG9zZVF1b3RlIiwiT1VURVIiLCJzaW5nbGUiLCJzbWFydHF1b3RlcyIsIlN0YXRlQ29yZSIsIkVNQUlMX1JFIiwiQVVUT0xJTktfUkUiLCJhdXRvbGluayIsImxpbmtNYXRjaCIsImVtYWlsTWF0Y2giLCJiYWNrdGljayIsIm1hdGNoU3RhcnQiLCJtYXRjaEVuZCIsImxpbmtfcGFpcnMiLCJsYXN0RGVsaW0iLCJjdXJyRGVsaW0iLCJvZGRfbWF0Y2giLCJESUdJVEFMX1JFIiwiTkFNRURfUkUiLCJFU0NBUEVEIiwiZXNjYXBlIiwiaXNMZXR0ZXIiLCJsYyIsImxhYmVsU3RhcnQiLCJyZWYiLCJwYXJzZVJlZmVyZW5jZSIsIm5ld2xpbmUiLCJwbWF4IiwiU3RhdGVJbmxpbmUiLCJwZW5kaW5nTGV2ZWwiLCJjYW5TcGxpdFdvcmQiLCJsZWZ0X2ZsYW5raW5nIiwicmlnaHRfZmxhbmtpbmciLCJpc1Rlcm1pbmF0b3JDaGFyIiwidGV4dF9jb2xsYXBzZSIsImN1cnIiLCJkZWNvZGVDYWNoZSIsImdldERlY29kZUNhY2hlIiwiZXhjbHVkZSIsImRlZmF1bHRDaGFycyIsInNlcSIsImIxIiwiYjIiLCJiMyIsImI0IiwiY2hyIiwiY29tcG9uZW50Q2hhcnMiLCJlbmNvZGVDYWNoZSIsImdldEVuY29kZUNhY2hlIiwia2VlcEVzY2FwZWQiLCJuZXh0Q29kZSIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsIlVybCIsInByb3RvY29sUGF0dGVybiIsInBvcnRQYXR0ZXJuIiwic2ltcGxlUGF0aFBhdHRlcm4iLCJkZWxpbXMiLCJ1bndpc2UiLCJhdXRvRXNjYXBlIiwibm9uSG9zdENoYXJzIiwiaG9zdEVuZGluZ0NoYXJzIiwiaG9zdG5hbWVNYXhMZW4iLCJob3N0bmFtZVBhcnRQYXR0ZXJuIiwiaG9zdG5hbWVQYXJ0U3RhcnQiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwidXJsUGFyc2UiLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJsb3dlclByb3RvIiwiaGVjIiwicmVzdCIsInNpbXBsZVBhdGgiLCJwcm90byIsImhvc3RFbmQiLCJhdFNpZ24iLCJob3N0IiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsInVuc2hpZnQiLCJxbSIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwibmV4dFRpY2siLCJJdGVtIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlR2xvYmFsIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZGVsaW1pdGVyIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJlcnJvcnMiLCJiYXNlTWludXNUTWluIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJjb3VudGVyIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsInciLCJiYXNlTWludXNUIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwiZGVmaW5lIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJkb2MiLCJyZWdpc3RlckltbWVkaWF0ZSIsInRhc2siLCJjbGVhckltbWVkaWF0ZSIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiZXZlbnQiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3J0MiIsImluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24iLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJnZXRQcm90b3R5cGVPZiIsImNzcyIsImJhc2VVcmwiLCJjdXJyZW50RGlyIiwiZml4ZWRDc3MiLCJmdWxsTWF0Y2giLCJvcmlnVXJsIiwidW5xdW90ZWRPcmlnVXJsIiwiJDEiLCJuZXdVcmwiLCJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwiQW55IiwiQ2MiLCJDZiIsIlAiLCJaIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7OztBQzlrRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGEwN2NkMjQ1ZjY1MDlkY2FkMTAxIiwiLy8gVXRpbGl0aWVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbn1cblxuLy8gTWVyZ2Ugb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLy8gUmVtb3ZlIGVsZW1lbnQgZnJvbSBhcnJheSBhbmQgcHV0IGFub3RoZXIgYXJyYXkgYXQgdGhvc2UgcG9zaXRpb24uXG4vLyBVc2VmdWwgZm9yIHNvbWUgb3BlcmF0aW9ucyB3aXRoIHRva2Vuc1xuZnVuY3Rpb24gYXJyYXlSZXBsYWNlQXQoc3JjLCBwb3MsIG5ld0VsZW1lbnRzKSB7XG4gIHJldHVybiBbXS5jb25jYXQoc3JjLnNsaWNlKDAsIHBvcyksIG5ld0VsZW1lbnRzLCBzcmMuc2xpY2UocG9zICsgMSkpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRW50aXR5Q29kZShjKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIC8vIGJyb2tlbiBzZXF1ZW5jZVxuICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIC8vIG5ldmVyIHVzZWRcbiAgaWYgKGMgPj0gMHhGREQwICYmIGMgPD0gMHhGREVGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoKGMgJiAweEZGRkYpID09PSAweEZGRkYgfHwgKGMgJiAweEZGRkYpID09PSAweEZGRkUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIC8vIGNvbnRyb2wgY29kZXNcbiAgaWYgKGMgPj0gMHgwMCAmJiBjIDw9IDB4MDgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID09PSAweDBCKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDBFICYmIGMgPD0gMHgxRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPj0gMHg3RiAmJiBjIDw9IDB4OUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIC8vIG91dCBvZiByYW5nZVxuICBpZiAoYyA+IDB4MTBGRkZGKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIGlmIChjID4gMHhmZmZmKSB7XG4gICAgYyAtPSAweDEwMDAwO1xuICAgIHZhciBzdXJyb2dhdGUxID0gMHhkODAwICsgKGMgPj4gMTApLFxuICAgICAgICBzdXJyb2dhdGUyID0gMHhkYzAwICsgKGMgJiAweDNmZik7XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzdXJyb2dhdGUxLCBzdXJyb2dhdGUyKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbn1cblxuXG52YXIgVU5FU0NBUEVfTURfUkUgID0gL1xcXFwoWyFcIiMkJSYnKCkqKyxcXC0uXFwvOjs8PT4/QFtcXFxcXFxdXl9ge3x9fl0pL2c7XG52YXIgRU5USVRZX1JFICAgICAgID0gLyYoW2EteiNdW2EtejAtOV17MSwzMX0pOy9naTtcbnZhciBVTkVTQ0FQRV9BTExfUkUgPSBuZXcgUmVnRXhwKFVORVNDQVBFX01EX1JFLnNvdXJjZSArICd8JyArIEVOVElUWV9SRS5zb3VyY2UsICdnaScpO1xuXG52YXIgRElHSVRBTF9FTlRJVFlfVEVTVF9SRSA9IC9eIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSkvaTtcblxudmFyIGVudGl0aWVzID0gcmVxdWlyZSgnLi9lbnRpdGllcycpO1xuXG5mdW5jdGlvbiByZXBsYWNlRW50aXR5UGF0dGVybihtYXRjaCwgbmFtZSkge1xuICB2YXIgY29kZSA9IDA7XG5cbiAgaWYgKGhhcyhlbnRpdGllcywgbmFtZSkpIHtcbiAgICByZXR1cm4gZW50aXRpZXNbbmFtZV07XG4gIH1cblxuICBpZiAobmFtZS5jaGFyQ29kZUF0KDApID09PSAweDIzLyogIyAqLyAmJiBESUdJVEFMX0VOVElUWV9URVNUX1JFLnRlc3QobmFtZSkpIHtcbiAgICBjb2RlID0gbmFtZVsxXS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgcGFyc2VJbnQobmFtZS5zbGljZSgyKSwgMTYpXG4gICAgOlxuICAgICAgcGFyc2VJbnQobmFtZS5zbGljZSgxKSwgMTApO1xuICAgIGlmIChpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG4vKmZ1bmN0aW9uIHJlcGxhY2VFbnRpdGllcyhzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoRU5USVRZX1JFLCByZXBsYWNlRW50aXR5UGF0dGVybik7XG59Ki9cblxuZnVuY3Rpb24gdW5lc2NhcGVNZChzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCdcXFxcJykgPCAwKSB7IHJldHVybiBzdHI7IH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFVORVNDQVBFX01EX1JFLCAnJDEnKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVBbGwoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCAmJiBzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFVORVNDQVBFX0FMTF9SRSwgZnVuY3Rpb24gKG1hdGNoLCBlc2NhcGVkLCBlbnRpdHkpIHtcbiAgICBpZiAoZXNjYXBlZCkgeyByZXR1cm4gZXNjYXBlZDsgfVxuICAgIHJldHVybiByZXBsYWNlRW50aXR5UGF0dGVybihtYXRjaCwgZW50aXR5KTtcbiAgfSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBIVE1MX0VTQ0FQRV9URVNUX1JFID0gL1smPD5cIl0vO1xudmFyIEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUgPSAvWyY8PlwiXS9nO1xudmFyIEhUTUxfUkVQTEFDRU1FTlRTID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90Oydcbn07XG5cbmZ1bmN0aW9uIHJlcGxhY2VVbnNhZmVDaGFyKGNoKSB7XG4gIHJldHVybiBIVE1MX1JFUExBQ0VNRU5UU1tjaF07XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIGlmIChIVE1MX0VTQ0FQRV9URVNUX1JFLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFLCByZXBsYWNlVW5zYWZlQ2hhcik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIFJFR0VYUF9FU0NBUEVfUkUgPSAvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVSRShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYUF9FU0NBUEVfUkUsICdcXFxcJCYnKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNTcGFjZShjb2RlKSB7XG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgMHgwOTpcbiAgICBjYXNlIDB4MjA6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFpzICh1bmljb2RlIGNsYXNzKSB8fCBbXFx0XFxmXFx2XFxyXFxuXVxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNvZGUpIHtcbiAgaWYgKGNvZGUgPj0gMHgyMDAwICYmIGNvZGUgPD0gMHgyMDBBKSB7IHJldHVybiB0cnVlOyB9XG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgMHgwOTogLy8gXFx0XG4gICAgY2FzZSAweDBBOiAvLyBcXG5cbiAgICBjYXNlIDB4MEI6IC8vIFxcdlxuICAgIGNhc2UgMHgwQzogLy8gXFxmXG4gICAgY2FzZSAweDBEOiAvLyBcXHJcbiAgICBjYXNlIDB4MjA6XG4gICAgY2FzZSAweEEwOlxuICAgIGNhc2UgMHgxNjgwOlxuICAgIGNhc2UgMHgyMDJGOlxuICAgIGNhc2UgMHgyMDVGOlxuICAgIGNhc2UgMHgzMDAwOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xudmFyIFVOSUNPREVfUFVOQ1RfUkUgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXgnKTtcblxuLy8gQ3VycmVudGx5IHdpdGhvdXQgYXN0cmFsIGNoYXJhY3RlcnMgc3VwcG9ydC5cbmZ1bmN0aW9uIGlzUHVuY3RDaGFyKGNoKSB7XG4gIHJldHVybiBVTklDT0RFX1BVTkNUX1JFLnRlc3QoY2gpO1xufVxuXG5cbi8vIE1hcmtkb3duIEFTQ0lJIHB1bmN0dWF0aW9uIGNoYXJhY3RlcnMuXG4vL1xuLy8gISwgXCIsICMsICQsICUsICYsICcsICgsICksICosICssICwsIC0sIC4sIC8sIDosIDssIDwsID0sID4sID8sIEAsIFssIFxcLCBdLCBeLCBfLCBgLCB7LCB8LCB9LCBvciB+XG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbi8vXG4vLyBEb24ndCBjb25mdXNlIHdpdGggdW5pY29kZSBwdW5jdHVhdGlvbiAhISEgSXQgbGFja3Mgc29tZSBjaGFycyBpbiBhc2NpaSByYW5nZS5cbi8vXG5mdW5jdGlvbiBpc01kQXNjaWlQdW5jdChjaCkge1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAweDIxLyogISAqLzpcbiAgICBjYXNlIDB4MjIvKiBcIiAqLzpcbiAgICBjYXNlIDB4MjMvKiAjICovOlxuICAgIGNhc2UgMHgyNC8qICQgKi86XG4gICAgY2FzZSAweDI1LyogJSAqLzpcbiAgICBjYXNlIDB4MjYvKiAmICovOlxuICAgIGNhc2UgMHgyNy8qICcgKi86XG4gICAgY2FzZSAweDI4LyogKCAqLzpcbiAgICBjYXNlIDB4MjkvKiApICovOlxuICAgIGNhc2UgMHgyQS8qICogKi86XG4gICAgY2FzZSAweDJCLyogKyAqLzpcbiAgICBjYXNlIDB4MkMvKiAsICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDJFLyogLiAqLzpcbiAgICBjYXNlIDB4MkYvKiAvICovOlxuICAgIGNhc2UgMHgzQS8qIDogKi86XG4gICAgY2FzZSAweDNCLyogOyAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4M0YvKiA/ICovOlxuICAgIGNhc2UgMHg0MC8qIEAgKi86XG4gICAgY2FzZSAweDVCLyogWyAqLzpcbiAgICBjYXNlIDB4NUMvKiBcXCAqLzpcbiAgICBjYXNlIDB4NUQvKiBdICovOlxuICAgIGNhc2UgMHg1RS8qIF4gKi86XG4gICAgY2FzZSAweDVGLyogXyAqLzpcbiAgICBjYXNlIDB4NjAvKiBgICovOlxuICAgIGNhc2UgMHg3Qi8qIHsgKi86XG4gICAgY2FzZSAweDdDLyogfCAqLzpcbiAgICBjYXNlIDB4N0QvKiB9ICovOlxuICAgIGNhc2UgMHg3RS8qIH4gKi86XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEhlcGxlciB0byB1bmlmeSBbcmVmZXJlbmNlIGxhYmVsc10uXG4vL1xuZnVuY3Rpb24gbm9ybWFsaXplUmVmZXJlbmNlKHN0cikge1xuICAvLyB1c2UgLnRvVXBwZXJDYXNlKCkgaW5zdGVhZCBvZiAudG9Mb3dlckNhc2UoKVxuICAvLyBoZXJlIHRvIGF2b2lkIGEgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlXG4gIC8vIG1lbWJlcnMgKG1vc3Qgbm90YWJseSwgYF9fcHJvdG9fX2ApXG4gIHJldHVybiBzdHIudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKS50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBSZS1leHBvcnQgbGlicmFyaWVzIGNvbW1vbmx5IHVzZWQgaW4gYm90aCBtYXJrZG93bi1pdCBhbmQgaXRzIHBsdWdpbnMsXG4vLyBzbyBwbHVnaW5zIHdvbid0IGhhdmUgdG8gZGVwZW5kIG9uIHRoZW0gZXhwbGljaXRseSwgd2hpY2ggcmVkdWNlcyB0aGVpclxuLy8gYnVuZGxlZCBzaXplIChlLmcuIGEgYnJvd3NlciBidWlsZCkuXG4vL1xuZXhwb3J0cy5saWIgICAgICAgICAgICAgICAgID0ge307XG5leHBvcnRzLmxpYi5tZHVybCAgICAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xuZXhwb3J0cy5saWIudWNtaWNybyAgICAgICAgID0gcmVxdWlyZSgndWMubWljcm8nKTtcblxuZXhwb3J0cy5hc3NpZ24gICAgICAgICAgICAgID0gYXNzaWduO1xuZXhwb3J0cy5pc1N0cmluZyAgICAgICAgICAgID0gaXNTdHJpbmc7XG5leHBvcnRzLmhhcyAgICAgICAgICAgICAgICAgPSBoYXM7XG5leHBvcnRzLnVuZXNjYXBlTWQgICAgICAgICAgPSB1bmVzY2FwZU1kO1xuZXhwb3J0cy51bmVzY2FwZUFsbCAgICAgICAgID0gdW5lc2NhcGVBbGw7XG5leHBvcnRzLmlzVmFsaWRFbnRpdHlDb2RlICAgPSBpc1ZhbGlkRW50aXR5Q29kZTtcbmV4cG9ydHMuZnJvbUNvZGVQb2ludCAgICAgICA9IGZyb21Db2RlUG9pbnQ7XG4vLyBleHBvcnRzLnJlcGxhY2VFbnRpdGllcyAgICAgPSByZXBsYWNlRW50aXRpZXM7XG5leHBvcnRzLmVzY2FwZUh0bWwgICAgICAgICAgPSBlc2NhcGVIdG1sO1xuZXhwb3J0cy5hcnJheVJlcGxhY2VBdCAgICAgID0gYXJyYXlSZXBsYWNlQXQ7XG5leHBvcnRzLmlzU3BhY2UgICAgICAgICAgICAgPSBpc1NwYWNlO1xuZXhwb3J0cy5pc1doaXRlU3BhY2UgICAgICAgID0gaXNXaGl0ZVNwYWNlO1xuZXhwb3J0cy5pc01kQXNjaWlQdW5jdCAgICAgID0gaXNNZEFzY2lpUHVuY3Q7XG5leHBvcnRzLmlzUHVuY3RDaGFyICAgICAgICAgPSBpc1B1bmN0Q2hhcjtcbmV4cG9ydHMuZXNjYXBlUkUgICAgICAgICAgICA9IGVzY2FwZVJFO1xuZXhwb3J0cy5ub3JtYWxpemVSZWZlcmVuY2UgID0gbm9ybWFsaXplUmVmZXJlbmNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgdW5kZWZpbmVkKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIHVuZGVmaW5lZCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSkgcmV0dXJuXG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCBcIlwiKVxuXHRcdFx0XHRlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXkyLCB2YWx1ZSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0TGF0ZUF0dHJzKHZub2RlKSB7XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwidmFsdWVcIiwgbnVsbCwgYXR0cnMyLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMyLnNlbGVjdGVkSW5kZXgsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cnModm5vZGUsIG9sZCwgYXR0cnMyLCBucykge1xuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5Miwgb2xkICYmIG9sZFtrZXkyXSwgYXR0cnMyW2tleTJdLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRpZiAoYXR0cnMyID09IG51bGwgfHwgIShrZXkyIGluIGF0dHJzMikpIHtcblx0XHRcdFx0XHRpZiAoa2V5MiA9PT0gXCJjbGFzc05hbWVcIikga2V5MiA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZWxzZSBpZiAoa2V5MiAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXHQvL3N0eWxlXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgc3R5bGUpIHtcblx0XHRpZiAob2xkID09PSBzdHlsZSkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIiwgb2xkID0gbnVsbFxuXHRcdGlmIChzdHlsZSA9PSBudWxsKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0ZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGQgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRcdGZvciAodmFyIGtleTIgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXkyXSA9IHN0eWxlW2tleTJdXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkICE9IG51bGwgJiYgdHlwZW9mIG9sZCAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleTIgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleTJdID0gXCJcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkyIGluIGVsZW1lbnQpIGVsZW1lbnRba2V5Ml0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleTIuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gPT09IGNhbGxiYWNrKSByZXR1cm5cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5Ml0gPSBjYWxsYmFja1xuXHRcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyKGRvbSwgdm5vZGVzKSB7XG5cdFx0aWYgKCFkb20pIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKVxuXHRcdHZhciBob29rcyA9IFtdXG5cdFx0dmFyIGFjdGl2ZSA9ICRkb2MuYWN0aXZlRWxlbWVudFxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCB1bmRlZmluZWQpXG5cdFx0ZG9tLnZub2RlcyA9IHZub2Rlc1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIGhvb2tzW2ldKClcblx0XHRpZiAoJGRvYy5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpXG5cdH1cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0RXZlbnRDYWxsYmFjazogc2V0RXZlbnRDYWxsYmFja31cbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrKSB7XG5cdC8vNjBmcHMgdHJhbnNsYXRlcyB0byAxNi42bXMsIHJvdW5kIGl0IGRvd24gc2luY2Ugc2V0VGltZW91dCByZXF1aXJlcyBpbnRcblx0dmFyIHRpbWUgPSAxNlxuXHR2YXIgbGFzdCA9IDAsIHBlbmRpbmcgPSBudWxsXG5cdHZhciB0aW1lb3V0ID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dFxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KClcblx0XHRpZiAobGFzdCA9PT0gMCB8fCBub3cgLSBsYXN0ID49IHRpbWUpIHtcblx0XHRcdGxhc3QgPSBub3dcblx0XHRcdGNhbGxiYWNrKClcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuXHRcdFx0cGVuZGluZyA9IHRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrKClcblx0XHRcdFx0bGFzdCA9IERhdGUubm93KClcblx0XHRcdH0sIHRpbWUgLSAobm93IC0gbGFzdCkpXG5cdFx0fVxuXHR9XG59XG52YXIgXzExID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgcmVuZGVyU2VydmljZSA9IGNvcmVSZW5kZXJlcigkd2luZG93KVxuXHRyZW5kZXJTZXJ2aWNlLnNldEV2ZW50Q2FsbGJhY2soZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLnJlZHJhdyAhPT0gZmFsc2UpIHJlZHJhdygpXG5cdH0pXG5cdHZhciBjYWxsYmFja3MgPSBbXVxuXHRmdW5jdGlvbiBzdWJzY3JpYmUoa2V5MSwgY2FsbGJhY2spIHtcblx0XHR1bnN1YnNjcmliZShrZXkxKVxuXHRcdGNhbGxiYWNrcy5wdXNoKGtleTEsIHRocm90dGxlKGNhbGxiYWNrKSlcblx0fVxuXHRmdW5jdGlvbiB1bnN1YnNjcmliZShrZXkxKSB7XG5cdFx0dmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2Yoa2V5MSlcblx0XHRpZiAoaW5kZXggPiAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMilcblx0fVxuXHRmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdGNhbGxiYWNrc1tpXSgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiB7c3Vic2NyaWJlOiBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSwgcmVkcmF3OiByZWRyYXcsIHJlbmRlcjogcmVuZGVyU2VydmljZS5yZW5kZXJ9XG59XG52YXIgcmVkcmF3U2VydmljZSA9IF8xMSh3aW5kb3cpXG5yZXF1ZXN0U2VydmljZS5zZXRDb21wbGV0aW9uQ2FsbGJhY2socmVkcmF3U2VydmljZS5yZWRyYXcpXG52YXIgXzE2ID0gZnVuY3Rpb24ocmVkcmF3U2VydmljZTApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudCkge1xuXHRcdGlmIChjb21wb25lbnQgPT09IG51bGwpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBbXSlcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnVuc3Vic2NyaWJlKHJvb3QpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNvbXBvbmVudC52aWV3ID09IG51bGwgJiYgdHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJtLm1vdW50KGVsZW1lbnQsIGNvbXBvbmVudCkgZXhwZWN0cyBhIGNvbXBvbmVudCwgbm90IGEgdm5vZGVcIilcblx0XHRcblx0XHR2YXIgcnVuMCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFZub2RlKGNvbXBvbmVudCkpXG5cdFx0fVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4wKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnJlZHJhdygpXG5cdH1cbn1cbm0ubW91bnQgPSBfMTYocmVkcmF3U2VydmljZSlcbnZhciBQcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG52YXIgcGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRpZiAoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PSBudWxsKSByZXR1cm4ge31cblx0aWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSlcblx0dmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCImXCIpLCBkYXRhMCA9IHt9LCBjb3VudGVycyA9IHt9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IGVudHJpZXNbaV0uc3BsaXQoXCI9XCIpXG5cdFx0dmFyIGtleTUgPSBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMF0pXG5cdFx0dmFyIHZhbHVlID0gZW50cnkubGVuZ3RoID09PSAyID8gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzFdKSA6IFwiXCJcblx0XHRpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWVcblx0XHRlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB2YWx1ZSA9IGZhbHNlXG5cdFx0dmFyIGxldmVscyA9IGtleTUuc3BsaXQoL1xcXVxcWz98XFxbLylcblx0XHR2YXIgY3Vyc29yID0gZGF0YTBcblx0XHRpZiAoa2V5NS5pbmRleE9mKFwiW1wiKSA+IC0xKSBsZXZlbHMucG9wKClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzW2pdLCBuZXh0TGV2ZWwgPSBsZXZlbHNbaiArIDFdXG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBuZXh0TGV2ZWwgPT0gXCJcIiB8fCAhaXNOYU4ocGFyc2VJbnQobmV4dExldmVsLCAxMCkpXG5cdFx0XHR2YXIgaXNWYWx1ZSA9IGogPT09IGxldmVscy5sZW5ndGggLSAxXG5cdFx0XHRpZiAobGV2ZWwgPT09IFwiXCIpIHtcblx0XHRcdFx0dmFyIGtleTUgPSBsZXZlbHMuc2xpY2UoMCwgaikuam9pbigpXG5cdFx0XHRcdGlmIChjb3VudGVyc1trZXk1XSA9PSBudWxsKSBjb3VudGVyc1trZXk1XSA9IDBcblx0XHRcdFx0bGV2ZWwgPSBjb3VudGVyc1trZXk1XSsrXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3Vyc29yW2xldmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdGN1cnNvcltsZXZlbF0gPSBpc1ZhbHVlID8gdmFsdWUgOiBpc051bWJlciA/IFtdIDoge31cblx0XHRcdH1cblx0XHRcdGN1cnNvciA9IGN1cnNvcltsZXZlbF1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGEwXG59XG52YXIgY29yZVJvdXRlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gdHlwZW9mICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPT09IFwiZnVuY3Rpb25cIlxuXHR2YXIgY2FsbEFzeW5jMCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gbm9ybWFsaXplMShmcmFnbWVudDApIHtcblx0XHR2YXIgZGF0YSA9ICR3aW5kb3cubG9jYXRpb25bZnJhZ21lbnQwXS5yZXBsYWNlKC8oPzolW2EtZjg5XVthLWYwLTldKSsvZ2ltLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0aWYgKGZyYWdtZW50MCA9PT0gXCJwYXRobmFtZVwiICYmIGRhdGFbMF0gIT09IFwiL1wiKSBkYXRhID0gXCIvXCIgKyBkYXRhXG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHR2YXIgYXN5bmNJZFxuXHRmdW5jdGlvbiBkZWJvdW5jZUFzeW5jKGNhbGxiYWNrMCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChhc3luY0lkICE9IG51bGwpIHJldHVyblxuXHRcdFx0YXN5bmNJZCA9IGNhbGxBc3luYzAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFzeW5jSWQgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrMCgpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSkge1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKVxuXHRcdHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpXG5cdFx0dmFyIHBhdGhFbmQgPSBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRcdHZhciBxdWVyeVBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSwgcXVlcnlFbmQpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBxdWVyeVBhcmFtcykgcXVlcnlEYXRhW2tleTRdID0gcXVlcnlQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0aWYgKGhhc2hJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgaGFzaFBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShoYXNoSW5kZXggKyAxKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gaGFzaFBhcmFtcykgaGFzaERhdGFba2V5NF0gPSBoYXNoUGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdHJldHVybiBwYXRoLnNsaWNlKDAsIHBhdGhFbmQpXG5cdH1cblx0dmFyIHJvdXRlciA9IHtwcmVmaXg6IFwiIyFcIn1cblx0cm91dGVyLmdldFBhdGggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZTIgPSByb3V0ZXIucHJlZml4LmNoYXJBdCgwKVxuXHRcdHN3aXRjaCAodHlwZTIpIHtcblx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBub3JtYWxpemUxKFwiaGFzaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aClcblx0XHRcdGNhc2UgXCI/XCI6IHJldHVybiBub3JtYWxpemUxKFwic2VhcmNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gbm9ybWFsaXplMShcInBhdGhuYW1lXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdH1cblx0fVxuXHRyb3V0ZXIuc2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHR2YXIgcXVlcnlEYXRhID0ge30sIGhhc2hEYXRhID0ge31cblx0XHRwYXRoID0gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpXG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBkYXRhKSBxdWVyeURhdGFba2V5NF0gPSBkYXRhW2tleTRdXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXSspL2csIGZ1bmN0aW9uKG1hdGNoMiwgdG9rZW4pIHtcblx0XHRcdFx0ZGVsZXRlIHF1ZXJ5RGF0YVt0b2tlbl1cblx0XHRcdFx0cmV0dXJuIGRhdGFbdG9rZW5dXG5cdFx0XHR9KVxuXHRcdH1cblx0XHR2YXIgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKHF1ZXJ5RGF0YSlcblx0XHRpZiAocXVlcnkpIHBhdGggKz0gXCI/XCIgKyBxdWVyeVxuXHRcdHZhciBoYXNoID0gYnVpbGRRdWVyeVN0cmluZyhoYXNoRGF0YSlcblx0XHRpZiAoaGFzaCkgcGF0aCArPSBcIiNcIiArIGhhc2hcblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnN0YXRlIDogbnVsbFxuXHRcdFx0dmFyIHRpdGxlID0gb3B0aW9ucyA/IG9wdGlvbnMudGl0bGUgOiBudWxsXG5cdFx0XHQkd2luZG93Lm9ucG9wc3RhdGUoKVxuXHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0XHRlbHNlICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHR9XG5cdFx0ZWxzZSAkd2luZG93LmxvY2F0aW9uLmhyZWYgPSByb3V0ZXIucHJlZml4ICsgcGF0aFxuXHR9XG5cdHJvdXRlci5kZWZpbmVSb3V0ZXMgPSBmdW5jdGlvbihyb3V0ZXMsIHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZ1bmN0aW9uIHJlc29sdmVSb3V0ZSgpIHtcblx0XHRcdHZhciBwYXRoID0gcm91dGVyLmdldFBhdGgoKVxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9XG5cdFx0XHR2YXIgcGF0aG5hbWUgPSBwYXJzZVBhdGgocGF0aCwgcGFyYW1zLCBwYXJhbXMpXG5cdFx0XHR2YXIgc3RhdGUgPSAkd2luZG93Lmhpc3Rvcnkuc3RhdGVcblx0XHRcdGlmIChzdGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGsgaW4gc3RhdGUpIHBhcmFtc1trXSA9IHN0YXRlW2tdXG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciByb3V0ZTAgaW4gcm91dGVzKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChcIl5cIiArIHJvdXRlMC5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZywgXCIoLio/KVwiKS5yZXBsYWNlKC86W15cXC9dKy9nLCBcIihbXlxcXFwvXSspXCIpICsgXCJcXC8/JFwiKVxuXHRcdFx0XHRpZiAobWF0Y2hlci50ZXN0KHBhdGhuYW1lKSkge1xuXHRcdFx0XHRcdHBhdGhuYW1lLnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5cyA9IHJvdXRlMC5tYXRjaCgvOlteXFwvXSsvZykgfHwgW11cblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTIpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zW2tleXNbaV0ucmVwbGFjZSgvOnxcXC4vZywgXCJcIildID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpXSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc29sdmUocm91dGVzW3JvdXRlMF0sIHBhcmFtcywgcGF0aCwgcm91dGUwKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlamVjdChwYXRoLCBwYXJhbXMpXG5cdFx0fVxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkgJHdpbmRvdy5vbnBvcHN0YXRlID0gZGVib3VuY2VBc3luYyhyZXNvbHZlUm91dGUpXG5cdFx0ZWxzZSBpZiAocm91dGVyLnByZWZpeC5jaGFyQXQoMCkgPT09IFwiI1wiKSAkd2luZG93Lm9uaGFzaGNoYW5nZSA9IHJlc29sdmVSb3V0ZVxuXHRcdHJlc29sdmVSb3V0ZSgpXG5cdH1cblx0cmV0dXJuIHJvdXRlclxufVxudmFyIF8yMCA9IGZ1bmN0aW9uKCR3aW5kb3csIHJlZHJhd1NlcnZpY2UwKSB7XG5cdHZhciByb3V0ZVNlcnZpY2UgPSBjb3JlUm91dGVyKCR3aW5kb3cpXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHYpIHtyZXR1cm4gdn1cblx0dmFyIHJlbmRlcjEsIGNvbXBvbmVudCwgYXR0cnMzLCBjdXJyZW50UGF0aCwgbGFzdFVwZGF0ZVxuXHR2YXIgcm91dGUgPSBmdW5jdGlvbihyb290LCBkZWZhdWx0Um91dGUsIHJvdXRlcykge1xuXHRcdGlmIChyb290ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIGBtLnJvdXRlYCBpcyBub3QgdW5kZWZpbmVkXCIpXG5cdFx0dmFyIHJ1bjEgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZW5kZXIxICE9IG51bGwpIHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCByZW5kZXIxKFZub2RlKGNvbXBvbmVudCwgYXR0cnMzLmtleSwgYXR0cnMzKSkpXG5cdFx0fVxuXHRcdHZhciBiYWlsID0gZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0aWYgKHBhdGggIT09IGRlZmF1bHRSb3V0ZSkgcm91dGVTZXJ2aWNlLnNldFBhdGgoZGVmYXVsdFJvdXRlLCBudWxsLCB7cmVwbGFjZTogdHJ1ZX0pXG5cdFx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGRlZmF1bHQgcm91dGUgXCIgKyBkZWZhdWx0Um91dGUpXG5cdFx0fVxuXHRcdHJvdXRlU2VydmljZS5kZWZpbmVSb3V0ZXMocm91dGVzLCBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIHBhdGgpIHtcblx0XHRcdHZhciB1cGRhdGUgPSBsYXN0VXBkYXRlID0gZnVuY3Rpb24ocm91dGVSZXNvbHZlciwgY29tcCkge1xuXHRcdFx0XHRpZiAodXBkYXRlICE9PSBsYXN0VXBkYXRlKSByZXR1cm5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcCAhPSBudWxsICYmICh0eXBlb2YgY29tcC52aWV3ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNvbXAgPT09IFwiZnVuY3Rpb25cIik/IGNvbXAgOiBcImRpdlwiXG5cdFx0XHRcdGF0dHJzMyA9IHBhcmFtcywgY3VycmVudFBhdGggPSBwYXRoLCBsYXN0VXBkYXRlID0gbnVsbFxuXHRcdFx0XHRyZW5kZXIxID0gKHJvdXRlUmVzb2x2ZXIucmVuZGVyIHx8IGlkZW50aXR5KS5iaW5kKHJvdXRlUmVzb2x2ZXIpXG5cdFx0XHRcdHJ1bjEoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBheWxvYWQudmlldyB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGUoe30sIHBheWxvYWQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHBheWxvYWQub25tYXRjaCkge1xuXHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShwYXlsb2FkLm9ubWF0Y2gocGFyYW1zLCBwYXRoKSkudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKHBheWxvYWQsIHJlc29sdmVkKVxuXHRcdFx0XHRcdH0sIGJhaWwpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB1cGRhdGUocGF5bG9hZCwgXCJkaXZcIilcblx0XHRcdH1cblx0XHR9LCBiYWlsKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4xKVxuXHR9XG5cdHJvdXRlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRpZiAobGFzdFVwZGF0ZSAhPSBudWxsKSBvcHRpb25zID0ge3JlcGxhY2U6IHRydWV9XG5cdFx0bGFzdFVwZGF0ZSA9IG51bGxcblx0XHRyb3V0ZVNlcnZpY2Uuc2V0UGF0aChwYXRoLCBkYXRhLCBvcHRpb25zKVxuXHR9XG5cdHJvdXRlLmdldCA9IGZ1bmN0aW9uKCkge3JldHVybiBjdXJyZW50UGF0aH1cblx0cm91dGUucHJlZml4ID0gZnVuY3Rpb24ocHJlZml4MCkge3JvdXRlU2VydmljZS5wcmVmaXggPSBwcmVmaXgwfVxuXHRyb3V0ZS5saW5rID0gZnVuY3Rpb24odm5vZGUxKSB7XG5cdFx0dm5vZGUxLmRvbS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHJvdXRlU2VydmljZS5wcmVmaXggKyB2bm9kZTEuYXR0cnMuaHJlZilcblx0XHR2bm9kZTEuZG9tLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGUud2hpY2ggPT09IDIpIHJldHVyblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRlLnJlZHJhdyA9IGZhbHNlXG5cdFx0XHR2YXIgaHJlZiA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuXHRcdFx0aWYgKGhyZWYuaW5kZXhPZihyb3V0ZVNlcnZpY2UucHJlZml4KSA9PT0gMCkgaHJlZiA9IGhyZWYuc2xpY2Uocm91dGVTZXJ2aWNlLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRyb3V0ZS5zZXQoaHJlZiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdHJvdXRlLnBhcmFtID0gZnVuY3Rpb24oa2V5Mykge1xuXHRcdGlmKHR5cGVvZiBhdHRyczMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGtleTMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBhdHRyczNba2V5M11cblx0XHRyZXR1cm4gYXR0cnMzXG5cdH1cblx0cmV0dXJuIHJvdXRlXG59XG5tLnJvdXRlID0gXzIwKHdpbmRvdywgcmVkcmF3U2VydmljZSlcbm0ud2l0aEF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSwgY2FsbGJhY2sxLCBjb250ZXh0KSB7XG5cdHJldHVybiBmdW5jdGlvbihlKSB7XG5cdFx0Y2FsbGJhY2sxLmNhbGwoY29udGV4dCB8fCB0aGlzLCBhdHRyTmFtZSBpbiBlLmN1cnJlbnRUYXJnZXQgPyBlLmN1cnJlbnRUYXJnZXRbYXR0ck5hbWVdIDogZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpXG5cdH1cbn1cbnZhciBfMjggPSBjb3JlUmVuZGVyZXIod2luZG93KVxubS5yZW5kZXIgPSBfMjgucmVuZGVyXG5tLnJlZHJhdyA9IHJlZHJhd1NlcnZpY2UucmVkcmF3XG5tLnJlcXVlc3QgPSByZXF1ZXN0U2VydmljZS5yZXF1ZXN0XG5tLmpzb25wID0gcmVxdWVzdFNlcnZpY2UuanNvbnBcbm0ucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmdcbm0uYnVpbGRRdWVyeVN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmdcbm0udmVyc2lvbiA9IFwiMS4xLjFcIlxubS52bm9kZSA9IFZub2RlXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IG1cbmVsc2Ugd2luZG93Lm0gPSBtXG59KCkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWl0aHJpbC9taXRocmlsLmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICB2bm9kZS5zdGF0ZS5zcGFuID0gdm5vZGUuYXR0cnMuc3BhbjtcbiAgICB2bm9kZS5zdGF0ZS5jbHMgPSB2bm9kZS5hdHRycy5jbHMgfHwgJyc7XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2BtZGwtY2VsbCBtZGwtY2VsbC0tJHt2bm9kZS5zdGF0ZS5zcGFufS1jb2wgJHt2bm9kZS5zdGF0ZS5jbHN9YH0+XG4gICAgICB7dm5vZGUuYXR0cnMuaW5uZXJ9XG4gICAgPC9kaXY+XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9saWJzL2NvbXBvbmVudHMvY2VsbC5qcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEtMSEuL3N0eWxlcy5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEtMSEuL3N0eWxlcy5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xpYnMvY29tcG9uZW50cy9zdHlsZXMuY3NzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCIvKipcbiAqIGNsYXNzIFJ1bGVyXG4gKlxuICogSGVscGVyIGNsYXNzLCB1c2VkIGJ5IFtbTWFya2Rvd25JdCNjb3JlXV0sIFtbTWFya2Rvd25JdCNibG9ja11dIGFuZFxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XG4gKlxuICogLSBrZWVwIHJ1bGVzIGluIGRlZmluZWQgb3JkZXJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxuICogLSBlbmFibGUvZGlzYWJsZSBydWxlc1xuICogLSBhZGQvcmVwbGFjZSBydWxlc1xuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxuICogLSBjYWNoZWluZyBsaXN0cyBvZiBhY3RpdmUgcnVsZXNcbiAqXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXG4gKiBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dLCBbW01hcmtkb3duSXQuZW5hYmxlXV0gYW5kXG4gKiBbW01hcmtkb3duSXQudXNlXV0uXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIG5hbWU6IFhYWCxcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxuICAvLyAgIGZuOiBGdW5jdGlvbigpLFxuICAvLyAgIGFsdDogWyBuYW1lMiwgbmFtZTMgXVxuICAvLyB9XG4gIC8vXG4gIHRoaXMuX19ydWxlc19fID0gW107XG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG5cblxuLy8gRmluZCBydWxlIGluZGV4IGJ5IG5hbWVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hdChuYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSBuYW1lIHRvIHJlcGxhY2UuXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBuZXcgcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxuICogZm91bmQuXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9yZ2FwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLmF0KCdyZXBsYWNlbWVudHMnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5mbiA9IGZuO1xuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmJlZm9yZShiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBiZWZvcmUgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdwYXJhZ3JhcGgnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGVPbmx5KGxpc3QgWywgaWdub3JlSW52YWxpZF0pXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUgKHdoaXRlbGlzdCkuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcywgYW5kIGRpc2FibGUgZXZlcnl0aGluZyBlbHNlLiBJZiBhbnkgcnVsZSBuYW1lXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlXV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB0aGlzLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7IHJ1bGUuZW5hYmxlZCA9IGZhbHNlOyB9KTtcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5kaXNhYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5lbmFibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gZmFsc2U7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gIH1cblxuICAvLyBDaGFpbiBjYW4gYmUgZW1wdHksIGlmIHJ1bGVzIGRpc2FibGVkLiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byByZXR1cm4gQXJyYXkuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwiLy8gVG9rZW4gY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogY2xhc3MgVG9rZW5cbiAqKi9cblxuLyoqXG4gKiBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKVxuICpcbiAqIENyZWF0ZSBuZXcgdG9rZW4gYW5kIGZpbGwgcGFzc2VkIHByb3BlcnRpZXMuXG4gKiovXG5mdW5jdGlvbiBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgLyoqXG4gICAqIFRva2VuI3R5cGUgLT4gU3RyaW5nXG4gICAqXG4gICAqIFR5cGUgb2YgdGhlIHRva2VuIChzdHJpbmcsIGUuZy4gXCJwYXJhZ3JhcGhfb3BlblwiKVxuICAgKiovXG4gIHRoaXMudHlwZSAgICAgPSB0eXBlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiN0YWcgLT4gU3RyaW5nXG4gICAqXG4gICAqIGh0bWwgdGFnIG5hbWUsIGUuZy4gXCJwXCJcbiAgICoqL1xuICB0aGlzLnRhZyAgICAgID0gdGFnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNhdHRycyAtPiBBcnJheVxuICAgKlxuICAgKiBIdG1sIGF0dHJpYnV0ZXMuIEZvcm1hdDogYFsgWyBuYW1lMSwgdmFsdWUxIF0sIFsgbmFtZTIsIHZhbHVlMiBdIF1gXG4gICAqKi9cbiAgdGhpcy5hdHRycyAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcCAtPiBBcnJheVxuICAgKlxuICAgKiBTb3VyY2UgbWFwIGluZm8uIEZvcm1hdDogYFsgbGluZV9iZWdpbiwgbGluZV9lbmQgXWBcbiAgICoqL1xuICB0aGlzLm1hcCAgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbmVzdGluZyAtPiBOdW1iZXJcbiAgICpcbiAgICogTGV2ZWwgY2hhbmdlIChudW1iZXIgaW4gey0xLCAwLCAxfSBzZXQpLCB3aGVyZTpcbiAgICpcbiAgICogLSAgYDFgIG1lYW5zIHRoZSB0YWcgaXMgb3BlbmluZ1xuICAgKiAtICBgMGAgbWVhbnMgdGhlIHRhZyBpcyBzZWxmLWNsb3NpbmdcbiAgICogLSBgLTFgIG1lYW5zIHRoZSB0YWcgaXMgY2xvc2luZ1xuICAgKiovXG4gIHRoaXMubmVzdGluZyAgPSBuZXN0aW5nO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNsZXZlbCAtPiBOdW1iZXJcbiAgICpcbiAgICogbmVzdGluZyBsZXZlbCwgdGhlIHNhbWUgYXMgYHN0YXRlLmxldmVsYFxuICAgKiovXG4gIHRoaXMubGV2ZWwgICAgPSAwO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjaGlsZHJlbiAtPiBBcnJheVxuICAgKlxuICAgKiBBbiBhcnJheSBvZiBjaGlsZCBub2RlcyAoaW5saW5lIGFuZCBpbWcgdG9rZW5zKVxuICAgKiovXG4gIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjb250ZW50IC0+IFN0cmluZ1xuICAgKlxuICAgKiBJbiBhIGNhc2Ugb2Ygc2VsZi1jbG9zaW5nIHRhZyAoY29kZSwgaHRtbCwgZmVuY2UsIGV0Yy4pLFxuICAgKiBpdCBoYXMgY29udGVudHMgb2YgdGhpcyB0YWcuXG4gICAqKi9cbiAgdGhpcy5jb250ZW50ICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtYXJrdXAgLT4gU3RyaW5nXG4gICAqXG4gICAqICcqJyBvciAnXycgZm9yIGVtcGhhc2lzLCBmZW5jZSBzdHJpbmcgZm9yIGZlbmNlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5tYXJrdXAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNpbmZvIC0+IFN0cmluZ1xuICAgKlxuICAgKiBmZW5jZSBpbmZvc3RyaW5nXG4gICAqKi9cbiAgdGhpcy5pbmZvICAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtZXRhIC0+IE9iamVjdFxuICAgKlxuICAgKiBBIHBsYWNlIGZvciBwbHVnaW5zIHRvIHN0b3JlIGFuIGFyYml0cmFyeSBkYXRhXG4gICAqKi9cbiAgdGhpcy5tZXRhICAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2Jsb2NrIC0+IEJvb2xlYW5cbiAgICpcbiAgICogVHJ1ZSBmb3IgYmxvY2stbGV2ZWwgdG9rZW5zLCBmYWxzZSBmb3IgaW5saW5lIHRva2Vucy5cbiAgICogVXNlZCBpbiByZW5kZXJlciB0byBjYWxjdWxhdGUgbGluZSBicmVha3NcbiAgICoqL1xuICB0aGlzLmJsb2NrICAgID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRva2VuI2hpZGRlbiAtPiBCb29sZWFuXG4gICAqXG4gICAqIElmIGl0J3MgdHJ1ZSwgaWdub3JlIHRoaXMgZWxlbWVudCB3aGVuIHJlbmRlcmluZy4gVXNlZCBmb3IgdGlnaHQgbGlzdHNcbiAgICogdG8gaGlkZSBwYXJhZ3JhcGhzLlxuICAgKiovXG4gIHRoaXMuaGlkZGVuICAgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFRva2VuLmF0dHJJbmRleChuYW1lKSAtPiBOdW1iZXJcbiAqXG4gKiBTZWFyY2ggYXR0cmlidXRlIGluZGV4IGJ5IG5hbWUuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckluZGV4ID0gZnVuY3Rpb24gYXR0ckluZGV4KG5hbWUpIHtcbiAgdmFyIGF0dHJzLCBpLCBsZW47XG5cbiAgaWYgKCF0aGlzLmF0dHJzKSB7IHJldHVybiAtMTsgfVxuXG4gIGF0dHJzID0gdGhpcy5hdHRycztcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhdHRyc1tpXVswXSA9PT0gbmFtZSkgeyByZXR1cm4gaTsgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyUHVzaChhdHRyRGF0YSlcbiAqXG4gKiBBZGQgYFsgbmFtZSwgdmFsdWUgXWAgYXR0cmlidXRlIHRvIGxpc3QuIEluaXQgYXR0cnMgaWYgbmVjZXNzYXJ5XG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0clB1c2ggPSBmdW5jdGlvbiBhdHRyUHVzaChhdHRyRGF0YSkge1xuICBpZiAodGhpcy5hdHRycykge1xuICAgIHRoaXMuYXR0cnMucHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRycyA9IFsgYXR0ckRhdGEgXTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJTZXQobmFtZSwgdmFsdWUpXG4gKlxuICogU2V0IGBuYW1lYCBhdHRyaWJ1dGUgdG8gYHZhbHVlYC4gT3ZlcnJpZGUgb2xkIHZhbHVlIGlmIGV4aXN0cy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyU2V0ID0gZnVuY3Rpb24gYXR0clNldChuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksXG4gICAgICBhdHRyRGF0YSA9IFsgbmFtZSwgdmFsdWUgXTtcblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goYXR0ckRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XSA9IGF0dHJEYXRhO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckdldChuYW1lKVxuICpcbiAqIEdldCB0aGUgdmFsdWUgb2YgYXR0cmlidXRlIGBuYW1lYCwgb3IgbnVsbCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyR2V0ID0gZnVuY3Rpb24gYXR0ckdldChuYW1lKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSwgdmFsdWUgPSBudWxsO1xuICBpZiAoaWR4ID49IDApIHtcbiAgICB2YWx1ZSA9IHRoaXMuYXR0cnNbaWR4XVsxXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckpvaW4obmFtZSwgdmFsdWUpXG4gKlxuICogSm9pbiB2YWx1ZSB0byBleGlzdGluZyBhdHRyaWJ1dGUgdmlhIHNwYWNlLiBPciBjcmVhdGUgbmV3IGF0dHJpYnV0ZSBpZiBub3RcbiAqIGV4aXN0cy4gVXNlZnVsIHRvIG9wZXJhdGUgd2l0aCB0b2tlbiBjbGFzc2VzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJKb2luID0gZnVuY3Rpb24gYXR0ckpvaW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChbIG5hbWUsIHZhbHVlIF0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XVsxXSA9IHRoaXMuYXR0cnNbaWR4XVsxXSArICcgJyArIHZhbHVlO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVG9rZW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIS0jJS1cXCosLS86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDRcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQzRCLVxcdURDNEZcXHVEQzVCXFx1REM1RFxcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERTYwLVxcdURFNkNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDdbXFx1REM0MS1cXHVEQzQ1XFx1REM3MFxcdURDNzFdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODNBW1xcdURENUVcXHVERDVGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleC5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICB2YXIgYmFzZTY0ID0gbmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cbiAgcmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCIvLyBIVE1MNSBlbnRpdGllcyBtYXA6IHsgbmFtZSAtPiB1dGYxNnN0cmluZyB9XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBxdW90ZXM6MCovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2VudGl0aWVzL21hcHMvZW50aXRpZXMuanNvbicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzIiwiLy8gUmVnZXhwcyB0byBtYXRjaCBodG1sIGVsZW1lbnRzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dHJfbmFtZSAgICAgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xuXG52YXIgdW5xdW90ZWQgICAgICA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBzaW5nbGVfcXVvdGVkID0gXCInW14nXSonXCI7XG52YXIgZG91YmxlX3F1b3RlZCA9ICdcIlteXCJdKlwiJztcblxudmFyIGF0dHJfdmFsdWUgID0gJyg/OicgKyB1bnF1b3RlZCArICd8JyArIHNpbmdsZV9xdW90ZWQgKyAnfCcgKyBkb3VibGVfcXVvdGVkICsgJyknO1xuXG52YXIgYXR0cmlidXRlICAgPSAnKD86XFxcXHMrJyArIGF0dHJfbmFtZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJfdmFsdWUgKyAnKT8pJztcblxudmFyIG9wZW5fdGFnICAgID0gJzxbQS1aYS16XVtBLVphLXowLTlcXFxcLV0qJyArIGF0dHJpYnV0ZSArICcqXFxcXHMqXFxcXC8/Pic7XG5cbnZhciBjbG9zZV90YWcgICA9ICc8XFxcXC9bQS1aYS16XVtBLVphLXowLTlcXFxcLV0qXFxcXHMqPic7XG52YXIgY29tbWVudCAgICAgPSAnPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPic7XG52YXIgcHJvY2Vzc2luZyAgPSAnPFs/XS4qP1s/XT4nO1xudmFyIGRlY2xhcmF0aW9uID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBjZGF0YSAgICAgICA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xuXG52YXIgSFRNTF9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJ3wnICsgY29tbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBwcm9jZXNzaW5nICsgJ3wnICsgZGVjbGFyYXRpb24gKyAnfCcgKyBjZGF0YSArICcpJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpO1xuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xubW9kdWxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IEhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qcyIsIi8vIFByb2Nlc3MgKnRoaXMqIGFuZCBfdGhhdF9cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChtYXJrZXIgIT09IDB4NUYgLyogXyAqLyAmJiBtYXJrZXIgIT09IDB4MkEgLyogKiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIG1hcmtlciA9PT0gMHgyQSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNjYW5uZWQubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgIC8vIENoYXIgY29kZSBvZiB0aGUgc3RhcnRpbmcgbWFya2VyIChudW1iZXIpLlxuICAgICAgLy9cbiAgICAgIG1hcmtlcjogbWFya2VyLFxuXG4gICAgICAvLyBUb3RhbCBsZW5ndGggb2YgdGhlc2Ugc2VyaWVzIG9mIGRlbGltaXRlcnMuXG4gICAgICAvL1xuICAgICAgbGVuZ3RoOiBzY2FubmVkLmxlbmd0aCxcblxuICAgICAgLy8gQW4gYW1vdW50IG9mIGNoYXJhY3RlcnMgYmVmb3JlIHRoaXMgb25lIHRoYXQncyBlcXVpdmFsZW50IHRvXG4gICAgICAvLyBjdXJyZW50IG9uZS4gSW4gcGxhaW4gRW5nbGlzaDogaWYgdGhpcyBkZWxpbWl0ZXIgZG9lcyBub3Qgb3BlblxuICAgICAgLy8gYW4gZW1waGFzaXMsIG5laXRoZXIgZG8gcHJldmlvdXMgYGp1bXBgIGNoYXJhY3RlcnMuXG4gICAgICAvL1xuICAgICAgLy8gVXNlZCB0byBza2lwIHNlcXVlbmNlcyBsaWtlIFwiKioqKipcIiBpbiBvbmUgc3RlcCwgZm9yIDFzdCBhc3Rlcmlza1xuICAgICAgLy8gdmFsdWUgd2lsbCBiZSAwLCBmb3IgMm5kIGl0J3MgMSBhbmQgc28gb24uXG4gICAgICAvL1xuICAgICAganVtcDogICBpLFxuXG4gICAgICAvLyBBIHBvc2l0aW9uIG9mIHRoZSB0b2tlbiB0aGlzIGRlbGltaXRlciBjb3JyZXNwb25kcyB0by5cbiAgICAgIC8vXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuXG4gICAgICAvLyBUb2tlbiBsZXZlbC5cbiAgICAgIC8vXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuXG4gICAgICAvLyBJZiB0aGlzIGRlbGltaXRlciBpcyBtYXRjaGVkIGFzIGEgdmFsaWQgb3BlbmVyLCBgZW5kYCB3aWxsIGJlXG4gICAgICAvLyBlcXVhbCB0byBpdHMgcG9zaXRpb24sIG90aGVyd2lzZSBpdCdzIGAtMWAuXG4gICAgICAvL1xuICAgICAgZW5kOiAgICAtMSxcblxuICAgICAgLy8gQm9vbGVhbiBmbGFncyB0aGF0IGRldGVybWluZSBpZiB0aGlzIGRlbGltaXRlciBjb3VsZCBvcGVuIG9yIGNsb3NlXG4gICAgICAvLyBhbiBlbXBoYXNpcy5cbiAgICAgIC8vXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlKSB7XG4gIHZhciBpLFxuICAgICAgc3RhcnREZWxpbSxcbiAgICAgIGVuZERlbGltLFxuICAgICAgdG9rZW4sXG4gICAgICBjaCxcbiAgICAgIGlzU3Ryb25nLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBzdGFydERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg1Ri8qIF8gKi8gJiYgc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4MkEvKiAqICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIG9ubHkgb3BlbmluZyBtYXJrZXJzXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIC8vIElmIHRoZSBuZXh0IGRlbGltaXRlciBoYXMgdGhlIHNhbWUgbWFya2VyIGFuZCBpcyBhZGphY2VudCB0byB0aGlzIG9uZSxcbiAgICAvLyBtZXJnZSB0aG9zZSBpbnRvIG9uZSBzdHJvbmcgZGVsaW1pdGVyLlxuICAgIC8vXG4gICAgLy8gYDxlbT48ZW0+d2hhdGV2ZXI8L2VtPjwvZW0+YCAtPiBgPHN0cm9uZz53aGF0ZXZlcjwvc3Ryb25nPmBcbiAgICAvL1xuICAgIGlzU3Ryb25nID0gaSArIDEgPCBtYXggJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSArIDFdLmVuZCA9PT0gc3RhcnREZWxpbS5lbmQgLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS50b2tlbiA9PT0gc3RhcnREZWxpbS50b2tlbiArIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgLSAxXS50b2tlbiA9PT0gZW5kRGVsaW0udG9rZW4gLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS5tYXJrZXIgPT09IHN0YXJ0RGVsaW0ubWFya2VyO1xuXG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0RGVsaW0ubWFya2VyKTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19vcGVuJyA6ICdlbV9vcGVuJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfY2xvc2UnIDogJ2VtX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoaXNTdHJvbmcpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW2kgKyAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgLSAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIi8vIH5+c3RyaWtlIHRocm91Z2h+flxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBJbnNlcnQgZWFjaCBtYXJrZXIgYXMgYSBzZXBhcmF0ZSB0ZXh0IHRva2VuLCBhbmQgYWRkIGl0IHRvIGRlbGltaXRlciBsaXN0XG4vL1xubW9kdWxlLmV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLCBsZW4sIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIHRydWUpO1xuICBsZW4gPSBzY2FubmVkLmxlbmd0aDtcbiAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgaWYgKGxlbiA8IDIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGxlbiAlIDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2g7XG4gICAgbGVuLS07XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2ggKyBjaDtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgIGp1bXA6ICAgaSxcbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuICAgICAgZW5kOiAgICAtMSxcbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSkge1xuICB2YXIgaSwgaixcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgbG9uZU1hcmtlcnMgPSBbXSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4N0UvKiB+ICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3Nfb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9ICdzJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3NfY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSAnfn4nO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW4gLSAxXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0uY29udGVudCA9PT0gJ34nKSB7XG5cbiAgICAgIGxvbmVNYXJrZXJzLnB1c2goZW5kRGVsaW0udG9rZW4gLSAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBhIG1hcmtlciBzZXF1ZW5jZSBoYXMgYW4gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBpdCdzIHNwbGl0dGVkXG4gIC8vIGxpa2UgdGhpczogYH5+fn5+YCAtPiBgfmAgKyBgfn5gICsgYH5+YCwgbGVhdmluZyBvbmUgbWFya2VyIGF0IHRoZVxuICAvLyBzdGFydCBvZiB0aGUgc2VxdWVuY2UuXG4gIC8vXG4gIC8vIFNvLCB3ZSBoYXZlIHRvIG1vdmUgYWxsIHRob3NlIG1hcmtlcnMgYWZ0ZXIgc3Vic2VxdWVudCBzX2Nsb3NlIHRhZ3MuXG4gIC8vXG4gIHdoaWxlIChsb25lTWFya2Vycy5sZW5ndGgpIHtcbiAgICBpID0gbG9uZU1hcmtlcnMucG9wKCk7XG4gICAgaiA9IGkgKyAxO1xuXG4gICAgd2hpbGUgKGogPCBzdGF0ZS50b2tlbnMubGVuZ3RoICYmIHN0YXRlLnRva2Vuc1tqXS50eXBlID09PSAnc19jbG9zZScpIHtcbiAgICAgIGorKztcbiAgICB9XG5cbiAgICBqLS07XG5cbiAgICBpZiAoaSAhPT0gaikge1xuICAgICAgdG9rZW4gPSBzdGF0ZS50b2tlbnNbal07XG4gICAgICBzdGF0ZS50b2tlbnNbal0gPSBzdGF0ZS50b2tlbnNbaV07XG4gICAgICBzdGF0ZS50b2tlbnNbaV0gPSB0b2tlbjtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx4MUZcXHg3Ri1cXHg5Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHRcdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0XHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyIFxuXHRcdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHRcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRcdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcblx0fSksXG5cdGdldEVsZW1lbnQgPSAoZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdFx0fTtcblx0fSkoZnVuY3Rpb24gKHN0eWxlVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3R5bGVUYXJnZXQpXG5cdH0pLFxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW10sXG5cdGZpeFVybHMgPSByZXF1aXJlKFwiLi9maXhVcmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRJbnRvID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblx0aWYgKCFzdHlsZVRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgc3R5bGVUYXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHRzdHlsZVRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0c3R5bGVUYXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhzdHlsZUVsZW1lbnQsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGF0dGFjaFRhZ0F0dHJzKGxpbmtFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUYWdBdHRycyhlbGVtZW50LCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKiBJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscyl7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcblxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuaW1wb3J0IENlbGwgZnJvbSAnbGlicy9jb21wb25lbnRzL2NlbGwnO1xuaW1wb3J0IFRpdGxlIGZyb20gJ2xpYnMvY29tcG9uZW50cy90aXRsZSc7XG5pbXBvcnQgVGFncyBmcm9tICdsaWJzL2NvbXBvbmVudHMvdGFncyc7XG5pbXBvcnQgU2x1ZyBmcm9tICdsaWJzL2NvbXBvbmVudHMvc2x1Zyc7XG5pbXBvcnQgRWRpdG9yIGZyb20gJ2xpYnMvY29tcG9uZW50cy9lZGl0b3InO1xuaW1wb3J0IFByZXZpZXcgZnJvbSAnbGlicy9jb21wb25lbnRzL3ByZXZpZXcnO1xuaW1wb3J0IFNhdmUgZnJvbSAnbGlicy9jb21wb25lbnRzL3NhdmUnO1xuaW1wb3J0IE1vZGVsIGZyb20gJ2xpYnMvbW9kZWxzL2FydGljbGUnO1xuXG5jb25zdCBtb2RlbCA9IG5ldyBNb2RlbCgpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIG1vZGVsLmZldGNoKCk7XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBpZiAobW9kZWwuZmV0Y2hlZCkge1xuICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPSdtZGwtZ3JpZCc+XG4gICAgICAgIDxUaXRsZSBtb2RlbD17bW9kZWx9IC8+XG4gICAgICAgIDxTbHVnIG1vZGVsPXttb2RlbH0gLz5cbiAgICAgICAgPFRhZ3MgbW9kZWw9e21vZGVsfSAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmVkaXRvcldyYXB9PlxuICAgICAgICAgIDxFZGl0b3Iga2V5PSdlZGl0b3InIG1vZGVsPXttb2RlbH0gLz5cbiAgICAgICAgICA8UHJldmlldyBrZXk9J3ByZXZpZXcnIGJvZHk9e21vZGVsLm1kQm9keSgpfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFNhdmUgbW9kZWw9e21vZGVsfSBvbmNsaWNrPXttb2RlbC51cGRhdGUuYmluZChtb2RlbCl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICB9XG4gICAgcmV0dXJuIDxkaXY+44OH44O844K/5Y+W5b6X5LitLi4uPC9kaXY+XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudC5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50LmpzJ1xuXG5tLm1vdW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJyksIENvbXBvbmVudCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbnRyeS5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9jZWxsLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICB2bm9kZS5zdGF0ZS5tb2RlbCA9IHZub2RlLmF0dHJzLm1vZGVsO1xuICAgIHZub2RlLnN0YXRlLm9uaW5wdXQgPSB2ID0+IHtcbiAgICAgIHZub2RlLnN0YXRlLm1vZGVsLmRhdGEuYm9keSA9IHY7XG4gICAgfTtcbiAgfSxcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gPHRleHRhcmVhXG4gICAgICBjbGFzc05hbWU9e3N0eWxlcy50ZXh0YXJlYX1cbiAgICAgIG9uaW5wdXQ9e20ud2l0aEF0dHIoJ3ZhbHVlJywgdm5vZGUuc3RhdGUub25pbnB1dCl9PlxuICAgICAgICB7dm5vZGUuc3RhdGUubW9kZWwuZGF0YS5ib2R5fVxuICAgIDwvdGV4dGFyZWE+XG4gICAgcmV0dXJuIDxDZWxsIHNwYW49ezZ9IGNscz17YCR7c3R5bGVzLmVkaXRvcn0gJHtzdHlsZXMuZWRpdG9yTGVmdFNpZGV9YH0gaW5uZXI9e2lubmVyfSAvPlxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvY29tcG9uZW50cy9lZGl0b3IuanMiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMuY3NzJztcbmltcG9ydCBDZWxsIGZyb20gJy4vY2VsbC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIHJldHVybiA8Q2VsbCBzcGFuPXs2fSBjbHM9e2Ake3N0eWxlcy5lZGl0b3J9ICR7c3R5bGVzLmVkaXRvclJpZ2h0U2lkZX1gfVxuICAgICAgICAgICAgICAgICBpbm5lcj17bS50cnVzdCh2bm9kZS5hdHRycy5ib2R5KX0gLz5cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvY29tcG9uZW50cy9wcmV2aWV3LmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gICAgdm5vZGUuc3RhdGUub25jbGljayA9IHZub2RlLmF0dHJzLm9uY2xpY2s7XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBjb25zdCBpbm5lciA9IDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT0nbWRsLWJ1dHRvbiBtZGwtanMtYnV0dG9uIG1kbC1idXR0b24tLXJhaXNlZCBtZGwtYnV0dG9uLS1jb2xvcmVkJ1xuICAgICAgb25jbGljaz17dm5vZGUuc3RhdGUub25jbGlja30+XG4gICAgICBzYXZlXG4gICAgPC9idXR0b24+XG4gICAgcmV0dXJuIDxDZWxsIHNwYW49ezEyfSBjbHM9e3N0eWxlcy5zYXZlQnV0dG9ufSBpbm5lcj17aW5uZXJ9IC8+XG4gIH1cbn07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9saWJzL2NvbXBvbmVudHMvc2F2ZS5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9jZWxsLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMuY3NzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICB2bm9kZS5zdGF0ZS5tb2RlbCA9IHZub2RlLmF0dHJzLm1vZGVsO1xuICAgIHZub2RlLnN0YXRlLm9uY2hhbmdlID0gdiA9PiB7XG4gICAgICB2bm9kZS5zdGF0ZS5tb2RlbC5kYXRhLnNsdWcgPSB2O1xuICAgIH07XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBjb25zdCBpbm5lciA9IDxsYWJlbD5cbiAgICAgIFVSTFxuICAgICAgPGlucHV0IHR5cGU9J3RleHQnIGNsYXNzTmFtZT17c3R5bGVzLnNsdWd9XG4gICAgICAgIG9uY2hhbmdlPXttLndpdGhBdHRyKCd2YWx1ZScsIHZub2RlLnN0YXRlLm9uY2hhbmdlKX1cbiAgICAgICAgdmFsdWU9e3Zub2RlLnN0YXRlLm1vZGVsLmRhdGEuc2x1Z31cbiAgICAgIC8+XG4gICAgPC9sYWJlbD5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9saWJzL2NvbXBvbmVudHMvc2x1Zy5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9jZWxsLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICB2bm9kZS5zdGF0ZS5tb2RlbCA9IHZub2RlLmF0dHJzLm1vZGVsO1xuICAgIHZub2RlLnN0YXRlLm9uY2hhbmdlID0gdiA9PiB7XG4gICAgICB2bm9kZS5zdGF0ZS5tb2RlbC5kYXRhLnRhZ3MgPSB2O1xuICAgIH07XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBjb25zdCBpbm5lciA9IDxsYWJlbD5cbiAgICAgIOOCv+OCsFxuICAgICAgPGlucHV0IHR5cGU9J3RleHQnIGNsYXNzTmFtZT17c3R5bGVzLnRhZ3N9XG4gICAgICAgIG9uY2hhbmdlPXttLndpdGhBdHRyKCd2YWx1ZScsIHZub2RlLnN0YXRlLm9uY2hhbmdlKX1cbiAgICAgICAgdmFsdWU9e3Zub2RlLnN0YXRlLm1vZGVsLmRhdGEudGFnc31cbiAgICAgIC8+XG4gICAgPC9sYWJlbD5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvY29tcG9uZW50cy90YWdzLmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gICAgdm5vZGUuc3RhdGUub25jaGFuZ2UgPSB2ID0+IHtcbiAgICAgIHZub2RlLnN0YXRlLm1vZGVsLmRhdGEudGl0bGUgPSB2O1xuICAgIH07XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBjb25zdCBpbm5lciA9IDxsYWJlbD5cbiAgICAgIOOCv+OCpOODiOODq1xuICAgICAgPGlucHV0IHR5cGU9J3RleHQnIGNsYXNzTmFtZT17c3R5bGVzLnRpdGxlfVxuICAgICAgICBvbmNoYW5nZT17bS53aXRoQXR0cigndmFsdWUnLCB2bm9kZS5zdGF0ZS5vbmNoYW5nZSl9XG4gICAgICAgIHZhbHVlPXt2bm9kZS5zdGF0ZS5tb2RlbC5kYXRhLnRpdGxlfVxuICAgICAgLz5cbiAgICA8L2xhYmVsPlxuICAgIHJldHVybiA8Q2VsbCBzcGFuPXsxMn0gaW5uZXI9e2lubmVyfSAvPlxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvY29tcG9uZW50cy90aXRsZS5qcyIsImltcG9ydCByZXF1ZXN0IGZyb20gJy4uL3JlcXVlc3QuanMnO1xuaW1wb3J0IE1hcmtkb3duSXQgZnJvbSAnbWFya2Rvd24taXQnO1xuXG5jb25zdCBtZCA9IG5ldyBNYXJrZG93bkl0KCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwge1xuICAgICAgdGl0bGU6ICcnLFxuICAgICAgYm9keTogJycsXG4gICAgICBzbHVnOiAnJyxcbiAgICAgIHB1Ymxpc2g6IGZhbHNlLFxuICAgICAgdGFnczogJycsXG4gICAgICBkYXRlOiBudWxsLFxuICAgIH07XG4gICAgdGhpcy5mZXRjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZXNvdXJjZXNVcmwgPSAnL2FwaS9hcnRpY2xlcyc7XG4gICAgdGhpcy5yZXNvdXJjZVVybCA9IGAke3RoaXMucmVzb3VyY2VzVXJsfS8ke2xvY2F0aW9uLmhyZWYuc3BsaXQoJy8nKS5zbGljZSg0KS5qb2luKCcvJyl9YDtcbiAgfVxuICBmZXRjaCgpIHtcbiAgICByZXR1cm4gcmVxdWVzdCgnR0VUJywgdGhpcy5yZXNvdXJjZVVybClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgdGhpcy5mZXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kYXRhID0gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlKCkge1xuICAgIHJldHVybiByZXF1ZXN0KCdQT1NUJywgdGhpcy5yZXNvdXJjZXNVcmwsIHRoaXMuZGF0YSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgdGhpcy5kYXRhID0gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHJldHVybiByZXF1ZXN0KCdQVVQnLCB0aGlzLnJlc291cmNlVXJsLCB0aGlzLmRhdGEpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHJlc3BvbnNlO1xuICAgIH0pO1xuICB9XG4gIGRlbGV0ZSgpIHtcbiAgICByZXR1cm4gcmVxdWVzdCgnREVMRVRFJywgdGhpcy5yZXNvdXJjZVVybClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgIH0pO1xuICB9XG4gIG1kQm9keSgpIHtcbiAgICByZXR1cm4gbWQucmVuZGVyKHRoaXMuZGF0YS5ib2R5KTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvbW9kZWxzL2FydGljbGUuanMiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWV0aG9kLCB1cmwsIGRhdGEpIHtcbiAgcmV0dXJuIG0ucmVxdWVzdCh7IG1ldGhvZCwgdXJsLCBkYXRhLCBkZXNlcmlhbGl6ZTogSlNPTi5wYXJzZX0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvcmVxdWVzdC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vYmFzZTY0LWpzL2luZGV4LmpzIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9idWZmZXIvaW5kZXguanMiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaWVlZTc1NC9pbmRleC5qcyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9pc2FycmF5L2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXJzXG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBPYmplY3RdJzsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJzsgfVxuXG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpOyB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmdXp6eUxpbms6IHRydWUsXG4gIGZ1enp5RW1haWw6IHRydWUsXG4gIGZ1enp5SVA6IGZhbHNlXG59O1xuXG5cbmZ1bmN0aW9uIGlzT3B0aW9uc09iaihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGspIHtcbiAgICByZXR1cm4gYWNjIHx8IGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KGspO1xuICB9LCBmYWxzZSk7XG59XG5cblxudmFyIGRlZmF1bHRTY2hlbWFzID0ge1xuICAnaHR0cDonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUuaHR0cCkge1xuICAgICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLmh0dHAgPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXlxcXFwvXFxcXC8nICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLmh0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLmh0dHApWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgJ2h0dHBzOic6ICAnaHR0cDonLFxuICAnZnRwOic6ICAgICdodHRwOicsXG4gICcvLyc6ICAgICAge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm5vX2h0dHApIHtcbiAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUubm9faHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfYXV0aCArXG4gICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgc2luZ2xlLWxldmVsIGRvbWFpbnMsIGJlY2F1c2Ugb2YgZmFsc2UgcG9zaXRpdmVzIGxpa2UgJy8vdGVzdCdcbiAgICAgICAgICAvLyB3aXRoIGNvZGUgY29tbWVudHNcbiAgICAgICAgICAnKD86bG9jYWxob3N0fCg/Oig/OicgKyBzZWxmLnJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsnICsgc2VsZi5yZS5zcmNfZG9tYWluX3Jvb3QgKyAnKScgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BvcnQgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2hvc3RfdGVybWluYXRvciArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcGF0aCxcblxuICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5yZS5ub19odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSBgOi8vYCAmIGAvLy9gLCB0aGF0IHByb3RlY3RzIGZyb20gZXJyb3JzIGluIHByb3RvY29sIG5hbWVcbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICc6JykgeyByZXR1cm4gMDsgfVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJy8nKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubm9faHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnbWFpbHRvOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5tYWlsdG8pIHtcbiAgICAgICAgc2VsZi5yZS5tYWlsdG8gPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXicgKyBzZWxmLnJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgc2VsZi5yZS5zcmNfaG9zdF9zdHJpY3QsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5tYWlsdG8pWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxuLy8gUkUgcGF0dGVybiBmb3IgMi1jaGFyYWN0ZXIgdGxkcyAoYXV0b2dlbmVyYXRlZCBieSAuL3N1cHBvcnQvdGxkc18yY2hhcl9nZW4uanMpXG52YXIgdGxkc18yY2hfc3JjX3JlID0gJ2FbY2RlZmdpbG1ub3Fyc3R1d3h6XXxiW2FiZGVmZ2hpam1ub3JzdHZ3eXpdfGNbYWNkZmdoaWtsbW5vcnV2d3h5el18ZFtlamttb3pdfGVbY2VncnN0dV18Zltpamttb3JdfGdbYWJkZWZnaGlsbW5wcXJzdHV3eV18aFtrbW5ydHVdfGlbZGVsbW5vcXJzdF18altlbW9wXXxrW2VnaGltbnByd3l6XXxsW2FiY2lrcnN0dXZ5XXxtW2FjZGVnaGtsbW5vcHFyc3R1dnd4eXpdfG5bYWNlZmdpbG9wcnV6XXxvbXxwW2FlZmdoa2xtbnJzdHd5XXxxYXxyW2Vvc3V3XXxzW2FiY2RlZ2hpamtsbW5vcnR1dnh5el18dFtjZGZnaGprbG1ub3J0dnd6XXx1W2Fna3N5el18dlthY2VnaW51XXx3W2ZzXXx5W2V0XXx6W2Ftd10nO1xuXG4vLyBET04nVCB0cnkgdG8gbWFrZSBQUnMgd2l0aCBjaGFuZ2VzLiBFeHRlbmQgVExEcyB3aXRoIExpbmtpZnlJdC50bGRzKCkgaW5zdGVhZFxudmFyIHRsZHNfZGVmYXVsdCA9ICdiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhCcuc3BsaXQoJ3wnKTtcblxuLyplc2xpbnQtZW5hYmxlIG1heC1sZW4qL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiByZXNldFNjYW5DYWNoZShzZWxmKSB7XG4gIHNlbGYuX19pbmRleF9fID0gLTE7XG4gIHNlbGYuX190ZXh0X2NhY2hlX18gICA9ICcnO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0b3IocmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0LCBwb3MpIHtcbiAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgIGlmIChyZS50ZXN0KHRhaWwpKSB7XG4gICAgICByZXR1cm4gdGFpbC5tYXRjaChyZSlbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXplcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwgc2VsZikge1xuICAgIHNlbGYubm9ybWFsaXplKG1hdGNoKTtcbiAgfTtcbn1cblxuLy8gU2NoZW1hcyBjb21waWxlci4gQnVpbGQgcmVnZXhwcy5cbi8vXG5mdW5jdGlvbiBjb21waWxlKHNlbGYpIHtcblxuICAvLyBMb2FkICYgY2xvbmUgUkUgcGF0dGVybnMuXG4gIHZhciByZSA9IHNlbGYucmUgPSByZXF1aXJlKCcuL2xpYi9yZScpKHNlbGYuX19vcHRzX18pO1xuXG4gIC8vIERlZmluZSBkeW5hbWljIHBhdHRlcm5zXG4gIHZhciB0bGRzID0gc2VsZi5fX3RsZHNfXy5zbGljZSgpO1xuXG4gIHNlbGYub25Db21waWxlKCk7XG5cbiAgaWYgKCFzZWxmLl9fdGxkc19yZXBsYWNlZF9fKSB7XG4gICAgdGxkcy5wdXNoKHRsZHNfMmNoX3NyY19yZSk7XG4gIH1cbiAgdGxkcy5wdXNoKHJlLnNyY194bik7XG5cbiAgcmUuc3JjX3RsZHMgPSB0bGRzLmpvaW4oJ3wnKTtcblxuICBmdW5jdGlvbiB1bnRwbCh0cGwpIHsgcmV0dXJuIHRwbC5yZXBsYWNlKCclVExEUyUnLCByZS5zcmNfdGxkcyk7IH1cblxuICByZS5lbWFpbF9mdXp6eSAgICAgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9lbWFpbF9mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfZnV6enkgICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfZnV6enkpLCAnaScpO1xuICByZS5saW5rX25vX2lwX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX25vX2lwX2Z1enp5KSwgJ2knKTtcbiAgcmUuaG9zdF9mdXp6eV90ZXN0ICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfaG9zdF9mdXp6eV90ZXN0KSwgJ2knKTtcblxuICAvL1xuICAvLyBDb21waWxlIGVhY2ggc2NoZW1hXG4gIC8vXG5cbiAgdmFyIGFsaWFzZXMgPSBbXTtcblxuICBzZWxmLl9fY29tcGlsZWRfXyA9IHt9OyAvLyBSZXNldCBjb21waWxlZCBkYXRhXG5cbiAgZnVuY3Rpb24gc2NoZW1hRXJyb3IobmFtZSwgdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcoTGlua2lmeUl0KSBJbnZhbGlkIHNjaGVtYSBcIicgKyBuYW1lICsgJ1wiOiAnICsgdmFsKTtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNlbGYuX19zY2hlbWFzX18pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsID0gc2VsZi5fX3NjaGVtYXNfX1tuYW1lXTtcblxuICAgIC8vIHNraXAgZGlzYWJsZWQgbWV0aG9kc1xuICAgIGlmICh2YWwgPT09IG51bGwpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSB7IHZhbGlkYXRlOiBudWxsLCBsaW5rOiBudWxsIH07XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXSA9IGNvbXBpbGVkO1xuXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gY3JlYXRlVmFsaWRhdG9yKHZhbC52YWxpZGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IHZhbC52YWxpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbC5ub3JtYWxpemUpKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XG4gICAgICB9IGVsc2UgaWYgKCF2YWwubm9ybWFsaXplKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IGNyZWF0ZU5vcm1hbGl6ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgYWxpYXNlcy5wdXNoKG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgcG9zdHBvbmVkIGFsaWFzZXNcbiAgLy9cblxuICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgaWYgKCFzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0pIHtcbiAgICAgIC8vIFNpbGVudGx5IGZhaWwgb24gbWlzc2VkIHNjaGVtYXMgdG8gYXZvaWQgZXJyb25zIG9uIGRpc2FibGUuXG4gICAgICAvLyBzY2hlbWFFcnJvcihhbGlhcywgc2VsZi5fX3NjaGVtYXNfX1thbGlhc10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS52YWxpZGF0ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLm5vcm1hbGl6ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0ubm9ybWFsaXplO1xuICB9KTtcblxuICAvL1xuICAvLyBGYWtlIHJlY29yZCBmb3IgZ3Vlc3NlZCBsaW5rc1xuICAvL1xuICBzZWxmLl9fY29tcGlsZWRfX1snJ10gPSB7IHZhbGlkYXRlOiBudWxsLCBub3JtYWxpemU6IGNyZWF0ZU5vcm1hbGl6ZXIoKSB9O1xuXG4gIC8vXG4gIC8vIEJ1aWxkIHNjaGVtYSBjb25kaXRpb25cbiAgLy9cbiAgdmFyIHNsaXN0ID0gT2JqZWN0LmtleXMoc2VsZi5fX2NvbXBpbGVkX18pXG4gICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGRpc2FibGVkICYgZmFrZSBzY2hlbWFzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGggPiAwICYmIHNlbGYuX19jb21waWxlZF9fW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChlc2NhcGVSRSlcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbignfCcpO1xuICAvLyAoPyFfKSBjYXVzZSAxLjV4IHNsb3dkb3duXG4gIHNlbGYucmUuc2NoZW1hX3Rlc3QgICA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaScpO1xuICBzZWxmLnJlLnNjaGVtYV9zZWFyY2ggPSBSZWdFeHAoJyhefCg/IV8pKD86Wz48XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2lnJyk7XG5cbiAgc2VsZi5yZS5wcmV0ZXN0ICAgICAgID0gUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNlbGYucmUuc2NoZW1hX3Rlc3Quc291cmNlICsgJyl8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5ob3N0X2Z1enp5X3Rlc3Quc291cmNlICsgJyl8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpJyk7XG5cbiAgLy9cbiAgLy8gQ2xlYW51cFxuICAvL1xuXG4gIHJlc2V0U2NhbkNhY2hlKHNlbGYpO1xufVxuXG4vKipcbiAqIGNsYXNzIE1hdGNoXG4gKlxuICogTWF0Y2ggcmVzdWx0LiBTaW5nbGUgZWxlbWVudCBvZiBhcnJheSwgcmV0dXJuZWQgYnkgW1tMaW5raWZ5SXQjbWF0Y2hdXVxuICoqL1xuZnVuY3Rpb24gTWF0Y2goc2VsZiwgc2hpZnQpIHtcbiAgdmFyIHN0YXJ0ID0gc2VsZi5fX2luZGV4X18sXG4gICAgICBlbmQgICA9IHNlbGYuX19sYXN0X2luZGV4X18sXG4gICAgICB0ZXh0ICA9IHNlbGYuX190ZXh0X2NhY2hlX18uc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgLyoqXG4gICAqIE1hdGNoI3NjaGVtYSAtPiBTdHJpbmdcbiAgICpcbiAgICogUHJlZml4IChwcm90b2NvbCkgZm9yIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMuc2NoZW1hICAgID0gc2VsZi5fX3NjaGVtYV9fLnRvTG93ZXJDYXNlKCk7XG4gIC8qKlxuICAgKiBNYXRjaCNpbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogRmlyc3QgcG9zaXRpb24gb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5pbmRleCAgICAgPSBzdGFydCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjbGFzdEluZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBOZXh0IHBvc2l0aW9uIGFmdGVyIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMubGFzdEluZGV4ID0gZW5kICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNyYXcgLT4gU3RyaW5nXG4gICAqXG4gICAqIE1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMucmF3ICAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3RleHQgLT4gU3RyaW5nXG4gICAqXG4gICAqIE5vdG1hbGl6ZWQgdGV4dCBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnRleHQgICAgICA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN1cmwgLT4gU3RyaW5nXG4gICAqXG4gICAqIE5vcm1hbGl6ZWQgdXJsIG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudXJsICAgICAgID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2goc2VsZiwgc2hpZnQpIHtcbiAgdmFyIG1hdGNoID0gbmV3IE1hdGNoKHNlbGYsIHNoaWZ0KTtcblxuICBzZWxmLl9fY29tcGlsZWRfX1ttYXRjaC5zY2hlbWFdLm5vcm1hbGl6ZShtYXRjaCwgc2VsZik7XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5cbi8qKlxuICogY2xhc3MgTGlua2lmeUl0XG4gKiovXG5cbi8qKlxuICogbmV3IExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKVxuICogLSBzY2hlbWFzIChPYmplY3QpOiBPcHRpb25hbC4gQWRkaXRpb25hbCBzY2hlbWFzIHRvIHZhbGlkYXRlIChwcmVmaXgvdmFsaWRhdG9yKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIENyZWF0ZXMgbmV3IGxpbmtpZmllciBpbnN0YW5jZSB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgc2NoZW1hcy5cbiAqIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YCBrZXl3b3JkIGZvciBjb252ZW5pZW5jZS5cbiAqXG4gKiBCeSBkZWZhdWx0IHVuZGVyc3RhbmRzOlxuICpcbiAqIC0gYGh0dHAocyk6Ly8uLi5gICwgYGZ0cDovLy4uLmAsIGBtYWlsdG86Li4uYCAmIGAvLy4uLmAgbGlua3NcbiAqIC0gXCJmdXp6eVwiIGxpbmtzIGFuZCBlbWFpbHMgKGV4YW1wbGUuY29tLCBmb29AYmFyLmNvbSkuXG4gKlxuICogYHNjaGVtYXNgIGlzIGFuIG9iamVjdCwgd2hlcmUgZWFjaCBrZXkvdmFsdWUgZGVzY3JpYmVzIHByb3RvY29sL3J1bGU6XG4gKlxuICogLSBfX2tleV9fIC0gbGluayBwcmVmaXggKHVzdWFsbHksIHByb3RvY29sIG5hbWUgd2l0aCBgOmAgYXQgdGhlIGVuZCwgYHNreXBlOmBcbiAqICAgZm9yIGV4YW1wbGUpLiBgbGlua2lmeS1pdGAgbWFrZXMgc2h1cmUgdGhhdCBwcmVmaXggaXMgbm90IHByZWNlZWRlZCB3aXRoXG4gKiAgIGFscGhhbnVtZXJpYyBjaGFyIGFuZCBzeW1ib2xzLiBPbmx5IHdoaXRlc3BhY2VzIGFuZCBwdW5jdHVhdGlvbiBhbGxvd2VkLlxuICogLSBfX3ZhbHVlX18gLSBydWxlIHRvIGNoZWNrIHRhaWwgYWZ0ZXIgbGluayBwcmVmaXhcbiAqICAgLSBfU3RyaW5nXyAtIGp1c3QgYWxpYXMgdG8gZXhpc3RpbmcgcnVsZVxuICogICAtIF9PYmplY3RfXG4gKiAgICAgLSBfdmFsaWRhdGVfIC0gdmFsaWRhdG9yIGZ1bmN0aW9uIChzaG91bGQgcmV0dXJuIG1hdGNoZWQgbGVuZ3RoIG9uIHN1Y2Nlc3MpLFxuICogICAgICAgb3IgYFJlZ0V4cGAuXG4gKiAgICAgLSBfbm9ybWFsaXplXyAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSB0ZXh0ICYgdXJsIG9mIG1hdGNoZWQgcmVzdWx0XG4gKiAgICAgICAoZm9yIGV4YW1wbGUsIGZvciBAdHdpdHRlciBtZW50aW9ucykuXG4gKlxuICogYG9wdGlvbnNgOlxuICpcbiAqIC0gX19mdXp6eUxpbmtfXyAtIHJlY29nbmlnZSBVUkwtcyB3aXRob3V0IGBodHRwKHMpOmAgcHJlZml4LiBEZWZhdWx0IGB0cnVlYC5cbiAqIC0gX19mdXp6eUlQX18gLSBhbGxvdyBJUHMgaW4gZnV6enkgbGlua3MgYWJvdmUuIENhbiBjb25mbGljdCB3aXRoIHNvbWUgdGV4dHNcbiAqICAgbGlrZSB2ZXJzaW9uIG51bWJlcnMuIERlZmF1bHQgYGZhbHNlYC5cbiAqIC0gX19mdXp6eUVtYWlsX18gLSByZWNvZ25pemUgZW1haWxzIHdpdGhvdXQgYG1haWx0bzpgIHByZWZpeC5cbiAqXG4gKiovXG5mdW5jdGlvbiBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlua2lmeUl0KSkge1xuICAgIHJldHVybiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKGlzT3B0aW9uc09iaihzY2hlbWFzKSkge1xuICAgICAgb3B0aW9ucyA9IHNjaGVtYXM7XG4gICAgICBzY2hlbWFzID0ge307XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fX29wdHNfXyAgICAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAvLyBDYWNoZSBsYXN0IHRlc3RlZCByZXN1bHQuIFVzZWQgdG8gc2tpcCByZXBlYXRpbmcgc3RlcHMgb24gbmV4dCBgbWF0Y2hgIGNhbGwuXG4gIHRoaXMuX19pbmRleF9fICAgICAgICAgID0gLTE7XG4gIHRoaXMuX19sYXN0X2luZGV4X18gICAgID0gLTE7IC8vIE5leHQgc2NhbiBwb3NpdGlvblxuICB0aGlzLl9fc2NoZW1hX18gICAgICAgICA9ICcnO1xuICB0aGlzLl9fdGV4dF9jYWNoZV9fICAgICA9ICcnO1xuXG4gIHRoaXMuX19zY2hlbWFzX18gICAgICAgID0gYXNzaWduKHt9LCBkZWZhdWx0U2NoZW1hcywgc2NoZW1hcyk7XG4gIHRoaXMuX19jb21waWxlZF9fICAgICAgID0ge307XG5cbiAgdGhpcy5fX3RsZHNfXyAgICAgICAgICAgPSB0bGRzX2RlZmF1bHQ7XG4gIHRoaXMuX190bGRzX3JlcGxhY2VkX18gID0gZmFsc2U7XG5cbiAgdGhpcy5yZSA9IHt9O1xuXG4gIGNvbXBpbGUodGhpcyk7XG59XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I2FkZChzY2hlbWEsIGRlZmluaXRpb24pXG4gKiAtIHNjaGVtYSAoU3RyaW5nKTogcnVsZSBuYW1lIChmaXhlZCBwYXR0ZXJuIHByZWZpeClcbiAqIC0gZGVmaW5pdGlvbiAoU3RyaW5nfFJlZ0V4cHxPYmplY3QpOiBzY2hlbWEgZGVmaW5pdGlvblxuICpcbiAqIEFkZCBuZXcgcnVsZSBkZWZpbml0aW9uLiBTZWUgY29uc3RydWN0b3IgZGVzY3JpcHRpb24gZm9yIGRldGFpbHMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChzY2hlbWEsIGRlZmluaXRpb24pIHtcbiAgdGhpcy5fX3NjaGVtYXNfX1tzY2hlbWFdID0gZGVmaW5pdGlvbjtcbiAgY29tcGlsZSh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNzZXQob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogeyBmdXp6eUxpbmt8ZnV6enlFbWFpbHxmdXp6eUlQOiB0cnVlfGZhbHNlIH1cbiAqXG4gKiBTZXQgcmVjb2duaXRpb24gb3B0aW9ucyBmb3IgbGlua3Mgd2l0aG91dCBzY2hlbWEuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gIHRoaXMuX19vcHRzX18gPSBhc3NpZ24odGhpcy5fX29wdHNfXywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBTZWFyY2hlcyBsaW5raWZpYWJsZSBwYXR0ZXJuIGFuZCByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzIG9yIGBmYWxzZWAgb24gZmFpbC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QodGV4dCkge1xuICAvLyBSZXNldCBzY2FuIGNhY2hlXG4gIHRoaXMuX190ZXh0X2NhY2hlX18gPSB0ZXh0O1xuICB0aGlzLl9faW5kZXhfXyAgICAgID0gLTE7XG5cbiAgaWYgKCF0ZXh0Lmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICB2YXIgbSwgbWwsIG1lLCBsZW4sIHNoaWZ0LCBuZXh0LCByZSwgdGxkX3BvcywgYXRfcG9zO1xuXG4gIC8vIHRyeSB0byBzY2FuIGZvciBsaW5rIHdpdGggc2NoZW1hIC0gdGhhdCdzIHRoZSBtb3N0IHNpbXBsZSBydWxlXG4gIGlmICh0aGlzLnJlLnNjaGVtYV90ZXN0LnRlc3QodGV4dCkpIHtcbiAgICByZSA9IHRoaXMucmUuc2NoZW1hX3NlYXJjaDtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgobSA9IHJlLmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICBsZW4gPSB0aGlzLnRlc3RTY2hlbWFBdCh0ZXh0LCBtWzJdLCByZS5sYXN0SW5kZXgpO1xuICAgICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gbVsyXTtcbiAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IG0uaW5kZXggKyBtWzFdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aCArIGxlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlMaW5rICYmIHRoaXMuX19jb21waWxlZF9fWydodHRwOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBsaW5rc1xuICAgIHRsZF9wb3MgPSB0ZXh0LnNlYXJjaCh0aGlzLnJlLmhvc3RfZnV6enlfdGVzdCk7XG4gICAgaWYgKHRsZF9wb3MgPj0gMCkge1xuICAgICAgLy8gaWYgdGxkIGlzIGxvY2F0ZWQgYWZ0ZXIgZm91bmQgbGluayAtIG5vIG5lZWQgdG8gY2hlY2sgZnV6enkgcGF0dGVyblxuICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCB0bGRfcG9zIDwgdGhpcy5fX2luZGV4X18pIHtcbiAgICAgICAgaWYgKChtbCA9IHRleHQubWF0Y2godGhpcy5fX29wdHNfXy5mdXp6eUlQID8gdGhpcy5yZS5saW5rX2Z1enp5IDogdGhpcy5yZS5saW5rX25vX2lwX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICAgIHNoaWZ0ID0gbWwuaW5kZXggKyBtbFsxXS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHNoaWZ0IDwgdGhpcy5fX2luZGV4X18pIHtcbiAgICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSAnJztcbiAgICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtbC5pbmRleCArIG1sWzBdLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUVtYWlsICYmIHRoaXMuX19jb21waWxlZF9fWydtYWlsdG86J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGVtYWlsc1xuICAgIGF0X3BvcyA9IHRleHQuaW5kZXhPZignQCcpO1xuICAgIGlmIChhdF9wb3MgPj0gMCkge1xuICAgICAgLy8gV2UgY2FuJ3Qgc2tpcCB0aGlzIGNoZWNrLCBiZWNhdXNlIHRoaXMgY2FzZXMgYXJlIHBvc3NpYmxlOlxuICAgICAgLy8gMTkyLjE2OC4xLjFAZ21haWwuY29tLCBteS5pbkBleGFtcGxlLmNvbVxuICAgICAgaWYgKChtZSA9IHRleHQubWF0Y2godGhpcy5yZS5lbWFpbF9mdXp6eSkpICE9PSBudWxsKSB7XG5cbiAgICAgICAgc2hpZnQgPSBtZS5pbmRleCArIG1lWzFdLmxlbmd0aDtcbiAgICAgICAgbmV4dCAgPSBtZS5pbmRleCArIG1lWzBdLmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHNoaWZ0IDwgdGhpcy5fX2luZGV4X18gfHxcbiAgICAgICAgICAgIChzaGlmdCA9PT0gdGhpcy5fX2luZGV4X18gJiYgbmV4dCA+IHRoaXMuX19sYXN0X2luZGV4X18pKSB7XG4gICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICdtYWlsdG86JztcbiAgICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gc2hpZnQ7XG4gICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX2luZGV4X18gPj0gMDtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjcHJldGVzdCh0ZXh0KSAtPiBCb29sZWFuXG4gKlxuICogVmVyeSBxdWljayBjaGVjaywgdGhhdCBjYW4gZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMuIFJldHVybnMgdHJ1ZSBpZiBsaW5rIE1BWSBCRVxuICogY2FuIGV4aXN0cy4gQ2FuIGJlIHVzZWQgZm9yIHNwZWVkIG9wdGltaXphdGlvbiwgd2hlbiB5b3UgbmVlZCB0byBjaGVjayB0aGF0XG4gKiBsaW5rIE5PVCBleGlzdHMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnByZXRlc3QgPSBmdW5jdGlvbiBwcmV0ZXN0KHRleHQpIHtcbiAgcmV0dXJuIHRoaXMucmUucHJldGVzdC50ZXN0KHRleHQpO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0U2NoZW1hQXQodGV4dCwgbmFtZSwgcG9zaXRpb24pIC0+IE51bWJlclxuICogLSB0ZXh0IChTdHJpbmcpOiB0ZXh0IHRvIHNjYW5cbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSAoc2NoZW1hKSBuYW1lXG4gKiAtIHBvc2l0aW9uIChOdW1iZXIpOiB0ZXh0IG9mZnNldCB0byBjaGVjayBmcm9tXG4gKlxuICogU2ltaWxhciB0byBbW0xpbmtpZnlJdCN0ZXN0XV0gYnV0IGNoZWNrcyBvbmx5IHNwZWNpZmljIHByb3RvY29sIHRhaWwgZXhhY3RseVxuICogYXQgZ2l2ZW4gcG9zaXRpb24uIFJldHVybnMgbGVuZ3RoIG9mIGZvdW5kIHBhdHRlcm4gKDAgb24gZmFpbCkuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRlc3RTY2hlbWFBdCA9IGZ1bmN0aW9uIHRlc3RTY2hlbWFBdCh0ZXh0LCBzY2hlbWEsIHBvcykge1xuICAvLyBJZiBub3Qgc3VwcG9ydGVkIHNjaGVtYSBjaGVjayByZXF1ZXN0ZWQgLSB0ZXJtaW5hdGVcbiAgaWYgKCF0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldLnZhbGlkYXRlKHRleHQsIHBvcywgdGhpcyk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I21hdGNoKHRleHQpIC0+IEFycmF5fG51bGxcbiAqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGZvdW5kIGxpbmsgZGVzY3JpcHRpb25zIG9yIGBudWxsYCBvbiBmYWlsLiBXZSBzdHJvbmdseVxuICogcmVjb21tZW5kIHRvIHVzZSBbW0xpbmtpZnlJdCN0ZXN0XV0gZmlyc3QsIGZvciBiZXN0IHNwZWVkLlxuICpcbiAqICMjIyMjIFJlc3VsdCBtYXRjaCBkZXNjcmlwdGlvblxuICpcbiAqIC0gX19zY2hlbWFfXyAtIGxpbmsgc2NoZW1hLCBjYW4gYmUgZW1wdHkgZm9yIGZ1enp5IGxpbmtzLCBvciBgLy9gIGZvclxuICogICBwcm90b2NvbC1uZXV0cmFsICBsaW5rcy5cbiAqIC0gX19pbmRleF9fIC0gb2Zmc2V0IG9mIG1hdGNoZWQgdGV4dFxuICogLSBfX2xhc3RJbmRleF9fIC0gaW5kZXggb2YgbmV4dCBjaGFyIGFmdGVyIG1hdGhjaCBlbmRcbiAqIC0gX19yYXdfXyAtIG1hdGNoZWQgdGV4dFxuICogLSBfX3RleHRfXyAtIG5vcm1hbGl6ZWQgdGV4dFxuICogLSBfX3VybF9fIC0gbGluaywgZ2VuZXJhdGVkIGZyb20gbWF0Y2hlZCB0ZXh0XG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2godGV4dCkge1xuICB2YXIgc2hpZnQgPSAwLCByZXN1bHQgPSBbXTtcblxuICAvLyBUcnkgdG8gdGFrZSBwcmV2aW91cyBlbGVtZW50IGZyb20gY2FjaGUsIGlmIC50ZXN0KCkgY2FsbGVkIGJlZm9yZVxuICBpZiAodGhpcy5fX2luZGV4X18gPj0gMCAmJiB0aGlzLl9fdGV4dF9jYWNoZV9fID09PSB0ZXh0KSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcbiAgICBzaGlmdCA9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICAvLyBDdXQgaGVhZCBpZiBjYWNoZSB3YXMgdXNlZFxuICB2YXIgdGFpbCA9IHNoaWZ0ID8gdGV4dC5zbGljZShzaGlmdCkgOiB0ZXh0O1xuXG4gIC8vIFNjYW4gc3RyaW5nIHVudGlsIGVuZCByZWFjaGVkXG4gIHdoaWxlICh0aGlzLnRlc3QodGFpbCkpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuXG4gICAgdGFpbCA9IHRhaWwuc2xpY2UodGhpcy5fX2xhc3RfaW5kZXhfXyk7XG4gICAgc2hpZnQgKz0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjdGxkcyhsaXN0IFssIGtlZXBPbGRdKSAtPiB0aGlzXG4gKiAtIGxpc3QgKEFycmF5KTogbGlzdCBvZiB0bGRzXG4gKiAtIGtlZXBPbGQgKEJvb2xlYW4pOiBtZXJnZSB3aXRoIGN1cnJlbnQgbGlzdCBpZiBgdHJ1ZWAgKGBmYWxzZWAgYnkgZGVmYXVsdClcbiAqXG4gKiBMb2FkIChvciBtZXJnZSkgbmV3IHRsZHMgbGlzdC4gVGhvc2UgYXJlIHVzZXIgZm9yIGZ1enp5IGxpbmtzICh3aXRob3V0IHByZWZpeClcbiAqIHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcy4gQnkgZGVmYXVsdCB0aGlzIGFsZ29yeXRobSB1c2VkOlxuICpcbiAqIC0gaG9zdG5hbWUgd2l0aCBhbnkgMi1sZXR0ZXIgcm9vdCB6b25lcyBhcmUgb2suXG4gKiAtIGJpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEXG4gKiAgIGFyZSBvay5cbiAqIC0gZW5jb2RlZCAoYHhuLS0uLi5gKSByb290IHpvbmVzIGFyZSBvay5cbiAqXG4gKiBJZiBsaXN0IGlzIHJlcGxhY2VkLCB0aGVuIGV4YWN0IG1hdGNoIGZvciAyLWNoYXJzIHJvb3Qgem9uZXMgd2lsbCBiZSBjaGVja2VkLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50bGRzID0gZnVuY3Rpb24gdGxkcyhsaXN0LCBrZWVwT2xkKSB7XG4gIGxpc3QgPSBBcnJheS5pc0FycmF5KGxpc3QpID8gbGlzdCA6IFsgbGlzdCBdO1xuXG4gIGlmICgha2VlcE9sZCkge1xuICAgIHRoaXMuX190bGRzX18gPSBsaXN0LnNsaWNlKCk7XG4gICAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyA9IHRydWU7XG4gICAgY29tcGlsZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX190bGRzX18gPSB0aGlzLl9fdGxkc19fLmNvbmNhdChsaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaWR4LCBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbCAhPT0gYXJyW2lkeCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldmVyc2UoKTtcblxuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTGlua2lmeUl0I25vcm1hbGl6ZShtYXRjaClcbiAqXG4gKiBEZWZhdWx0IG5vcm1hbGl6ZXIgKGlmIHNjaGVtYSBkb2VzIG5vdCBkZWZpbmUgaXQncyBvd24pLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWF0Y2gpIHtcblxuICAvLyBEbyBtaW5pbWFsIHBvc3NpYmxlIGNoYW5nZXMgYnkgZGVmYXVsdC4gTmVlZCB0byBjb2xsZWN0IGZlZWRiYWNrIHByaW9yXG4gIC8vIHRvIG1vdmUgZm9yd2FyZCBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdC9pc3N1ZXMvMVxuXG4gIGlmICghbWF0Y2guc2NoZW1hKSB7IG1hdGNoLnVybCA9ICdodHRwOi8vJyArIG1hdGNoLnVybDsgfVxuXG4gIGlmIChtYXRjaC5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdChtYXRjaC51cmwpKSB7XG4gICAgbWF0Y2gudXJsID0gJ21haWx0bzonICsgbWF0Y2gudXJsO1xuICB9XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I29uQ29tcGlsZSgpXG4gKlxuICogT3ZlcnJpZGUgdG8gbW9kaWZ5IGJhc2ljIFJlZ0V4cC1zLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5vbkNvbXBpbGUgPSBmdW5jdGlvbiBvbkNvbXBpbGUoKSB7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2lmeUl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHJlID0ge307XG5cbiAgLy8gVXNlIGRpcmVjdCBleHRyYWN0IGluc3RlYWQgb2YgYHJlZ2VuZXJhdGVgIHRvIHJlZHVzZSBicm93c2VyaWZpZWQgc2l6ZVxuICByZS5zcmNfQW55ID0gcmVxdWlyZSgndWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19DYyAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfWiAgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfUCAgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jykuc291cmNlO1xuXG4gIC8vIFxccHtcXFpcXFBcXENjXFxDRn0gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wgKyBmb3JtYXQgKyBwdW5jdHVhdGlvbilcbiAgcmUuc3JjX1pQQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfUCwgcmUuc3JjX0NjIF0uam9pbignfCcpO1xuXG4gIC8vIFxccHtcXFpcXENjfSAod2hpdGUgc3BhY2VzICsgY29udHJvbClcbiAgcmUuc3JjX1pDYyA9IFsgcmUuc3JjX1osIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBFeHBlcmltZW50YWwuIExpc3Qgb2YgY2hhcnMsIGNvbXBsZXRlbHkgcHJvaGliaXRlZCBpbiBsaW5rc1xuICAvLyBiZWNhdXNlIGNhbiBzZXBhcmF0ZSBpdCBmcm9tIG90aGVyIHBhcnQgb2YgdGV4dFxuICB2YXIgdGV4dF9zZXBhcmF0b3JzID0gJ1s+PFxcdWZmNWNdJztcblxuICAvLyBBbGwgcG9zc2libGUgd29yZCBjaGFyYWN0ZXJzIChldmVyeXRoaW5nIHdpdGhvdXQgcHVuY3R1YXRpb24sIHNwYWNlcyAmIGNvbnRyb2xzKVxuICAvLyBEZWZpbmVkIHZpYSBwdW5jdHVhdGlvbiAmIHNwYWNlcyB0byBzYXZlIHNwYWNlXG4gIC8vIFNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSBcXHB7XFxMXFxOXFxTXFxNfSAoXFx3IGJ1dCB3aXRob3V0IGBfYClcbiAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgICAgICAgPSAnKD86KD8hJyArIHRleHRfc2VwYXJhdG9ycyArICd8JyArIHJlLnNyY19aUENjICsgJyknICsgcmUuc3JjX0FueSArICcpJztcbiAgLy8gVGhlIHNhbWUgYXMgYWJvdGhlIGJ1dCB3aXRob3V0IFswLTldXG4gIC8vIHZhciBzcmNfcHNldWRvX2xldHRlcl9ub25fZCA9ICcoPzooPyFbMC05XXwnICsgc3JjX1pQQ2MgKyAnKScgKyBzcmNfQW55ICsgJyknO1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgcmUuc3JjX2lwNCA9XG5cbiAgICAnKD86KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXFxcLil7M30oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSc7XG5cbiAgLy8gUHJvaGliaXQgYW55IG9mIFwiQC9bXSgpXCIgaW4gdXNlci9wYXNzIHRvIGF2b2lkIHdyb25nIGRvbWFpbiBmZXRjaC5cbiAgcmUuc3JjX2F1dGggICAgPSAnKD86KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtAL1xcXFxbXFxcXF0oKV0pLikrQCk/JztcblxuICByZS5zcmNfcG9ydCA9XG5cbiAgICAnKD86Oig/OjYoPzpbMC00XVxcXFxkezN9fDUoPzpbMC00XVxcXFxkezJ9fDUoPzpbMC0yXVxcXFxkfDNbMC01XSkpKXxbMS01XT9cXFxcZHsxLDR9KSk/JztcblxuICByZS5zcmNfaG9zdF90ZXJtaW5hdG9yID1cblxuICAgICcoPz0kfCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpKD8hLXxffDpcXFxcZHxcXFxcLi18XFxcXC4oPyEkfCcgKyByZS5zcmNfWlBDYyArICcpKSc7XG5cbiAgcmUuc3JjX3BhdGggPVxuXG4gICAgJyg/OicgK1xuICAgICAgJ1svPyNdJyArXG4gICAgICAgICcoPzonICtcbiAgICAgICAgICAnKD8hJyArIHJlLnNyY19aQ2MgKyAnfCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfFsoKVtcXFxcXXt9LixcIlxcJz8hXFxcXC1dKS58JyArXG4gICAgICAgICAgJ1xcXFxbKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFxcXFxdKS4pKlxcXFxdfCcgK1xuICAgICAgICAgICdcXFxcKCg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbKV0pLikqXFxcXCl8JyArXG4gICAgICAgICAgJ1xcXFx7KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFt9XSkuKSpcXFxcfXwnICtcbiAgICAgICAgICAnXFxcXFwiKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtcIl0pLikrXFxcXFwifCcgK1xuICAgICAgICAgIFwiXFxcXCcoPzooPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbJ10pLikrXFxcXCd8XCIgK1xuICAgICAgICAgIFwiXFxcXCcoPz1cIiArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3xbLV0pLnwnICsgIC8vIGFsbG93IGBJJ21fa2luZ2AgaWYgbm8gcGFpciBmb3VuZFxuICAgICAgICAgICdcXFxcLnsyLDN9W2EtekEtWjAtOSUvXXwnICsgLy8gZ2l0aHViIGhhcyAuLi4gaW4gY29tbWl0IHJhbmdlIGxpbmtzLiBSZXN0cmljdCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gZW5nbGlzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGVyY2VudC1lbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwYXJ0cyBvZiBmaWxlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnRpbCBtb3JlIGV4YW1wbGVzIGZvdW5kLlxuICAgICAgICAgICdcXFxcLig/IScgKyByZS5zcmNfWkNjICsgJ3xbLl0pLnwnICtcbiAgICAgICAgICAob3B0cyAmJiBvcHRzWyctLS0nXSA/XG4gICAgICAgICAgICAnXFxcXC0oPyEtLSg/OlteLV18JCkpKD86LSopfCcgLy8gYC0tLWAgPT4gbG9uZyBkYXNoLCB0ZXJtaW5hdGVcbiAgICAgICAgICA6XG4gICAgICAgICAgICAnXFxcXC0rfCdcbiAgICAgICAgICApICtcbiAgICAgICAgICAnXFxcXCwoPyEnICsgcmUuc3JjX1pDYyArICcpLnwnICsgICAgICAvLyBhbGxvdyBgLCwsYCBpbiBwYXRoc1xuICAgICAgICAgICdcXFxcISg/IScgKyByZS5zcmNfWkNjICsgJ3xbIV0pLnwnICtcbiAgICAgICAgICAnXFxcXD8oPyEnICsgcmUuc3JjX1pDYyArICd8Wz9dKS4nICtcbiAgICAgICAgJykrJyArXG4gICAgICAnfFxcXFwvJyArXG4gICAgJyk/JztcblxuICByZS5zcmNfZW1haWxfbmFtZSA9XG5cbiAgICAnW1xcXFwtOzomPVxcXFwrXFxcXCQsXFxcXFwiXFxcXC5hLXpBLVowLTlfXSsnO1xuXG4gIHJlLnNyY194biA9XG5cbiAgICAneG4tLVthLXowLTlcXFxcLV17MSw1OX0nO1xuXG4gIC8vIE1vcmUgdG8gcmVhZCBhYm91dCBkb21haW4gbmFtZXNcbiAgLy8gaHR0cDovL3NlcnZlcmZhdWx0LmNvbS9xdWVzdGlvbnMvNjM4MjYwL1xuXG4gIHJlLnNyY19kb21haW5fcm9vdCA9XG5cbiAgICAvLyBBbGxvdyBsZXR0ZXJzICYgZGlnaXRzIChodHRwOi8vdGVzdDEpXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICByZS5zcmNfcHNldWRvX2xldHRlciArICd7MSw2M30nICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2RvbWFpbiA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICAgJ3wnICtcbiAgICAgIC8vIGRvbid0IGFsbG93IGAtLWAgaW4gZG9tYWluIG5hbWVzLCBiZWNhdXNlOlxuICAgICAgLy8gLSB0aGF0IGNhbiBjb25mbGljdCB3aXRoIG1hcmtkb3duICZtZGFzaDsgLyAmbmRhc2g7XG4gICAgICAvLyAtIG5vYm9keSB1c2UgdGhvc2UgYW55d2F5XG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyg/Oi0oPyEtKXwnICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKXswLDYxfScgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19ob3N0ID1cblxuICAgICcoPzonICtcbiAgICAvLyBEb24ndCBuZWVkIElQIGNoZWNrLCBiZWNhdXNlIGRpZ2l0cyBhcmUgYWxyZWFkeSBhbGxvd2VkIGluIG5vcm1hbCBkb21haW4gbmFtZXNcbiAgICAvLyAgIHNyY19pcDQgK1xuICAgIC8vICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSonICsgcmUuc3JjX2RvbWFpbi8qX3Jvb3QqLyArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5ID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY19pcDQgK1xuICAgICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSA9XG5cbiAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKSc7XG5cbiAgcmUuc3JjX2hvc3Rfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnNyY19ob3N0X3BvcnRfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTWFpbiBydWxlc1xuXG4gIC8vIFJ1ZGUgdGVzdCBmdXp6eSBsaW5rcyBieSBob3N0LCBmb3IgcXVpY2sgZGVueVxuICByZS50cGxfaG9zdF9mdXp6eV90ZXN0ID1cblxuICAgICdsb2NhbGhvc3R8d3d3XFxcXC58XFxcXC5cXFxcZHsxLDN9XFxcXC58KD86XFxcXC4oPzolVExEUyUpKD86JyArIHJlLnNyY19aUENjICsgJ3w+fCQpKSc7XG5cbiAgcmUudHBsX2VtYWlsX2Z1enp5ID1cblxuICAgICAgJyhefCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfFxcXFwofCcgKyByZS5zcmNfWkNjICsgJykoJyArIHJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX25vX2lwX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJldHVybiByZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2xpbmtpZnktaXQvbGliL3JlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwiLy8gTGlzdCBvZiB2YWxpZCBodG1sIGJsb2NrcyBuYW1lcywgYWNjb3J0aW5nIHRvIGNvbW1vbm1hcmsgc3BlY1xuLy8gaHR0cDovL2pnbS5naXRodWIuaW8vQ29tbW9uTWFyay9zcGVjLmh0bWwjaHRtbC1ibG9ja3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnYWRkcmVzcycsXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2Jhc2UnLFxuICAnYmFzZWZvbnQnLFxuICAnYmxvY2txdW90ZScsXG4gICdib2R5JyxcbiAgJ2NhcHRpb24nLFxuICAnY2VudGVyJyxcbiAgJ2NvbCcsXG4gICdjb2xncm91cCcsXG4gICdkZCcsXG4gICdkZXRhaWxzJyxcbiAgJ2RpYWxvZycsXG4gICdkaXInLFxuICAnZGl2JyxcbiAgJ2RsJyxcbiAgJ2R0JyxcbiAgJ2ZpZWxkc2V0JyxcbiAgJ2ZpZ2NhcHRpb24nLFxuICAnZmlndXJlJyxcbiAgJ2Zvb3RlcicsXG4gICdmb3JtJyxcbiAgJ2ZyYW1lJyxcbiAgJ2ZyYW1lc2V0JyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWQnLFxuICAnaGVhZGVyJyxcbiAgJ2hyJyxcbiAgJ2h0bWwnLFxuICAnaWZyYW1lJyxcbiAgJ2xlZ2VuZCcsXG4gICdsaScsXG4gICdsaW5rJyxcbiAgJ21haW4nLFxuICAnbWVudScsXG4gICdtZW51aXRlbScsXG4gICdtZXRhJyxcbiAgJ25hdicsXG4gICdub2ZyYW1lcycsXG4gICdvbCcsXG4gICdvcHRncm91cCcsXG4gICdvcHRpb24nLFxuICAncCcsXG4gICdwYXJhbScsXG4gICdwcmUnLFxuICAnc2VjdGlvbicsXG4gICdzb3VyY2UnLFxuICAndGl0bGUnLFxuICAnc3VtbWFyeScsXG4gICd0YWJsZScsXG4gICd0Ym9keScsXG4gICd0ZCcsXG4gICd0Zm9vdCcsXG4gICd0aCcsXG4gICd0aGVhZCcsXG4gICd0aXRsZScsXG4gICd0cicsXG4gICd0cmFjaycsXG4gICd1bCdcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCIvLyBKdXN0IGEgc2hvcnRjdXQgZm9yIGJ1bGsgZXhwb3J0XG4ndXNlIHN0cmljdCc7XG5cblxuZXhwb3J0cy5wYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19sYWJlbCcpO1xuZXhwb3J0cy5wYXJzZUxpbmtEZXN0aW5hdGlvbiA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19kZXN0aW5hdGlvbicpO1xuZXhwb3J0cy5wYXJzZUxpbmtUaXRsZSAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua190aXRsZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9pbmRleC5qcyIsIi8vIFBhcnNlIGxpbmsgZGVzdGluYXRpb25cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGlzU3BhY2UgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSwgbGV2ZWwsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6ICcnXG4gICAgICB9O1xuXG4gIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDNDIC8qIDwgKi8pIHtcbiAgICBwb3MrKztcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjb2RlID09PSAweDBBIC8qIFxcbiAqLyB8fCBpc1NwYWNlKGNvZGUpKSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICAgIGlmIChjb2RlID09PSAweDNFIC8qID4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICAvLyBubyBjbG9zaW5nICc+J1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyB0aGlzIHNob3VsZCBiZSAuLi4gfSBlbHNlIHsgLi4uIGJyYW5jaFxuXG4gIGxldmVsID0gMDtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNvZGUgPT09IDB4MjApIHsgYnJlYWs7IH1cblxuICAgIC8vIGFzY2lpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMHgyMCB8fCBjb2RlID09PSAweDdGKSB7IGJyZWFrOyB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBwb3MgKz0gMjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI4IC8qICggKi8pIHtcbiAgICAgIGxldmVsKys7XG4gICAgICBpZiAobGV2ZWwgPiAxKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjkgLyogKSAqLykge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA8IDApIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gcG9zKSB7IHJldHVybiByZXN1bHQ7IH1cblxuICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0LCBwb3MpKTtcbiAgcmVzdWx0LmxpbmVzID0gbGluZXM7XG4gIHJlc3VsdC5wb3MgPSBwb3M7XG4gIHJlc3VsdC5vayA9IHRydWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLmpzIiwiLy8gUGFyc2UgbGluayBsYWJlbFxuLy9cbi8vIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGZpcnN0IGNoYXJhY3RlciAoXCJbXCIpIGFscmVhZHkgbWF0Y2hlcztcbi8vIHJldHVybnMgdGhlIGVuZCBvZiB0aGUgbGFiZWxcbi8vXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXJ0LCBkaXNhYmxlTmVzdGVkKSB7XG4gIHZhciBsZXZlbCwgZm91bmQsIG1hcmtlciwgcHJldlBvcyxcbiAgICAgIGxhYmVsRW5kID0gLTEsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3M7XG5cbiAgc3RhdGUucG9zID0gc3RhcnQgKyAxO1xuICBsZXZlbCA9IDE7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IG1heCkge1xuICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsZXZlbC0tO1xuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldlBvcyA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5tZC5pbmxpbmUuc2tpcFRva2VuKHN0YXRlKTtcbiAgICBpZiAobWFya2VyID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIGlmIChwcmV2UG9zID09PSBzdGF0ZS5wb3MgLSAxKSB7XG4gICAgICAgIC8vIGluY3JlYXNlIGxldmVsIGlmIHdlIGZpbmQgdGV4dCBgW2AsIHdoaWNoIGlzIG5vdCBhIHBhcnQgb2YgYW55IHRva2VuXG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKGRpc2FibGVOZXN0ZWQpIHtcbiAgICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvdW5kKSB7XG4gICAgbGFiZWxFbmQgPSBzdGF0ZS5wb3M7XG4gIH1cblxuICAvLyByZXN0b3JlIG9sZCBzdGF0ZVxuICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG5cbiAgcmV0dXJuIGxhYmVsRW5kO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcyIsIi8vIFBhcnNlIGxpbmsgdGl0bGVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KSB7XG4gIHZhciBjb2RlLFxuICAgICAgbWFya2VyLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgbWFya2VyID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDIyIC8qIFwiICovICYmIG1hcmtlciAhPT0gMHgyNyAvKiAnICovICYmIG1hcmtlciAhPT0gMHgyOCAvKiAoICovKSB7IHJldHVybiByZXN1bHQ7IH1cblxuICBwb3MrKztcblxuICAvLyBpZiBvcGVuaW5nIG1hcmtlciBpcyBcIihcIiwgc3dpdGNoIGl0IHRvIGNsb3NpbmcgbWFya2VyIFwiKVwiXG4gIGlmIChtYXJrZXIgPT09IDB4MjgpIHsgbWFya2VyID0gMHgyOTsgfVxuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua190aXRsZS5qcyIsIi8vIE1haW4gcGFyc2VyIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKTtcbnZhciBoZWxwZXJzICAgICAgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbnZhciBSZW5kZXJlciAgICAgPSByZXF1aXJlKCcuL3JlbmRlcmVyJyk7XG52YXIgUGFyc2VyQ29yZSAgID0gcmVxdWlyZSgnLi9wYXJzZXJfY29yZScpO1xudmFyIFBhcnNlckJsb2NrICA9IHJlcXVpcmUoJy4vcGFyc2VyX2Jsb2NrJyk7XG52YXIgUGFyc2VySW5saW5lID0gcmVxdWlyZSgnLi9wYXJzZXJfaW5saW5lJyk7XG52YXIgTGlua2lmeUl0ICAgID0gcmVxdWlyZSgnbGlua2lmeS1pdCcpO1xudmFyIG1kdXJsICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XG52YXIgcHVueWNvZGUgICAgID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxuXG52YXIgY29uZmlnID0ge1xuICAnZGVmYXVsdCc6IHJlcXVpcmUoJy4vcHJlc2V0cy9kZWZhdWx0JyksXG4gIHplcm86IHJlcXVpcmUoJy4vcHJlc2V0cy96ZXJvJyksXG4gIGNvbW1vbm1hcms6IHJlcXVpcmUoJy4vcHJlc2V0cy9jb21tb25tYXJrJylcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gVGhpcyB2YWxpZGF0b3IgY2FuIHByb2hpYml0IG1vcmUgdGhhbiByZWFsbHkgbmVlZGVkIHRvIHByZXZlbnQgWFNTLiBJdCdzIGFcbi8vIHRyYWRlb2ZmIHRvIGtlZXAgY29kZSBzaW1wbGUgYW5kIHRvIGJlIHNlY3VyZSBieSBkZWZhdWx0LlxuLy9cbi8vIElmIHlvdSBuZWVkIGRpZmZlcmVudCBzZXR1cCAtIG92ZXJyaWRlIHZhbGlkYXRvciBtZXRob2QgYXMgeW91IHdpc2guIE9yXG4vLyByZXBsYWNlIGl0IHdpdGggZHVtbXkgZnVuY3Rpb24gYW5kIHVzZSBleHRlcm5hbCBzYW5pdGl6ZXIuXG4vL1xuXG52YXIgQkFEX1BST1RPX1JFID0gL14odmJzY3JpcHR8amF2YXNjcmlwdHxmaWxlfGRhdGEpOi87XG52YXIgR09PRF9EQVRBX1JFID0gL15kYXRhOmltYWdlXFwvKGdpZnxwbmd8anBlZ3x3ZWJwKTsvO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUxpbmsodXJsKSB7XG4gIC8vIHVybCBzaG91bGQgYmUgbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50LCBhbmQgZXhpc3RpbmcgZW50aXRpZXMgYXJlIGRlY29kZWRcbiAgdmFyIHN0ciA9IHVybC50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gQkFEX1BST1RPX1JFLnRlc3Qoc3RyKSA/IChHT09EX0RBVEFfUkUudGVzdChzdHIpID8gdHJ1ZSA6IGZhbHNlKSA6IHRydWU7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIFJFQ09ERV9IT1NUTkFNRV9GT1IgPSBbICdodHRwOicsICdodHRwczonLCAnbWFpbHRvOicgXTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTGluayh1cmwpIHtcbiAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG5cbiAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXG4gICAgLy9cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHBhcnNlZC5ob3N0bmFtZSk7XG4gICAgICB9IGNhdGNoIChlcikgeyAvKiovIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWR1cmwuZW5jb2RlKG1kdXJsLmZvcm1hdChwYXJzZWQpKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTGlua1RleHQodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9Vbmljb2RlKHBhcnNlZC5ob3N0bmFtZSk7XG4gICAgICB9IGNhdGNoIChlcikgeyAvKiovIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWR1cmwuZGVjb2RlKG1kdXJsLmZvcm1hdChwYXJzZWQpKTtcbn1cblxuXG4vKipcbiAqIGNsYXNzIE1hcmtkb3duSXRcbiAqXG4gKiBNYWluIHBhcnNlci9yZW5kZXJlciBjbGFzcy5cbiAqXG4gKiAjIyMjIyBVc2FnZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIG5vZGUuanMsIFwiY2xhc3NpY1wiIHdheTpcbiAqIHZhciBNYXJrZG93bkl0ID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSxcbiAqICAgICBtZCA9IG5ldyBNYXJrZG93bkl0KCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqXG4gKiAvLyBub2RlLmpzLCB0aGUgc2FtZSwgYnV0IHdpdGggc3VnYXI6XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqXG4gKiAvLyBicm93c2VyIHdpdGhvdXQgQU1ELCBhZGRlZCB0byBcIndpbmRvd1wiIG9uIHNjcmlwdCBsb2FkXG4gKiAvLyBOb3RlLCB0aGVyZSBhcmUgbm8gZGFzaC5cbiAqIHZhciBtZCA9IHdpbmRvdy5tYXJrZG93bml0KCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqIGBgYFxuICpcbiAqIFNpbmdsZSBsaW5lIHJlbmRlcmluZywgd2l0aG91dCBwYXJhZ3JhcGggd3JhcDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKCdfX21hcmtkb3duLWl0X18gcnVsZXp6IScpO1xuICogYGBgXG4gKiovXG5cbi8qKlxuICogbmV3IE1hcmtkb3duSXQoW3ByZXNldE5hbWUsIG9wdGlvbnNdKVxuICogLSBwcmVzZXROYW1lIChTdHJpbmcpOiBvcHRpb25hbCwgYGNvbW1vbm1hcmtgIC8gYHplcm9gXG4gKiAtIG9wdGlvbnMgKE9iamVjdClcbiAqXG4gKiBDcmVhdGVzIHBhcnNlciBpbnN0YW5zZSB3aXRoIGdpdmVuIGNvbmZpZy4gQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgLlxuICpcbiAqICMjIyMjIHByZXNldE5hbWVcbiAqXG4gKiBNYXJrZG93bkl0IHByb3ZpZGVzIG5hbWVkIHByZXNldHMgYXMgYSBjb252ZW5pZW5jZSB0byBxdWlja2x5XG4gKiBlbmFibGUvZGlzYWJsZSBhY3RpdmUgc3ludGF4IHJ1bGVzIGFuZCBvcHRpb25zIGZvciBjb21tb24gdXNlIGNhc2VzLlxuICpcbiAqIC0gW1wiY29tbW9ubWFya1wiXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcykgLVxuICogICBjb25maWd1cmVzIHBhcnNlciB0byBzdHJpY3QgW0NvbW1vbk1hcmtdKGh0dHA6Ly9jb21tb25tYXJrLm9yZy8pIG1vZGUuXG4gKiAtIFtkZWZhdWx0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvZGVmYXVsdC5qcykgLVxuICogICBzaW1pbGFyIHRvIEdGTSwgdXNlZCB3aGVuIG5vIHByZXNldCBuYW1lIGdpdmVuLiBFbmFibGVzIGFsbCBhdmFpbGFibGUgcnVsZXMsXG4gKiAgIGJ1dCBzdGlsbCB3aXRob3V0IGh0bWwsIHR5cG9ncmFwaGVyICYgYXV0b2xpbmtlci5cbiAqIC0gW1wiemVyb1wiXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvemVyby5qcykgLVxuICogICBhbGwgcnVsZXMgZGlzYWJsZWQuIFVzZWZ1bCB0byBxdWlja2x5IHNldHVwIHlvdXIgY29uZmlnIHZpYSBgLmVuYWJsZSgpYC5cbiAqICAgRm9yIGV4YW1wbGUsIHdoZW4geW91IG5lZWQgb25seSBgYm9sZGAgYW5kIGBpdGFsaWNgIG1hcmt1cCBhbmQgbm90aGluZyBlbHNlLlxuICpcbiAqICMjIyMjIG9wdGlvbnM6XG4gKlxuICogLSBfX2h0bWxfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2UuIEJlIGNhcmVmdWwhXG4gKiAgIFRoYXQncyBub3Qgc2FmZSEgWW91IG1heSBuZWVkIGV4dGVybmFsIHNhbml0aXplciB0byBwcm90ZWN0IG91dHB1dCBmcm9tIFhTUy5cbiAqICAgSXQncyBiZXR0ZXIgdG8gZXh0ZW5kIGZlYXR1cmVzIHZpYSBwbHVnaW5zLCBpbnN0ZWFkIG9mIGVuYWJsaW5nIEhUTUwuXG4gKiAtIF9feGh0bWxPdXRfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYWRkICcvJyB3aGVuIGNsb3Npbmcgc2luZ2xlIHRhZ3NcbiAqICAgKGA8YnIgLz5gKS4gVGhpcyBpcyBuZWVkZWQgb25seSBmb3IgZnVsbCBDb21tb25NYXJrIGNvbXBhdGliaWxpdHkuIEluIHJlYWxcbiAqICAgd29ybGQgeW91IHdpbGwgbmVlZCBIVE1MIG91dHB1dC5cbiAqIC0gX19icmVha3NfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gY29udmVydCBgXFxuYCBpbiBwYXJhZ3JhcGhzIGludG8gYDxicj5gLlxuICogLSBfX2xhbmdQcmVmaXhfXyAtIGBsYW5ndWFnZS1gLiBDU1MgbGFuZ3VhZ2UgY2xhc3MgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzLlxuICogICBDYW4gYmUgdXNlZnVsIGZvciBleHRlcm5hbCBoaWdobGlnaHRlcnMuXG4gKiAtIF9fbGlua2lmeV9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0IHRvIGxpbmtzLlxuICogLSBfX3R5cG9ncmFwaGVyX18gIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBlbmFibGUgW3NvbWUgbGFuZ3VhZ2UtbmV1dHJhbFxuICogICByZXBsYWNlbWVudF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcykgK1xuICogICBxdW90ZXMgYmVhdXRpZmljYXRpb24gKHNtYXJ0cXVvdGVzKS5cbiAqIC0gX19xdW90ZXNfXyAtIGDigJzigJ3igJjigJlgLCBTdHJpbmcgb3IgQXJyYXkuIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnRcbiAqICAgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCBhbmQgc21hcnRxdW90ZXMgb24uIEZvciBleGFtcGxlLCB5b3UgY2FuXG4gKiAgIHVzZSBgJ8KrwrvigJ7igJwnYCBmb3IgUnVzc2lhbiwgYCfigJ7igJzigJrigJgnYCBmb3IgR2VybWFuLCBhbmRcbiAqICAgYFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J11gIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAqIC0gX19oaWdobGlnaHRfXyAtIGBudWxsYC4gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24gZm9yIGZlbmNlZCBjb2RlIGJsb2Nrcy5cbiAqICAgSGlnaGxpZ2h0ZXIgYGZ1bmN0aW9uIChzdHIsIGxhbmcpYCBzaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTC4gSXQgY2FuIGFsc29cbiAqICAgcmV0dXJuIGVtcHR5IHN0cmluZyBpZiB0aGUgc291cmNlIHdhcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWRcbiAqICAgZXh0ZXJuYWx5LiBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIGNvbW1vbm1hcmsgbW9kZVxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgnY29tbW9ubWFyaycpO1xuICpcbiAqIC8vIGRlZmF1bHQgbW9kZVxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaHRtbDogdHJ1ZSxcbiAqICAgbGlua2lmeTogdHJ1ZSxcbiAqICAgdHlwb2dyYXBoZXI6IHRydWVcbiAqIH0pO1xuICogYGBgXG4gKlxuICogIyMjIyMgU3ludGF4IGhpZ2hsaWdodGluZ1xuICpcbiAqIGBgYGpzXG4gKiB2YXIgaGxqcyA9IHJlcXVpcmUoJ2hpZ2hsaWdodC5qcycpIC8vIGh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuICpcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0Jykoe1xuICogICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzdHIsIGxhbmcpIHtcbiAqICAgICBpZiAobGFuZyAmJiBobGpzLmdldExhbmd1YWdlKGxhbmcpKSB7XG4gKiAgICAgICB0cnkge1xuICogICAgICAgICByZXR1cm4gaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZTtcbiAqICAgICAgIH0gY2F0Y2ggKF9fKSB7fVxuICogICAgIH1cbiAqXG4gKiAgICAgcmV0dXJuICcnOyAvLyB1c2UgZXh0ZXJuYWwgZGVmYXVsdCBlc2NhcGluZ1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIE9yIHdpdGggZnVsbCB3cmFwcGVyIG92ZXJyaWRlIChpZiB5b3UgbmVlZCBhc3NpZ24gY2xhc3MgdG8gYDxwcmU+YCk6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiAvLyBBY3R1YWwgZGVmYXVsdCB2YWx1ZXNcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0Jykoe1xuICogICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzdHIsIGxhbmcpIHtcbiAqICAgICBpZiAobGFuZyAmJiBobGpzLmdldExhbmd1YWdlKGxhbmcpKSB7XG4gKiAgICAgICB0cnkge1xuICogICAgICAgICByZXR1cm4gJzxwcmUgY2xhc3M9XCJobGpzXCI+PGNvZGU+JyArXG4gKiAgICAgICAgICAgICAgICBobGpzLmhpZ2hsaWdodChsYW5nLCBzdHIsIHRydWUpLnZhbHVlICtcbiAqICAgICAgICAgICAgICAgICc8L2NvZGU+PC9wcmU+JztcbiAqICAgICAgIH0gY2F0Y2ggKF9fKSB7fVxuICogICAgIH1cbiAqXG4gKiAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgKyBtZC51dGlscy5lc2NhcGVIdG1sKHN0cikgKyAnPC9jb2RlPjwvcHJlPic7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICoqL1xuZnVuY3Rpb24gTWFya2Rvd25JdChwcmVzZXROYW1lLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXJrZG93bkl0KSkge1xuICAgIHJldHVybiBuZXcgTWFya2Rvd25JdChwcmVzZXROYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmICghdXRpbHMuaXNTdHJpbmcocHJlc2V0TmFtZSkpIHtcbiAgICAgIG9wdGlvbnMgPSBwcmVzZXROYW1lIHx8IHt9O1xuICAgICAgcHJlc2V0TmFtZSA9ICdkZWZhdWx0JztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFya2Rvd25JdCNpbmxpbmUgLT4gUGFyc2VySW5saW5lXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUGFyc2VySW5saW5lXV0uIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cbiAgICogd3JpdGluZyBwbHVnaW5zLiBGb3Igc2ltcGxlIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0gYW5kXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cbiAgICoqL1xuICB0aGlzLmlubGluZSA9IG5ldyBQYXJzZXJJbmxpbmUoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNibG9jayAtPiBQYXJzZXJCbG9ja1xuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlckJsb2NrXV0uIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cbiAgICogd3JpdGluZyBwbHVnaW5zLiBGb3Igc2ltcGxlIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0gYW5kXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cbiAgICoqL1xuICB0aGlzLmJsb2NrID0gbmV3IFBhcnNlckJsb2NrKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjY29yZSAtPiBDb3JlXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbQ29yZV1dIGNoYWluIGV4ZWN1dG9yLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5jb3JlID0gbmV3IFBhcnNlckNvcmUoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNyZW5kZXJlciAtPiBSZW5kZXJlclxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1JlbmRlcmVyXV0uIFVzZSBpdCB0byBtb2RpZnkgb3V0cHV0IGxvb2suIE9yIHRvIGFkZCByZW5kZXJpbmdcbiAgICogcnVsZXMgZm9yIG5ldyB0b2tlbiB0eXBlcywgZ2VuZXJhdGVkIGJ5IHBsdWdpbnMuXG4gICAqXG4gICAqICMjIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqXG4gICAqIGZ1bmN0aW9uIG15VG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2VsZikge1xuICAgKiAgIC8vLi4uXG4gICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICogfTtcbiAgICpcbiAgICogbWQucmVuZGVyZXIucnVsZXNbJ215X3Rva2VuJ10gPSBteVRva2VuXG4gICAqIGBgYFxuICAgKlxuICAgKiBTZWUgW1tSZW5kZXJlcl1dIGRvY3MgYW5kIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5qcykuXG4gICAqKi9cbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2xpbmtpZnkgLT4gTGlua2lmeUl0XG4gICAqXG4gICAqIFtsaW5raWZ5LWl0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdCkgaW5zdGFuY2UuXG4gICAqIFVzZWQgYnkgW2xpbmtpZnldKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzKVxuICAgKiBydWxlLlxuICAgKiovXG4gIHRoaXMubGlua2lmeSA9IG5ldyBMaW5raWZ5SXQoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCN2YWxpZGF0ZUxpbmsodXJsKSAtPiBCb29sZWFuXG4gICAqXG4gICAqIExpbmsgdmFsaWRhdGlvbiBmdW5jdGlvbi4gQ29tbW9uTWFyayBhbGxvd3MgdG9vIG11Y2ggaW4gbGlua3MuIEJ5IGRlZmF1bHRcbiAgICogd2UgZGlzYWJsZSBgamF2YXNjcmlwdDpgLCBgdmJzY3JpcHQ6YCwgYGZpbGU6YCBzY2hlbWFzLCBhbmQgYWxtb3N0IGFsbCBgZGF0YTouLi5gIHNjaGVtYXNcbiAgICogZXhjZXB0IHNvbWUgZW1iZWRkZWQgaW1hZ2UgdHlwZXMuXG4gICAqXG4gICAqIFlvdSBjYW4gY2hhbmdlIHRoaXMgYmVoYXZpb3VyOlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICogLy8gZW5hYmxlIGV2ZXJ5dGhpbmdcbiAgICogbWQudmFsaWRhdGVMaW5rID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgKiBgYGBcbiAgICoqL1xuICB0aGlzLnZhbGlkYXRlTGluayA9IHZhbGlkYXRlTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rKHVybCkgLT4gU3RyaW5nXG4gICAqXG4gICAqIEZ1bmN0aW9uIHVzZWQgdG8gZW5jb2RlIGxpbmsgdXJsIHRvIGEgbWFjaGluZS1yZWFkYWJsZSBmb3JtYXQsXG4gICAqIHdoaWNoIGluY2x1ZGVzIHVybC1lbmNvZGluZywgcHVueWNvZGUsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmsgPSBub3JtYWxpemVMaW5rO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I25vcm1hbGl6ZUxpbmtUZXh0KHVybCkgLT4gU3RyaW5nXG4gICAqXG4gICAqIEZ1bmN0aW9uIHVzZWQgdG8gZGVjb2RlIGxpbmsgdXJsIHRvIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0YFxuICAgKiovXG4gIHRoaXMubm9ybWFsaXplTGlua1RleHQgPSBub3JtYWxpemVMaW5rVGV4dDtcblxuXG4gIC8vIEV4cG9zZSB1dGlscyAmIGhlbHBlcnMgZm9yIGVhc3kgYWNjZXMgZnJvbSBwbHVnaW5zXG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdXRpbHMgLT4gdXRpbHNcbiAgICpcbiAgICogQXNzb3J0ZWQgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWZ1bCB0byB3cml0ZSBwbHVnaW5zLiBTZWUgZGV0YWlsc1xuICAgKiBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9jb21tb24vdXRpbHMuanMpLlxuICAgKiovXG4gIHRoaXMudXRpbHMgPSB1dGlscztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNoZWxwZXJzIC0+IGhlbHBlcnNcbiAgICpcbiAgICogTGluayBjb21wb25lbnRzIHBhcnNlciBmdW5jdGlvbnMsIHVzZWZ1bCB0byB3cml0ZSBwbHVnaW5zLiBTZWUgZGV0YWlsc1xuICAgKiBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9oZWxwZXJzKS5cbiAgICoqL1xuICB0aGlzLmhlbHBlcnMgPSB1dGlscy5hc3NpZ24oe30sIGhlbHBlcnMpO1xuXG5cbiAgdGhpcy5vcHRpb25zID0ge307XG4gIHRoaXMuY29uZmlndXJlKHByZXNldE5hbWUpO1xuXG4gIGlmIChvcHRpb25zKSB7IHRoaXMuc2V0KG9wdGlvbnMpOyB9XG59XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5zZXQob3B0aW9ucylcbiAqXG4gKiBTZXQgcGFyc2VyIG9wdGlvbnMgKGluIHRoZSBzYW1lIGZvcm1hdCBhcyBpbiBjb25zdHJ1Y3RvcikuIFByb2JhYmx5LCB5b3VcbiAqIHdpbGwgbmV2ZXIgbmVlZCBpdCwgYnV0IHlvdSBjYW4gY2hhbmdlIG9wdGlvbnMgYWZ0ZXIgY29uc3RydWN0b3IgY2FsbC5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAuc2V0KHsgaHRtbDogdHJ1ZSwgYnJlYWtzOiB0cnVlIH0pXG4gKiAgICAgICAgICAgICAuc2V0KHsgdHlwb2dyYXBoZXIsIHRydWUgfSk7XG4gKiBgYGBcbiAqXG4gKiBfX05vdGU6X18gVG8gYWNoaWV2ZSB0aGUgYmVzdCBwb3NzaWJsZSBwZXJmb3JtYW5jZSwgZG9uJ3QgbW9kaWZ5IGFcbiAqIGBtYXJrZG93bi1pdGAgaW5zdGFuY2Ugb3B0aW9ucyBvbiB0aGUgZmx5LiBJZiB5b3UgbmVlZCBtdWx0aXBsZSBjb25maWd1cmF0aW9uc1xuICogaXQncyBiZXN0IHRvIGNyZWF0ZSBtdWx0aXBsZSBpbnN0YW5jZXMgYW5kIGluaXRpYWxpemUgZWFjaCB3aXRoIHNlcGFyYXRlXG4gKiBjb25maWcuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB1dGlscy5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGUsIGludGVybmFsXG4gKiBNYXJrZG93bkl0LmNvbmZpZ3VyZShwcmVzZXRzKVxuICpcbiAqIEJhdGNoIGxvYWQgb2YgYWxsIG9wdGlvbnMgYW5kIGNvbXBlbmVudCBzZXR0aW5ncy4gVGhpcyBpcyBpbnRlcm5hbCBtZXRob2QsXG4gKiBhbmQgeW91IHByb2JhYmx5IHdpbGwgbm90IG5lZWQgaXQuIEJ1dCBpZiB5b3Ugd2l0aCAtIHNlZSBhdmFpbGFibGUgcHJlc2V0c1xuICogYW5kIGRhdGEgc3RydWN0dXJlIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvdHJlZS9tYXN0ZXIvbGliL3ByZXNldHMpXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBwcmVzZXRzIGluc3RlYWQgb2YgZGlyZWN0IGNvbmZpZyBsb2Fkcy4gVGhhdFxuICogd2lsbCBnaXZlIGJldHRlciBjb21wYXRpYmlsaXR5IHdpdGggbmV4dCB2ZXJzaW9ucy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChwcmVzZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcywgcHJlc2V0TmFtZTtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcocHJlc2V0cykpIHtcbiAgICBwcmVzZXROYW1lID0gcHJlc2V0cztcbiAgICBwcmVzZXRzID0gY29uZmlnW3ByZXNldE5hbWVdO1xuICAgIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0IFwiJyArIHByZXNldE5hbWUgKyAnXCIsIGNoZWNrIG5hbWUnKTsgfVxuICB9XG5cbiAgaWYgKCFwcmVzZXRzKSB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQsIGNhblxcJ3QgYmUgZW1wdHknKTsgfVxuXG4gIGlmIChwcmVzZXRzLm9wdGlvbnMpIHsgc2VsZi5zZXQocHJlc2V0cy5vcHRpb25zKTsgfVxuXG4gIGlmIChwcmVzZXRzLmNvbXBvbmVudHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcmVzZXRzLmNvbXBvbmVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlci5lbmFibGVPbmx5KHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlcyk7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzMikge1xuICAgICAgICBzZWxmW25hbWVdLnJ1bGVyMi5lbmFibGVPbmx5KHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZVxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIGxpc3Qgb3IgcnVsZXMuIEl0IHdpbGwgYXV0b21hdGljYWxseSBmaW5kIGFwcHJvcHJpYXRlIGNvbXBvbmVudHMsXG4gKiBjb250YWluaW5nIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIHJ1bGUgbm90IGZvdW5kLCBhbmQgYGlnbm9yZUludmFsaWRgXG4gKiBub3Qgc2V0IC0gdGhyb3dzIGV4Y2VwdGlvbi5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAuZW5hYmxlKFsnc3ViJywgJ3N1cCddKVxuICogICAgICAgICAgICAgLmRpc2FibGUoJ3NtYXJ0cXVvdGVzJyk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgWyAnY29yZScsICdibG9jaycsICdpbmxpbmUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXNbY2hhaW5dLnJ1bGVyLmVuYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmVuYWJsZShsaXN0LCB0cnVlKSk7XG5cbiAgdmFyIG1pc3NlZCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDA7IH0pO1xuXG4gIGlmIChtaXNzZWQubGVuZ3RoICYmICFpZ25vcmVJbnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXJrZG93bkl0LiBGYWlsZWQgdG8gZW5hYmxlIHVua25vd24gcnVsZShzKTogJyArIG1pc3NlZCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5kaXNhYmxlKGxpc3QsIGlnbm9yZUludmFsaWQpXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IHJ1bGUgbmFtZSBvciBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZGlzYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbTWFya2Rvd25JdC5lbmFibGVdXSwgYnV0IHR1cm4gc3BlY2lmaWVkIHJ1bGVzIG9mZi5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5kaXNhYmxlKGxpc3QsIHRydWUpKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG5cbiAgdmFyIG1pc3NlZCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDA7IH0pO1xuXG4gIGlmIChtaXNzZWQubGVuZ3RoICYmICFpZ25vcmVJbnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXJrZG93bkl0LiBGYWlsZWQgdG8gZGlzYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LnVzZShwbHVnaW4sIHBhcmFtcylcbiAqXG4gKiBMb2FkIHNwZWNpZmllZCBwbHVnaW4gd2l0aCBnaXZlbiBwYXJhbXMgaW50byBjdXJyZW50IHBhcnNlciBpbnN0YW5jZS5cbiAqIEl0J3MganVzdCBhIHN1Z2FyIHRvIGNhbGwgYHBsdWdpbihtZCwgcGFyYW1zKWAgd2l0aCBjdXJyaW5nLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgaXRlcmF0b3IgPSByZXF1aXJlKCdtYXJrZG93bi1pdC1mb3ItaW5saW5lJyk7XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcbiAqICAgICAgICAgICAgIC51c2UoaXRlcmF0b3IsICdmb29fcmVwbGFjZScsICd0ZXh0JywgZnVuY3Rpb24gKHRva2VucywgaWR4KSB7XG4gKiAgICAgICAgICAgICAgIHRva2Vuc1tpZHhdLmNvbnRlbnQgPSB0b2tlbnNbaWR4XS5jb250ZW50LnJlcGxhY2UoL2Zvby9nLCAnYmFyJyk7XG4gKiAgICAgICAgICAgICB9KTtcbiAqIGBgYFxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKHBsdWdpbiAvKiwgcGFyYW1zLCAuLi4gKi8pIHtcbiAgdmFyIGFyZ3MgPSBbIHRoaXMgXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIHBsdWdpbi5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogUGFyc2UgaW5wdXQgc3RyaW5nIGFuZCByZXR1cm5zIGxpc3Qgb2YgYmxvY2sgdG9rZW5zIChzcGVjaWFsIHRva2VuIHR5cGVcbiAqIFwiaW5saW5lXCIgd2lsbCBjb250YWluIGxpc3Qgb2YgaW5saW5lIHRva2VucykuIFlvdSBzaG91bGQgbm90IGNhbGwgdGhpc1xuICogbWV0aG9kIGRpcmVjdGx5LCB1bnRpbCB5b3Ugd3JpdGUgY3VzdG9tIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgdG8gcHJvZHVjZVxuICogQVNUKS5cbiAqXG4gKiBgZW52YCBpcyB1c2VkIHRvIHBhc3MgZGF0YSBiZXR3ZWVuIFwiZGlzdHJpYnV0ZWRcIiBydWxlcyBhbmQgcmV0dXJuIGFkZGl0aW9uYWxcbiAqIG1ldGFkYXRhIGxpa2UgcmVmZXJlbmNlIGluZm8sIG5lZWRlZCBmb3IgdGhlIHJlbmRlcmVyLiBJdCBhbHNvIGNhbiBiZSB1c2VkIHRvXG4gKiBpbmplY3QgZGF0YSBpbiBzcGVjaWZpYyBjYXNlcy4gVXN1YWxseSwgeW91IHdpbGwgYmUgb2sgdG8gcGFzcyBge31gLFxuICogYW5kIHRoZW4gcGFzcyB1cGRhdGVkIG9iamVjdCB0byByZW5kZXJlci5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBzaG91bGQgYmUgYSBTdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHRoaXMuY29yZS5wcm9jZXNzKHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xufTtcblxuXG4vKipcbiAqIE1hcmtkb3duSXQucmVuZGVyKHNyYyBbLCBlbnZdKSAtPiBTdHJpbmdcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFJlbmRlciBtYXJrZG93biBzdHJpbmcgaW50byBodG1sLiBJdCBkb2VzIGFsbCBtYWdpYyBmb3IgeW91IDopLlxuICpcbiAqIGBlbnZgIGNhbiBiZSB1c2VkIHRvIGluamVjdCBhZGRpdGlvbmFsIG1ldGFkYXRhIChge31gIGJ5IGRlZmF1bHQpLlxuICogQnV0IHlvdSB3aWxsIG5vdCBuZWVkIGl0IHdpdGggaGlnaCBwcm9iYWJpbGl0eS4gU2VlIGFsc28gY29tbWVudFxuICogaW4gW1tNYXJrZG93bkl0LnBhcnNlXV0uXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2VJbmxpbmUoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQucGFyc2VdXSBidXQgc2tpcCBhbGwgYmxvY2sgcnVsZXMuIEl0IHJldHVybnMgdGhlXG4gKiBibG9jayB0b2tlbnMgbGlzdCB3aXRoIHRoZSBzaW5nbGUgYGlubGluZWAgZWxlbWVudCwgY29udGFpbmluZyBwYXJzZWQgaW5saW5lXG4gKiB0b2tlbnMgaW4gYGNoaWxkcmVuYCBwcm9wZXJ0eS4gQWxzbyB1cGRhdGVzIGBlbnZgIG9iamVjdC5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHN0YXRlLmlubGluZU1vZGUgPSB0cnVlO1xuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcklubGluZShzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBTaW1pbGFyIHRvIFtbTWFya2Rvd25JdC5yZW5kZXJdXSBidXQgZm9yIHNpbmdsZSBwYXJhZ3JhcGggY29udGVudC4gUmVzdWx0XG4gKiB3aWxsIE5PVCBiZSB3cmFwcGVkIGludG8gYDxwPmAgdGFncy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBlbnYgPSBlbnYgfHwge307XG5cbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2VJbmxpbmUoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFya2Rvd25JdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJCbG9ja1xuICpcbiAqIEJsb2NrLWxldmVsIHRva2VuaXplci5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbnZhciBfcnVsZXMgPSBbXG4gIC8vIEZpcnN0IDIgcGFyYW1zIC0gcnVsZSBuYW1lICYgc291cmNlLiBTZWNvbmRhcnkgYXJyYXkgLSBsaXN0IG9mIHJ1bGVzLFxuICAvLyB3aGljaCBjYW4gYmUgdGVybWluYXRlZCBieSB0aGlzIG9uZS5cbiAgWyAndGFibGUnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svdGFibGUnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJyBdIF0sXG4gIFsgJ2NvZGUnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2NvZGUnKSBdLFxuICBbICdmZW5jZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9mZW5jZScpLCAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2Jsb2NrcXVvdGUnLCByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUnKSwgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdsaXN0JyBdIF0sXG4gIFsgJ2hyJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hyJyksICAgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnbGlzdCcsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGlzdCcpLCAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncmVmZXJlbmNlJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcmVmZXJlbmNlJykgXSxcbiAgWyAnaGVhZGluZycsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaGVhZGluZycpLCAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnbGhlYWRpbmcnLCAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGhlYWRpbmcnKSBdLFxuICBbICdodG1sX2Jsb2NrJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9odG1sX2Jsb2NrJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdwYXJhZ3JhcGgnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9wYXJhZ3JhcGgnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlckJsb2NrKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlckJsb2NrKCkge1xuICAvKipcbiAgICogUGFyc2VyQmxvY2sjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgYmxvY2sgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdLCB7IGFsdDogKF9ydWxlc1tpXVsyXSB8fCBbXSkuc2xpY2UoKSB9KTtcbiAgfVxufVxuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJCbG9jay5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbGluZSA9IHN0YXJ0TGluZSxcbiAgICAgIGhhc0VtcHR5TGluZXMgPSBmYWxzZSxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKGxpbmUgPCBlbmRMaW5lKSB7XG4gICAgc3RhdGUubGluZSA9IGxpbmUgPSBzdGF0ZS5za2lwRW1wdHlMaW5lcyhsaW5lKTtcbiAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBUZXJtaW5hdGlvbiBjb25kaXRpb24gZm9yIG5lc3RlZCBjYWxscy5cbiAgICAvLyBOZXN0ZWQgY2FsbHMgY3VycmVudGx5IHVzZWQgZm9yIGJsb2NrcXVvdGVzICYgbGlzdHNcbiAgICBpZiAoc3RhdGUuc0NvdW50W2xpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBJZiBuZXN0aW5nIGxldmVsIGV4Y2VlZGVkIC0gc2tpcCB0YWlsIHRvIHRoZSBlbmQuIFRoYXQncyBub3Qgb3JkaW5hcnlcbiAgICAvLyBzaXR1YXRpb24gYW5kIHdlIHNob3VsZCBub3QgY2FyZSBhYm91dCBjb250ZW50LlxuICAgIGlmIChzdGF0ZS5sZXZlbCA+PSBtYXhOZXN0aW5nKSB7XG4gICAgICBzdGF0ZS5saW5lID0gZW5kTGluZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUubGluZWBcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlLnRpZ2h0IGlmZiB3ZSBoYWQgYW4gZW1wdHkgbGluZSBiZWZvcmUgY3VycmVudCB0YWdcbiAgICAvLyBpLmUuIGxhdGVzdCBlbXB0eSBsaW5lIHNob3VsZCBub3QgY291bnRcbiAgICBzdGF0ZS50aWdodCA9ICFoYXNFbXB0eUxpbmVzO1xuXG4gICAgLy8gcGFyYWdyYXBoIG1pZ2h0IFwiZWF0XCIgb25lIG5ld2xpbmUgYWZ0ZXIgaXQgaW4gbmVzdGVkIGxpc3RzXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsaW5lID0gc3RhdGUubGluZTtcblxuICAgIGlmIChsaW5lIDwgZW5kTGluZSAmJiBzdGF0ZS5pc0VtcHR5KGxpbmUpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICAgIGxpbmUrKztcbiAgICAgIHN0YXRlLmxpbmUgPSBsaW5lO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlckJsb2NrLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGJsb2NrIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXG4gKiovXG5QYXJzZXJCbG9jay5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3JjKSB7IHJldHVybjsgfVxuXG4gIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUsIHN0YXRlLmxpbmUsIHN0YXRlLmxpbmVNYXgpO1xufTtcblxuXG5QYXJzZXJCbG9jay5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9ibG9jay5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgQ29yZVxuICpcbiAqIFRvcC1sZXZlbCBydWxlcyBleGVjdXRvci4gR2x1ZXMgYmxvY2svaW5saW5lIHBhcnNlcnMgYW5kIGRvZXMgaW50ZXJtZWRpYXRlXG4gKiB0cmFuc2Zvcm1hdGlvbnMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICBbICdub3JtYWxpemUnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ub3JtYWxpemUnKSAgICAgIF0sXG4gIFsgJ2Jsb2NrJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2Jsb2NrJykgICAgICAgICAgXSxcbiAgWyAnaW5saW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvaW5saW5lJykgICAgICAgICBdLFxuICBbICdsaW5raWZ5JywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9saW5raWZ5JykgICAgICAgIF0sXG4gIFsgJ3JlcGxhY2VtZW50cycsICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cycpICAgXSxcbiAgWyAnc21hcnRxdW90ZXMnLCAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMnKSAgICBdXG5dO1xuXG5cbi8qKlxuICogbmV3IENvcmUoKVxuICoqL1xuZnVuY3Rpb24gQ29yZSgpIHtcbiAgLyoqXG4gICAqIENvcmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgY29yZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG59XG5cblxuLyoqXG4gKiBDb3JlLnByb2Nlc3Moc3RhdGUpXG4gKlxuICogRXhlY3V0ZXMgY29yZSBjaGFpbiBydWxlcy5cbiAqKi9cbkNvcmUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIGksIGwsIHJ1bGVzO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuQ29yZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc3RhdGVfY29yZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJJbmxpbmVcbiAqXG4gKiBUb2tlbml6ZXMgcGFyYWdyYXBoIGNvbnRlbnQuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUGFyc2VyIHJ1bGVzXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ3RleHQnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHQnKSBdLFxuICBbICduZXdsaW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9uZXdsaW5lJykgXSxcbiAgWyAnZXNjYXBlJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZXNjYXBlJykgXSxcbiAgWyAnYmFja3RpY2tzJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFja3RpY2tzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnRva2VuaXplIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykudG9rZW5pemUgXSxcbiAgWyAnbGluaycsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbGluaycpIF0sXG4gIFsgJ2ltYWdlJywgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2ltYWdlJykgXSxcbiAgWyAnYXV0b2xpbmsnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYXV0b2xpbmsnKSBdLFxuICBbICdodG1sX2lubGluZScsICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9odG1sX2lubGluZScpIF0sXG4gIFsgJ2VudGl0eScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VudGl0eScpIF1cbl07XG5cbnZhciBfcnVsZXMyID0gW1xuICBbICdiYWxhbmNlX3BhaXJzJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykucG9zdFByb2Nlc3MgXSxcbiAgWyAndGV4dF9jb2xsYXBzZScsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZScpIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgUGFyc2VySW5saW5lKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlcklubGluZSgpIHtcbiAgdmFyIGk7XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBpbmxpbmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlcjIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBTZWNvbmQgcnVsZXIgdXNlZCBmb3IgcG9zdC1wcm9jZXNzaW5nXG4gICAqIChlLmcuIGluIGVtcGhhc2lzLWxpa2UgcnVsZXMpLlxuICAgKiovXG4gIHRoaXMucnVsZXIyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlczIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyMi5wdXNoKF9ydWxlczJbaV1bMF0sIF9ydWxlczJbaV1bMV0pO1xuICB9XG59XG5cblxuLy8gU2tpcCBzaW5nbGUgdG9rZW4gYnkgcnVubmluZyBhbGwgcnVsZXMgaW4gdmFsaWRhdGlvbiBtb2RlO1xuLy8gcmV0dXJucyBgdHJ1ZWAgaWYgYW55IHJ1bGUgcmVwb3J0ZWQgc3VjY2Vzc1xuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUuc2tpcFRva2VuID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSwgcG9zID0gc3RhdGUucG9zLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3RpbmcsXG4gICAgICBjYWNoZSA9IHN0YXRlLmNhY2hlO1xuXG5cbiAgaWYgKHR5cGVvZiBjYWNoZVtwb3NdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLnBvcyA9IGNhY2hlW3Bvc107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gSW5jcmVtZW50IHN0YXRlLmxldmVsIGFuZCBkZWNyZW1lbnQgaXQgbGF0ZXIgdG8gbGltaXQgcmVjdXJzaW9uLlxuICAgICAgLy8gSXQncyBoYXJtbGVzcyB0byBkbyBoZXJlLCBiZWNhdXNlIG5vIHRva2VucyBhcmUgY3JlYXRlZC4gQnV0IGlkZWFsbHksXG4gICAgICAvLyB3ZSdkIG5lZWQgYSBzZXBhcmF0ZSBwcml2YXRlIHN0YXRlIHZhcmlhYmxlIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAvL1xuICAgICAgc3RhdGUubGV2ZWwrKztcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIHRydWUpO1xuICAgICAgc3RhdGUubGV2ZWwtLTtcblxuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRvbyBtdWNoIG5lc3RpbmcsIGp1c3Qgc2tpcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGguXG4gICAgLy9cbiAgICAvLyBOT1RFOiB0aGlzIHdpbGwgY2F1c2UgbGlua3MgdG8gYmVoYXZlIGluY29ycmVjdGx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZSxcbiAgICAvLyAgICAgICB3aGVuIGFuIGFtb3VudCBvZiBgW2AgaXMgZXhhY3RseSBlcXVhbCB0byBgbWF4TmVzdGluZyArIDFgOlxuICAgIC8vXG4gICAgLy8gICAgICAgW1tbW1tbW1tbW1tbW1tbW1tbW1tbZm9vXSgpXG4gICAgLy9cbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3b3JrYXJvdW5kIHdoZW4gQ00gc3RhbmRhcmQgd2lsbCBhbGxvdyBuZXN0ZWQgbGlua3NcbiAgICAvLyAgICAgICAod2UgY2FuIHJlcGxhY2UgaXQgYnkgcHJldmVudGluZyBsaW5rcyBmcm9tIGJlaW5nIHBhcnNlZCBpblxuICAgIC8vICAgICAgIHZhbGlkYXRpb24gbW9kZSlcbiAgICAvL1xuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heDtcbiAgfVxuXG4gIGlmICghb2spIHsgc3RhdGUucG9zKys7IH1cbiAgY2FjaGVbcG9zXSA9IHN0YXRlLnBvcztcbn07XG5cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGVuZCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IGVuZCkge1xuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUucG9zYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9rKSB7XG4gICAgICBpZiAoc3RhdGUucG9zID49IGVuZCkgeyBicmVhazsgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbc3RhdGUucG9zKytdO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICBzdGF0ZS5wdXNoUGVuZGluZygpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VySW5saW5lLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGlubGluZSB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgaSwgcnVsZXMsIGxlbjtcbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUpO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlcjIuZ2V0UnVsZXMoJycpO1xuICBsZW4gPSBydWxlcy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5cblBhcnNlcklubGluZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcklubGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9pbmxpbmUuanMiLCIvLyBDb21tb25tYXJrIGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIHRydWUsICAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIHRydWUsICAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAnY29kZScsXG4gICAgICAgICdmZW5jZScsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2hyJyxcbiAgICAgICAgJ2h0bWxfYmxvY2snLFxuICAgICAgICAnbGhlYWRpbmcnLFxuICAgICAgICAnbGlzdCcsXG4gICAgICAgICdyZWZlcmVuY2UnLFxuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdhdXRvbGluaycsXG4gICAgICAgICdiYWNrdGlja3MnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZW50aXR5JyxcbiAgICAgICAgJ2VzY2FwZScsXG4gICAgICAgICdodG1sX2lubGluZScsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICdsaW5rJyxcbiAgICAgICAgJ25ld2xpbmUnLFxuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMiLCIvLyBtYXJrZG93bi1pdCBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMTAwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge30sXG4gICAgYmxvY2s6IHt9LFxuICAgIGlubGluZToge31cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcyIsIi8vIFwiWmVyb1wiIHByZXNldCwgd2l0aCBub3RoaW5nIGVuYWJsZWQuIFVzZWZ1bCBmb3IgbWFudWFsIGNvbmZpZ3VyaW5nIG9mIHNpbXBsZVxuLy8gbW9kZXMuIEZvciBleGFtcGxlLCB0byBwYXJzZSBib2xkL2l0YWxpYyBvbmx5LlxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL3plcm8uanMiLCIvKipcbiAqIGNsYXNzIFJlbmRlcmVyXG4gKlxuICogR2VuZXJhdGVzIEhUTUwgZnJvbSBwYXJzZWQgdG9rZW4gc3RyZWFtLiBFYWNoIGluc3RhbmNlIGhhcyBpbmRlcGVuZGVudFxuICogY29weSBvZiBydWxlcy4gVGhvc2UgY2FuIGJlIHJld3JpdHRlbiB3aXRoIGVhc2UuIEFsc28sIHlvdSBjYW4gYWRkIG5ld1xuICogcnVsZXMgaWYgeW91IGNyZWF0ZSBwbHVnaW4gYW5kIGFkZHMgbmV3IHRva2VuIHR5cGVzLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhc3NpZ24gICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmFzc2lnbjtcbnZhciB1bmVzY2FwZUFsbCAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xudmFyIGVzY2FwZUh0bWwgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuZXNjYXBlSHRtbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZGVmYXVsdF9ydWxlcyA9IHt9O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+Jztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8cHJlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPjxjb2RlPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5mZW5jZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF0sXG4gICAgICBpbmZvID0gdG9rZW4uaW5mbyA/IHVuZXNjYXBlQWxsKHRva2VuLmluZm8pLnRyaW0oKSA6ICcnLFxuICAgICAgbGFuZ05hbWUgPSAnJyxcbiAgICAgIGhpZ2hsaWdodGVkLCBpLCB0bXBBdHRycywgdG1wVG9rZW47XG5cbiAgaWYgKGluZm8pIHtcbiAgICBsYW5nTmFtZSA9IGluZm8uc3BsaXQoL1xccysvZylbMF07XG4gIH1cblxuICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICBoaWdobGlnaHRlZCA9IG9wdGlvbnMuaGlnaGxpZ2h0KHRva2VuLmNvbnRlbnQsIGxhbmdOYW1lKSB8fCBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodGVkID0gZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfVxuXG4gIGlmIChoaWdobGlnaHRlZC5pbmRleE9mKCc8cHJlJykgPT09IDApIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgKyAnXFxuJztcbiAgfVxuXG4gIC8vIElmIGxhbmd1YWdlIGV4aXN0cywgaW5qZWN0IGNsYXNzIGdlbnRseSwgd2l0aG91dCBtdWRvZnlpbmcgb3JpZ2luYWwgdG9rZW4uXG4gIC8vIE1heSBiZSwgb25lIGRheSB3ZSB3aWxsIGFkZCAuY2xvbmUoKSBmb3IgdG9rZW4gYW5kIHNpbXBsaWZ5IHRoaXMgcGFydCwgYnV0XG4gIC8vIG5vdyB3ZSBwcmVmZXIgdG8ga2VlcCB0aGluZ3MgbG9jYWwuXG4gIGlmIChpbmZvKSB7XG4gICAgaSAgICAgICAgPSB0b2tlbi5hdHRySW5kZXgoJ2NsYXNzJyk7XG4gICAgdG1wQXR0cnMgPSB0b2tlbi5hdHRycyA/IHRva2VuLmF0dHJzLnNsaWNlKCkgOiBbXTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgdG1wQXR0cnMucHVzaChbICdjbGFzcycsIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lIF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXBBdHRyc1tpXVsxXSArPSAnICcgKyBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZTtcbiAgICB9XG5cbiAgICAvLyBGYWtlIHRva2VuIGp1c3QgdG8gcmVuZGVyIGF0dHJpYnV0ZXNcbiAgICB0bXBUb2tlbiA9IHtcbiAgICAgIGF0dHJzOiB0bXBBdHRyc1xuICAgIH07XG5cbiAgICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0bXBUb2tlbikgKyAnPidcbiAgICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gIH1cblxuXG4gIHJldHVybiAgJzxwcmU+PGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+J1xuICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmltYWdlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBcImFsdFwiIGF0dHIgTVVTVCBiZSBzZXQsIGV2ZW4gaWYgZW1wdHkuIEJlY2F1c2UgaXQncyBtYW5kYXRvcnkgYW5kXG4gIC8vIHNob3VsZCBiZSBwbGFjZWQgb24gcHJvcGVyIHBvc2l0aW9uIGZvciB0ZXN0cy5cbiAgLy9cbiAgLy8gUmVwbGFjZSBjb250ZW50IHdpdGggYWN0dWFsIHZhbHVlXG5cbiAgdG9rZW4uYXR0cnNbdG9rZW4uYXR0ckluZGV4KCdhbHQnKV1bMV0gPVxuICAgIHNsZi5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW4uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG5cbiAgcmV0dXJuIHNsZi5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucyk7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaGFyZGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJztcbn07XG5kZWZhdWx0X3J1bGVzLnNvZnRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLmJyZWFrcyA/IChvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbicpIDogJ1xcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMudGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmh0bWxfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5kZWZhdWx0X3J1bGVzLmh0bWxfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuXG5cbi8qKlxuICogbmV3IFJlbmRlcmVyKClcbiAqXG4gKiBDcmVhdGVzIG5ldyBbW1JlbmRlcmVyXV0gaW5zdGFuY2UgYW5kIGZpbGwgW1tSZW5kZXJlciNydWxlc11dIHdpdGggZGVmYXVsdHMuXG4gKiovXG5mdW5jdGlvbiBSZW5kZXJlcigpIHtcblxuICAvKipcbiAgICogUmVuZGVyZXIjcnVsZXMgLT4gT2JqZWN0XG4gICAqXG4gICAqIENvbnRhaW5zIHJlbmRlciBydWxlcyBmb3IgdG9rZW5zLiBDYW4gYmUgdXBkYXRlZCBhbmQgZXh0ZW5kZWQuXG4gICAqXG4gICAqICMjIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19vcGVuICA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8Yj4nOyB9O1xuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfY2xvc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPC9iPic7IH07XG4gICAqXG4gICAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoLi4uKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEVhY2ggcnVsZSBpcyBjYWxsZWQgYXMgaW5kZXBlbmRlZCBzdGF0aWMgZnVuY3Rpb24gd2l0aCBmaXhlZCBzaWduYXR1cmU6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogZnVuY3Rpb24gbXlfdG9rZW5fcmVuZGVyKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHJlbmRlcmVyKSB7XG4gICAqICAgLy8gLi4uXG4gICAqICAgcmV0dXJuIHJlbmRlcmVkSFRNTDtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5qcylcbiAgICogZm9yIG1vcmUgZGV0YWlscyBhbmQgZXhhbXBsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlcyA9IGFzc2lnbih7fSwgZGVmYXVsdF9ydWxlcyk7XG59XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJBdHRycyh0b2tlbikgLT4gU3RyaW5nXG4gKlxuICogUmVuZGVyIHRva2VuIGF0dHJpYnV0ZXMgdG8gc3RyaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckF0dHJzID0gZnVuY3Rpb24gcmVuZGVyQXR0cnModG9rZW4pIHtcbiAgdmFyIGksIGwsIHJlc3VsdDtcblxuICBpZiAoIXRva2VuLmF0dHJzKSB7IHJldHVybiAnJzsgfVxuXG4gIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAoaSA9IDAsIGwgPSB0b2tlbi5hdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByZXN1bHQgKz0gJyAnICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVswXSkgKyAnPVwiJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMV0pICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvZiB0b2tlbnNcbiAqIC0gaWR4IChOdW1iZWQpOiB0b2tlbiBpbmRleCB0byByZW5kZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICpcbiAqIERlZmF1bHQgdG9rZW4gcmVuZGVyZXIuIENhbiBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGZ1bmN0aW9uXG4gKiBpbiBbW1JlbmRlcmVyI3J1bGVzXV0uXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVG9rZW4gPSBmdW5jdGlvbiByZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykge1xuICB2YXIgbmV4dFRva2VuLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBuZWVkTGYgPSBmYWxzZSxcbiAgICAgIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gVGlnaHQgbGlzdCBwYXJhZ3JhcGhzXG4gIGlmICh0b2tlbi5oaWRkZW4pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyBJbnNlcnQgYSBuZXdsaW5lIGJldHdlZW4gaGlkZGVuIHBhcmFncmFwaCBhbmQgc3Vic2VxdWVudCBvcGVuaW5nXG4gIC8vIGJsb2NrLWxldmVsIHRhZy5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIGhlcmUgd2Ugc2hvdWxkIGluc2VydCBhIG5ld2xpbmUgYmVmb3JlIGJsb2NrcXVvdGU6XG4gIC8vICAtIGFcbiAgLy8gICAgPlxuICAvL1xuICBpZiAodG9rZW4uYmxvY2sgJiYgdG9rZW4ubmVzdGluZyAhPT0gLTEgJiYgaWR4ICYmIHRva2Vuc1tpZHggLSAxXS5oaWRkZW4pIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBBZGQgdG9rZW4gbmFtZSwgZS5nLiBgPGltZ2BcbiAgcmVzdWx0ICs9ICh0b2tlbi5uZXN0aW5nID09PSAtMSA/ICc8LycgOiAnPCcpICsgdG9rZW4udGFnO1xuXG4gIC8vIEVuY29kZSBhdHRyaWJ1dGVzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiYFxuICByZXN1bHQgKz0gdGhpcy5yZW5kZXJBdHRycyh0b2tlbik7XG5cbiAgLy8gQWRkIGEgc2xhc2ggZm9yIHNlbGYtY2xvc2luZyB0YWdzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiIC9gXG4gIGlmICh0b2tlbi5uZXN0aW5nID09PSAwICYmIG9wdGlvbnMueGh0bWxPdXQpIHtcbiAgICByZXN1bHQgKz0gJyAvJztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGEgbmV3bGluZSBhZnRlciB0aGlzIHRhZ1xuICBpZiAodG9rZW4uYmxvY2spIHtcbiAgICBuZWVkTGYgPSB0cnVlO1xuXG4gICAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDEpIHtcbiAgICAgIGlmIChpZHggKyAxIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBuZXh0VG9rZW4gPSB0b2tlbnNbaWR4ICsgMV07XG5cbiAgICAgICAgaWYgKG5leHRUb2tlbi50eXBlID09PSAnaW5saW5lJyB8fCBuZXh0VG9rZW4uaGlkZGVuKSB7XG4gICAgICAgICAgLy8gQmxvY2stbGV2ZWwgdGFnIGNvbnRhaW5pbmcgYW4gaW5saW5lIHRhZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFRva2VuLm5lc3RpbmcgPT09IC0xICYmIG5leHRUb2tlbi50YWcgPT09IHRva2VuLnRhZykge1xuICAgICAgICAgIC8vIE9wZW5pbmcgdGFnICsgY2xvc2luZyB0YWcgb2YgdGhlIHNhbWUgdHlwZS4gRS5nLiBgPGxpPjwvbGk+YC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ICs9IG5lZWRMZiA/ICc+XFxuJyA6ICc+JztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZSh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogVGhlIHNhbWUgYXMgW1tSZW5kZXJlci5yZW5kZXJdXSwgYnV0IGZvciBzaW5nbGUgdG9rZW4gb2YgYGlubGluZWAgdHlwZS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHR5cGUsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFNwZWNpYWwga2x1ZGdlIGZvciBpbWFnZSBgYWx0YCBhdHRyaWJ1dGVzIHRvIGNvbmZvcm0gQ29tbW9uTWFyayBzcGVjLlxuICogRG9uJ3QgdHJ5IHRvIHVzZSBpdCEgU3BlYyByZXF1aXJlcyB0byBzaG93IGBhbHRgIGNvbnRlbnQgd2l0aCBzdHJpcHBlZCBtYXJrdXAsXG4gKiBpbnN0ZWFkIG9mIHNpbXBsZSBlc2NhcGluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmVBc1RleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzdWx0ICs9IHRva2Vuc1tpXS5jb250ZW50O1xuICAgIH0gZWxzZSBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXIodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRha2VzIHRva2VuIHN0cmVhbSBhbmQgZ2VuZXJhdGVzIEhUTUwuIFByb2JhYmx5LCB5b3Ugd2lsbCBuZXZlciBuZWVkIHRvIGNhbGxcbiAqIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgaSwgbGVuLCB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmUodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3Rva2Vuc1tpXS50eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwiLy8gQmxvY2sgcXVvdGVzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2txdW90ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGFkanVzdFRhYixcbiAgICAgIGNoLFxuICAgICAgaSxcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc091dGRlbnRlZCxcbiAgICAgIGwsXG4gICAgICBsYXN0TGluZUVtcHR5LFxuICAgICAgbGluZXMsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEJNYXJrcyxcbiAgICAgIG9sZEJTQ291bnQsXG4gICAgICBvbGRJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkU0NvdW50LFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgc3BhY2VBZnRlck1hcmtlcixcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRva2VuLFxuICAgICAgb2xkTGluZU1heCA9IHN0YXRlLmxpbmVNYXgsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY2hlY2sgdGhlIGJsb2NrIHF1b3RlIG1hcmtlclxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspICE9PSAweDNFLyogPiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyB3ZSBrbm93IHRoYXQgaXQncyBnb2luZyB0byBiZSBhIHZhbGlkIGJsb2NrcXVvdGUsXG4gIC8vIHNvIG5vIHBvaW50IHRyeWluZyB0byBmaW5kIHRoZSBlbmQgb2YgaXQgaW4gc2lsZW50IG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNraXAgc3BhY2VzIGFmdGVyIFwiPlwiIGFuZCByZS1jYWxjdWxhdGUgb2Zmc2V0XG4gIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIHBvcyAtIChzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdKTtcblxuICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjAgLyogc3BhY2UgKi8pIHtcbiAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgcG9zKys7XG4gICAgaW5pdGlhbCsrO1xuICAgIG9mZnNldCsrO1xuICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG5cbiAgICBpZiAoKHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIG9mZnNldCkgJSA0ID09PSAzKSB7XG4gICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgIHBvcysrO1xuICAgICAgaW5pdGlhbCsrO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgIC8vICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICsgc2hpZnQgYnNDb3VudCBzbGlnaHRseVxuICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICB9XG5cbiAgb2xkQk1hcmtzID0gWyBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSA9IHBvcztcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgb2xkQlNDb3VudCA9IFsgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdIF07XG4gIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdICsgMSArIChzcGFjZUFmdGVyTWFya2VyID8gMSA6IDApO1xuXG4gIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4O1xuXG4gIG9sZFNDb3VudCA9IFsgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsO1xuXG4gIG9sZFRTaGlmdCA9IFsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnYmxvY2txdW90ZScpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2Jsb2NrcXVvdGUnO1xuXG4gIC8vIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBibG9ja1xuICAvL1xuICAvLyBCbG9jayBlbmRzIHdpdGggZWl0aGVyOlxuICAvLyAgMS4gYW4gZW1wdHkgbGluZSBvdXRzaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy9cbiAgLy8gICAgIGBgYFxuICAvLyAgMi4gYW4gZW1wdHkgbGluZSBpbnNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID5cbiAgLy8gICAgIHRlc3RcbiAgLy8gICAgIGBgYFxuICAvLyAgMy4gYW5vdGhlciB0YWc6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvLyAgICAgIC0gLSAtXG4gIC8vICAgICBgYGBcbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIC8vIGNoZWNrIGlmIGl0J3Mgb3V0ZGVudGVkLCBpLmUuIGl0J3MgaW5zaWRlIGxpc3QgaXRlbSBhbmQgaW5kZW50ZWRcbiAgICAvLyBsZXNzIHRoYW4gc2FpZCBsaXN0IGl0ZW06XG4gICAgLy9cbiAgICAvLyBgYGBcbiAgICAvLyAxLiBhbnl0aGluZ1xuICAgIC8vICAgID4gY3VycmVudCBibG9ja3F1b3RlXG4gICAgLy8gMi4gY2hlY2tpbmcgdGhpcyBsaW5lXG4gICAgLy8gYGBgXG4gICAgaXNPdXRkZW50ZWQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50O1xuXG4gICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAvLyBDYXNlIDE6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoaXMgbGluZSBpcyBlbXB0eS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgPT09IDB4M0UvKiA+ICovICYmICFpc091dGRlbnRlZCkge1xuICAgICAgLy8gVGhpcyBsaW5lIGlzIGluc2lkZSB0aGUgYmxvY2txdW90ZS5cblxuICAgICAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcblxuICAgICAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgICAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAgICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgICAgICBwb3MrKztcbiAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5iTWFya3NbbmV4dExpbmVdID0gcG9zO1xuXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUudFNoaWZ0W25leHRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tuZXh0TGluZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDYXNlIDI6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoZSBsYXN0IGxpbmUgd2FzIGVtcHR5LlxuICAgIGlmIChsYXN0TGluZUVtcHR5KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBDYXNlIDM6IGFub3RoZXIgdGFnIGZvdW5kLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgLy8gUXVpcmsgdG8gZW5mb3JjZSBcImhhcmQgdGVybWluYXRpb24gbW9kZVwiIGZvciBwYXJhZ3JhcGhzO1xuICAgICAgLy8gbm9ybWFsbHkgaWYgeW91IGNhbGwgYHRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKWAsXG4gICAgICAvLyBwYXJhZ3JhcGhzIHdpbGwgbG9vayBiZWxvdyBuZXh0TGluZSBmb3IgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbixcbiAgICAgIC8vIGJ1dCBpZiBibG9ja3F1b3RlIGlzIHRlcm1pbmF0ZWQgYnkgYW5vdGhlciB0YWcsIHRoZXkgc2hvdWxkbid0XG4gICAgICBzdGF0ZS5saW5lTWF4ID0gbmV4dExpbmU7XG5cbiAgICAgIGlmIChzdGF0ZS5ibGtJbmRlbnQgIT09IDApIHtcbiAgICAgICAgLy8gc3RhdGUuYmxrSW5kZW50IHdhcyBub24temVybywgd2Ugbm93IHNldCBpdCB0byB6ZXJvLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBhbGwgb2Zmc2V0cyB0byBhcHBlYXIgYXNcbiAgICAgICAgLy8gaWYgaW5kZW50IHdhc24ndCBjaGFuZ2VkXG4gICAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLT0gc3RhdGUuYmxrSW5kZW50O1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaXNPdXRkZW50ZWQpIGJyZWFrO1xuXG4gICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcblxuICAgIC8vIEEgbmVnYXRpdmUgaW5kZW50YXRpb24gbWVhbnMgdGhhdCB0aGlzIGlzIGEgcGFyYWdyYXBoIGNvbnRpbnVhdGlvblxuICAgIC8vXG4gICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IC0xO1xuICB9XG5cbiAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICBzdGF0ZS5ibGtJbmRlbnQgPSAwO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfb3BlbicsICdibG9ja3F1b3RlJywgMSk7XG4gIHRva2VuLm1hcmt1cCA9ICc+JztcbiAgdG9rZW4ubWFwICAgID0gbGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX2Nsb3NlJywgJ2Jsb2NrcXVvdGUnLCAtMSk7XG4gIHRva2VuLm1hcmt1cCA9ICc+JztcblxuICBzdGF0ZS5saW5lTWF4ID0gb2xkTGluZU1heDtcbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG4gIGxpbmVzWzFdID0gc3RhdGUubGluZTtcblxuICAvLyBSZXN0b3JlIG9yaWdpbmFsIHRTaGlmdDsgdGhpcyBtaWdodCBub3QgYmUgbmVjZXNzYXJ5IHNpbmNlIHRoZSBwYXJzZXJcbiAgLy8gaGFzIGFscmVhZHkgYmVlbiBoZXJlLCBidXQganVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIGRvIHRoYXQuXG4gIGZvciAoaSA9IDA7IGkgPCBvbGRUU2hpZnQubGVuZ3RoOyBpKyspIHtcbiAgICBzdGF0ZS5iTWFya3NbaSArIHN0YXJ0TGluZV0gPSBvbGRCTWFya3NbaV07XG4gICAgc3RhdGUudFNoaWZ0W2kgKyBzdGFydExpbmVdID0gb2xkVFNoaWZ0W2ldO1xuICAgIHN0YXRlLnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZFNDb3VudFtpXTtcbiAgICBzdGF0ZS5ic0NvdW50W2kgKyBzdGFydExpbmVdID0gb2xkQlNDb3VudFtpXTtcbiAgfVxuICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIi8vIENvZGUgYmxvY2sgKDQgc3BhY2VzIHBhZGRlZClcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29kZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBuZXh0TGluZSwgbGFzdCwgdG9rZW47XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50IDwgNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYXN0ID0gbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgbGFzdCA9IG5leHRMaW5lO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IGxhc3Q7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfYmxvY2snLCAnY29kZScsIDApO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBsYXN0LCA0ICsgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIi8vIGZlbmNlcyAoYGBgIGxhbmcsIH5+fiBsYW5nKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG1hcmtlciwgbGVuLCBwYXJhbXMsIG5leHRMaW5lLCBtZW0sIHRva2VuLCBtYXJrdXAsXG4gICAgICBoYXZlRW5kTWFya2VyID0gZmFsc2UsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDMgPiBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLyAmJiBtYXJrZXIgIT09IDB4NjAgLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHNjYW4gbWFya2VyIGxlbmd0aFxuICBtZW0gPSBwb3M7XG4gIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgbGVuID0gcG9zIC0gbWVtO1xuXG4gIGlmIChsZW4gPCAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmt1cCA9IHN0YXRlLnNyYy5zbGljZShtZW0sIHBvcyk7XG4gIHBhcmFtcyA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgaWYgKHBhcmFtcy5pbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSkgPj0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW5jZSBzdGFydCBpcyBmb3VuZCwgd2UgY2FuIHJlcG9ydCBzdWNjZXNzIGhlcmUgaW4gdmFsaWRhdGlvbiBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBzZWFyY2ggZW5kIG9mIGJsb2NrXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuXG4gIGZvciAoOzspIHtcbiAgICBuZXh0TGluZSsrO1xuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7XG4gICAgICAvLyB1bmNsb3NlZCBibG9jayBzaG91bGQgYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgZG9jdW1lbnQuXG4gICAgICAvLyBhbHNvIGJsb2NrIHNlZW1zIHRvIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIHBhcmVudFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zID0gbWVtID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgLy8gbm9uLWVtcHR5IGxpbmUgd2l0aCBuZWdhdGl2ZSBpbmRlbnQgc2hvdWxkIHN0b3AgdGhlIGxpc3Q6XG4gICAgICAvLyAtIGBgYFxuICAgICAgLy8gIHRlc3RcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBtYXJrZXIpIHsgY29udGludWU7IH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIC8vIGNsb3NpbmcgZmVuY2Ugc2hvdWxkIGJlIGluZGVudGVkIGxlc3MgdGhhbiA0IHNwYWNlc1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICAgIC8vIGNsb3NpbmcgY29kZSBmZW5jZSBtdXN0IGJlIGF0IGxlYXN0IGFzIGxvbmcgYXMgdGhlIG9wZW5pbmcgb25lXG4gICAgaWYgKHBvcyAtIG1lbSA8IGxlbikgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRhaWwgaGFzIHNwYWNlcyBvbmx5XG4gICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgaWYgKHBvcyA8IG1heCkgeyBjb250aW51ZTsgfVxuXG4gICAgaGF2ZUVuZE1hcmtlciA9IHRydWU7XG4gICAgLy8gZm91bmQhXG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBJZiBhIGZlbmNlIGhhcyBoZWFkaW5nIHNwYWNlcywgdGhleSBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGl0cyBpbm5lciBibG9ja1xuICBsZW4gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAoaGF2ZUVuZE1hcmtlciA/IDEgOiAwKTtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnZmVuY2UnLCAnY29kZScsIDApO1xuICB0b2tlbi5pbmZvICAgID0gcGFyYW1zO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lICsgMSwgbmV4dExpbmUsIGxlbiwgdHJ1ZSk7XG4gIHRva2VuLm1hcmt1cCAgPSBtYXJrdXA7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzIiwiLy8gaGVhZGluZyAoIywgIyMsIC4uLilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxldmVsLCB0bXAsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoICA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKGNoICE9PSAweDIzLyogIyAqLyB8fCBwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNvdW50IGhlYWRpbmcgbGV2ZWxcbiAgbGV2ZWwgPSAxO1xuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgd2hpbGUgKGNoID09PSAweDIzLyogIyAqLyAmJiBwb3MgPCBtYXggJiYgbGV2ZWwgPD0gNikge1xuICAgIGxldmVsKys7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIH1cblxuICBpZiAobGV2ZWwgPiA2IHx8IChwb3MgPCBtYXggJiYgIWlzU3BhY2UoY2gpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gTGV0J3MgY3V0IHRhaWxzIGxpa2UgJyAgICAjIyMgICcgZnJvbSB0aGUgZW5kIG9mIHN0cmluZ1xuXG4gIG1heCA9IHN0YXRlLnNraXBTcGFjZXNCYWNrKG1heCwgcG9zKTtcbiAgdG1wID0gc3RhdGUuc2tpcENoYXJzQmFjayhtYXgsIDB4MjMsIHBvcyk7IC8vICNcbiAgaWYgKHRtcCA+IHBvcyAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHRtcCAtIDEpKSkge1xuICAgIG1heCA9IHRtcDtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpLnRyaW0oKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCIvLyBIb3Jpem9udGFsIHJ1bGVcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBocihzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG1hcmtlciwgY250LCBjaCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIC8vIENoZWNrIGhyIG1hcmtlclxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDVGLyogXyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG1hcmtlcnMgY2FuIGJlIG1peGVkIHdpdGggc3BhY2VzLCBidXQgdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IDMgb2YgdGhlbVxuXG4gIGNudCA9IDE7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICBpZiAoY2ggIT09IG1hcmtlciAmJiAhaXNTcGFjZShjaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKGNoID09PSBtYXJrZXIpIHsgY250Kys7IH1cbiAgfVxuXG4gIGlmIChjbnQgPCAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdocicsICdocicsIDApO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5tYXJrdXAgPSBBcnJheShjbnQgKyAxKS5qb2luKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHIuanMiLCIvLyBIVE1MIGJsb2NrXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYmxvY2tfbmFtZXMgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9ibG9ja3MnKTtcbnZhciBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX09QRU5fQ0xPU0VfVEFHX1JFO1xuXG4vLyBBbiBhcnJheSBvZiBvcGVuaW5nIGFuZCBjb3JyZXNwb25kaW5nIGNsb3Npbmcgc2VxdWVuY2VzIGZvciBodG1sIHRhZ3MsXG4vLyBsYXN0IGFyZ3VtZW50IGRlZmluZXMgd2hldGhlciBpdCBjYW4gdGVybWluYXRlIGEgcGFyYWdyYXBoIG9yIG5vdFxuLy9cbnZhciBIVE1MX1NFUVVFTkNFUyA9IFtcbiAgWyAvXjwoc2NyaXB0fHByZXxzdHlsZSkoPz0oXFxzfD58JCkpL2ksIC88XFwvKHNjcmlwdHxwcmV8c3R5bGUpPi9pLCB0cnVlIF0sXG4gIFsgL148IS0tLywgICAgICAgIC8tLT4vLCAgIHRydWUgXSxcbiAgWyAvXjxcXD8vLCAgICAgICAgIC9cXD8+LywgICB0cnVlIF0sXG4gIFsgL148IVtBLVpdLywgICAgIC8+LywgICAgIHRydWUgXSxcbiAgWyAvXjwhXFxbQ0RBVEFcXFsvLCAvXFxdXFxdPi8sIHRydWUgXSxcbiAgWyBuZXcgUmVnRXhwKCdePC8/KCcgKyBibG9ja19uYW1lcy5qb2luKCd8JykgKyAnKSg/PShcXFxcc3wvPz58JCkpJywgJ2knKSwgL14kLywgdHJ1ZSBdLFxuICBbIG5ldyBSZWdFeHAoSFRNTF9PUEVOX0NMT1NFX1RBR19SRS5zb3VyY2UgKyAnXFxcXHMqJCcpLCAgL14kLywgZmFsc2UgXVxuXTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfYmxvY2soc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBpLCBuZXh0TGluZSwgdG9rZW4sIGxpbmVUZXh0LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzBdLnRlc3QobGluZVRleHQpKSB7IGJyZWFrOyB9XG4gIH1cblxuICBpZiAoaSA9PT0gSFRNTF9TRVFVRU5DRVMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHtcbiAgICAvLyB0cnVlIGlmIHRoaXMgc2VxdWVuY2UgY2FuIGJlIGEgdGVybWluYXRvciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgcmV0dXJuIEhUTUxfU0VRVUVOQ0VTW2ldWzJdO1xuICB9XG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIC8vIElmIHdlIGFyZSBoZXJlIC0gd2UgZGV0ZWN0ZWQgSFRNTCBibG9jay5cbiAgLy8gTGV0J3Mgcm9sbCBkb3duIHRpbGwgYmxvY2sgZW5kLlxuICBpZiAoIUhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuICAgICAgbGluZVRleHQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gICAgICBpZiAoSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICAgICAgaWYgKGxpbmVUZXh0Lmxlbmd0aCAhPT0gMCkgeyBuZXh0TGluZSsrOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9ibG9jaycsICcnLCAwKTtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBuZXh0TGluZSBdO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwiLy8gbGhlYWRpbmcgKC0tLSwgPT09KVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBwb3MsIG1heCwgbGV2ZWwsIG1hcmtlcixcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSwgb2xkUGFyZW50VHlwZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnOyAvLyB1c2UgcGFyYWdyYXBoIHRvIG1hdGNoIHRlcm1pbmF0b3JSdWxlc1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvL1xuICAgIC8vIENoZWNrIGZvciB1bmRlcmxpbmUgaW4gc2V0ZXh0IGhlYWRlclxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAobWFya2VyID09PSAweDJELyogLSAqLyB8fCBtYXJrZXIgPT09IDB4M0QvKiA9ICovKSB7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICAgICAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgICAgICAgbGV2ZWwgPSAobWFya2VyID09PSAweDNELyogPSAqLyA/IDEgOiAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmICghbGV2ZWwpIHtcbiAgICAvLyBEaWRuJ3QgZmluZCB2YWxpZCB1bmRlcmxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIC0gMSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCIvLyBMaXN0c1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG4vLyBTZWFyY2ggYFstKypdW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhcnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIG1hcmtlciwgcG9zLCBtYXgsIGNoO1xuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgLy8gQ2hlY2sgYnVsbGV0XG4gIGlmIChtYXJrZXIgIT09IDB4MkEvKiAqICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkQvKiAtICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkIvKiArICovKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgIC8vIFwiIC10ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvcztcbn1cblxuLy8gU2VhcmNoIGBcXGQrWy4pXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYXJ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICB2YXIgY2gsXG4gICAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBwb3MgPSBzdGFydCxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIExpc3QgbWFya2VyIHNob3VsZCBoYXZlIGF0IGxlYXN0IDIgY2hhcnMgKGRpZ2l0ICsgZG90KVxuICBpZiAocG9zICsgMSA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgaWYgKGNoIDwgMHgzMC8qIDAgKi8gfHwgY2ggPiAweDM5LyogOSAqLykgeyByZXR1cm4gLTE7IH1cblxuICBmb3IgKDs7KSB7XG4gICAgLy8gRU9MIC0+IGZhaWxcbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gICAgaWYgKGNoID49IDB4MzAvKiAwICovICYmIGNoIDw9IDB4MzkvKiA5ICovKSB7XG5cbiAgICAgIC8vIExpc3QgbWFya2VyIHNob3VsZCBoYXZlIG5vIG1vcmUgdGhhbiA5IGRpZ2l0c1xuICAgICAgLy8gKHByZXZlbnRzIGludGVnZXIgb3ZlcmZsb3cgaW4gYnJvd3NlcnMpXG4gICAgICBpZiAocG9zIC0gc3RhcnQgPj0gMTApIHsgcmV0dXJuIC0xOyB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZvdW5kIHZhbGlkIG1hcmtlclxuICAgIGlmIChjaCA9PT0gMHgyOS8qICkgKi8gfHwgY2ggPT09IDB4MmUvKiAuICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAxLnRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn1cblxuZnVuY3Rpb24gbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgaWR4KSB7XG4gIHZhciBpLCBsLFxuICAgICAgbGV2ZWwgPSBzdGF0ZS5sZXZlbCArIDI7XG5cbiAgZm9yIChpID0gaWR4ICsgMiwgbCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHN0YXRlLnRva2Vuc1tpXS5sZXZlbCA9PT0gbGV2ZWwgJiYgc3RhdGUudG9rZW5zW2ldLnR5cGUgPT09ICdwYXJhZ3JhcGhfb3BlbicpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tpICsgMl0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnRva2Vuc1tpXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgaSArPSAyO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgY29udGVudFN0YXJ0LFxuICAgICAgaSxcbiAgICAgIGluZGVudCxcbiAgICAgIGluZGVudEFmdGVyTWFya2VyLFxuICAgICAgaW5pdGlhbCxcbiAgICAgIGlzT3JkZXJlZCxcbiAgICAgIGl0ZW1MaW5lcyxcbiAgICAgIGwsXG4gICAgICBsaXN0TGluZXMsXG4gICAgICBsaXN0VG9rSWR4LFxuICAgICAgbWFya2VyQ2hhckNvZGUsXG4gICAgICBtYXJrZXJWYWx1ZSxcbiAgICAgIG1heCxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkTEluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBvbGRUaWdodCxcbiAgICAgIHBvcyxcbiAgICAgIHBvc0FmdGVyTWFya2VyLFxuICAgICAgcHJldkVtcHR5RW5kLFxuICAgICAgc3RhcnQsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0b2tlbixcbiAgICAgIGlzVGVybWluYXRpbmdQYXJhZ3JhcGggPSBmYWxzZSxcbiAgICAgIHRpZ2h0ID0gdHJ1ZTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBsaW1pdCBjb25kaXRpb25zIHdoZW4gbGlzdCBjYW4gaW50ZXJydXB0XG4gIC8vIGEgcGFyYWdyYXBoICh2YWxpZGF0aW9uIG1vZGUgb25seSlcbiAgaWYgKHNpbGVudCAmJiBzdGF0ZS5wYXJlbnRUeXBlID09PSAncGFyYWdyYXBoJykge1xuICAgIC8vIE5leHQgbGlzdCBpdGVtIHNob3VsZCBzdGlsbCB0ZXJtaW5hdGUgcHJldmlvdXMgbGlzdCBpdGVtO1xuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGNhbiBmYWlsIGlmIHBsdWdpbnMgdXNlIGJsa0luZGVudCBhcyB3ZWxsIGFzIGxpc3RzLFxuICAgIC8vIGJ1dCBJIGhvcGUgdGhlIHNwZWMgZ2V0cyBmaXhlZCBsb25nIGJlZm9yZSB0aGF0IGhhcHBlbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBEZXRlY3QgbGlzdCB0eXBlIGFuZCBwb3NpdGlvbiBhZnRlciBtYXJrZXJcbiAgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSkgPj0gMCkge1xuICAgIGlzT3JkZXJlZCA9IHRydWU7XG4gICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG1hcmtlclZhbHVlID0gTnVtYmVyKHN0YXRlLnNyYy5zdWJzdHIoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gc3RhcnQgLSAxKSk7XG5cbiAgICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyBvcmRlcmVkIGxpc3QgcmlnaHQgYWZ0ZXJcbiAgICAvLyBhIHBhcmFncmFwaCwgaXQgc2hvdWxkIHN0YXJ0IHdpdGggMS5cbiAgICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCAmJiBtYXJrZXJWYWx1ZSAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gIH0gZWxzZSBpZiAoKHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSBmYWxzZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIHN0YXJ0aW5nIGEgbmV3IHVub3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gIC8vIGEgcGFyYWdyYXBoLCBmaXJzdCBsaW5lIHNob3VsZCBub3QgYmUgZW1wdHkuXG4gIGlmIChpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoKSB7XG4gICAgaWYgKHN0YXRlLnNraXBTcGFjZXMocG9zQWZ0ZXJNYXJrZXIpID49IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBXZSBzaG91bGQgdGVybWluYXRlIGxpc3Qgb24gc3R5bGUgY2hhbmdlLiBSZW1lbWJlciBmaXJzdCBvbmUgdG8gY29tcGFyZS5cbiAgbWFya2VyQ2hhckNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpO1xuXG4gIC8vIEZvciB2YWxpZGF0aW9uIG1vZGUgd2UgY2FuIHRlcm1pbmF0ZSBpbW1lZGlhdGVseVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gU3RhcnQgbGlzdFxuICBsaXN0VG9rSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgdG9rZW4gICAgICAgPSBzdGF0ZS5wdXNoKCdvcmRlcmVkX2xpc3Rfb3BlbicsICdvbCcsIDEpO1xuICAgIGlmIChtYXJrZXJWYWx1ZSAhPT0gMSkge1xuICAgICAgdG9rZW4uYXR0cnMgPSBbIFsgJ3N0YXJ0JywgbWFya2VyVmFsdWUgXSBdO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3Rfb3BlbicsICd1bCcsIDEpO1xuICB9XG5cbiAgdG9rZW4ubWFwICAgID0gbGlzdExpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcbiAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgLy9cbiAgLy8gSXRlcmF0ZSBsaXN0IGl0ZW1zXG4gIC8vXG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmU7XG4gIHByZXZFbXB0eUVuZCA9IGZhbHNlO1xuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnbGlzdCcpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2xpc3QnO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBwb3MgPSBwb3NBZnRlck1hcmtlcjtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyBwb3NBZnRlck1hcmtlciAtIChzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdKTtcblxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKSAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBjb250ZW50U3RhcnQgPSBwb3M7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCkge1xuICAgICAgLy8gdHJpbW1pbmcgc3BhY2UgaW4gXCItICAgIFxcbiAgM1wiIGNhc2UsIGluZGVudCBpcyAxIGhlcmVcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBcIiAgLSAgdGVzdFwiXG4gICAgLy8gIF5eXl5eIC0gY2FsY3VsYXRpbmcgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdGhpbmdcbiAgICBpbmRlbnQgPSBpbml0aWFsICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG5cbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX29wZW4nLCAnbGknLCAxKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gICAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XG4gICAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgb2xkTEluZGVudCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuICAgIHN0YXRlLmJsa0luZGVudCA9IGluZGVudDtcbiAgICBzdGF0ZS50aWdodCA9IHRydWU7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBjb250ZW50U3RhcnQgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldDtcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4ICYmIHN0YXRlLmlzRW1wdHkoc3RhcnRMaW5lICsgMSkpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIHRoaXMgY2FzZVxuICAgICAgLy8gKGxpc3QgaXRlbSBpcyBlbXB0eSwgbGlzdCB0ZXJtaW5hdGVzIGJlZm9yZSBcImZvb1wiKTpcbiAgICAgIC8vIH5+fn5+fn5+XG4gICAgICAvLyAgIC1cbiAgICAgIC8vXG4gICAgICAvLyAgICAgZm9vXG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgc3RhdGUubGluZSA9IE1hdGgubWluKHN0YXRlLmxpbmUgKyAyLCBlbmRMaW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG9mIGxpc3QgaXRlbSBpcyB0aWdodCwgbWFyayBsaXN0IGFzIHRpZ2h0XG4gICAgaWYgKCFzdGF0ZS50aWdodCB8fCBwcmV2RW1wdHlFbmQpIHtcbiAgICAgIHRpZ2h0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEl0ZW0gYmVjb21lIGxvb3NlIGlmIGZpbmlzaCB3aXRoIGVtcHR5IGxpbmUsXG4gICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgcHJldkVtcHR5RW5kID0gKHN0YXRlLmxpbmUgLSBzdGFydExpbmUpID4gMSAmJiBzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKTtcblxuICAgIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IG9sZFRTaGlmdDtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9sZExJbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSBvbGRUaWdodDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9jbG9zZScsICdsaScsIC0xKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICAgIG5leHRMaW5lID0gc3RhcnRMaW5lID0gc3RhdGUubGluZTtcbiAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvL1xuICAgIC8vIFRyeSB0byBjaGVjayBpZiBsaXN0IGlzIHRlcm1pbmF0ZWQgb3IgY29udGludWVkLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIC8vIGZhaWwgaWYgdGVybWluYXRpbmcgYmxvY2sgZm91bmRcbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIGxpc3QgaGFzIGFub3RoZXIgdHlwZVxuICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAobWFya2VyQ2hhckNvZGUgIT09IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIC8vIEZpbmlsaXplIGxpc3RcbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X2Nsb3NlJywgJ29sJywgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3RfY2xvc2UnLCAndWwnLCAtMSk7XG4gIH1cbiAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgbGlzdExpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICAvLyBtYXJrIHBhcmFncmFwaHMgdGlnaHQgaWYgbmVlZGVkXG4gIGlmICh0aWdodCkge1xuICAgIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGxpc3RUb2tJZHgpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIi8vIFBhcmFncmFwaFxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3RhdGUsIHN0YXJ0TGluZS8qLCBlbmRMaW5lKi8pIHtcbiAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIG9sZFBhcmVudFR5cGUsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyksXG4gICAgICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnO1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9vcGVuJywgJ3AnLCAxKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9jbG9zZScsICdwJywgLTEpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVmZXJlbmNlKHN0YXRlLCBzdGFydExpbmUsIF9lbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgZGVzdEVuZFBvcyxcbiAgICAgIGRlc3RFbmRMaW5lTm8sXG4gICAgICBlbmRMaW5lLFxuICAgICAgaHJlZixcbiAgICAgIGksXG4gICAgICBsLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICByZXMsXG4gICAgICBzdGFydCxcbiAgICAgIHN0cixcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW1wbGUgY2hlY2sgdG8gcXVpY2tseSBpbnRlcnJ1cHQgc2NhbiBvbiBbbGlua10odXJsKSBhdCB0aGUgc3RhcnQgb2YgbGluZS5cbiAgLy8gQ2FuIGJlIHVzZWZ1bCBvbiBwcmFjdGljZTogaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2lzc3Vlcy81NFxuICB3aGlsZSAoKytwb3MgPCBtYXgpIHtcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1RCAvKiBdICovICYmXG4gICAgICAgIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyAtIDEpICE9PSAweDVDLyogXFwgKi8pIHtcbiAgICAgIGlmIChwb3MgKyAxID09PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncmVmZXJlbmNlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncmVmZXJlbmNlJztcblxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIHN0ciA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcbiAgbWF4ID0gc3RyLmxlbmd0aDtcblxuICBmb3IgKHBvcyA9IDE7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxhYmVsRW5kID0gcG9zO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgwQSAvKiBcXG4gKi8pIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLykge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZXMrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobGFiZWxFbmQgPCAwIHx8IHN0ci5jaGFyQ29kZUF0KGxhYmVsRW5kICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgXl5eIHNraXAgb3B0aW9uYWwgd2hpdGVzcGFjZSBoZXJlXG4gIGZvciAocG9zID0gbGFiZWxFbmQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICBeXl5eXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCk7XG4gIGlmICghcmVzLm9rKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSByZXMucG9zO1xuICBsaW5lcyArPSByZXMubGluZXM7XG5cbiAgLy8gc2F2ZSBjdXJzb3Igc3RhdGUsIHdlIGNvdWxkIHJlcXVpcmUgdG8gcm9sbGJhY2sgbGF0ZXJcbiAgZGVzdEVuZFBvcyA9IHBvcztcbiAgZGVzdEVuZExpbmVObyA9IGxpbmVzO1xuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBeXl4gc2tpcHBpbmcgdGhvc2Ugc3BhY2VzXG4gIHN0YXJ0ID0gcG9zO1xuICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICBwb3MgPSByZXMucG9zO1xuICAgIGxpbmVzICs9IHJlcy5saW5lcztcbiAgfSBlbHNlIHtcbiAgICB0aXRsZSA9ICcnO1xuICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICB9XG5cbiAgLy8gc2tpcCB0cmFpbGluZyBzcGFjZXMgdW50aWwgdGhlIHJlc3Qgb2YgdGhlIGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSBhZnRlciB0aXRsZSxcbiAgICAgIC8vIGJ1dCBpdCBjb3VsZCBzdGlsbCBiZSBhIHZhbGlkIHJlZmVyZW5jZSBpZiB3ZSByb2xsIGJhY2tcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2Uoc3RyLnNsaWNlKDEsIGxhYmVsRW5kKSk7XG4gIGlmICghbGFiZWwpIHtcbiAgICAvLyBDb21tb25NYXJrIDAuMjAgZGlzYWxsb3dzIGVtcHR5IGxhYmVsc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFJlZmVyZW5jZSBjYW4gbm90IHRlcm1pbmF0ZSBhbnl0aGluZy4gVGhpcyBjaGVjayBpcyBmb3Igc2FmZXR5IG9ubHkuXG4gIC8qaXN0YW5idWwgaWdub3JlIGlmKi9cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXMgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPSB7IHRpdGxlOiB0aXRsZSwgaHJlZjogaHJlZiB9O1xuICB9XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIGxpbmVzICsgMTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzIiwiLy8gUGFyc2VyIHN0YXRlIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBTdGF0ZUJsb2NrKHNyYywgbWQsIGVudiwgdG9rZW5zKSB7XG4gIHZhciBjaCwgcywgc3RhcnQsIHBvcywgbGVuLCBpbmRlbnQsIG9mZnNldCwgaW5kZW50X2ZvdW5kO1xuXG4gIHRoaXMuc3JjID0gc3JjO1xuXG4gIC8vIGxpbmsgdG8gcGFyc2VyIGluc3RhbmNlXG4gIHRoaXMubWQgICAgID0gbWQ7XG5cbiAgdGhpcy5lbnYgPSBlbnY7XG5cbiAgLy9cbiAgLy8gSW50ZXJuYWwgc3RhdGUgdmFydGlhYmxlc1xuICAvL1xuXG4gIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuXG4gIHRoaXMuYk1hcmtzID0gW107ICAvLyBsaW5lIGJlZ2luIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy5lTWFya3MgPSBbXTsgIC8vIGxpbmUgZW5kIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy50U2hpZnQgPSBbXTsgIC8vIG9mZnNldHMgb2YgdGhlIGZpcnN0IG5vbi1zcGFjZSBjaGFyYWN0ZXJzICh0YWJzIG5vdCBleHBhbmRlZClcbiAgdGhpcy5zQ291bnQgPSBbXTsgIC8vIGluZGVudHMgZm9yIGVhY2ggbGluZSAodGFicyBleHBhbmRlZClcblxuICAvLyBBbiBhbW91bnQgb2YgdmlydHVhbCBzcGFjZXMgKHRhYnMgZXhwYW5kZWQpIGJldHdlZW4gYmVnaW5uaW5nXG4gIC8vIG9mIGVhY2ggbGluZSAoYk1hcmtzKSBhbmQgcmVhbCBiZWdpbm5pbmcgb2YgdGhhdCBsaW5lLlxuICAvL1xuICAvLyBJdCBleGlzdHMgb25seSBhcyBhIGhhY2sgYmVjYXVzZSBibG9ja3F1b3RlcyBvdmVycmlkZSBiTWFya3NcbiAgLy8gbG9zaW5nIGluZm9ybWF0aW9uIGluIHRoZSBwcm9jZXNzLlxuICAvL1xuICAvLyBJdCdzIHVzZWQgb25seSB3aGVuIGV4cGFuZGluZyB0YWJzLCB5b3UgY2FuIHRoaW5rIGFib3V0IGl0IGFzXG4gIC8vIGFuIGluaXRpYWwgdGFiIGxlbmd0aCwgZS5nLiBic0NvdW50PTIxIGFwcGxpZWQgdG8gc3RyaW5nIGBcXHQxMjNgXG4gIC8vIG1lYW5zIGZpcnN0IHRhYiBzaG91bGQgYmUgZXhwYW5kZWQgdG8gNC0yMSU0ID09PSAzIHNwYWNlcy5cbiAgLy9cbiAgdGhpcy5ic0NvdW50ID0gW107XG5cbiAgLy8gYmxvY2sgcGFyc2VyIHZhcmlhYmxlc1xuICB0aGlzLmJsa0luZGVudCAgPSAwOyAvLyByZXF1aXJlZCBibG9jayBjb250ZW50IGluZGVudFxuICAgICAgICAgICAgICAgICAgICAgICAvLyAoZm9yIGV4YW1wbGUsIGlmIHdlIGFyZSBpbiBsaXN0KVxuICB0aGlzLmxpbmUgICAgICAgPSAwOyAvLyBsaW5lIGluZGV4IGluIHNyY1xuICB0aGlzLmxpbmVNYXggICAgPSAwOyAvLyBsaW5lcyBjb3VudFxuICB0aGlzLnRpZ2h0ICAgICAgPSBmYWxzZTsgIC8vIGxvb3NlL3RpZ2h0IG1vZGUgZm9yIGxpc3RzXG4gIHRoaXMuZGRJbmRlbnQgICA9IC0xOyAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgZGQgYmxvY2sgKC0xIGlmIHRoZXJlIGlzbid0IGFueSlcblxuICAvLyBjYW4gYmUgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdyb290JywgJ3BhcmFncmFwaCcgb3IgJ3JlZmVyZW5jZSdcbiAgLy8gdXNlZCBpbiBsaXN0cyB0byBkZXRlcm1pbmUgaWYgdGhleSBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGhcbiAgdGhpcy5wYXJlbnRUeXBlID0gJ3Jvb3QnO1xuXG4gIHRoaXMubGV2ZWwgPSAwO1xuXG4gIC8vIHJlbmRlcmVyXG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgLy8gQ3JlYXRlIGNhY2hlc1xuICAvLyBHZW5lcmF0ZSBtYXJrZXJzLlxuICBzID0gdGhpcy5zcmM7XG4gIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuXG4gIGZvciAoc3RhcnQgPSBwb3MgPSBpbmRlbnQgPSBvZmZzZXQgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgIGNoID0gcy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWluZGVudF9mb3VuZCkge1xuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGluZGVudCsrO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIG9mZnNldCArPSA0IC0gb2Zmc2V0ICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudF9mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBIHx8IHBvcyA9PT0gbGVuIC0gMSkge1xuICAgICAgaWYgKGNoICE9PSAweDBBKSB7IHBvcysrOyB9XG4gICAgICB0aGlzLmJNYXJrcy5wdXNoKHN0YXJ0KTtcbiAgICAgIHRoaXMuZU1hcmtzLnB1c2gocG9zKTtcbiAgICAgIHRoaXMudFNoaWZ0LnB1c2goaW5kZW50KTtcbiAgICAgIHRoaXMuc0NvdW50LnB1c2gob2Zmc2V0KTtcbiAgICAgIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gICAgICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggZmFrZSBlbnRyeSB0byBzaW1wbGlmeSBjYWNoZSBib3VuZHMgY2hlY2tzXG4gIHRoaXMuYk1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLmVNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy50U2hpZnQucHVzaCgwKTtcbiAgdGhpcy5zQ291bnQucHVzaCgwKTtcbiAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgdGhpcy5saW5lTWF4ID0gdGhpcy5iTWFya3MubGVuZ3RoIC0gMTsgLy8gZG9uJ3QgY291bnQgbGFzdCBmYWtlIGxpbmVcbn1cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcbiAgdG9rZW4uYmxvY2sgPSB0cnVlO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XG5cbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgcmV0dXJuIHRoaXMuYk1hcmtzW2xpbmVdICsgdGhpcy50U2hpZnRbbGluZV0gPj0gdGhpcy5lTWFya3NbbGluZV07XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIHNraXBFbXB0eUxpbmVzKGZyb20pIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4OyBmcm9tKyspIHtcbiAgICBpZiAodGhpcy5iTWFya3NbZnJvbV0gKyB0aGlzLnRTaGlmdFtmcm9tXSA8IHRoaXMuZU1hcmtzW2Zyb21dKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb207XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlcyA9IGZ1bmN0aW9uIHNraXBTcGFjZXMocG9zKSB7XG4gIHZhciBjaDtcblxuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24gaW4gcmV2ZXJzZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXNCYWNrID0gZnVuY3Rpb24gc2tpcFNwYWNlc0JhY2socG9zLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoIWlzU3BhY2UodGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyBmcm9tIGdpdmVuIHBvc2l0aW9uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmICh0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IGNvZGUpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIHJldmVyc2UgZnJvbSBnaXZlbiBwb3NpdGlvbiAtIDFcblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFyc0JhY2sgPSBmdW5jdGlvbiBza2lwQ2hhcnNCYWNrKHBvcywgY29kZSwgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKGNvZGUgIT09IHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIGN1dCBsaW5lcyByYW5nZSBmcm9tIHNvdXJjZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmVnaW4sIGVuZCwgaW5kZW50LCBrZWVwTGFzdExGKSB7XG4gIHZhciBpLCBsaW5lSW5kZW50LCBjaCwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBsaW5lU3RhcnQsXG4gICAgICBsaW5lID0gYmVnaW47XG5cbiAgaWYgKGJlZ2luID49IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcblxuICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgIGxpbmVJbmRlbnQgPSAwO1xuICAgIGxpbmVTdGFydCA9IGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV07XG5cbiAgICBpZiAobGluZSArIDEgPCBlbmQgfHwga2VlcExhc3RMRikge1xuICAgICAgLy8gTm8gbmVlZCBmb3IgYm91bmRzIGNoZWNrIGJlY2F1c2Ugd2UgaGF2ZSBmYWtlIGVudHJ5IG9uIHRhaWwuXG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV07XG4gICAgfVxuXG4gICAgd2hpbGUgKGZpcnN0IDwgbGFzdCAmJiBsaW5lSW5kZW50IDwgaW5kZW50KSB7XG4gICAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoZmlyc3QpO1xuXG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgbGluZUluZGVudCArPSA0IC0gKGxpbmVJbmRlbnQgKyB0aGlzLmJzQ291bnRbbGluZV0pICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3QgLSBsaW5lU3RhcnQgPCB0aGlzLnRTaGlmdFtsaW5lXSkge1xuICAgICAgICAvLyBwYXRjaGVkIHRTaGlmdCBtYXNrZWQgY2hhcmFjdGVycyB0byBsb29rIGxpa2Ugc3BhY2VzIChibG9ja3F1b3RlcywgbGlzdCBtYXJrZXJzKVxuICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZmlyc3QrKztcbiAgICB9XG5cbiAgICBpZiAobGluZUluZGVudCA+IGluZGVudCkge1xuICAgICAgLy8gcGFydGlhbGx5IGV4cGFuZGluZyB0YWJzIGluIGNvZGUgYmxvY2tzLCBlLmcgJ1xcdFxcdGZvb2JhcidcbiAgICAgIC8vIHdpdGggaW5kZW50PTIgYmVjb21lcyAnICBcXHRmb29iYXInXG4gICAgICBxdWV1ZVtpXSA9IG5ldyBBcnJheShsaW5lSW5kZW50IC0gaW5kZW50ICsgMSkuam9pbignICcpICsgdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZVtpXSA9IHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVldWUuam9pbignJyk7XG59O1xuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwiLy8gR0ZNIHRhYmxlLCBub24tc3RhbmRhcmRcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gZ2V0TGluZShzdGF0ZSwgbGluZSkge1xuICB2YXIgcG9zID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUuYmxrSW5kZW50LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW2xpbmVdO1xuXG4gIHJldHVybiBzdGF0ZS5zcmMuc3Vic3RyKHBvcywgbWF4IC0gcG9zKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZFNwbGl0KHN0cikge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBwb3MgPSAwLFxuICAgICAgbWF4ID0gc3RyLmxlbmd0aCxcbiAgICAgIGNoLFxuICAgICAgZXNjYXBlcyA9IDAsXG4gICAgICBsYXN0UG9zID0gMCxcbiAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZSxcbiAgICAgIGxhc3RCYWNrVGljayA9IDA7XG5cbiAgY2ggID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgaWYgKGNoID09PSAweDYwLyogYCAqLykge1xuICAgICAgaWYgKGJhY2tUaWNrZWQpIHtcbiAgICAgICAgLy8gbWFrZSBcXGAgY2xvc2UgY29kZSBzZXF1ZW5jZSwgYnV0IG5vdCBvcGVuIGl0O1xuICAgICAgICAvLyB0aGUgcmVhc29uIGlzOiBgXFxgIGlzIGNvcnJlY3QgY29kZSBibG9ja1xuICAgICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlcyAlIDIgPT09IDApIHtcbiAgICAgICAgYmFja1RpY2tlZCA9IHRydWU7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDdjLyogfCAqLyAmJiAoZXNjYXBlcyAlIDIgPT09IDApICYmICFiYWNrVGlja2VkKSB7XG4gICAgICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIHBvcykpO1xuICAgICAgbGFzdFBvcyA9IHBvcyArIDE7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDVjLyogXFwgKi8pIHtcbiAgICAgIGVzY2FwZXMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgZXNjYXBlcyA9IDA7XG4gICAgfVxuXG4gICAgcG9zKys7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgYW4gdW4tY2xvc2VkIGJhY2t0aWNrLCBnbyBiYWNrIHRvIGp1c3QgYWZ0ZXJcbiAgICAvLyB0aGUgbGFzdCBiYWNrdGljaywgYnV0IGFzIGlmIGl0IHdhcyBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAgICBpZiAocG9zID09PSBtYXggJiYgYmFja1RpY2tlZCkge1xuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlO1xuICAgICAgcG9zID0gbGFzdEJhY2tUaWNrICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gIH1cblxuICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MpKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGFibGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGluZVRleHQsIHBvcywgaSwgbmV4dExpbmUsIGNvbHVtbnMsIGNvbHVtbkNvdW50LCB0b2tlbixcbiAgICAgIGFsaWducywgdCwgdGFibGVMaW5lcywgdGJvZHlMaW5lcztcblxuICAvLyBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0d28gbGluZXNcbiAgaWYgKHN0YXJ0TGluZSArIDIgPiBlbmRMaW5lKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc2Vjb25kIGxpbmUgc2hvdWxkIGJlICd8JywgJy0nLCAnOicsXG4gIC8vIGFuZCBubyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBhbGxvd2VkIGJ1dCBzcGFjZXM7XG4gIC8vIGJhc2ljYWxseSwgdGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiAvXlstOnxdWy06fFxcc10qJC8gcmVnZXhwXG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUgKyAxKTtcblxuICBjb2x1bW5zID0gbGluZVRleHQuc3BsaXQoJ3wnKTtcbiAgYWxpZ25zID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdCA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIGlmICghdCkge1xuICAgICAgLy8gYWxsb3cgZW1wdHkgY29sdW1ucyBiZWZvcmUgYW5kIGFmdGVyIHRhYmxlLCBidXQgbm90IGluIGJldHdlZW4gY29sdW1ucztcbiAgICAgIC8vIGUuZy4gYWxsb3cgYCB8LS0tfCBgLCBkaXNhbGxvdyBgIC0tLXx8LS0tIGBcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGNvbHVtbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eOj8tKzo/JC8udGVzdCh0KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSkgPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBhbGlnbnMucHVzaCh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovID8gJ2NlbnRlcicgOiAncmlnaHQnKTtcbiAgICB9IGVsc2UgaWYgKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKCdsZWZ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWducy5wdXNoKCcnKTtcbiAgICB9XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSkudHJpbSgpO1xuICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgLy8gaGVhZGVyIHJvdyB3aWxsIGRlZmluZSBhbiBhbW91bnQgb2YgY29sdW1ucyBpbiB0aGUgZW50aXJlIHRhYmxlLFxuICAvLyBhbmQgYWxpZ24gcm93IHNob3VsZG4ndCBiZSBzbWFsbGVyIHRoYW4gdGhhdCAodGhlIHJlc3Qgb2YgdGhlIHJvd3MgY2FuKVxuICBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoO1xuICBpZiAoY29sdW1uQ291bnQgPiBhbGlnbnMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0YWJsZV9vcGVuJywgJ3RhYmxlJywgMSk7XG4gIHRva2VuLm1hcCA9IHRhYmxlTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX29wZW4nLCAndGhlYWQnLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gIHRva2VuLm1hcCA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG5cbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX29wZW4nLCAndGgnLCAxKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgIH1cblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX2Nsb3NlJywgJ3RoJywgLTEpO1xuICB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX2Nsb3NlJywgJ3RoZWFkJywgLTEpO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3Rib2R5X29wZW4nLCAndGJvZHknLCAxKTtcbiAgdG9rZW4ubWFwID0gdGJvZHlMaW5lcyA9IFsgc3RhcnRMaW5lICsgMiwgMCBdO1xuXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAyOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBuZXh0TGluZSkudHJpbSgpO1xuICAgIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IGJyZWFrOyB9XG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyBicmVhazsgfVxuICAgIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9vcGVuJywgJ3RkJywgMSk7XG4gICAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0gPyBjb2x1bW5zW2ldLnRyaW0oKSA6ICcnO1xuICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9jbG9zZScsICd0ZCcsIC0xKTtcbiAgICB9XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgfVxuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3Rib2R5X2Nsb3NlJywgJ3Rib2R5JywgLTEpO1xuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RhYmxlX2Nsb3NlJywgJ3RhYmxlJywgLTEpO1xuXG4gIHRhYmxlTGluZXNbMV0gPSB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svdGFibGUuanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9jayhzdGF0ZSkge1xuICB2YXIgdG9rZW47XG5cbiAgaWYgKHN0YXRlLmlubGluZU1vZGUpIHtcbiAgICB0b2tlbiAgICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyAwLCAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubWQuYmxvY2sucGFyc2Uoc3RhdGUuc3JjLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucywgdG9rLCBpLCBsO1xuXG4gIC8vIFBhcnNlIGlubGluZXNcbiAgZm9yIChpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2sgPSB0b2tlbnNbaV07XG4gICAgaWYgKHRvay50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKHRvay5jb250ZW50LCBzdGF0ZS5tZCwgc3RhdGUuZW52LCB0b2suY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvaW5saW5lLmpzIiwiLy8gUmVwbGFjZSBsaW5rLWxpa2UgdGV4dHMgd2l0aCBsaW5rIG5vZGVzLlxuLy9cbi8vIEN1cnJlbnRseSByZXN0cmljdGVkIGJ5IGBtZC52YWxpZGF0ZUxpbmsoKWAgdG8gaHR0cC9odHRwcy9mdHBcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGFycmF5UmVwbGFjZUF0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuYXJyYXlSZXBsYWNlQXQ7XG5cblxuZnVuY3Rpb24gaXNMaW5rT3BlbihzdHIpIHtcbiAgcmV0dXJuIC9ePGFbPlxcc10vaS50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc0xpbmtDbG9zZShzdHIpIHtcbiAgcmV0dXJuIC9ePFxcL2FcXHMqPi9pLnRlc3Qoc3RyKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmtpZnkoc3RhdGUpIHtcbiAgdmFyIGksIGosIGwsIHRva2VucywgdG9rZW4sIGN1cnJlbnRUb2tlbiwgbm9kZXMsIGxuLCB0ZXh0LCBwb3MsIGxhc3RQb3MsXG4gICAgICBsZXZlbCwgaHRtbExpbmtMZXZlbCwgdXJsLCBmdWxsVXJsLCB1cmxUZXh0LFxuICAgICAgYmxvY2tUb2tlbnMgPSBzdGF0ZS50b2tlbnMsXG4gICAgICBsaW5rcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMubGlua2lmeSkgeyByZXR1cm47IH1cblxuICBmb3IgKGogPSAwLCBsID0gYmxvY2tUb2tlbnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgaWYgKGJsb2NrVG9rZW5zW2pdLnR5cGUgIT09ICdpbmxpbmUnIHx8XG4gICAgICAgICFzdGF0ZS5tZC5saW5raWZ5LnByZXRlc3QoYmxvY2tUb2tlbnNbal0uY29udGVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRva2VucyA9IGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuO1xuXG4gICAgaHRtbExpbmtMZXZlbCA9IDA7XG5cbiAgICAvLyBXZSBzY2FuIGZyb20gdGhlIGVuZCwgdG8ga2VlcCBwb3NpdGlvbiB3aGVuIG5ldyB0YWdzIGFkZGVkLlxuICAgIC8vIFVzZSByZXZlcnNlZCBsb2dpYyBpbiBsaW5rcyBzdGFydC9lbmQgbWF0Y2hcbiAgICBmb3IgKGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGN1cnJlbnRUb2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgLy8gU2tpcCBjb250ZW50IG9mIG1hcmtkb3duIGxpbmtzXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJykge1xuICAgICAgICBpLS07XG4gICAgICAgIHdoaWxlICh0b2tlbnNbaV0ubGV2ZWwgIT09IGN1cnJlbnRUb2tlbi5sZXZlbCAmJiB0b2tlbnNbaV0udHlwZSAhPT0gJ2xpbmtfb3BlbicpIHtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBodG1sIHRhZyBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnaHRtbF9pbmxpbmUnKSB7XG4gICAgICAgIGlmIChpc0xpbmtPcGVuKGN1cnJlbnRUb2tlbi5jb250ZW50KSAmJiBodG1sTGlua0xldmVsID4gMCkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaW5rQ2xvc2UoY3VycmVudFRva2VuLmNvbnRlbnQpKSB7XG4gICAgICAgICAgaHRtbExpbmtMZXZlbCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaHRtbExpbmtMZXZlbCA+IDApIHsgY29udGludWU7IH1cblxuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAndGV4dCcgJiYgc3RhdGUubWQubGlua2lmeS50ZXN0KGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuXG4gICAgICAgIHRleHQgPSBjdXJyZW50VG9rZW4uY29udGVudDtcbiAgICAgICAgbGlua3MgPSBzdGF0ZS5tZC5saW5raWZ5Lm1hdGNoKHRleHQpO1xuXG4gICAgICAgIC8vIE5vdyBzcGxpdCBzdHJpbmcgdG8gbm9kZXNcbiAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgbGV2ZWwgPSBjdXJyZW50VG9rZW4ubGV2ZWw7XG4gICAgICAgIGxhc3RQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobG4gPSAwOyBsbiA8IGxpbmtzLmxlbmd0aDsgbG4rKykge1xuXG4gICAgICAgICAgdXJsID0gbGlua3NbbG5dLnVybDtcbiAgICAgICAgICBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluayh1cmwpO1xuICAgICAgICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB1cmxUZXh0ID0gbGlua3NbbG5dLnRleHQ7XG5cbiAgICAgICAgICAvLyBMaW5raWZpZXIgbWlnaHQgc2VuZCByYXcgaG9zdG5hbWVzIGxpa2UgXCJleGFtcGxlLmNvbVwiLCB3aGVyZSB1cmxcbiAgICAgICAgICAvLyBzdGFydHMgd2l0aCBkb21haW4gbmFtZS4gU28gd2UgcHJlcGVuZCBodHRwOi8vIGluIHRob3NlIGNhc2VzLFxuICAgICAgICAgIC8vIGFuZCByZW1vdmUgaXQgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmICghbGlua3NbbG5dLnNjaGVtYSkge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KCdodHRwOi8vJyArIHVybFRleHQpLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sICcnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmtzW2xuXS5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdCh1cmxUZXh0KSkge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KCdtYWlsdG86JyArIHVybFRleHQpLnJlcGxhY2UoL15tYWlsdG86LywgJycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsVGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9zID0gbGlua3NbbG5dLmluZGV4O1xuXG4gICAgICAgICAgaWYgKHBvcyA+IGxhc3RQb3MpIHtcbiAgICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dC5zbGljZShsYXN0UG9zLCBwb3MpO1xuICAgICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsKys7XG4gICAgICAgICAgdG9rZW4ubWFya3VwICA9ICdsaW5raWZ5JztcbiAgICAgICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdXJsVGV4dDtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IC0tbGV2ZWw7XG4gICAgICAgICAgdG9rZW4ubWFya3VwICA9ICdsaW5raWZ5JztcbiAgICAgICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgbGFzdFBvcyA9IGxpbmtzW2xuXS5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQb3MgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcyk7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjZSBjdXJyZW50IG5vZGVcbiAgICAgICAgYmxvY2tUb2tlbnNbal0uY2hpbGRyZW4gPSB0b2tlbnMgPSBhcnJheVJlcGxhY2VBdCh0b2tlbnMsIGksIG5vZGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMiLCIvLyBOb3JtYWxpemUgaW5wdXQgc3RyaW5nXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgTkVXTElORVNfUkUgID0gL1xccltcXG5cXHUwMDg1XT98W1xcdTI0MjRcXHUyMDI4XFx1MDA4NV0vZztcbnZhciBOVUxMX1JFICAgICAgPSAvXFx1MDAwMC9nO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5saW5lKHN0YXRlKSB7XG4gIHZhciBzdHI7XG5cbiAgLy8gTm9ybWFsaXplIG5ld2xpbmVzXG4gIHN0ciA9IHN0YXRlLnNyYy5yZXBsYWNlKE5FV0xJTkVTX1JFLCAnXFxuJyk7XG5cbiAgLy8gUmVwbGFjZSBOVUxMIGNoYXJhY3RlcnNcbiAgc3RyID0gc3RyLnJlcGxhY2UoTlVMTF9SRSwgJ1xcdUZGRkQnKTtcblxuICBzdGF0ZS5zcmMgPSBzdHI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCIvLyBTaW1wbGUgdHlwb2dyYXBoeWMgcmVwbGFjZW1lbnRzXG4vL1xuLy8gKGMpIChDKSDihpIgwqlcbi8vICh0bSkgKFRNKSDihpIg4oSiXG4vLyAocikgKFIpIOKGkiDCrlxuLy8gKy0g4oaSIMKxXG4vLyAocCkgKFApIC0+IMKnXG4vLyAuLi4g4oaSIOKApiAoYWxzbyA/Li4uLiDihpIgPy4uLCAhLi4uLiDihpIgIS4uKVxuLy8gPz8/Pz8/Pz8g4oaSID8/PywgISEhISEg4oaSICEhISwgYCwsYCDihpIgYCxgXG4vLyAtLSDihpIgJm5kYXNoOywgLS0tIOKGkiAmbWRhc2g7XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOlxuLy8gLSBmcmFjdGlvbmFscyAxLzIsIDEvNCwgMy80IC0+IMK9LCDCvCwgwr5cbi8vIC0gbWlsdGlwbGljYXRpb24gMiB4IDQgLT4gMiDDlyA0XG5cbnZhciBSQVJFX1JFID0gL1xcKy18XFwuXFwufFxcP1xcP1xcP1xcP3whISEhfCwsfC0tLztcblxuLy8gV29ya2Fyb3VuZCBmb3IgcGhhbnRvbWpzIC0gbmVlZCByZWdleCB3aXRob3V0IC9nIGZsYWcsXG4vLyBvciByb290IGNoZWNrIHdpbGwgZmFpbCBldmVyeSBzZWNvbmQgdGltZVxudmFyIFNDT1BFRF9BQkJSX1RFU1RfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pO1xuXG52YXIgU0NPUEVEX0FCQlJfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pZztcbnZhciBTQ09QRURfQUJCUiA9IHtcbiAgYzogJ8KpJyxcbiAgcjogJ8KuJyxcbiAgcDogJ8KnJyxcbiAgdG06ICfihKInXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlRm4obWF0Y2gsIG5hbWUpIHtcbiAgcmV0dXJuIFNDT1BFRF9BQkJSW25hbWUudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2Vfc2NvcGVkKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50LnJlcGxhY2UoU0NPUEVEX0FCQlJfUkUsIHJlcGxhY2VGbik7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlX3JhcmUoaW5saW5lVG9rZW5zKSB7XG4gIHZhciBpLCB0b2tlbiwgaW5zaWRlX2F1dG9saW5rID0gMDtcblxuICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgaWYgKFJBUkVfUkUudGVzdCh0b2tlbi5jb250ZW50KSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwrLS9nLCAnwrEnKVxuICAgICAgICAgICAgICAgICAgICAvLyAuLiwgLi4uLCAuLi4uLi4uIC0+IOKAplxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgPy4uLi4uICYgIS4uLi4uIC0+ID8uLiAmICEuLlxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuezIsfS9nLCAn4oCmJykucmVwbGFjZSgvKFs/IV0p4oCmL2csICckMS4uJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbPyFdKXs0LH0vZywgJyQxJDEkMScpLnJlcGxhY2UoLyx7Mix9L2csICcsJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW0tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXSktLS0oW14tXXwkKS9tZywgJyQxXFx1MjAxNCQyJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW4tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58XFxzKS0tKFxcc3wkKS9tZywgJyQxXFx1MjAxMyQyJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLVxcc10pLS0oW14tXFxzXXwkKS9tZywgJyQxXFx1MjAxMyQyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKFNDT1BFRF9BQkJSX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChSQVJFX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2VfcmFyZShzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcyIsIi8vIENvbnZlcnQgc3RyYWlnaHQgcXVvdGF0aW9uIG1hcmtzIHRvIHR5cG9ncmFwaGljIG9uZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxudmFyIFFVT1RFX1RFU1RfUkUgPSAvWydcIl0vO1xudmFyIFFVT1RFX1JFID0gL1snXCJdL2c7XG52YXIgQVBPU1RST1BIRSA9ICdcXHUyMDE5JzsgLyog4oCZICovXG5cblxuZnVuY3Rpb24gcmVwbGFjZUF0KHN0ciwgaW5kZXgsIGNoKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIGluZGV4KSArIGNoICsgc3RyLnN1YnN0cihpbmRleCArIDEpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzX2lubGluZXModG9rZW5zLCBzdGF0ZSkge1xuICB2YXIgaSwgdG9rZW4sIHRleHQsIHQsIHBvcywgbWF4LCB0aGlzTGV2ZWwsIGl0ZW0sIGxhc3RDaGFyLCBuZXh0Q2hhcixcbiAgICAgIGlzTGFzdFB1bmN0Q2hhciwgaXNOZXh0UHVuY3RDaGFyLCBpc0xhc3RXaGl0ZVNwYWNlLCBpc05leHRXaGl0ZVNwYWNlLFxuICAgICAgY2FuT3BlbiwgY2FuQ2xvc2UsIGosIGlzU2luZ2xlLCBzdGFjaywgb3BlblF1b3RlLCBjbG9zZVF1b3RlO1xuXG4gIHN0YWNrID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgdGhpc0xldmVsID0gdG9rZW5zW2ldLmxldmVsO1xuXG4gICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8PSB0aGlzTGV2ZWwpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgc3RhY2subGVuZ3RoID0gaiArIDE7XG5cbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcbiAgICBwb3MgPSAwO1xuICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgLyplc2xpbnQgbm8tbGFiZWxzOjAsYmxvY2stc2NvcGVkLXZhcjowKi9cbiAgICBPVVRFUjpcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBRVU9URV9SRS5sYXN0SW5kZXggPSBwb3M7XG4gICAgICB0ID0gUVVPVEVfUkUuZXhlYyh0ZXh0KTtcbiAgICAgIGlmICghdCkgeyBicmVhazsgfVxuXG4gICAgICBjYW5PcGVuID0gY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgcG9zID0gdC5pbmRleCArIDE7XG4gICAgICBpc1NpbmdsZSA9ICh0WzBdID09PSBcIidcIik7XG5cbiAgICAgIC8vIEZpbmQgcHJldmlvdXMgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBsYXN0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmICh0LmluZGV4IC0gMSA+PSAwKSB7XG4gICAgICAgIGxhc3RDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHQuaW5kZXggLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBsYXN0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQodG9rZW5zW2pdLmNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbmV4dENoYXIgPSAweDIwO1xuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG5leHRDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBuZXh0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgICAgIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgICAgIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dENoYXIgPT09IDB4MjIgLyogXCIgKi8gJiYgdFswXSA9PT0gJ1wiJykge1xuICAgICAgICBpZiAobGFzdENoYXIgPj0gMHgzMCAvKiAwICovICYmIGxhc3RDaGFyIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogMVwiXCIgLSBjb3VudCBmaXJzdCBxdW90ZSBhcyBhbiBpbmNoXG4gICAgICAgICAgY2FuQ2xvc2UgPSBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4gJiYgY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdHJlYXQgdGhpcyBhcyB0aGUgbWlkZGxlIG9mIHRoZSB3b3JkXG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgY2FuQ2xvc2UgPSBpc05leHRQdW5jdENoYXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2FuT3BlbiAmJiAhY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gbWlkZGxlIG9mIHdvcmRcbiAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbkNsb3NlKSB7XG4gICAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBjbG9zaW5nIHF1b3RlLCByZXdpbmQgdGhlIHN0YWNrIHRvIGdldCBhIG1hdGNoXG4gICAgICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuICAgICAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgICAgICAgIGlmIChpdGVtLnNpbmdsZSA9PT0gaXNTaW5nbGUgJiYgc3RhY2tbal0ubGV2ZWwgPT09IHRoaXNMZXZlbCkge1xuICAgICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuXG4gICAgICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMl07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1szXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzBdO1xuICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdG9rZW4uY29udGVudCAqYmVmb3JlKiB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UsIGlmIHRoZXkgYXJlIHBvaW50aW5nIGF0IHRoZSBzYW1lIHRva2VuLCByZXBsYWNlQXRcbiAgICAgICAgICAgIC8vIGNvdWxkIG1lc3MgdXAgaW5kaWNlcyB3aGVuIHF1b3RlIGxlbmd0aCAhPSAxXG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIGNsb3NlUXVvdGUpO1xuICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQgPSByZXBsYWNlQXQoXG4gICAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LCBpdGVtLnBvcywgb3BlblF1b3RlKTtcblxuICAgICAgICAgICAgcG9zICs9IGNsb3NlUXVvdGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChpdGVtLnRva2VuID09PSBpKSB7IHBvcyArPSBvcGVuUXVvdGUubGVuZ3RoIC0gMTsgfVxuXG4gICAgICAgICAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcbiAgICAgICAgICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggPSBqO1xuICAgICAgICAgICAgY29udGludWUgT1VURVI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5PcGVuKSB7XG4gICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgIHRva2VuOiBpLFxuICAgICAgICAgIHBvczogdC5pbmRleCxcbiAgICAgICAgICBzaW5nbGU6IGlzU2luZ2xlLFxuICAgICAgICAgIGxldmVsOiB0aGlzTGV2ZWxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbkNsb3NlICYmIGlzU2luZ2xlKSB7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzbWFydHF1b3RlcyhzdGF0ZSkge1xuICAvKmVzbGludCBtYXgtZGVwdGg6MCovXG4gIHZhciBibGtJZHg7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLnR5cG9ncmFwaGVyKSB7IHJldHVybjsgfVxuXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tibGtJZHhdLnR5cGUgIT09ICdpbmxpbmUnIHx8XG4gICAgICAgICFRVU9URV9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb2Nlc3NfaW5saW5lcyhzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbiwgc3RhdGUpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qcyIsIi8vIENvcmUgc3RhdGUgb2JqZWN0XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xuXG5cbmZ1bmN0aW9uIFN0YXRlQ29yZShzcmMsIG1kLCBlbnYpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLmlubGluZU1vZGUgPSBmYWxzZTtcbiAgdGhpcy5tZCA9IG1kOyAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxufVxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGNvcmUgcnVsZXNcblN0YXRlQ29yZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5qcyIsIi8vIFByb2Nlc3MgYXV0b2xpbmtzICc8cHJvdG9jb2w6Li4uPidcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qZXNsaW50IG1heC1sZW46MCovXG52YXIgRU1BSUxfUkUgICAgPSAvXjwoW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKik+LztcbnZhciBBVVRPTElOS19SRSA9IC9ePChbYS16QS1aXVthLXpBLVowLTkrLlxcLV17MSwzMX0pOihbXjw+XFx4MDAtXFx4MjBdKik+LztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF1dG9saW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHRhaWwsIGxpbmtNYXRjaCwgZW1haWxNYXRjaCwgdXJsLCBmdWxsVXJsLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdGFpbCA9IHN0YXRlLnNyYy5zbGljZShwb3MpO1xuXG4gIGlmICh0YWlsLmluZGV4T2YoJz4nKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKEFVVE9MSU5LX1JFLnRlc3QodGFpbCkpIHtcbiAgICBsaW5rTWF0Y2ggPSB0YWlsLm1hdGNoKEFVVE9MSU5LX1JFKTtcblxuICAgIHVybCA9IGxpbmtNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gbGlua01hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFTUFJTF9SRS50ZXN0KHRhaWwpKSB7XG4gICAgZW1haWxNYXRjaCA9IHRhaWwubWF0Y2goRU1BSUxfUkUpO1xuXG4gICAgdXJsID0gZW1haWxNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gZW1haWxNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2F1dG9saW5rLmpzIiwiLy8gUGFyc2UgYmFja3RpY2tzXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYWNrdGljayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBzdGFydCwgbWF4LCBtYXJrZXIsIG1hdGNoU3RhcnQsIG1hdGNoRW5kLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4NjAvKiBgICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gcG9zO1xuICBwb3MrKztcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg2MC8qIGAgKi8pIHsgcG9zKys7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7XG5cbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xuXG4gIHdoaWxlICgobWF0Y2hTdGFydCA9IHN0YXRlLnNyYy5pbmRleE9mKCdgJywgbWF0Y2hFbmQpKSAhPT0gLTEpIHtcbiAgICBtYXRjaEVuZCA9IG1hdGNoU3RhcnQgKyAxO1xuXG4gICAgd2hpbGUgKG1hdGNoRW5kIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KG1hdGNoRW5kKSA9PT0gMHg2MC8qIGAgKi8pIHsgbWF0Y2hFbmQrKzsgfVxuXG4gICAgaWYgKG1hdGNoRW5kIC0gbWF0Y2hTdGFydCA9PT0gbWFya2VyLmxlbmd0aCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfaW5saW5lJywgJ2NvZGUnLCAwKTtcbiAgICAgICAgdG9rZW4ubWFya3VwICA9IG1hcmtlcjtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1hdGNoU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyBcXG5dKy9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gbWF0Y2hFbmQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjsgfVxuICBzdGF0ZS5wb3MgKz0gbWFya2VyLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIi8vIEZvciBlYWNoIG9wZW5pbmcgZW1waGFzaXMtbGlrZSBtYXJrZXIgZmluZCBhIG1hdGNoaW5nIGNsb3Npbmcgb25lXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua19wYWlycyhzdGF0ZSkge1xuICB2YXIgaSwgaiwgbGFzdERlbGltLCBjdXJyRGVsaW0sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGxhc3REZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoIWxhc3REZWxpbS5jbG9zZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaiA9IGkgLSBsYXN0RGVsaW0uanVtcCAtIDE7XG5cbiAgICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgICBjdXJyRGVsaW0gPSBkZWxpbWl0ZXJzW2pdO1xuXG4gICAgICBpZiAoY3VyckRlbGltLm9wZW4gJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubWFya2VyID09PSBsYXN0RGVsaW0ubWFya2VyICYmXG4gICAgICAgICAgY3VyckRlbGltLmVuZCA8IDAgJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubGV2ZWwgPT09IGxhc3REZWxpbS5sZXZlbCkge1xuXG4gICAgICAgIC8vIHR5cGVvZnMgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggcGx1Z2luc1xuICAgICAgICB2YXIgb2RkX21hdGNoID0gKGN1cnJEZWxpbS5jbG9zZSB8fCBsYXN0RGVsaW0ub3BlbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyRGVsaW0ubGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxhc3REZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VyckRlbGltLmxlbmd0aCArIGxhc3REZWxpbS5sZW5ndGgpICUgMyA9PT0gMDtcblxuICAgICAgICBpZiAoIW9kZF9tYXRjaCkge1xuICAgICAgICAgIGxhc3REZWxpbS5qdW1wID0gaSAtIGo7XG4gICAgICAgICAgbGFzdERlbGltLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kICA9IGk7XG4gICAgICAgICAgY3VyckRlbGltLmp1bXAgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGogLT0gY3VyckRlbGltLmp1bXAgKyAxO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzLmpzIiwiLy8gUHJvY2VzcyBodG1sIGVudGl0eSAtICYjMTIzOywgJiN4QUY7LCAmcXVvdDssIC4uLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbnRpdGllcyAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lbnRpdGllcycpO1xudmFyIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaGFzO1xudmFyIGlzVmFsaWRFbnRpdHlDb2RlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNWYWxpZEVudGl0eUNvZGU7XG52YXIgZnJvbUNvZGVQb2ludCAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5mcm9tQ29kZVBvaW50O1xuXG5cbnZhciBESUdJVEFMX1JFID0gL14mIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSk7L2k7XG52YXIgTkFNRURfUkUgICA9IC9eJihbYS16XVthLXowLTldezEsMzF9KTsvaTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVudGl0eShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgY29kZSwgbWF0Y2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI2LyogJiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMSA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjMgLyogIyAqLykge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChESUdJVEFMX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIGNvZGUgPSBtYXRjaFsxXVswXS50b0xvd2VyQ2FzZSgpID09PSAneCcgPyBwYXJzZUludChtYXRjaFsxXS5zbGljZSgxKSwgMTYpIDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpID8gZnJvbUNvZGVQb2ludChjb2RlKSA6IGZyb21Db2RlUG9pbnQoMHhGRkZEKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChOQU1FRF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKGhhcyhlbnRpdGllcywgbWF0Y2hbMV0pKSB7XG4gICAgICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBlbnRpdGllc1ttYXRjaFsxXV07IH1cbiAgICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnJic7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCIvLyBQcm9jZWVzcyBlc2NhcGVkIGNoYXJzIGFuZCBoYXJkYnJlYWtzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG52YXIgRVNDQVBFRCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7IEVTQ0FQRUQucHVzaCgwKTsgfVxuXG4nXFxcXCFcIiMkJSZcXCcoKSorLC4vOjs8PT4/QFtdXl9ge3x9fi0nXG4gIC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2gpIHsgRVNDQVBFRFtjaC5jaGFyQ29kZUF0KDApXSA9IDE7IH0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXNjYXBlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qy8qIFxcICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcysrO1xuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggPCAyNTYgJiYgRVNDQVBFRFtjaF0gIT09IDApIHtcbiAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3Bvc107IH1cbiAgICAgIHN0YXRlLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wdXNoKCdoYXJkYnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgICAvLyBza2lwIGxlYWRpbmcgd2hpdGVzcGFjZXMgZnJvbSBuZXh0IGxpbmVcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICdcXFxcJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5qcyIsIi8vIFByb2Nlc3MgaHRtbCB0YWdzXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgSFRNTF9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfVEFHX1JFO1xuXG5cbmZ1bmN0aW9uIGlzTGV0dGVyKGNoKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIHZhciBsYyA9IGNoIHwgMHgyMDsgLy8gdG8gbG93ZXIgY2FzZVxuICByZXR1cm4gKGxjID49IDB4NjEvKiBhICovKSAmJiAobGMgPD0gMHg3YS8qIHogKi8pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9pbmxpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIG1hdGNoLCBtYXgsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIENoZWNrIHN0YXJ0XG4gIG1heCA9IHN0YXRlLnBvc01heDtcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovIHx8XG4gICAgICBwb3MgKyAyID49IG1heCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFF1aWNrIGZhaWwgb24gc2Vjb25kIGNoYXJcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgaWYgKGNoICE9PSAweDIxLyogISAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YvKiA/ICovICYmXG4gICAgICBjaCAhPT0gMHgyRi8qIC8gKi8gJiZcbiAgICAgICFpc0xldHRlcihjaCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKEhUTUxfVEFHX1JFKTtcbiAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCIvLyBQcm9jZXNzICFbaW1hZ2VdKDxzcmM+IFwidGl0bGVcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW1hZ2Uoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgY29udGVudCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVmLFxuICAgICAgcmVzLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIHRva2VucyxcbiAgICAgIHN0YXJ0LFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDIxLyogISAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMjtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MgKyAxLCBmYWxzZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH0gZWxzZSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UoXG4gICAgICBjb250ZW50LFxuICAgICAgc3RhdGUubWQsXG4gICAgICBzdGF0ZS5lbnYsXG4gICAgICB0b2tlbnMgPSBbXVxuICAgICk7XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2ltYWdlJywgJ2ltZycsIDApO1xuICAgIHRva2VuLmF0dHJzICAgID0gYXR0cnMgPSBbIFsgJ3NyYycsIGhyZWYgXSwgWyAnYWx0JywgJycgXSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gdG9rZW5zO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaW1hZ2UuanMiLCIvLyBQcm9jZXNzIFtsaW5rXSg8dG8+IFwic3R1ZmZcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBhdHRycyxcbiAgICAgIGNvZGUsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlcyxcbiAgICAgIHJlZixcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICBocmVmID0gJycsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDE7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zLCB0cnVlKTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIG1pZ2h0IGhhdmUgZm91bmQgYSB2YWxpZCBzaG9ydGN1dCBsaW5rLCBkaXNhYmxlIHJlZmVyZW5jZSBwYXJzaW5nXG4gICAgcGFyc2VSZWZlcmVuY2UgPSBmYWxzZTtcblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHBvcysrO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2luZyBsaW5rIHRpdGxlXG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgICBwb3MgPSByZXMucG9zO1xuXG4gICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGUgPSAnJztcbiAgICB9XG5cbiAgICBpZiAocG9zID49IG1heCB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI5LyogKSAqLykge1xuICAgICAgLy8gcGFyc2luZyBhIHZhbGlkIHNob3J0Y3V0IGxpbmsgZmFpbGVkLCBmYWxsYmFjayB0byByZWZlcmVuY2VcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocGFyc2VSZWZlcmVuY2UpIHtcbiAgICAvL1xuICAgIC8vIExpbmsgcmVmZXJlbmNlXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgIHBvcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHBvcyk7XG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcysrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgIH1cblxuICAgIC8vIGNvdmVycyBsYWJlbCA9PT0gJycgYW5kIGxhYmVsID09PSB1bmRlZmluZWRcbiAgICAvLyAoY29sbGFwc2VkIHJlZmVyZW5jZSBsaW5rIGFuZCBzaG9ydGN1dCByZWZlcmVuY2UgbGluayByZXNwZWN0aXZlbHkpXG4gICAgaWYgKCFsYWJlbCkgeyBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7IH1cblxuICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xuICAgIGlmICghcmVmKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhyZWYgPSByZWYuaHJlZjtcbiAgICB0aXRsZSA9IHJlZi50aXRsZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIGZvdW5kIHRoZSBlbmQgb2YgdGhlIGxpbmssIGFuZCBrbm93IGZvciBhIGZhY3QgaXQncyBhIHZhbGlkIGxpbms7XG4gIC8vIHNvIGFsbCB0aGF0J3MgbGVmdCB0byBkbyBpcyB0byBjYWxsIHRva2VuaXplci5cbiAgLy9cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBzdGF0ZS5wb3MgPSBsYWJlbFN0YXJ0O1xuICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICB0b2tlbi5hdHRycyAgPSBhdHRycyA9IFsgWyAnaHJlZicsIGhyZWYgXSBdO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cblxuICAgIHN0YXRlLm1kLmlubGluZS50b2tlbml6ZShzdGF0ZSk7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanMiLCIvLyBQcm9jZWVzcyAnXFxuJ1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5ld2xpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG1heCwgbWF4LCBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEvKiBcXG4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG1heCA9IHN0YXRlLnBlbmRpbmcubGVuZ3RoIC0gMTtcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vICcgIFxcbicgLT4gaGFyZGJyZWFrXG4gIC8vIExvb2t1cCBpbiBwZW5kaW5nIGNoYXJzIGlzIGJhZCBwcmFjdGljZSEgRG9uJ3QgY29weSB0byBvdGhlciBydWxlcyFcbiAgLy8gUGVuZGluZyBzdHJpbmcgaXMgc3RvcmVkIGluIGNvbmNhdCBtb2RlLCBpbmRleGVkIGxvb2t1cHMgd2lsbCBjYXVzZVxuICAvLyBjb252ZXJ0aW9uIHRvIGZsYXQgbW9kZS5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAocG1heCA+PSAwICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4KSA9PT0gMHgyMCkge1xuICAgICAgaWYgKHBtYXggPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCAtIDEpID09PSAweDIwKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnJlcGxhY2UoLyArJC8sICcnKTtcbiAgICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApO1xuICAgIH1cbiAgfVxuXG4gIHBvcysrO1xuXG4gIC8vIHNraXAgaGVhZGluZyBzcGFjZXMgZm9yIG5leHQgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4ICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHsgcG9zKys7IH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwiLy8gSW5saW5lIHBhcnNlciBzdGF0ZVxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFRva2VuICAgICAgICAgID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XG5cblxuZnVuY3Rpb24gU3RhdGVJbmxpbmUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLm1kID0gbWQ7XG4gIHRoaXMudG9rZW5zID0gb3V0VG9rZW5zO1xuXG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5wb3NNYXggPSB0aGlzLnNyYy5sZW5ndGg7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLnBlbmRpbmcgPSAnJztcbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSAwO1xuXG4gIHRoaXMuY2FjaGUgPSB7fTsgICAgICAgIC8vIFN0b3JlcyB7IHN0YXJ0OiBlbmQgfSBwYWlycy4gVXNlZnVsIGZvciBiYWNrdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uIG9mIHBhaXJzIHBhcnNlIChlbXBoYXNpcywgc3RyaWtlcykuXG5cbiAgdGhpcy5kZWxpbWl0ZXJzID0gW107ICAgLy8gRW1waGFzaXMtbGlrZSBkZWxpbWl0ZXJzXG59XG5cblxuLy8gRmx1c2ggcGVuZGluZyB0ZXh0XG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2hQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgPSB0aGlzLnBlbmRpbmc7XG4gIHRva2VuLmxldmVsID0gdGhpcy5wZW5kaW5nTGV2ZWw7XG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLnBlbmRpbmcgPSAnJztcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy8gSWYgcGVuZGluZyB0ZXh0IGV4aXN0cyAtIGZsdXNoIGl0IGFzIHRleHQgdG9rZW5cbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgaWYgKHRoaXMucGVuZGluZykge1xuICAgIHRoaXMucHVzaFBlbmRpbmcoKTtcbiAgfVxuXG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XG5cbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSB0aGlzLmxldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuXG4vLyBTY2FuIGEgc2VxdWVuY2Ugb2YgZW1waGFzaXMtbGlrZSBtYXJrZXJzLCBhbmQgZGV0ZXJtaW5lIHdoZXRoZXJcbi8vIGl0IGNhbiBzdGFydCBhbiBlbXBoYXNpcyBzZXF1ZW5jZSBvciBlbmQgYW4gZW1waGFzaXMgc2VxdWVuY2UuXG4vL1xuLy8gIC0gc3RhcnQgLSBwb3NpdGlvbiB0byBzY2FuIGZyb20gKGl0IHNob3VsZCBwb2ludCBhdCBhIHZhbGlkIG1hcmtlcik7XG4vLyAgLSBjYW5TcGxpdFdvcmQgLSBkZXRlcm1pbmUgaWYgdGhlc2UgbWFya2VycyBjYW4gYmUgZm91bmQgaW5zaWRlIGEgd29yZFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5zY2FuRGVsaW1zID0gZnVuY3Rpb24gKHN0YXJ0LCBjYW5TcGxpdFdvcmQpIHtcbiAgdmFyIHBvcyA9IHN0YXJ0LCBsYXN0Q2hhciwgbmV4dENoYXIsIGNvdW50LCBjYW5fb3BlbiwgY2FuX2Nsb3NlLFxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSwgaXNMYXN0UHVuY3RDaGFyLFxuICAgICAgaXNOZXh0V2hpdGVTcGFjZSwgaXNOZXh0UHVuY3RDaGFyLFxuICAgICAgbGVmdF9mbGFua2luZyA9IHRydWUsXG4gICAgICByaWdodF9mbGFua2luZyA9IHRydWUsXG4gICAgICBtYXggPSB0aGlzLnBvc01heCxcbiAgICAgIG1hcmtlciA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIC8vIHRyZWF0IGJlZ2lubmluZyBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcbiAgbGFzdENoYXIgPSBzdGFydCA+IDAgPyB0aGlzLnNyYy5jaGFyQ29kZUF0KHN0YXJ0IC0gMSkgOiAweDIwO1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpID09PSBtYXJrZXIpIHsgcG9zKys7IH1cblxuICBjb3VudCA9IHBvcyAtIHN0YXJ0O1xuXG4gIC8vIHRyZWF0IGVuZCBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcbiAgbmV4dENoYXIgPSBwb3MgPCBtYXggPyB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgOiAweDIwO1xuXG4gIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XG4gIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gIGlzTmV4dFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuXG4gIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgbGVmdF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgbGVmdF9mbGFua2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjYW5TcGxpdFdvcmQpIHtcbiAgICBjYW5fb3BlbiAgPSBsZWZ0X2ZsYW5raW5nICAmJiAoIXJpZ2h0X2ZsYW5raW5nIHx8IGlzTGFzdFB1bmN0Q2hhcik7XG4gICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmcgJiYgKCFsZWZ0X2ZsYW5raW5nICB8fCBpc05leHRQdW5jdENoYXIpO1xuICB9IGVsc2Uge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmc7XG4gICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNhbl9vcGVuOiAgY2FuX29wZW4sXG4gICAgY2FuX2Nsb3NlOiBjYW5fY2xvc2UsXG4gICAgbGVuZ3RoOiAgICBjb3VudFxuICB9O1xufTtcblxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlSW5saW5lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZS5qcyIsIi8vIFNraXAgdGV4dCBjaGFyYWN0ZXJzIGZvciB0ZXh0IHRva2VuLCBwbGFjZSB0aG9zZSB0byBwZW5kaW5nIGJ1ZmZlclxuLy8gYW5kIGluY3JlbWVudCBjdXJyZW50IHBvc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gUnVsZSB0byBza2lwIHB1cmUgdGV4dFxuLy8gJ3t9JCVAfis9OicgcmVzZXJ2ZWQgZm9yIGV4dGVudGlvbnNcblxuLy8gISwgXCIsICMsICQsICUsICYsICcsICgsICksICosICssICwsIC0sIC4sIC8sIDosIDssIDwsID0sID4sID8sIEAsIFssIFxcLCBdLCBeLCBfLCBgLCB7LCB8LCB9LCBvciB+XG5cbi8vICEhISEgRG9uJ3QgY29uZnVzZSB3aXRoIFwiTWFya2Rvd24gQVNDSUkgUHVuY3R1YXRpb25cIiBjaGFyc1xuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG5mdW5jdGlvbiBpc1Rlcm1pbmF0b3JDaGFyKGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MEEvKiBcXG4gKi86XG4gICAgY2FzZSAweDIxLyogISAqLzpcbiAgICBjYXNlIDB4MjMvKiAjICovOlxuICAgIGNhc2UgMHgyNC8qICQgKi86XG4gICAgY2FzZSAweDI1LyogJSAqLzpcbiAgICBjYXNlIDB4MjYvKiAmICovOlxuICAgIGNhc2UgMHgyQS8qICogKi86XG4gICAgY2FzZSAweDJCLyogKyAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgzQS8qIDogKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0QvKiB9ICovOlxuICAgIGNhc2UgMHg3RS8qIH4gKi86XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLnBvc01heCAmJiAhaXNUZXJtaW5hdG9yQ2hhcihzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkge1xuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBvcyA9PT0gc3RhdGUucG9zKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHN0YXRlLnBvcywgcG9zKTsgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9uLCBmb3IgbWVtb3J5LlxuLy9cbi8vIEl0IGNvc3RzIDEwJSBvZiBwZXJmb3JtYW5jZSwgYnV0IGFsbG93cyBleHRlbmQgdGVybWluYXRvcnMgbGlzdCwgaWYgcGxhY2UgaXRcbi8vIHRvIGBQYXJjZXJJbmxpbmVgIHByb3BlcnR5LiBQcm9iYWJseSwgd2lsbCBzd2l0Y2ggdG8gaXQgc29tZXRpbWUsIHN1Y2hcbi8vIGZsZXhpYmlsaXR5IHJlcXVpcmVkLlxuXG4vKlxudmFyIFRFUk1JTkFUT1JfUkUgPSAvW1xcbiEjJCUmKitcXC06PD0+QFtcXFxcXFxdXl9ge31+XS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBpZHggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5zZWFyY2goVEVSTUlOQVRPUl9SRSk7XG5cbiAgLy8gZmlyc3QgY2hhciBpcyB0ZXJtaW5hdG9yIC0+IGVtcHR5IHRleHRcbiAgaWYgKGlkeCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBubyB0ZXJtaW5hdG9yIC0+IHRleHQgdGlsbCBlbmQgb2Ygc3RyaW5nXG4gIGlmIChpZHggPCAwKSB7XG4gICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTsgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnNyYy5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIGlkeCk7IH1cblxuICBzdGF0ZS5wb3MgKz0gaWR4O1xuXG4gIHJldHVybiB0cnVlO1xufTsqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCIvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGludG8gb25lLCBhbmQgcmUtY2FsY3VsYXRlIGFsbCB0b2tlbiBsZXZlbHNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0X2NvbGxhcHNlKHN0YXRlKSB7XG4gIHZhciBjdXJyLCBsYXN0LFxuICAgICAgbGV2ZWwgPSAwLFxuICAgICAgdG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbWF4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBmb3IgKGN1cnIgPSBsYXN0ID0gMDsgY3VyciA8IG1heDsgY3VycisrKSB7XG4gICAgLy8gcmUtY2FsY3VsYXRlIGxldmVsc1xuICAgIGxldmVsICs9IHRva2Vuc1tjdXJyXS5uZXN0aW5nO1xuICAgIHRva2Vuc1tjdXJyXS5sZXZlbCA9IGxldmVsO1xuXG4gICAgaWYgKHRva2Vuc1tjdXJyXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgY3VyciArIDEgPCBtYXggJiZcbiAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS50eXBlID09PSAndGV4dCcpIHtcblxuICAgICAgLy8gY29sbGFwc2UgdHdvIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgIHRva2Vuc1tjdXJyICsgMV0uY29udGVudCA9IHRva2Vuc1tjdXJyXS5jb250ZW50ICsgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkgeyB0b2tlbnNbbGFzdF0gPSB0b2tlbnNbY3Vycl07IH1cblxuICAgICAgbGFzdCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyICE9PSBsYXN0KSB7XG4gICAgdG9rZW5zLmxlbmd0aCA9IGxhc3Q7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxudmFyIGRlY29kZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBjYWNoZS5wdXNoKGNoKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgY2ggPSBleGNsdWRlLmNoYXJDb2RlQXQoaSk7XG4gICAgY2FjaGVbY2hdID0gJyUnICsgKCcwJyArIGNoLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59XG5cblxuLy8gRGVjb2RlIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcuXG4vL1xuZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgZXhjbHVkZSkge1xuICB2YXIgY2FjaGU7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIGV4Y2x1ZGUgPSBkZWNvZGUuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgY2FjaGUgPSBnZXREZWNvZGVDYWNoZShleGNsdWRlKTtcblxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyglW2EtZjAtOV17Mn0pKy9naSwgZnVuY3Rpb24oc2VxKSB7XG4gICAgdmFyIGksIGwsIGIxLCBiMiwgYjMsIGI0LCBjaHIsXG4gICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHNlcS5sZW5ndGg7IGkgPCBsOyBpICs9IDMpIHtcbiAgICAgIGIxID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxLCBpICsgMyksIDE2KTtcblxuICAgICAgaWYgKGIxIDwgMHg4MCkge1xuICAgICAgICByZXN1bHQgKz0gY2FjaGVbYjFdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RTApID09PSAweEMwICYmIChpICsgMyA8IGwpKSB7XG4gICAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDYpICYgMHg3QzApIHwgKGIyICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAzO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEYwKSA9PT0gMHhFMCAmJiAoaSArIDYgPCBsKSkge1xuICAgICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDEyKSAmIDB4RjAwMCkgfCAoKGIyIDw8IDYpICYgMHhGQzApIHwgKGIzICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHg4MDAgfHwgKGNociA+PSAweEQ4MDAgJiYgY2hyIDw9IDB4REZGRikpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDY7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjgpID09PSAweEYwICYmIChpICsgOSA8IGwpKSB7XG4gICAgICAgIC8vIDExMTExMHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuICAgICAgICBiNCA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMTAsIGkgKyAxMiksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODAgJiYgKGI0ICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDE4KSAmIDB4MUMwMDAwKSB8ICgoYjIgPDwgMTIpICYgMHgzRjAwMCkgfCAoKGIzIDw8IDYpICYgMHhGQzApIHwgKGI0ICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHgxMDAwMCB8fCBjaHIgPiAweDEwRkZGRikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyIC09IDB4MTAwMDA7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoY2hyID4+IDEwKSwgMHhEQzAwICsgKGNociAmIDB4M0ZGKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA5O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG5cblxuZGVjb2RlLmRlZmF1bHRDaGFycyAgID0gJzsvPzpAJj0rJCwjJztcbmRlY29kZS5jb21wb25lbnRDaGFycyA9ICcnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9kZWNvZGUuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICB2YXIgaSwgbCwgY29kZSwgbmV4dENvZGUsIGNhY2hlLFxuICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XG4gICAgZXhjbHVkZSA9IGVuY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgaWYgKG5leHRDb2RlID49IDB4REMwMCAmJiBuZXh0Q29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZW5jb2RlLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZW5jb2RlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXQodXJsKSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICByZXN1bHQgKz0gdXJsLnByb3RvY29sIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNsYXNoZXMgPyAnLy8nIDogJyc7XG4gIHJlc3VsdCArPSB1cmwuYXV0aCA/IHVybC5hdXRoICsgJ0AnIDogJyc7XG5cbiAgaWYgKHVybC5ob3N0bmFtZSAmJiB1cmwuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIC8vIGlwdjYgYWRkcmVzc1xuICAgIHJlc3VsdCArPSAnWycgKyB1cmwuaG9zdG5hbWUgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IHVybC5ob3N0bmFtZSB8fCAnJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwucG9ydCA/ICc6JyArIHVybC5wb3J0IDogJyc7XG4gIHJlc3VsdCArPSB1cmwucGF0aG5hbWUgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2VhcmNoIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLmhhc2ggfHwgJyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2Zvcm1hdC5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBDaGFuZ2VzIGZyb20gam95ZW50L25vZGU6XG4vL1xuLy8gMS4gTm8gbGVhZGluZyBzbGFzaCBpbiBwYXRocyxcbi8vICAgIGUuZy4gaW4gYHVybC5wYXJzZSgnaHR0cDovL2Zvbz9iYXInKWAgcGF0aG5hbWUgaXMgYGAsIG5vdCBgL2Bcbi8vXG4vLyAyLiBCYWNrc2xhc2hlcyBhcmUgbm90IHJlcGxhY2VkIHdpdGggc2xhc2hlcyxcbi8vICAgIHNvIGBodHRwOlxcXFxleGFtcGxlLm9yZ1xcYCBpcyB0cmVhdGVkIGxpa2UgYSByZWxhdGl2ZSBwYXRoXG4vL1xuLy8gMy4gVHJhaWxpbmcgY29sb24gaXMgdHJlYXRlZCBsaWtlIGEgcGFydCBvZiB0aGUgcGF0aCxcbi8vICAgIGkuZS4gaW4gYGh0dHA6Ly9leGFtcGxlLm9yZzpmb29gIHBhdGhuYW1lIGlzIGA6Zm9vYFxuLy9cbi8vIDQuIE5vdGhpbmcgaXMgVVJMLWVuY29kZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsXG4vLyAgICAoaW4gam95ZW50L25vZGUgc29tZSBjaGFycyBpbiBhdXRoIGFuZCBwYXRocyBhcmUgZW5jb2RlZClcbi8vXG4vLyA1LiBgdXJsLnBhcnNlKClgIGRvZXMgbm90IGhhdmUgYHBhcnNlUXVlcnlTdHJpbmdgIGFyZ3VtZW50XG4vL1xuLy8gNi4gUmVtb3ZlZCBleHRyYW5lb3VzIHJlc3VsdCBwcm9wZXJ0aWVzOiBgaG9zdGAsIGBwYXRoYCwgYHF1ZXJ5YCwgZXRjLixcbi8vICAgIHdoaWNoIGNhbiBiZSBjb25zdHJ1Y3RlZCB1c2luZyBvdGhlciBwYXJ0cyBvZiB0aGUgdXJsLlxuLy9cblxuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyAnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCcgXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyAneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnIF0uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsgJ1xcJycgXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsgJyUnLCAnLycsICc/JywgJzsnLCAnIycgXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWyAnLycsICc/JywgJyMnIF0sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zY3JpcHQtdXJsICovXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2NyaXB0LXVybCAqL1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSB7IHJldHVybiB1cmw7IH1cblxuICB2YXIgdSA9IG5ldyBVcmwoKTtcbiAgdS5wYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIHZhciBpLCBsLCBsb3dlclByb3RvLCBoZWMsIHNsYXNoZXMsXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IHByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChyZXN0W2hvc3RFbmQgLSAxXSA9PT0gJzonKSB7IGhvc3RFbmQtLTsgfVxuICAgIHZhciBob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoaG9zdCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH1cbiAgaWYgKHJlc3QpIHsgdGhpcy5wYXRobmFtZSA9IHJlc3Q7IH1cbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnJztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbihob3N0KSB7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB7IHRoaXMuaG9zdG5hbWUgPSBob3N0OyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybFBhcnNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9wYXJzZS5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3N0eWxlLWxvYWRlci9maXhVcmxzLmpzIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xceEFEXFx1MDYwMC1cXHUwNjA1XFx1MDYxQ1xcdTA2RERcXHUwNzBGXFx1MDhFMlxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNjRcXHUyMDY2LVxcdTIwNkZcXHVGRUZGXFx1RkZGOS1cXHVGRkZCXXxcXHVEODA0XFx1RENCRHxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdURCNDBbXFx1REMwMVxcdURDMjAtXFx1REM3Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFueSA9IHJlcXVpcmUoJy4vcHJvcGVydGllcy9BbnkvcmVnZXgnKTtcbmV4cG9ydHMuQ2MgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NjL3JlZ2V4Jyk7XG5leHBvcnRzLkNmICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DZi9yZWdleCcpO1xuZXhwb3J0cy5QICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuZXhwb3J0cy5aICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvWi9yZWdleCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuXzJZcktFbXJ1U1hxLUxZOEhUOWdqY0F7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtoZWlnaHQ6Y2FsYygxMDAlIC0gMjMwcHgpfS5fM0w1TkVCODRLeFBmbHhCWnZleXNkZHt0ZXh0LWFsaWduOnJpZ2h0O21hcmdpbi10b3A6MTVweH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJlZGl0b3JXcmFwXCI6IFwiXzJZcktFbXJ1U1hxLUxZOEhUOWdqY0FcIixcblx0XCJzYXZlQnV0dG9uXCI6IFwiXzNMNU5FQjg0S3hQZmx4Qlp2ZXlzZGRcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vY3NzLWxvYWRlcj97XCJtb2R1bGVzXCI6dHJ1ZSxcIm1pbmltaXplXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWV9IS4vc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLlplVzNISXdhX0JXSUdXMHlaSmk1R3t3aWR0aDoxMDAlO2ZvbnQtc2l6ZToyNHB0O3BhZGRpbmctbGVmdDoxMHB4fS5BQU1FTmNuZG1vLW83SWpqelFIUlksLlpjc2FadmNvZjB0eFdkZXFpa0NHWnt3aWR0aDoxMDAlO2ZvbnQtc2l6ZToxOHB0O3BhZGRpbmctbGVmdDoxMHB4fS5fMW91YXNqNjQ2TTdpOW9Ldy0wUV81NXtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlO2hlaWdodDpjYWxjKDEwMCUgLSAyMzBweCl9Ll8yTUxXUjhXX3BIZk5Ca0JtcDBuaTA4e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JhY2tncm91bmQ6I2ZjZmNmYztwYWRkaW5nOjEwcHg7b3ZlcmZsb3c6YXV0bztoZWlnaHQ6MTAwJX0uR0pZb25TSExPWFpKaFBTVXdaZHZie2xlZnQ6MH0udV9SU3l2QkxEN2IwWjEyaHBLOEQ0e2xlZnQ6NTAlO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uXzJnQXRnbTlvQURPclpZdDF1ZG1jSlJ7dGV4dC1hbGlnbjpyaWdodDttYXJnaW4tdG9wOjE1cHh9Ll8zTkJiSXI0V2xIeVVRYzI5WVc2YlNYe3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7cmVzaXplOm5vbmU7YmFja2dyb3VuZC1jb2xvcjojZmNmY2ZjO2JvcmRlcjpub25lO2ZvbnQtc2l6ZToxMHB0fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInRpdGxlXCI6IFwiWmVXM0hJd2FfQldJR1cweVpKaTVHXCIsXG5cdFwidGFnc1wiOiBcIlpjc2FadmNvZjB0eFdkZXFpa0NHWlwiLFxuXHRcInNsdWdcIjogXCJBQU1FTmNuZG1vLW83SWpqelFIUllcIixcblx0XCJlZGl0b3JXcmFwXCI6IFwiXzFvdWFzajY0Nk03aTlvS3ctMFFfNTVcIixcblx0XCJlZGl0b3JcIjogXCJfMk1MV1I4V19wSGZOQmtCbXAwbmkwOFwiLFxuXHRcImVkaXRvckxlZnRTaWRlXCI6IFwiR0pZb25TSExPWFpKaFBTVXdaZHZiXCIsXG5cdFwiZWRpdG9yUmlnaHRTaWRlXCI6IFwidV9SU3l2QkxEN2IwWjEyaHBLOEQ0XCIsXG5cdFwic2F2ZUJ1dHRvblwiOiBcIl8yZ0F0Z205b0FET3JaWXQxdWRtY0pSXCIsXG5cdFwidGV4dGFyZWFcIjogXCJfM05CYklyNFdsSHlVUWMyOVlXNmJTWFwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9jc3MtbG9hZGVyP3tcIm1vZHVsZXNcIjp0cnVlLFwibWluaW1pemVcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZX0hLi4vbGlicy9jb21wb25lbnRzL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcIkFhY3V0ZVwiOiBcIsOBXCIsXG5cdFwiYWFjdXRlXCI6IFwiw6FcIixcblx0XCJBYnJldmVcIjogXCLEglwiLFxuXHRcImFicmV2ZVwiOiBcIsSDXCIsXG5cdFwiYWNcIjogXCLiiL5cIixcblx0XCJhY2RcIjogXCLiiL9cIixcblx0XCJhY0VcIjogXCLiiL7Ms1wiLFxuXHRcIkFjaXJjXCI6IFwiw4JcIixcblx0XCJhY2lyY1wiOiBcIsOiXCIsXG5cdFwiYWN1dGVcIjogXCLCtFwiLFxuXHRcIkFjeVwiOiBcItCQXCIsXG5cdFwiYWN5XCI6IFwi0LBcIixcblx0XCJBRWxpZ1wiOiBcIsOGXCIsXG5cdFwiYWVsaWdcIjogXCLDplwiLFxuXHRcImFmXCI6IFwi4oGhXCIsXG5cdFwiQWZyXCI6IFwi8J2UhFwiLFxuXHRcImFmclwiOiBcIvCdlJ5cIixcblx0XCJBZ3JhdmVcIjogXCLDgFwiLFxuXHRcImFncmF2ZVwiOiBcIsOgXCIsXG5cdFwiYWxlZnN5bVwiOiBcIuKEtVwiLFxuXHRcImFsZXBoXCI6IFwi4oS1XCIsXG5cdFwiQWxwaGFcIjogXCLOkVwiLFxuXHRcImFscGhhXCI6IFwizrFcIixcblx0XCJBbWFjclwiOiBcIsSAXCIsXG5cdFwiYW1hY3JcIjogXCLEgVwiLFxuXHRcImFtYWxnXCI6IFwi4qi/XCIsXG5cdFwiYW1wXCI6IFwiJlwiLFxuXHRcIkFNUFwiOiBcIiZcIixcblx0XCJhbmRhbmRcIjogXCLiqZVcIixcblx0XCJBbmRcIjogXCLiqZNcIixcblx0XCJhbmRcIjogXCLiiKdcIixcblx0XCJhbmRkXCI6IFwi4qmcXCIsXG5cdFwiYW5kc2xvcGVcIjogXCLiqZhcIixcblx0XCJhbmR2XCI6IFwi4qmaXCIsXG5cdFwiYW5nXCI6IFwi4oigXCIsXG5cdFwiYW5nZVwiOiBcIuKmpFwiLFxuXHRcImFuZ2xlXCI6IFwi4oigXCIsXG5cdFwiYW5nbXNkYWFcIjogXCLipqhcIixcblx0XCJhbmdtc2RhYlwiOiBcIuKmqVwiLFxuXHRcImFuZ21zZGFjXCI6IFwi4qaqXCIsXG5cdFwiYW5nbXNkYWRcIjogXCLipqtcIixcblx0XCJhbmdtc2RhZVwiOiBcIuKmrFwiLFxuXHRcImFuZ21zZGFmXCI6IFwi4qatXCIsXG5cdFwiYW5nbXNkYWdcIjogXCLipq5cIixcblx0XCJhbmdtc2RhaFwiOiBcIuKmr1wiLFxuXHRcImFuZ21zZFwiOiBcIuKIoVwiLFxuXHRcImFuZ3J0XCI6IFwi4oifXCIsXG5cdFwiYW5ncnR2YlwiOiBcIuKKvlwiLFxuXHRcImFuZ3J0dmJkXCI6IFwi4qadXCIsXG5cdFwiYW5nc3BoXCI6IFwi4oiiXCIsXG5cdFwiYW5nc3RcIjogXCLDhVwiLFxuXHRcImFuZ3phcnJcIjogXCLijbxcIixcblx0XCJBb2dvblwiOiBcIsSEXCIsXG5cdFwiYW9nb25cIjogXCLEhVwiLFxuXHRcIkFvcGZcIjogXCLwnZS4XCIsXG5cdFwiYW9wZlwiOiBcIvCdlZJcIixcblx0XCJhcGFjaXJcIjogXCLiqa9cIixcblx0XCJhcFwiOiBcIuKJiFwiLFxuXHRcImFwRVwiOiBcIuKpsFwiLFxuXHRcImFwZVwiOiBcIuKJilwiLFxuXHRcImFwaWRcIjogXCLiiYtcIixcblx0XCJhcG9zXCI6IFwiJ1wiLFxuXHRcIkFwcGx5RnVuY3Rpb25cIjogXCLigaFcIixcblx0XCJhcHByb3hcIjogXCLiiYhcIixcblx0XCJhcHByb3hlcVwiOiBcIuKJilwiLFxuXHRcIkFyaW5nXCI6IFwiw4VcIixcblx0XCJhcmluZ1wiOiBcIsOlXCIsXG5cdFwiQXNjclwiOiBcIvCdkpxcIixcblx0XCJhc2NyXCI6IFwi8J2StlwiLFxuXHRcIkFzc2lnblwiOiBcIuKJlFwiLFxuXHRcImFzdFwiOiBcIipcIixcblx0XCJhc3ltcFwiOiBcIuKJiFwiLFxuXHRcImFzeW1wZXFcIjogXCLiiY1cIixcblx0XCJBdGlsZGVcIjogXCLDg1wiLFxuXHRcImF0aWxkZVwiOiBcIsOjXCIsXG5cdFwiQXVtbFwiOiBcIsOEXCIsXG5cdFwiYXVtbFwiOiBcIsOkXCIsXG5cdFwiYXdjb25pbnRcIjogXCLiiLNcIixcblx0XCJhd2ludFwiOiBcIuKokVwiLFxuXHRcImJhY2tjb25nXCI6IFwi4omMXCIsXG5cdFwiYmFja2Vwc2lsb25cIjogXCLPtlwiLFxuXHRcImJhY2twcmltZVwiOiBcIuKAtVwiLFxuXHRcImJhY2tzaW1cIjogXCLiiL1cIixcblx0XCJiYWNrc2ltZXFcIjogXCLii41cIixcblx0XCJCYWNrc2xhc2hcIjogXCLiiJZcIixcblx0XCJCYXJ2XCI6IFwi4qunXCIsXG5cdFwiYmFydmVlXCI6IFwi4oq9XCIsXG5cdFwiYmFyd2VkXCI6IFwi4oyFXCIsXG5cdFwiQmFyd2VkXCI6IFwi4oyGXCIsXG5cdFwiYmFyd2VkZ2VcIjogXCLijIVcIixcblx0XCJiYnJrXCI6IFwi4o61XCIsXG5cdFwiYmJya3RicmtcIjogXCLijrZcIixcblx0XCJiY29uZ1wiOiBcIuKJjFwiLFxuXHRcIkJjeVwiOiBcItCRXCIsXG5cdFwiYmN5XCI6IFwi0LFcIixcblx0XCJiZHF1b1wiOiBcIuKAnlwiLFxuXHRcImJlY2F1c1wiOiBcIuKItVwiLFxuXHRcImJlY2F1c2VcIjogXCLiiLVcIixcblx0XCJCZWNhdXNlXCI6IFwi4oi1XCIsXG5cdFwiYmVtcHR5dlwiOiBcIuKmsFwiLFxuXHRcImJlcHNpXCI6IFwiz7ZcIixcblx0XCJiZXJub3VcIjogXCLihKxcIixcblx0XCJCZXJub3VsbGlzXCI6IFwi4oSsXCIsXG5cdFwiQmV0YVwiOiBcIs6SXCIsXG5cdFwiYmV0YVwiOiBcIs6yXCIsXG5cdFwiYmV0aFwiOiBcIuKEtlwiLFxuXHRcImJldHdlZW5cIjogXCLiiaxcIixcblx0XCJCZnJcIjogXCLwnZSFXCIsXG5cdFwiYmZyXCI6IFwi8J2Un1wiLFxuXHRcImJpZ2NhcFwiOiBcIuKLglwiLFxuXHRcImJpZ2NpcmNcIjogXCLil69cIixcblx0XCJiaWdjdXBcIjogXCLii4NcIixcblx0XCJiaWdvZG90XCI6IFwi4qiAXCIsXG5cdFwiYmlnb3BsdXNcIjogXCLiqIFcIixcblx0XCJiaWdvdGltZXNcIjogXCLiqIJcIixcblx0XCJiaWdzcWN1cFwiOiBcIuKohlwiLFxuXHRcImJpZ3N0YXJcIjogXCLimIVcIixcblx0XCJiaWd0cmlhbmdsZWRvd25cIjogXCLilr1cIixcblx0XCJiaWd0cmlhbmdsZXVwXCI6IFwi4pazXCIsXG5cdFwiYmlndXBsdXNcIjogXCLiqIRcIixcblx0XCJiaWd2ZWVcIjogXCLii4FcIixcblx0XCJiaWd3ZWRnZVwiOiBcIuKLgFwiLFxuXHRcImJrYXJvd1wiOiBcIuKkjVwiLFxuXHRcImJsYWNrbG96ZW5nZVwiOiBcIuKnq1wiLFxuXHRcImJsYWNrc3F1YXJlXCI6IFwi4paqXCIsXG5cdFwiYmxhY2t0cmlhbmdsZVwiOiBcIuKWtFwiLFxuXHRcImJsYWNrdHJpYW5nbGVkb3duXCI6IFwi4pa+XCIsXG5cdFwiYmxhY2t0cmlhbmdsZWxlZnRcIjogXCLil4JcIixcblx0XCJibGFja3RyaWFuZ2xlcmlnaHRcIjogXCLilrhcIixcblx0XCJibGFua1wiOiBcIuKQo1wiLFxuXHRcImJsazEyXCI6IFwi4paSXCIsXG5cdFwiYmxrMTRcIjogXCLilpFcIixcblx0XCJibGszNFwiOiBcIuKWk1wiLFxuXHRcImJsb2NrXCI6IFwi4paIXCIsXG5cdFwiYm5lXCI6IFwiPeKDpVwiLFxuXHRcImJuZXF1aXZcIjogXCLiiaHig6VcIixcblx0XCJiTm90XCI6IFwi4qutXCIsXG5cdFwiYm5vdFwiOiBcIuKMkFwiLFxuXHRcIkJvcGZcIjogXCLwnZS5XCIsXG5cdFwiYm9wZlwiOiBcIvCdlZNcIixcblx0XCJib3RcIjogXCLiiqVcIixcblx0XCJib3R0b21cIjogXCLiiqVcIixcblx0XCJib3d0aWVcIjogXCLii4hcIixcblx0XCJib3hib3hcIjogXCLip4lcIixcblx0XCJib3hkbFwiOiBcIuKUkFwiLFxuXHRcImJveGRMXCI6IFwi4pWVXCIsXG5cdFwiYm94RGxcIjogXCLilZZcIixcblx0XCJib3hETFwiOiBcIuKVl1wiLFxuXHRcImJveGRyXCI6IFwi4pSMXCIsXG5cdFwiYm94ZFJcIjogXCLilZJcIixcblx0XCJib3hEclwiOiBcIuKVk1wiLFxuXHRcImJveERSXCI6IFwi4pWUXCIsXG5cdFwiYm94aFwiOiBcIuKUgFwiLFxuXHRcImJveEhcIjogXCLilZBcIixcblx0XCJib3hoZFwiOiBcIuKUrFwiLFxuXHRcImJveEhkXCI6IFwi4pWkXCIsXG5cdFwiYm94aERcIjogXCLilaVcIixcblx0XCJib3hIRFwiOiBcIuKVplwiLFxuXHRcImJveGh1XCI6IFwi4pS0XCIsXG5cdFwiYm94SHVcIjogXCLiladcIixcblx0XCJib3hoVVwiOiBcIuKVqFwiLFxuXHRcImJveEhVXCI6IFwi4pWpXCIsXG5cdFwiYm94bWludXNcIjogXCLiip9cIixcblx0XCJib3hwbHVzXCI6IFwi4oqeXCIsXG5cdFwiYm94dGltZXNcIjogXCLiiqBcIixcblx0XCJib3h1bFwiOiBcIuKUmFwiLFxuXHRcImJveHVMXCI6IFwi4pWbXCIsXG5cdFwiYm94VWxcIjogXCLilZxcIixcblx0XCJib3hVTFwiOiBcIuKVnVwiLFxuXHRcImJveHVyXCI6IFwi4pSUXCIsXG5cdFwiYm94dVJcIjogXCLilZhcIixcblx0XCJib3hVclwiOiBcIuKVmVwiLFxuXHRcImJveFVSXCI6IFwi4pWaXCIsXG5cdFwiYm94dlwiOiBcIuKUglwiLFxuXHRcImJveFZcIjogXCLilZFcIixcblx0XCJib3h2aFwiOiBcIuKUvFwiLFxuXHRcImJveHZIXCI6IFwi4pWqXCIsXG5cdFwiYm94VmhcIjogXCLilatcIixcblx0XCJib3hWSFwiOiBcIuKVrFwiLFxuXHRcImJveHZsXCI6IFwi4pSkXCIsXG5cdFwiYm94dkxcIjogXCLilaFcIixcblx0XCJib3hWbFwiOiBcIuKVolwiLFxuXHRcImJveFZMXCI6IFwi4pWjXCIsXG5cdFwiYm94dnJcIjogXCLilJxcIixcblx0XCJib3h2UlwiOiBcIuKVnlwiLFxuXHRcImJveFZyXCI6IFwi4pWfXCIsXG5cdFwiYm94VlJcIjogXCLilaBcIixcblx0XCJicHJpbWVcIjogXCLigLVcIixcblx0XCJicmV2ZVwiOiBcIsuYXCIsXG5cdFwiQnJldmVcIjogXCLLmFwiLFxuXHRcImJydmJhclwiOiBcIsKmXCIsXG5cdFwiYnNjclwiOiBcIvCdkrdcIixcblx0XCJCc2NyXCI6IFwi4oSsXCIsXG5cdFwiYnNlbWlcIjogXCLigY9cIixcblx0XCJic2ltXCI6IFwi4oi9XCIsXG5cdFwiYnNpbWVcIjogXCLii41cIixcblx0XCJic29sYlwiOiBcIuKnhVwiLFxuXHRcImJzb2xcIjogXCJcXFxcXCIsXG5cdFwiYnNvbGhzdWJcIjogXCLin4hcIixcblx0XCJidWxsXCI6IFwi4oCiXCIsXG5cdFwiYnVsbGV0XCI6IFwi4oCiXCIsXG5cdFwiYnVtcFwiOiBcIuKJjlwiLFxuXHRcImJ1bXBFXCI6IFwi4qquXCIsXG5cdFwiYnVtcGVcIjogXCLiiY9cIixcblx0XCJCdW1wZXFcIjogXCLiiY5cIixcblx0XCJidW1wZXFcIjogXCLiiY9cIixcblx0XCJDYWN1dGVcIjogXCLEhlwiLFxuXHRcImNhY3V0ZVwiOiBcIsSHXCIsXG5cdFwiY2FwYW5kXCI6IFwi4qmEXCIsXG5cdFwiY2FwYnJjdXBcIjogXCLiqYlcIixcblx0XCJjYXBjYXBcIjogXCLiqYtcIixcblx0XCJjYXBcIjogXCLiiKlcIixcblx0XCJDYXBcIjogXCLii5JcIixcblx0XCJjYXBjdXBcIjogXCLiqYdcIixcblx0XCJjYXBkb3RcIjogXCLiqYBcIixcblx0XCJDYXBpdGFsRGlmZmVyZW50aWFsRFwiOiBcIuKFhVwiLFxuXHRcImNhcHNcIjogXCLiiKnvuIBcIixcblx0XCJjYXJldFwiOiBcIuKBgVwiLFxuXHRcImNhcm9uXCI6IFwiy4dcIixcblx0XCJDYXlsZXlzXCI6IFwi4oStXCIsXG5cdFwiY2NhcHNcIjogXCLiqY1cIixcblx0XCJDY2Fyb25cIjogXCLEjFwiLFxuXHRcImNjYXJvblwiOiBcIsSNXCIsXG5cdFwiQ2NlZGlsXCI6IFwiw4dcIixcblx0XCJjY2VkaWxcIjogXCLDp1wiLFxuXHRcIkNjaXJjXCI6IFwixIhcIixcblx0XCJjY2lyY1wiOiBcIsSJXCIsXG5cdFwiQ2NvbmludFwiOiBcIuKIsFwiLFxuXHRcImNjdXBzXCI6IFwi4qmMXCIsXG5cdFwiY2N1cHNzbVwiOiBcIuKpkFwiLFxuXHRcIkNkb3RcIjogXCLEilwiLFxuXHRcImNkb3RcIjogXCLEi1wiLFxuXHRcImNlZGlsXCI6IFwiwrhcIixcblx0XCJDZWRpbGxhXCI6IFwiwrhcIixcblx0XCJjZW1wdHl2XCI6IFwi4qayXCIsXG5cdFwiY2VudFwiOiBcIsKiXCIsXG5cdFwiY2VudGVyZG90XCI6IFwiwrdcIixcblx0XCJDZW50ZXJEb3RcIjogXCLCt1wiLFxuXHRcImNmclwiOiBcIvCdlKBcIixcblx0XCJDZnJcIjogXCLihK1cIixcblx0XCJDSGN5XCI6IFwi0KdcIixcblx0XCJjaGN5XCI6IFwi0YdcIixcblx0XCJjaGVja1wiOiBcIuKck1wiLFxuXHRcImNoZWNrbWFya1wiOiBcIuKck1wiLFxuXHRcIkNoaVwiOiBcIs6nXCIsXG5cdFwiY2hpXCI6IFwiz4dcIixcblx0XCJjaXJjXCI6IFwiy4ZcIixcblx0XCJjaXJjZXFcIjogXCLiiZdcIixcblx0XCJjaXJjbGVhcnJvd2xlZnRcIjogXCLihrpcIixcblx0XCJjaXJjbGVhcnJvd3JpZ2h0XCI6IFwi4oa7XCIsXG5cdFwiY2lyY2xlZGFzdFwiOiBcIuKKm1wiLFxuXHRcImNpcmNsZWRjaXJjXCI6IFwi4oqaXCIsXG5cdFwiY2lyY2xlZGRhc2hcIjogXCLiip1cIixcblx0XCJDaXJjbGVEb3RcIjogXCLiiplcIixcblx0XCJjaXJjbGVkUlwiOiBcIsKuXCIsXG5cdFwiY2lyY2xlZFNcIjogXCLik4hcIixcblx0XCJDaXJjbGVNaW51c1wiOiBcIuKKllwiLFxuXHRcIkNpcmNsZVBsdXNcIjogXCLiipVcIixcblx0XCJDaXJjbGVUaW1lc1wiOiBcIuKKl1wiLFxuXHRcImNpclwiOiBcIuKXi1wiLFxuXHRcImNpckVcIjogXCLip4NcIixcblx0XCJjaXJlXCI6IFwi4omXXCIsXG5cdFwiY2lyZm5pbnRcIjogXCLiqJBcIixcblx0XCJjaXJtaWRcIjogXCLiq69cIixcblx0XCJjaXJzY2lyXCI6IFwi4qeCXCIsXG5cdFwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6IFwi4oiyXCIsXG5cdFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6IFwi4oCdXCIsXG5cdFwiQ2xvc2VDdXJseVF1b3RlXCI6IFwi4oCZXCIsXG5cdFwiY2x1YnNcIjogXCLimaNcIixcblx0XCJjbHVic3VpdFwiOiBcIuKZo1wiLFxuXHRcImNvbG9uXCI6IFwiOlwiLFxuXHRcIkNvbG9uXCI6IFwi4oi3XCIsXG5cdFwiQ29sb25lXCI6IFwi4qm0XCIsXG5cdFwiY29sb25lXCI6IFwi4omUXCIsXG5cdFwiY29sb25lcVwiOiBcIuKJlFwiLFxuXHRcImNvbW1hXCI6IFwiLFwiLFxuXHRcImNvbW1hdFwiOiBcIkBcIixcblx0XCJjb21wXCI6IFwi4oiBXCIsXG5cdFwiY29tcGZuXCI6IFwi4oiYXCIsXG5cdFwiY29tcGxlbWVudFwiOiBcIuKIgVwiLFxuXHRcImNvbXBsZXhlc1wiOiBcIuKEglwiLFxuXHRcImNvbmdcIjogXCLiiYVcIixcblx0XCJjb25nZG90XCI6IFwi4qmtXCIsXG5cdFwiQ29uZ3J1ZW50XCI6IFwi4omhXCIsXG5cdFwiY29uaW50XCI6IFwi4oiuXCIsXG5cdFwiQ29uaW50XCI6IFwi4oivXCIsXG5cdFwiQ29udG91ckludGVncmFsXCI6IFwi4oiuXCIsXG5cdFwiY29wZlwiOiBcIvCdlZRcIixcblx0XCJDb3BmXCI6IFwi4oSCXCIsXG5cdFwiY29wcm9kXCI6IFwi4oiQXCIsXG5cdFwiQ29wcm9kdWN0XCI6IFwi4oiQXCIsXG5cdFwiY29weVwiOiBcIsKpXCIsXG5cdFwiQ09QWVwiOiBcIsKpXCIsXG5cdFwiY29weXNyXCI6IFwi4oSXXCIsXG5cdFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOiBcIuKIs1wiLFxuXHRcImNyYXJyXCI6IFwi4oa1XCIsXG5cdFwiY3Jvc3NcIjogXCLinJdcIixcblx0XCJDcm9zc1wiOiBcIuKor1wiLFxuXHRcIkNzY3JcIjogXCLwnZKeXCIsXG5cdFwiY3NjclwiOiBcIvCdkrhcIixcblx0XCJjc3ViXCI6IFwi4quPXCIsXG5cdFwiY3N1YmVcIjogXCLiq5FcIixcblx0XCJjc3VwXCI6IFwi4quQXCIsXG5cdFwiY3N1cGVcIjogXCLiq5JcIixcblx0XCJjdGRvdFwiOiBcIuKLr1wiLFxuXHRcImN1ZGFycmxcIjogXCLipLhcIixcblx0XCJjdWRhcnJyXCI6IFwi4qS1XCIsXG5cdFwiY3VlcHJcIjogXCLii55cIixcblx0XCJjdWVzY1wiOiBcIuKLn1wiLFxuXHRcImN1bGFyclwiOiBcIuKGtlwiLFxuXHRcImN1bGFycnBcIjogXCLipL1cIixcblx0XCJjdXBicmNhcFwiOiBcIuKpiFwiLFxuXHRcImN1cGNhcFwiOiBcIuKphlwiLFxuXHRcIkN1cENhcFwiOiBcIuKJjVwiLFxuXHRcImN1cFwiOiBcIuKIqlwiLFxuXHRcIkN1cFwiOiBcIuKLk1wiLFxuXHRcImN1cGN1cFwiOiBcIuKpilwiLFxuXHRcImN1cGRvdFwiOiBcIuKKjVwiLFxuXHRcImN1cG9yXCI6IFwi4qmFXCIsXG5cdFwiY3Vwc1wiOiBcIuKIqu+4gFwiLFxuXHRcImN1cmFyclwiOiBcIuKGt1wiLFxuXHRcImN1cmFycm1cIjogXCLipLxcIixcblx0XCJjdXJseWVxcHJlY1wiOiBcIuKLnlwiLFxuXHRcImN1cmx5ZXFzdWNjXCI6IFwi4oufXCIsXG5cdFwiY3VybHl2ZWVcIjogXCLii45cIixcblx0XCJjdXJseXdlZGdlXCI6IFwi4ouPXCIsXG5cdFwiY3VycmVuXCI6IFwiwqRcIixcblx0XCJjdXJ2ZWFycm93bGVmdFwiOiBcIuKGtlwiLFxuXHRcImN1cnZlYXJyb3dyaWdodFwiOiBcIuKGt1wiLFxuXHRcImN1dmVlXCI6IFwi4ouOXCIsXG5cdFwiY3V3ZWRcIjogXCLii49cIixcblx0XCJjd2NvbmludFwiOiBcIuKIslwiLFxuXHRcImN3aW50XCI6IFwi4oixXCIsXG5cdFwiY3lsY3R5XCI6IFwi4oytXCIsXG5cdFwiZGFnZ2VyXCI6IFwi4oCgXCIsXG5cdFwiRGFnZ2VyXCI6IFwi4oChXCIsXG5cdFwiZGFsZXRoXCI6IFwi4oS4XCIsXG5cdFwiZGFyclwiOiBcIuKGk1wiLFxuXHRcIkRhcnJcIjogXCLihqFcIixcblx0XCJkQXJyXCI6IFwi4oeTXCIsXG5cdFwiZGFzaFwiOiBcIuKAkFwiLFxuXHRcIkRhc2h2XCI6IFwi4qukXCIsXG5cdFwiZGFzaHZcIjogXCLiiqNcIixcblx0XCJkYmthcm93XCI6IFwi4qSPXCIsXG5cdFwiZGJsYWNcIjogXCLLnVwiLFxuXHRcIkRjYXJvblwiOiBcIsSOXCIsXG5cdFwiZGNhcm9uXCI6IFwixI9cIixcblx0XCJEY3lcIjogXCLQlFwiLFxuXHRcImRjeVwiOiBcItC0XCIsXG5cdFwiZGRhZ2dlclwiOiBcIuKAoVwiLFxuXHRcImRkYXJyXCI6IFwi4oeKXCIsXG5cdFwiRERcIjogXCLihYVcIixcblx0XCJkZFwiOiBcIuKFhlwiLFxuXHRcIkREb3RyYWhkXCI6IFwi4qSRXCIsXG5cdFwiZGRvdHNlcVwiOiBcIuKpt1wiLFxuXHRcImRlZ1wiOiBcIsKwXCIsXG5cdFwiRGVsXCI6IFwi4oiHXCIsXG5cdFwiRGVsdGFcIjogXCLOlFwiLFxuXHRcImRlbHRhXCI6IFwizrRcIixcblx0XCJkZW1wdHl2XCI6IFwi4qaxXCIsXG5cdFwiZGZpc2h0XCI6IFwi4qW/XCIsXG5cdFwiRGZyXCI6IFwi8J2Uh1wiLFxuXHRcImRmclwiOiBcIvCdlKFcIixcblx0XCJkSGFyXCI6IFwi4qWlXCIsXG5cdFwiZGhhcmxcIjogXCLih4NcIixcblx0XCJkaGFyclwiOiBcIuKHglwiLFxuXHRcIkRpYWNyaXRpY2FsQWN1dGVcIjogXCLCtFwiLFxuXHRcIkRpYWNyaXRpY2FsRG90XCI6IFwiy5lcIixcblx0XCJEaWFjcml0aWNhbERvdWJsZUFjdXRlXCI6IFwiy51cIixcblx0XCJEaWFjcml0aWNhbEdyYXZlXCI6IFwiYFwiLFxuXHRcIkRpYWNyaXRpY2FsVGlsZGVcIjogXCLLnFwiLFxuXHRcImRpYW1cIjogXCLii4RcIixcblx0XCJkaWFtb25kXCI6IFwi4ouEXCIsXG5cdFwiRGlhbW9uZFwiOiBcIuKLhFwiLFxuXHRcImRpYW1vbmRzdWl0XCI6IFwi4pmmXCIsXG5cdFwiZGlhbXNcIjogXCLimaZcIixcblx0XCJkaWVcIjogXCLCqFwiLFxuXHRcIkRpZmZlcmVudGlhbERcIjogXCLihYZcIixcblx0XCJkaWdhbW1hXCI6IFwiz51cIixcblx0XCJkaXNpblwiOiBcIuKLslwiLFxuXHRcImRpdlwiOiBcIsO3XCIsXG5cdFwiZGl2aWRlXCI6IFwiw7dcIixcblx0XCJkaXZpZGVvbnRpbWVzXCI6IFwi4ouHXCIsXG5cdFwiZGl2b254XCI6IFwi4ouHXCIsXG5cdFwiREpjeVwiOiBcItCCXCIsXG5cdFwiZGpjeVwiOiBcItGSXCIsXG5cdFwiZGxjb3JuXCI6IFwi4oyeXCIsXG5cdFwiZGxjcm9wXCI6IFwi4oyNXCIsXG5cdFwiZG9sbGFyXCI6IFwiJFwiLFxuXHRcIkRvcGZcIjogXCLwnZS7XCIsXG5cdFwiZG9wZlwiOiBcIvCdlZVcIixcblx0XCJEb3RcIjogXCLCqFwiLFxuXHRcImRvdFwiOiBcIsuZXCIsXG5cdFwiRG90RG90XCI6IFwi4oOcXCIsXG5cdFwiZG90ZXFcIjogXCLiiZBcIixcblx0XCJkb3RlcWRvdFwiOiBcIuKJkVwiLFxuXHRcIkRvdEVxdWFsXCI6IFwi4omQXCIsXG5cdFwiZG90bWludXNcIjogXCLiiLhcIixcblx0XCJkb3RwbHVzXCI6IFwi4oiUXCIsXG5cdFwiZG90c3F1YXJlXCI6IFwi4oqhXCIsXG5cdFwiZG91YmxlYmFyd2VkZ2VcIjogXCLijIZcIixcblx0XCJEb3VibGVDb250b3VySW50ZWdyYWxcIjogXCLiiK9cIixcblx0XCJEb3VibGVEb3RcIjogXCLCqFwiLFxuXHRcIkRvdWJsZURvd25BcnJvd1wiOiBcIuKHk1wiLFxuXHRcIkRvdWJsZUxlZnRBcnJvd1wiOiBcIuKHkFwiLFxuXHRcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6IFwi4oeUXCIsXG5cdFwiRG91YmxlTGVmdFRlZVwiOiBcIuKrpFwiLFxuXHRcIkRvdWJsZUxvbmdMZWZ0QXJyb3dcIjogXCLin7hcIixcblx0XCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjogXCLin7pcIixcblx0XCJEb3VibGVMb25nUmlnaHRBcnJvd1wiOiBcIuKfuVwiLFxuXHRcIkRvdWJsZVJpZ2h0QXJyb3dcIjogXCLih5JcIixcblx0XCJEb3VibGVSaWdodFRlZVwiOiBcIuKKqFwiLFxuXHRcIkRvdWJsZVVwQXJyb3dcIjogXCLih5FcIixcblx0XCJEb3VibGVVcERvd25BcnJvd1wiOiBcIuKHlVwiLFxuXHRcIkRvdWJsZVZlcnRpY2FsQmFyXCI6IFwi4oilXCIsXG5cdFwiRG93bkFycm93QmFyXCI6IFwi4qSTXCIsXG5cdFwiZG93bmFycm93XCI6IFwi4oaTXCIsXG5cdFwiRG93bkFycm93XCI6IFwi4oaTXCIsXG5cdFwiRG93bmFycm93XCI6IFwi4oeTXCIsXG5cdFwiRG93bkFycm93VXBBcnJvd1wiOiBcIuKHtVwiLFxuXHRcIkRvd25CcmV2ZVwiOiBcIsyRXCIsXG5cdFwiZG93bmRvd25hcnJvd3NcIjogXCLih4pcIixcblx0XCJkb3duaGFycG9vbmxlZnRcIjogXCLih4NcIixcblx0XCJkb3duaGFycG9vbnJpZ2h0XCI6IFwi4oeCXCIsXG5cdFwiRG93bkxlZnRSaWdodFZlY3RvclwiOiBcIuKlkFwiLFxuXHRcIkRvd25MZWZ0VGVlVmVjdG9yXCI6IFwi4qWeXCIsXG5cdFwiRG93bkxlZnRWZWN0b3JCYXJcIjogXCLipZZcIixcblx0XCJEb3duTGVmdFZlY3RvclwiOiBcIuKGvVwiLFxuXHRcIkRvd25SaWdodFRlZVZlY3RvclwiOiBcIuKln1wiLFxuXHRcIkRvd25SaWdodFZlY3RvckJhclwiOiBcIuKll1wiLFxuXHRcIkRvd25SaWdodFZlY3RvclwiOiBcIuKHgVwiLFxuXHRcIkRvd25UZWVBcnJvd1wiOiBcIuKGp1wiLFxuXHRcIkRvd25UZWVcIjogXCLiiqRcIixcblx0XCJkcmJrYXJvd1wiOiBcIuKkkFwiLFxuXHRcImRyY29yblwiOiBcIuKMn1wiLFxuXHRcImRyY3JvcFwiOiBcIuKMjFwiLFxuXHRcIkRzY3JcIjogXCLwnZKfXCIsXG5cdFwiZHNjclwiOiBcIvCdkrlcIixcblx0XCJEU2N5XCI6IFwi0IVcIixcblx0XCJkc2N5XCI6IFwi0ZVcIixcblx0XCJkc29sXCI6IFwi4qe2XCIsXG5cdFwiRHN0cm9rXCI6IFwixJBcIixcblx0XCJkc3Ryb2tcIjogXCLEkVwiLFxuXHRcImR0ZG90XCI6IFwi4ouxXCIsXG5cdFwiZHRyaVwiOiBcIuKWv1wiLFxuXHRcImR0cmlmXCI6IFwi4pa+XCIsXG5cdFwiZHVhcnJcIjogXCLih7VcIixcblx0XCJkdWhhclwiOiBcIuKlr1wiLFxuXHRcImR3YW5nbGVcIjogXCLipqZcIixcblx0XCJEWmN5XCI6IFwi0I9cIixcblx0XCJkemN5XCI6IFwi0Z9cIixcblx0XCJkemlncmFyclwiOiBcIuKfv1wiLFxuXHRcIkVhY3V0ZVwiOiBcIsOJXCIsXG5cdFwiZWFjdXRlXCI6IFwiw6lcIixcblx0XCJlYXN0ZXJcIjogXCLiqa5cIixcblx0XCJFY2Fyb25cIjogXCLEmlwiLFxuXHRcImVjYXJvblwiOiBcIsSbXCIsXG5cdFwiRWNpcmNcIjogXCLDilwiLFxuXHRcImVjaXJjXCI6IFwiw6pcIixcblx0XCJlY2lyXCI6IFwi4omWXCIsXG5cdFwiZWNvbG9uXCI6IFwi4omVXCIsXG5cdFwiRWN5XCI6IFwi0K1cIixcblx0XCJlY3lcIjogXCLRjVwiLFxuXHRcImVERG90XCI6IFwi4qm3XCIsXG5cdFwiRWRvdFwiOiBcIsSWXCIsXG5cdFwiZWRvdFwiOiBcIsSXXCIsXG5cdFwiZURvdFwiOiBcIuKJkVwiLFxuXHRcImVlXCI6IFwi4oWHXCIsXG5cdFwiZWZEb3RcIjogXCLiiZJcIixcblx0XCJFZnJcIjogXCLwnZSIXCIsXG5cdFwiZWZyXCI6IFwi8J2UolwiLFxuXHRcImVnXCI6IFwi4qqaXCIsXG5cdFwiRWdyYXZlXCI6IFwiw4hcIixcblx0XCJlZ3JhdmVcIjogXCLDqFwiLFxuXHRcImVnc1wiOiBcIuKqllwiLFxuXHRcImVnc2RvdFwiOiBcIuKqmFwiLFxuXHRcImVsXCI6IFwi4qqZXCIsXG5cdFwiRWxlbWVudFwiOiBcIuKIiFwiLFxuXHRcImVsaW50ZXJzXCI6IFwi4o+nXCIsXG5cdFwiZWxsXCI6IFwi4oSTXCIsXG5cdFwiZWxzXCI6IFwi4qqVXCIsXG5cdFwiZWxzZG90XCI6IFwi4qqXXCIsXG5cdFwiRW1hY3JcIjogXCLEklwiLFxuXHRcImVtYWNyXCI6IFwixJNcIixcblx0XCJlbXB0eVwiOiBcIuKIhVwiLFxuXHRcImVtcHR5c2V0XCI6IFwi4oiFXCIsXG5cdFwiRW1wdHlTbWFsbFNxdWFyZVwiOiBcIuKXu1wiLFxuXHRcImVtcHR5dlwiOiBcIuKIhVwiLFxuXHRcIkVtcHR5VmVyeVNtYWxsU3F1YXJlXCI6IFwi4parXCIsXG5cdFwiZW1zcDEzXCI6IFwi4oCEXCIsXG5cdFwiZW1zcDE0XCI6IFwi4oCFXCIsXG5cdFwiZW1zcFwiOiBcIuKAg1wiLFxuXHRcIkVOR1wiOiBcIsWKXCIsXG5cdFwiZW5nXCI6IFwixYtcIixcblx0XCJlbnNwXCI6IFwi4oCCXCIsXG5cdFwiRW9nb25cIjogXCLEmFwiLFxuXHRcImVvZ29uXCI6IFwixJlcIixcblx0XCJFb3BmXCI6IFwi8J2UvFwiLFxuXHRcImVvcGZcIjogXCLwnZWWXCIsXG5cdFwiZXBhclwiOiBcIuKLlVwiLFxuXHRcImVwYXJzbFwiOiBcIuKno1wiLFxuXHRcImVwbHVzXCI6IFwi4qmxXCIsXG5cdFwiZXBzaVwiOiBcIs61XCIsXG5cdFwiRXBzaWxvblwiOiBcIs6VXCIsXG5cdFwiZXBzaWxvblwiOiBcIs61XCIsXG5cdFwiZXBzaXZcIjogXCLPtVwiLFxuXHRcImVxY2lyY1wiOiBcIuKJllwiLFxuXHRcImVxY29sb25cIjogXCLiiZVcIixcblx0XCJlcXNpbVwiOiBcIuKJglwiLFxuXHRcImVxc2xhbnRndHJcIjogXCLiqpZcIixcblx0XCJlcXNsYW50bGVzc1wiOiBcIuKqlVwiLFxuXHRcIkVxdWFsXCI6IFwi4qm1XCIsXG5cdFwiZXF1YWxzXCI6IFwiPVwiLFxuXHRcIkVxdWFsVGlsZGVcIjogXCLiiYJcIixcblx0XCJlcXVlc3RcIjogXCLiiZ9cIixcblx0XCJFcXVpbGlicml1bVwiOiBcIuKHjFwiLFxuXHRcImVxdWl2XCI6IFwi4omhXCIsXG5cdFwiZXF1aXZERFwiOiBcIuKpuFwiLFxuXHRcImVxdnBhcnNsXCI6IFwi4qelXCIsXG5cdFwiZXJhcnJcIjogXCLipbFcIixcblx0XCJlckRvdFwiOiBcIuKJk1wiLFxuXHRcImVzY3JcIjogXCLihK9cIixcblx0XCJFc2NyXCI6IFwi4oSwXCIsXG5cdFwiZXNkb3RcIjogXCLiiZBcIixcblx0XCJFc2ltXCI6IFwi4qmzXCIsXG5cdFwiZXNpbVwiOiBcIuKJglwiLFxuXHRcIkV0YVwiOiBcIs6XXCIsXG5cdFwiZXRhXCI6IFwizrdcIixcblx0XCJFVEhcIjogXCLDkFwiLFxuXHRcImV0aFwiOiBcIsOwXCIsXG5cdFwiRXVtbFwiOiBcIsOLXCIsXG5cdFwiZXVtbFwiOiBcIsOrXCIsXG5cdFwiZXVyb1wiOiBcIuKCrFwiLFxuXHRcImV4Y2xcIjogXCIhXCIsXG5cdFwiZXhpc3RcIjogXCLiiINcIixcblx0XCJFeGlzdHNcIjogXCLiiINcIixcblx0XCJleHBlY3RhdGlvblwiOiBcIuKEsFwiLFxuXHRcImV4cG9uZW50aWFsZVwiOiBcIuKFh1wiLFxuXHRcIkV4cG9uZW50aWFsRVwiOiBcIuKFh1wiLFxuXHRcImZhbGxpbmdkb3RzZXFcIjogXCLiiZJcIixcblx0XCJGY3lcIjogXCLQpFwiLFxuXHRcImZjeVwiOiBcItGEXCIsXG5cdFwiZmVtYWxlXCI6IFwi4pmAXCIsXG5cdFwiZmZpbGlnXCI6IFwi76yDXCIsXG5cdFwiZmZsaWdcIjogXCLvrIBcIixcblx0XCJmZmxsaWdcIjogXCLvrIRcIixcblx0XCJGZnJcIjogXCLwnZSJXCIsXG5cdFwiZmZyXCI6IFwi8J2Uo1wiLFxuXHRcImZpbGlnXCI6IFwi76yBXCIsXG5cdFwiRmlsbGVkU21hbGxTcXVhcmVcIjogXCLil7xcIixcblx0XCJGaWxsZWRWZXJ5U21hbGxTcXVhcmVcIjogXCLilqpcIixcblx0XCJmamxpZ1wiOiBcImZqXCIsXG5cdFwiZmxhdFwiOiBcIuKZrVwiLFxuXHRcImZsbGlnXCI6IFwi76yCXCIsXG5cdFwiZmx0bnNcIjogXCLilrFcIixcblx0XCJmbm9mXCI6IFwixpJcIixcblx0XCJGb3BmXCI6IFwi8J2UvVwiLFxuXHRcImZvcGZcIjogXCLwnZWXXCIsXG5cdFwiZm9yYWxsXCI6IFwi4oiAXCIsXG5cdFwiRm9yQWxsXCI6IFwi4oiAXCIsXG5cdFwiZm9ya1wiOiBcIuKLlFwiLFxuXHRcImZvcmt2XCI6IFwi4quZXCIsXG5cdFwiRm91cmllcnRyZlwiOiBcIuKEsVwiLFxuXHRcImZwYXJ0aW50XCI6IFwi4qiNXCIsXG5cdFwiZnJhYzEyXCI6IFwiwr1cIixcblx0XCJmcmFjMTNcIjogXCLihZNcIixcblx0XCJmcmFjMTRcIjogXCLCvFwiLFxuXHRcImZyYWMxNVwiOiBcIuKFlVwiLFxuXHRcImZyYWMxNlwiOiBcIuKFmVwiLFxuXHRcImZyYWMxOFwiOiBcIuKFm1wiLFxuXHRcImZyYWMyM1wiOiBcIuKFlFwiLFxuXHRcImZyYWMyNVwiOiBcIuKFllwiLFxuXHRcImZyYWMzNFwiOiBcIsK+XCIsXG5cdFwiZnJhYzM1XCI6IFwi4oWXXCIsXG5cdFwiZnJhYzM4XCI6IFwi4oWcXCIsXG5cdFwiZnJhYzQ1XCI6IFwi4oWYXCIsXG5cdFwiZnJhYzU2XCI6IFwi4oWaXCIsXG5cdFwiZnJhYzU4XCI6IFwi4oWdXCIsXG5cdFwiZnJhYzc4XCI6IFwi4oWeXCIsXG5cdFwiZnJhc2xcIjogXCLigYRcIixcblx0XCJmcm93blwiOiBcIuKMolwiLFxuXHRcImZzY3JcIjogXCLwnZK7XCIsXG5cdFwiRnNjclwiOiBcIuKEsVwiLFxuXHRcImdhY3V0ZVwiOiBcIse1XCIsXG5cdFwiR2FtbWFcIjogXCLOk1wiLFxuXHRcImdhbW1hXCI6IFwizrNcIixcblx0XCJHYW1tYWRcIjogXCLPnFwiLFxuXHRcImdhbW1hZFwiOiBcIs+dXCIsXG5cdFwiZ2FwXCI6IFwi4qqGXCIsXG5cdFwiR2JyZXZlXCI6IFwixJ5cIixcblx0XCJnYnJldmVcIjogXCLEn1wiLFxuXHRcIkdjZWRpbFwiOiBcIsSiXCIsXG5cdFwiR2NpcmNcIjogXCLEnFwiLFxuXHRcImdjaXJjXCI6IFwixJ1cIixcblx0XCJHY3lcIjogXCLQk1wiLFxuXHRcImdjeVwiOiBcItCzXCIsXG5cdFwiR2RvdFwiOiBcIsSgXCIsXG5cdFwiZ2RvdFwiOiBcIsShXCIsXG5cdFwiZ2VcIjogXCLiiaVcIixcblx0XCJnRVwiOiBcIuKJp1wiLFxuXHRcImdFbFwiOiBcIuKqjFwiLFxuXHRcImdlbFwiOiBcIuKLm1wiLFxuXHRcImdlcVwiOiBcIuKJpVwiLFxuXHRcImdlcXFcIjogXCLiiadcIixcblx0XCJnZXFzbGFudFwiOiBcIuKpvlwiLFxuXHRcImdlc2NjXCI6IFwi4qqpXCIsXG5cdFwiZ2VzXCI6IFwi4qm+XCIsXG5cdFwiZ2VzZG90XCI6IFwi4qqAXCIsXG5cdFwiZ2VzZG90b1wiOiBcIuKqglwiLFxuXHRcImdlc2RvdG9sXCI6IFwi4qqEXCIsXG5cdFwiZ2VzbFwiOiBcIuKLm++4gFwiLFxuXHRcImdlc2xlc1wiOiBcIuKqlFwiLFxuXHRcIkdmclwiOiBcIvCdlIpcIixcblx0XCJnZnJcIjogXCLwnZSkXCIsXG5cdFwiZ2dcIjogXCLiiatcIixcblx0XCJHZ1wiOiBcIuKLmVwiLFxuXHRcImdnZ1wiOiBcIuKLmVwiLFxuXHRcImdpbWVsXCI6IFwi4oS3XCIsXG5cdFwiR0pjeVwiOiBcItCDXCIsXG5cdFwiZ2pjeVwiOiBcItGTXCIsXG5cdFwiZ2xhXCI6IFwi4qqlXCIsXG5cdFwiZ2xcIjogXCLiibdcIixcblx0XCJnbEVcIjogXCLiqpJcIixcblx0XCJnbGpcIjogXCLiqqRcIixcblx0XCJnbmFwXCI6IFwi4qqKXCIsXG5cdFwiZ25hcHByb3hcIjogXCLiqopcIixcblx0XCJnbmVcIjogXCLiqohcIixcblx0XCJnbkVcIjogXCLiialcIixcblx0XCJnbmVxXCI6IFwi4qqIXCIsXG5cdFwiZ25lcXFcIjogXCLiialcIixcblx0XCJnbnNpbVwiOiBcIuKLp1wiLFxuXHRcIkdvcGZcIjogXCLwnZS+XCIsXG5cdFwiZ29wZlwiOiBcIvCdlZhcIixcblx0XCJncmF2ZVwiOiBcImBcIixcblx0XCJHcmVhdGVyRXF1YWxcIjogXCLiiaVcIixcblx0XCJHcmVhdGVyRXF1YWxMZXNzXCI6IFwi4oubXCIsXG5cdFwiR3JlYXRlckZ1bGxFcXVhbFwiOiBcIuKJp1wiLFxuXHRcIkdyZWF0ZXJHcmVhdGVyXCI6IFwi4qqiXCIsXG5cdFwiR3JlYXRlckxlc3NcIjogXCLiibdcIixcblx0XCJHcmVhdGVyU2xhbnRFcXVhbFwiOiBcIuKpvlwiLFxuXHRcIkdyZWF0ZXJUaWxkZVwiOiBcIuKJs1wiLFxuXHRcIkdzY3JcIjogXCLwnZKiXCIsXG5cdFwiZ3NjclwiOiBcIuKEilwiLFxuXHRcImdzaW1cIjogXCLiibNcIixcblx0XCJnc2ltZVwiOiBcIuKqjlwiLFxuXHRcImdzaW1sXCI6IFwi4qqQXCIsXG5cdFwiZ3RjY1wiOiBcIuKqp1wiLFxuXHRcImd0Y2lyXCI6IFwi4qm6XCIsXG5cdFwiZ3RcIjogXCI+XCIsXG5cdFwiR1RcIjogXCI+XCIsXG5cdFwiR3RcIjogXCLiiatcIixcblx0XCJndGRvdFwiOiBcIuKLl1wiLFxuXHRcImd0bFBhclwiOiBcIuKmlVwiLFxuXHRcImd0cXVlc3RcIjogXCLiqbxcIixcblx0XCJndHJhcHByb3hcIjogXCLiqoZcIixcblx0XCJndHJhcnJcIjogXCLipbhcIixcblx0XCJndHJkb3RcIjogXCLii5dcIixcblx0XCJndHJlcWxlc3NcIjogXCLii5tcIixcblx0XCJndHJlcXFsZXNzXCI6IFwi4qqMXCIsXG5cdFwiZ3RybGVzc1wiOiBcIuKJt1wiLFxuXHRcImd0cnNpbVwiOiBcIuKJs1wiLFxuXHRcImd2ZXJ0bmVxcVwiOiBcIuKJqe+4gFwiLFxuXHRcImd2bkVcIjogXCLiianvuIBcIixcblx0XCJIYWNla1wiOiBcIsuHXCIsXG5cdFwiaGFpcnNwXCI6IFwi4oCKXCIsXG5cdFwiaGFsZlwiOiBcIsK9XCIsXG5cdFwiaGFtaWx0XCI6IFwi4oSLXCIsXG5cdFwiSEFSRGN5XCI6IFwi0KpcIixcblx0XCJoYXJkY3lcIjogXCLRilwiLFxuXHRcImhhcnJjaXJcIjogXCLipYhcIixcblx0XCJoYXJyXCI6IFwi4oaUXCIsXG5cdFwiaEFyclwiOiBcIuKHlFwiLFxuXHRcImhhcnJ3XCI6IFwi4oatXCIsXG5cdFwiSGF0XCI6IFwiXlwiLFxuXHRcImhiYXJcIjogXCLihI9cIixcblx0XCJIY2lyY1wiOiBcIsSkXCIsXG5cdFwiaGNpcmNcIjogXCLEpVwiLFxuXHRcImhlYXJ0c1wiOiBcIuKZpVwiLFxuXHRcImhlYXJ0c3VpdFwiOiBcIuKZpVwiLFxuXHRcImhlbGxpcFwiOiBcIuKAplwiLFxuXHRcImhlcmNvblwiOiBcIuKKuVwiLFxuXHRcImhmclwiOiBcIvCdlKVcIixcblx0XCJIZnJcIjogXCLihIxcIixcblx0XCJIaWxiZXJ0U3BhY2VcIjogXCLihItcIixcblx0XCJoa3NlYXJvd1wiOiBcIuKkpVwiLFxuXHRcImhrc3dhcm93XCI6IFwi4qSmXCIsXG5cdFwiaG9hcnJcIjogXCLih79cIixcblx0XCJob210aHRcIjogXCLiiLtcIixcblx0XCJob29rbGVmdGFycm93XCI6IFwi4oapXCIsXG5cdFwiaG9va3JpZ2h0YXJyb3dcIjogXCLihqpcIixcblx0XCJob3BmXCI6IFwi8J2VmVwiLFxuXHRcIkhvcGZcIjogXCLihI1cIixcblx0XCJob3JiYXJcIjogXCLigJVcIixcblx0XCJIb3Jpem9udGFsTGluZVwiOiBcIuKUgFwiLFxuXHRcImhzY3JcIjogXCLwnZK9XCIsXG5cdFwiSHNjclwiOiBcIuKEi1wiLFxuXHRcImhzbGFzaFwiOiBcIuKEj1wiLFxuXHRcIkhzdHJva1wiOiBcIsSmXCIsXG5cdFwiaHN0cm9rXCI6IFwixKdcIixcblx0XCJIdW1wRG93bkh1bXBcIjogXCLiiY5cIixcblx0XCJIdW1wRXF1YWxcIjogXCLiiY9cIixcblx0XCJoeWJ1bGxcIjogXCLigYNcIixcblx0XCJoeXBoZW5cIjogXCLigJBcIixcblx0XCJJYWN1dGVcIjogXCLDjVwiLFxuXHRcImlhY3V0ZVwiOiBcIsOtXCIsXG5cdFwiaWNcIjogXCLigaNcIixcblx0XCJJY2lyY1wiOiBcIsOOXCIsXG5cdFwiaWNpcmNcIjogXCLDrlwiLFxuXHRcIkljeVwiOiBcItCYXCIsXG5cdFwiaWN5XCI6IFwi0LhcIixcblx0XCJJZG90XCI6IFwixLBcIixcblx0XCJJRWN5XCI6IFwi0JVcIixcblx0XCJpZWN5XCI6IFwi0LVcIixcblx0XCJpZXhjbFwiOiBcIsKhXCIsXG5cdFwiaWZmXCI6IFwi4oeUXCIsXG5cdFwiaWZyXCI6IFwi8J2UplwiLFxuXHRcIklmclwiOiBcIuKEkVwiLFxuXHRcIklncmF2ZVwiOiBcIsOMXCIsXG5cdFwiaWdyYXZlXCI6IFwiw6xcIixcblx0XCJpaVwiOiBcIuKFiFwiLFxuXHRcImlpaWludFwiOiBcIuKojFwiLFxuXHRcImlpaW50XCI6IFwi4oitXCIsXG5cdFwiaWluZmluXCI6IFwi4qecXCIsXG5cdFwiaWlvdGFcIjogXCLihKlcIixcblx0XCJJSmxpZ1wiOiBcIsSyXCIsXG5cdFwiaWpsaWdcIjogXCLEs1wiLFxuXHRcIkltYWNyXCI6IFwixKpcIixcblx0XCJpbWFjclwiOiBcIsSrXCIsXG5cdFwiaW1hZ2VcIjogXCLihJFcIixcblx0XCJJbWFnaW5hcnlJXCI6IFwi4oWIXCIsXG5cdFwiaW1hZ2xpbmVcIjogXCLihJBcIixcblx0XCJpbWFncGFydFwiOiBcIuKEkVwiLFxuXHRcImltYXRoXCI6IFwixLFcIixcblx0XCJJbVwiOiBcIuKEkVwiLFxuXHRcImltb2ZcIjogXCLiirdcIixcblx0XCJpbXBlZFwiOiBcIsa1XCIsXG5cdFwiSW1wbGllc1wiOiBcIuKHklwiLFxuXHRcImluY2FyZVwiOiBcIuKEhVwiLFxuXHRcImluXCI6IFwi4oiIXCIsXG5cdFwiaW5maW5cIjogXCLiiJ5cIixcblx0XCJpbmZpbnRpZVwiOiBcIuKnnVwiLFxuXHRcImlub2RvdFwiOiBcIsSxXCIsXG5cdFwiaW50Y2FsXCI6IFwi4oq6XCIsXG5cdFwiaW50XCI6IFwi4oirXCIsXG5cdFwiSW50XCI6IFwi4oisXCIsXG5cdFwiaW50ZWdlcnNcIjogXCLihKRcIixcblx0XCJJbnRlZ3JhbFwiOiBcIuKIq1wiLFxuXHRcImludGVyY2FsXCI6IFwi4oq6XCIsXG5cdFwiSW50ZXJzZWN0aW9uXCI6IFwi4ouCXCIsXG5cdFwiaW50bGFyaGtcIjogXCLiqJdcIixcblx0XCJpbnRwcm9kXCI6IFwi4qi8XCIsXG5cdFwiSW52aXNpYmxlQ29tbWFcIjogXCLigaNcIixcblx0XCJJbnZpc2libGVUaW1lc1wiOiBcIuKBolwiLFxuXHRcIklPY3lcIjogXCLQgVwiLFxuXHRcImlvY3lcIjogXCLRkVwiLFxuXHRcIklvZ29uXCI6IFwixK5cIixcblx0XCJpb2dvblwiOiBcIsSvXCIsXG5cdFwiSW9wZlwiOiBcIvCdlYBcIixcblx0XCJpb3BmXCI6IFwi8J2VmlwiLFxuXHRcIklvdGFcIjogXCLOmVwiLFxuXHRcImlvdGFcIjogXCLOuVwiLFxuXHRcImlwcm9kXCI6IFwi4qi8XCIsXG5cdFwiaXF1ZXN0XCI6IFwiwr9cIixcblx0XCJpc2NyXCI6IFwi8J2SvlwiLFxuXHRcIklzY3JcIjogXCLihJBcIixcblx0XCJpc2luXCI6IFwi4oiIXCIsXG5cdFwiaXNpbmRvdFwiOiBcIuKLtVwiLFxuXHRcImlzaW5FXCI6IFwi4ou5XCIsXG5cdFwiaXNpbnNcIjogXCLii7RcIixcblx0XCJpc2luc3ZcIjogXCLii7NcIixcblx0XCJpc2ludlwiOiBcIuKIiFwiLFxuXHRcIml0XCI6IFwi4oGiXCIsXG5cdFwiSXRpbGRlXCI6IFwixKhcIixcblx0XCJpdGlsZGVcIjogXCLEqVwiLFxuXHRcIkl1a2N5XCI6IFwi0IZcIixcblx0XCJpdWtjeVwiOiBcItGWXCIsXG5cdFwiSXVtbFwiOiBcIsOPXCIsXG5cdFwiaXVtbFwiOiBcIsOvXCIsXG5cdFwiSmNpcmNcIjogXCLEtFwiLFxuXHRcImpjaXJjXCI6IFwixLVcIixcblx0XCJKY3lcIjogXCLQmVwiLFxuXHRcImpjeVwiOiBcItC5XCIsXG5cdFwiSmZyXCI6IFwi8J2UjVwiLFxuXHRcImpmclwiOiBcIvCdlKdcIixcblx0XCJqbWF0aFwiOiBcIsi3XCIsXG5cdFwiSm9wZlwiOiBcIvCdlYFcIixcblx0XCJqb3BmXCI6IFwi8J2Vm1wiLFxuXHRcIkpzY3JcIjogXCLwnZKlXCIsXG5cdFwianNjclwiOiBcIvCdkr9cIixcblx0XCJKc2VyY3lcIjogXCLQiFwiLFxuXHRcImpzZXJjeVwiOiBcItGYXCIsXG5cdFwiSnVrY3lcIjogXCLQhFwiLFxuXHRcImp1a2N5XCI6IFwi0ZRcIixcblx0XCJLYXBwYVwiOiBcIs6aXCIsXG5cdFwia2FwcGFcIjogXCLOulwiLFxuXHRcImthcHBhdlwiOiBcIs+wXCIsXG5cdFwiS2NlZGlsXCI6IFwixLZcIixcblx0XCJrY2VkaWxcIjogXCLEt1wiLFxuXHRcIktjeVwiOiBcItCaXCIsXG5cdFwia2N5XCI6IFwi0LpcIixcblx0XCJLZnJcIjogXCLwnZSOXCIsXG5cdFwia2ZyXCI6IFwi8J2UqFwiLFxuXHRcImtncmVlblwiOiBcIsS4XCIsXG5cdFwiS0hjeVwiOiBcItClXCIsXG5cdFwia2hjeVwiOiBcItGFXCIsXG5cdFwiS0pjeVwiOiBcItCMXCIsXG5cdFwia2pjeVwiOiBcItGcXCIsXG5cdFwiS29wZlwiOiBcIvCdlYJcIixcblx0XCJrb3BmXCI6IFwi8J2VnFwiLFxuXHRcIktzY3JcIjogXCLwnZKmXCIsXG5cdFwia3NjclwiOiBcIvCdk4BcIixcblx0XCJsQWFyclwiOiBcIuKHmlwiLFxuXHRcIkxhY3V0ZVwiOiBcIsS5XCIsXG5cdFwibGFjdXRlXCI6IFwixLpcIixcblx0XCJsYWVtcHR5dlwiOiBcIuKmtFwiLFxuXHRcImxhZ3JhblwiOiBcIuKEklwiLFxuXHRcIkxhbWJkYVwiOiBcIs6bXCIsXG5cdFwibGFtYmRhXCI6IFwizrtcIixcblx0XCJsYW5nXCI6IFwi4p+oXCIsXG5cdFwiTGFuZ1wiOiBcIuKfqlwiLFxuXHRcImxhbmdkXCI6IFwi4qaRXCIsXG5cdFwibGFuZ2xlXCI6IFwi4p+oXCIsXG5cdFwibGFwXCI6IFwi4qqFXCIsXG5cdFwiTGFwbGFjZXRyZlwiOiBcIuKEklwiLFxuXHRcImxhcXVvXCI6IFwiwqtcIixcblx0XCJsYXJyYlwiOiBcIuKHpFwiLFxuXHRcImxhcnJiZnNcIjogXCLipJ9cIixcblx0XCJsYXJyXCI6IFwi4oaQXCIsXG5cdFwiTGFyclwiOiBcIuKGnlwiLFxuXHRcImxBcnJcIjogXCLih5BcIixcblx0XCJsYXJyZnNcIjogXCLipJ1cIixcblx0XCJsYXJyaGtcIjogXCLihqlcIixcblx0XCJsYXJybHBcIjogXCLihqtcIixcblx0XCJsYXJycGxcIjogXCLipLlcIixcblx0XCJsYXJyc2ltXCI6IFwi4qWzXCIsXG5cdFwibGFycnRsXCI6IFwi4oaiXCIsXG5cdFwibGF0YWlsXCI6IFwi4qSZXCIsXG5cdFwibEF0YWlsXCI6IFwi4qSbXCIsXG5cdFwibGF0XCI6IFwi4qqrXCIsXG5cdFwibGF0ZVwiOiBcIuKqrVwiLFxuXHRcImxhdGVzXCI6IFwi4qqt77iAXCIsXG5cdFwibGJhcnJcIjogXCLipIxcIixcblx0XCJsQmFyclwiOiBcIuKkjlwiLFxuXHRcImxiYnJrXCI6IFwi4p2yXCIsXG5cdFwibGJyYWNlXCI6IFwie1wiLFxuXHRcImxicmFja1wiOiBcIltcIixcblx0XCJsYnJrZVwiOiBcIuKmi1wiLFxuXHRcImxicmtzbGRcIjogXCLipo9cIixcblx0XCJsYnJrc2x1XCI6IFwi4qaNXCIsXG5cdFwiTGNhcm9uXCI6IFwixL1cIixcblx0XCJsY2Fyb25cIjogXCLEvlwiLFxuXHRcIkxjZWRpbFwiOiBcIsS7XCIsXG5cdFwibGNlZGlsXCI6IFwixLxcIixcblx0XCJsY2VpbFwiOiBcIuKMiFwiLFxuXHRcImxjdWJcIjogXCJ7XCIsXG5cdFwiTGN5XCI6IFwi0JtcIixcblx0XCJsY3lcIjogXCLQu1wiLFxuXHRcImxkY2FcIjogXCLipLZcIixcblx0XCJsZHF1b1wiOiBcIuKAnFwiLFxuXHRcImxkcXVvclwiOiBcIuKAnlwiLFxuXHRcImxkcmRoYXJcIjogXCLipadcIixcblx0XCJsZHJ1c2hhclwiOiBcIuKli1wiLFxuXHRcImxkc2hcIjogXCLihrJcIixcblx0XCJsZVwiOiBcIuKJpFwiLFxuXHRcImxFXCI6IFwi4ommXCIsXG5cdFwiTGVmdEFuZ2xlQnJhY2tldFwiOiBcIuKfqFwiLFxuXHRcIkxlZnRBcnJvd0JhclwiOiBcIuKHpFwiLFxuXHRcImxlZnRhcnJvd1wiOiBcIuKGkFwiLFxuXHRcIkxlZnRBcnJvd1wiOiBcIuKGkFwiLFxuXHRcIkxlZnRhcnJvd1wiOiBcIuKHkFwiLFxuXHRcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjogXCLih4ZcIixcblx0XCJsZWZ0YXJyb3d0YWlsXCI6IFwi4oaiXCIsXG5cdFwiTGVmdENlaWxpbmdcIjogXCLijIhcIixcblx0XCJMZWZ0RG91YmxlQnJhY2tldFwiOiBcIuKfplwiLFxuXHRcIkxlZnREb3duVGVlVmVjdG9yXCI6IFwi4qWhXCIsXG5cdFwiTGVmdERvd25WZWN0b3JCYXJcIjogXCLipZlcIixcblx0XCJMZWZ0RG93blZlY3RvclwiOiBcIuKHg1wiLFxuXHRcIkxlZnRGbG9vclwiOiBcIuKMilwiLFxuXHRcImxlZnRoYXJwb29uZG93blwiOiBcIuKGvVwiLFxuXHRcImxlZnRoYXJwb29udXBcIjogXCLihrxcIixcblx0XCJsZWZ0bGVmdGFycm93c1wiOiBcIuKHh1wiLFxuXHRcImxlZnRyaWdodGFycm93XCI6IFwi4oaUXCIsXG5cdFwiTGVmdFJpZ2h0QXJyb3dcIjogXCLihpRcIixcblx0XCJMZWZ0cmlnaHRhcnJvd1wiOiBcIuKHlFwiLFxuXHRcImxlZnRyaWdodGFycm93c1wiOiBcIuKHhlwiLFxuXHRcImxlZnRyaWdodGhhcnBvb25zXCI6IFwi4oeLXCIsXG5cdFwibGVmdHJpZ2h0c3F1aWdhcnJvd1wiOiBcIuKGrVwiLFxuXHRcIkxlZnRSaWdodFZlY3RvclwiOiBcIuKljlwiLFxuXHRcIkxlZnRUZWVBcnJvd1wiOiBcIuKGpFwiLFxuXHRcIkxlZnRUZWVcIjogXCLiiqNcIixcblx0XCJMZWZ0VGVlVmVjdG9yXCI6IFwi4qWaXCIsXG5cdFwibGVmdHRocmVldGltZXNcIjogXCLii4tcIixcblx0XCJMZWZ0VHJpYW5nbGVCYXJcIjogXCLip49cIixcblx0XCJMZWZ0VHJpYW5nbGVcIjogXCLiirJcIixcblx0XCJMZWZ0VHJpYW5nbGVFcXVhbFwiOiBcIuKKtFwiLFxuXHRcIkxlZnRVcERvd25WZWN0b3JcIjogXCLipZFcIixcblx0XCJMZWZ0VXBUZWVWZWN0b3JcIjogXCLipaBcIixcblx0XCJMZWZ0VXBWZWN0b3JCYXJcIjogXCLipZhcIixcblx0XCJMZWZ0VXBWZWN0b3JcIjogXCLihr9cIixcblx0XCJMZWZ0VmVjdG9yQmFyXCI6IFwi4qWSXCIsXG5cdFwiTGVmdFZlY3RvclwiOiBcIuKGvFwiLFxuXHRcImxFZ1wiOiBcIuKqi1wiLFxuXHRcImxlZ1wiOiBcIuKLmlwiLFxuXHRcImxlcVwiOiBcIuKJpFwiLFxuXHRcImxlcXFcIjogXCLiiaZcIixcblx0XCJsZXFzbGFudFwiOiBcIuKpvVwiLFxuXHRcImxlc2NjXCI6IFwi4qqoXCIsXG5cdFwibGVzXCI6IFwi4qm9XCIsXG5cdFwibGVzZG90XCI6IFwi4qm/XCIsXG5cdFwibGVzZG90b1wiOiBcIuKqgVwiLFxuXHRcImxlc2RvdG9yXCI6IFwi4qqDXCIsXG5cdFwibGVzZ1wiOiBcIuKLmu+4gFwiLFxuXHRcImxlc2dlc1wiOiBcIuKqk1wiLFxuXHRcImxlc3NhcHByb3hcIjogXCLiqoVcIixcblx0XCJsZXNzZG90XCI6IFwi4ouWXCIsXG5cdFwibGVzc2VxZ3RyXCI6IFwi4ouaXCIsXG5cdFwibGVzc2VxcWd0clwiOiBcIuKqi1wiLFxuXHRcIkxlc3NFcXVhbEdyZWF0ZXJcIjogXCLii5pcIixcblx0XCJMZXNzRnVsbEVxdWFsXCI6IFwi4ommXCIsXG5cdFwiTGVzc0dyZWF0ZXJcIjogXCLiibZcIixcblx0XCJsZXNzZ3RyXCI6IFwi4om2XCIsXG5cdFwiTGVzc0xlc3NcIjogXCLiqqFcIixcblx0XCJsZXNzc2ltXCI6IFwi4omyXCIsXG5cdFwiTGVzc1NsYW50RXF1YWxcIjogXCLiqb1cIixcblx0XCJMZXNzVGlsZGVcIjogXCLiibJcIixcblx0XCJsZmlzaHRcIjogXCLipbxcIixcblx0XCJsZmxvb3JcIjogXCLijIpcIixcblx0XCJMZnJcIjogXCLwnZSPXCIsXG5cdFwibGZyXCI6IFwi8J2UqVwiLFxuXHRcImxnXCI6IFwi4om2XCIsXG5cdFwibGdFXCI6IFwi4qqRXCIsXG5cdFwibEhhclwiOiBcIuKlolwiLFxuXHRcImxoYXJkXCI6IFwi4oa9XCIsXG5cdFwibGhhcnVcIjogXCLihrxcIixcblx0XCJsaGFydWxcIjogXCLipapcIixcblx0XCJsaGJsa1wiOiBcIuKWhFwiLFxuXHRcIkxKY3lcIjogXCLQiVwiLFxuXHRcImxqY3lcIjogXCLRmVwiLFxuXHRcImxsYXJyXCI6IFwi4oeHXCIsXG5cdFwibGxcIjogXCLiiapcIixcblx0XCJMbFwiOiBcIuKLmFwiLFxuXHRcImxsY29ybmVyXCI6IFwi4oyeXCIsXG5cdFwiTGxlZnRhcnJvd1wiOiBcIuKHmlwiLFxuXHRcImxsaGFyZFwiOiBcIuKlq1wiLFxuXHRcImxsdHJpXCI6IFwi4pe6XCIsXG5cdFwiTG1pZG90XCI6IFwixL9cIixcblx0XCJsbWlkb3RcIjogXCLFgFwiLFxuXHRcImxtb3VzdGFjaGVcIjogXCLijrBcIixcblx0XCJsbW91c3RcIjogXCLijrBcIixcblx0XCJsbmFwXCI6IFwi4qqJXCIsXG5cdFwibG5hcHByb3hcIjogXCLiqolcIixcblx0XCJsbmVcIjogXCLiqodcIixcblx0XCJsbkVcIjogXCLiiahcIixcblx0XCJsbmVxXCI6IFwi4qqHXCIsXG5cdFwibG5lcXFcIjogXCLiiahcIixcblx0XCJsbnNpbVwiOiBcIuKLplwiLFxuXHRcImxvYW5nXCI6IFwi4p+sXCIsXG5cdFwibG9hcnJcIjogXCLih71cIixcblx0XCJsb2Jya1wiOiBcIuKfplwiLFxuXHRcImxvbmdsZWZ0YXJyb3dcIjogXCLin7VcIixcblx0XCJMb25nTGVmdEFycm93XCI6IFwi4p+1XCIsXG5cdFwiTG9uZ2xlZnRhcnJvd1wiOiBcIuKfuFwiLFxuXHRcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOiBcIuKft1wiLFxuXHRcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOiBcIuKft1wiLFxuXHRcIkxvbmdsZWZ0cmlnaHRhcnJvd1wiOiBcIuKfulwiLFxuXHRcImxvbmdtYXBzdG9cIjogXCLin7xcIixcblx0XCJsb25ncmlnaHRhcnJvd1wiOiBcIuKftlwiLFxuXHRcIkxvbmdSaWdodEFycm93XCI6IFwi4p+2XCIsXG5cdFwiTG9uZ3JpZ2h0YXJyb3dcIjogXCLin7lcIixcblx0XCJsb29wYXJyb3dsZWZ0XCI6IFwi4oarXCIsXG5cdFwibG9vcGFycm93cmlnaHRcIjogXCLihqxcIixcblx0XCJsb3BhclwiOiBcIuKmhVwiLFxuXHRcIkxvcGZcIjogXCLwnZWDXCIsXG5cdFwibG9wZlwiOiBcIvCdlZ1cIixcblx0XCJsb3BsdXNcIjogXCLiqK1cIixcblx0XCJsb3RpbWVzXCI6IFwi4qi0XCIsXG5cdFwibG93YXN0XCI6IFwi4oiXXCIsXG5cdFwibG93YmFyXCI6IFwiX1wiLFxuXHRcIkxvd2VyTGVmdEFycm93XCI6IFwi4oaZXCIsXG5cdFwiTG93ZXJSaWdodEFycm93XCI6IFwi4oaYXCIsXG5cdFwibG96XCI6IFwi4peKXCIsXG5cdFwibG96ZW5nZVwiOiBcIuKXilwiLFxuXHRcImxvemZcIjogXCLip6tcIixcblx0XCJscGFyXCI6IFwiKFwiLFxuXHRcImxwYXJsdFwiOiBcIuKmk1wiLFxuXHRcImxyYXJyXCI6IFwi4oeGXCIsXG5cdFwibHJjb3JuZXJcIjogXCLijJ9cIixcblx0XCJscmhhclwiOiBcIuKHi1wiLFxuXHRcImxyaGFyZFwiOiBcIuKlrVwiLFxuXHRcImxybVwiOiBcIuKAjlwiLFxuXHRcImxydHJpXCI6IFwi4oq/XCIsXG5cdFwibHNhcXVvXCI6IFwi4oC5XCIsXG5cdFwibHNjclwiOiBcIvCdk4FcIixcblx0XCJMc2NyXCI6IFwi4oSSXCIsXG5cdFwibHNoXCI6IFwi4oawXCIsXG5cdFwiTHNoXCI6IFwi4oawXCIsXG5cdFwibHNpbVwiOiBcIuKJslwiLFxuXHRcImxzaW1lXCI6IFwi4qqNXCIsXG5cdFwibHNpbWdcIjogXCLiqo9cIixcblx0XCJsc3FiXCI6IFwiW1wiLFxuXHRcImxzcXVvXCI6IFwi4oCYXCIsXG5cdFwibHNxdW9yXCI6IFwi4oCaXCIsXG5cdFwiTHN0cm9rXCI6IFwixYFcIixcblx0XCJsc3Ryb2tcIjogXCLFglwiLFxuXHRcImx0Y2NcIjogXCLiqqZcIixcblx0XCJsdGNpclwiOiBcIuKpuVwiLFxuXHRcImx0XCI6IFwiPFwiLFxuXHRcIkxUXCI6IFwiPFwiLFxuXHRcIkx0XCI6IFwi4omqXCIsXG5cdFwibHRkb3RcIjogXCLii5ZcIixcblx0XCJsdGhyZWVcIjogXCLii4tcIixcblx0XCJsdGltZXNcIjogXCLii4lcIixcblx0XCJsdGxhcnJcIjogXCLipbZcIixcblx0XCJsdHF1ZXN0XCI6IFwi4qm7XCIsXG5cdFwibHRyaVwiOiBcIuKXg1wiLFxuXHRcImx0cmllXCI6IFwi4oq0XCIsXG5cdFwibHRyaWZcIjogXCLil4JcIixcblx0XCJsdHJQYXJcIjogXCLippZcIixcblx0XCJsdXJkc2hhclwiOiBcIuKlilwiLFxuXHRcImx1cnVoYXJcIjogXCLipaZcIixcblx0XCJsdmVydG5lcXFcIjogXCLiiajvuIBcIixcblx0XCJsdm5FXCI6IFwi4omo77iAXCIsXG5cdFwibWFjclwiOiBcIsKvXCIsXG5cdFwibWFsZVwiOiBcIuKZglwiLFxuXHRcIm1hbHRcIjogXCLinKBcIixcblx0XCJtYWx0ZXNlXCI6IFwi4pygXCIsXG5cdFwiTWFwXCI6IFwi4qSFXCIsXG5cdFwibWFwXCI6IFwi4oamXCIsXG5cdFwibWFwc3RvXCI6IFwi4oamXCIsXG5cdFwibWFwc3RvZG93blwiOiBcIuKGp1wiLFxuXHRcIm1hcHN0b2xlZnRcIjogXCLihqRcIixcblx0XCJtYXBzdG91cFwiOiBcIuKGpVwiLFxuXHRcIm1hcmtlclwiOiBcIuKWrlwiLFxuXHRcIm1jb21tYVwiOiBcIuKoqVwiLFxuXHRcIk1jeVwiOiBcItCcXCIsXG5cdFwibWN5XCI6IFwi0LxcIixcblx0XCJtZGFzaFwiOiBcIuKAlFwiLFxuXHRcIm1ERG90XCI6IFwi4oi6XCIsXG5cdFwibWVhc3VyZWRhbmdsZVwiOiBcIuKIoVwiLFxuXHRcIk1lZGl1bVNwYWNlXCI6IFwi4oGfXCIsXG5cdFwiTWVsbGludHJmXCI6IFwi4oSzXCIsXG5cdFwiTWZyXCI6IFwi8J2UkFwiLFxuXHRcIm1mclwiOiBcIvCdlKpcIixcblx0XCJtaG9cIjogXCLihKdcIixcblx0XCJtaWNyb1wiOiBcIsK1XCIsXG5cdFwibWlkYXN0XCI6IFwiKlwiLFxuXHRcIm1pZGNpclwiOiBcIuKrsFwiLFxuXHRcIm1pZFwiOiBcIuKIo1wiLFxuXHRcIm1pZGRvdFwiOiBcIsK3XCIsXG5cdFwibWludXNiXCI6IFwi4oqfXCIsXG5cdFwibWludXNcIjogXCLiiJJcIixcblx0XCJtaW51c2RcIjogXCLiiLhcIixcblx0XCJtaW51c2R1XCI6IFwi4qiqXCIsXG5cdFwiTWludXNQbHVzXCI6IFwi4oiTXCIsXG5cdFwibWxjcFwiOiBcIuKrm1wiLFxuXHRcIm1sZHJcIjogXCLigKZcIixcblx0XCJtbnBsdXNcIjogXCLiiJNcIixcblx0XCJtb2RlbHNcIjogXCLiiqdcIixcblx0XCJNb3BmXCI6IFwi8J2VhFwiLFxuXHRcIm1vcGZcIjogXCLwnZWeXCIsXG5cdFwibXBcIjogXCLiiJNcIixcblx0XCJtc2NyXCI6IFwi8J2TglwiLFxuXHRcIk1zY3JcIjogXCLihLNcIixcblx0XCJtc3Rwb3NcIjogXCLiiL5cIixcblx0XCJNdVwiOiBcIs6cXCIsXG5cdFwibXVcIjogXCLOvFwiLFxuXHRcIm11bHRpbWFwXCI6IFwi4oq4XCIsXG5cdFwibXVtYXBcIjogXCLiirhcIixcblx0XCJuYWJsYVwiOiBcIuKIh1wiLFxuXHRcIk5hY3V0ZVwiOiBcIsWDXCIsXG5cdFwibmFjdXRlXCI6IFwixYRcIixcblx0XCJuYW5nXCI6IFwi4oig4oOSXCIsXG5cdFwibmFwXCI6IFwi4omJXCIsXG5cdFwibmFwRVwiOiBcIuKpsMy4XCIsXG5cdFwibmFwaWRcIjogXCLiiYvMuFwiLFxuXHRcIm5hcG9zXCI6IFwixYlcIixcblx0XCJuYXBwcm94XCI6IFwi4omJXCIsXG5cdFwibmF0dXJhbFwiOiBcIuKZrlwiLFxuXHRcIm5hdHVyYWxzXCI6IFwi4oSVXCIsXG5cdFwibmF0dXJcIjogXCLima5cIixcblx0XCJuYnNwXCI6IFwiwqBcIixcblx0XCJuYnVtcFwiOiBcIuKJjsy4XCIsXG5cdFwibmJ1bXBlXCI6IFwi4omPzLhcIixcblx0XCJuY2FwXCI6IFwi4qmDXCIsXG5cdFwiTmNhcm9uXCI6IFwixYdcIixcblx0XCJuY2Fyb25cIjogXCLFiFwiLFxuXHRcIk5jZWRpbFwiOiBcIsWFXCIsXG5cdFwibmNlZGlsXCI6IFwixYZcIixcblx0XCJuY29uZ1wiOiBcIuKJh1wiLFxuXHRcIm5jb25nZG90XCI6IFwi4qmtzLhcIixcblx0XCJuY3VwXCI6IFwi4qmCXCIsXG5cdFwiTmN5XCI6IFwi0J1cIixcblx0XCJuY3lcIjogXCLQvVwiLFxuXHRcIm5kYXNoXCI6IFwi4oCTXCIsXG5cdFwibmVhcmhrXCI6IFwi4qSkXCIsXG5cdFwibmVhcnJcIjogXCLihpdcIixcblx0XCJuZUFyclwiOiBcIuKHl1wiLFxuXHRcIm5lYXJyb3dcIjogXCLihpdcIixcblx0XCJuZVwiOiBcIuKJoFwiLFxuXHRcIm5lZG90XCI6IFwi4omQzLhcIixcblx0XCJOZWdhdGl2ZU1lZGl1bVNwYWNlXCI6IFwi4oCLXCIsXG5cdFwiTmVnYXRpdmVUaGlja1NwYWNlXCI6IFwi4oCLXCIsXG5cdFwiTmVnYXRpdmVUaGluU3BhY2VcIjogXCLigItcIixcblx0XCJOZWdhdGl2ZVZlcnlUaGluU3BhY2VcIjogXCLigItcIixcblx0XCJuZXF1aXZcIjogXCLiiaJcIixcblx0XCJuZXNlYXJcIjogXCLipKhcIixcblx0XCJuZXNpbVwiOiBcIuKJgsy4XCIsXG5cdFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjogXCLiiatcIixcblx0XCJOZXN0ZWRMZXNzTGVzc1wiOiBcIuKJqlwiLFxuXHRcIk5ld0xpbmVcIjogXCJcXG5cIixcblx0XCJuZXhpc3RcIjogXCLiiIRcIixcblx0XCJuZXhpc3RzXCI6IFwi4oiEXCIsXG5cdFwiTmZyXCI6IFwi8J2UkVwiLFxuXHRcIm5mclwiOiBcIvCdlKtcIixcblx0XCJuZ0VcIjogXCLiiafMuFwiLFxuXHRcIm5nZVwiOiBcIuKJsVwiLFxuXHRcIm5nZXFcIjogXCLiibFcIixcblx0XCJuZ2VxcVwiOiBcIuKJp8y4XCIsXG5cdFwibmdlcXNsYW50XCI6IFwi4qm+zLhcIixcblx0XCJuZ2VzXCI6IFwi4qm+zLhcIixcblx0XCJuR2dcIjogXCLii5nMuFwiLFxuXHRcIm5nc2ltXCI6IFwi4om1XCIsXG5cdFwibkd0XCI6IFwi4omr4oOSXCIsXG5cdFwibmd0XCI6IFwi4omvXCIsXG5cdFwibmd0clwiOiBcIuKJr1wiLFxuXHRcIm5HdHZcIjogXCLiiavMuFwiLFxuXHRcIm5oYXJyXCI6IFwi4oauXCIsXG5cdFwibmhBcnJcIjogXCLih45cIixcblx0XCJuaHBhclwiOiBcIuKrslwiLFxuXHRcIm5pXCI6IFwi4oiLXCIsXG5cdFwibmlzXCI6IFwi4ou8XCIsXG5cdFwibmlzZFwiOiBcIuKLulwiLFxuXHRcIm5pdlwiOiBcIuKIi1wiLFxuXHRcIk5KY3lcIjogXCLQilwiLFxuXHRcIm5qY3lcIjogXCLRmlwiLFxuXHRcIm5sYXJyXCI6IFwi4oaaXCIsXG5cdFwibmxBcnJcIjogXCLih41cIixcblx0XCJubGRyXCI6IFwi4oClXCIsXG5cdFwibmxFXCI6IFwi4ommzLhcIixcblx0XCJubGVcIjogXCLiibBcIixcblx0XCJubGVmdGFycm93XCI6IFwi4oaaXCIsXG5cdFwibkxlZnRhcnJvd1wiOiBcIuKHjVwiLFxuXHRcIm5sZWZ0cmlnaHRhcnJvd1wiOiBcIuKGrlwiLFxuXHRcIm5MZWZ0cmlnaHRhcnJvd1wiOiBcIuKHjlwiLFxuXHRcIm5sZXFcIjogXCLiibBcIixcblx0XCJubGVxcVwiOiBcIuKJpsy4XCIsXG5cdFwibmxlcXNsYW50XCI6IFwi4qm9zLhcIixcblx0XCJubGVzXCI6IFwi4qm9zLhcIixcblx0XCJubGVzc1wiOiBcIuKJrlwiLFxuXHRcIm5MbFwiOiBcIuKLmMy4XCIsXG5cdFwibmxzaW1cIjogXCLiibRcIixcblx0XCJuTHRcIjogXCLiiarig5JcIixcblx0XCJubHRcIjogXCLiia5cIixcblx0XCJubHRyaVwiOiBcIuKLqlwiLFxuXHRcIm5sdHJpZVwiOiBcIuKLrFwiLFxuXHRcIm5MdHZcIjogXCLiiarMuFwiLFxuXHRcIm5taWRcIjogXCLiiKRcIixcblx0XCJOb0JyZWFrXCI6IFwi4oGgXCIsXG5cdFwiTm9uQnJlYWtpbmdTcGFjZVwiOiBcIsKgXCIsXG5cdFwibm9wZlwiOiBcIvCdlZ9cIixcblx0XCJOb3BmXCI6IFwi4oSVXCIsXG5cdFwiTm90XCI6IFwi4qusXCIsXG5cdFwibm90XCI6IFwiwqxcIixcblx0XCJOb3RDb25ncnVlbnRcIjogXCLiiaJcIixcblx0XCJOb3RDdXBDYXBcIjogXCLiia1cIixcblx0XCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOiBcIuKIplwiLFxuXHRcIk5vdEVsZW1lbnRcIjogXCLiiIlcIixcblx0XCJOb3RFcXVhbFwiOiBcIuKJoFwiLFxuXHRcIk5vdEVxdWFsVGlsZGVcIjogXCLiiYLMuFwiLFxuXHRcIk5vdEV4aXN0c1wiOiBcIuKIhFwiLFxuXHRcIk5vdEdyZWF0ZXJcIjogXCLiia9cIixcblx0XCJOb3RHcmVhdGVyRXF1YWxcIjogXCLiibFcIixcblx0XCJOb3RHcmVhdGVyRnVsbEVxdWFsXCI6IFwi4omnzLhcIixcblx0XCJOb3RHcmVhdGVyR3JlYXRlclwiOiBcIuKJq8y4XCIsXG5cdFwiTm90R3JlYXRlckxlc3NcIjogXCLiiblcIixcblx0XCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOiBcIuKpvsy4XCIsXG5cdFwiTm90R3JlYXRlclRpbGRlXCI6IFwi4om1XCIsXG5cdFwiTm90SHVtcERvd25IdW1wXCI6IFwi4omOzLhcIixcblx0XCJOb3RIdW1wRXF1YWxcIjogXCLiiY/MuFwiLFxuXHRcIm5vdGluXCI6IFwi4oiJXCIsXG5cdFwibm90aW5kb3RcIjogXCLii7XMuFwiLFxuXHRcIm5vdGluRVwiOiBcIuKLucy4XCIsXG5cdFwibm90aW52YVwiOiBcIuKIiVwiLFxuXHRcIm5vdGludmJcIjogXCLii7dcIixcblx0XCJub3RpbnZjXCI6IFwi4ou2XCIsXG5cdFwiTm90TGVmdFRyaWFuZ2xlQmFyXCI6IFwi4qePzLhcIixcblx0XCJOb3RMZWZ0VHJpYW5nbGVcIjogXCLii6pcIixcblx0XCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOiBcIuKLrFwiLFxuXHRcIk5vdExlc3NcIjogXCLiia5cIixcblx0XCJOb3RMZXNzRXF1YWxcIjogXCLiibBcIixcblx0XCJOb3RMZXNzR3JlYXRlclwiOiBcIuKJuFwiLFxuXHRcIk5vdExlc3NMZXNzXCI6IFwi4omqzLhcIixcblx0XCJOb3RMZXNzU2xhbnRFcXVhbFwiOiBcIuKpvcy4XCIsXG5cdFwiTm90TGVzc1RpbGRlXCI6IFwi4om0XCIsXG5cdFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXJcIjogXCLiqqLMuFwiLFxuXHRcIk5vdE5lc3RlZExlc3NMZXNzXCI6IFwi4qqhzLhcIixcblx0XCJub3RuaVwiOiBcIuKIjFwiLFxuXHRcIm5vdG5pdmFcIjogXCLiiIxcIixcblx0XCJub3RuaXZiXCI6IFwi4ou+XCIsXG5cdFwibm90bml2Y1wiOiBcIuKLvVwiLFxuXHRcIk5vdFByZWNlZGVzXCI6IFwi4oqAXCIsXG5cdFwiTm90UHJlY2VkZXNFcXVhbFwiOiBcIuKqr8y4XCIsXG5cdFwiTm90UHJlY2VkZXNTbGFudEVxdWFsXCI6IFwi4ougXCIsXG5cdFwiTm90UmV2ZXJzZUVsZW1lbnRcIjogXCLiiIxcIixcblx0XCJOb3RSaWdodFRyaWFuZ2xlQmFyXCI6IFwi4qeQzLhcIixcblx0XCJOb3RSaWdodFRyaWFuZ2xlXCI6IFwi4ourXCIsXG5cdFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsXCI6IFwi4outXCIsXG5cdFwiTm90U3F1YXJlU3Vic2V0XCI6IFwi4oqPzLhcIixcblx0XCJOb3RTcXVhcmVTdWJzZXRFcXVhbFwiOiBcIuKLolwiLFxuXHRcIk5vdFNxdWFyZVN1cGVyc2V0XCI6IFwi4oqQzLhcIixcblx0XCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsXCI6IFwi4oujXCIsXG5cdFwiTm90U3Vic2V0XCI6IFwi4oqC4oOSXCIsXG5cdFwiTm90U3Vic2V0RXF1YWxcIjogXCLiiohcIixcblx0XCJOb3RTdWNjZWVkc1wiOiBcIuKKgVwiLFxuXHRcIk5vdFN1Y2NlZWRzRXF1YWxcIjogXCLiqrDMuFwiLFxuXHRcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbFwiOiBcIuKLoVwiLFxuXHRcIk5vdFN1Y2NlZWRzVGlsZGVcIjogXCLiib/MuFwiLFxuXHRcIk5vdFN1cGVyc2V0XCI6IFwi4oqD4oOSXCIsXG5cdFwiTm90U3VwZXJzZXRFcXVhbFwiOiBcIuKKiVwiLFxuXHRcIk5vdFRpbGRlXCI6IFwi4omBXCIsXG5cdFwiTm90VGlsZGVFcXVhbFwiOiBcIuKJhFwiLFxuXHRcIk5vdFRpbGRlRnVsbEVxdWFsXCI6IFwi4omHXCIsXG5cdFwiTm90VGlsZGVUaWxkZVwiOiBcIuKJiVwiLFxuXHRcIk5vdFZlcnRpY2FsQmFyXCI6IFwi4oikXCIsXG5cdFwibnBhcmFsbGVsXCI6IFwi4oimXCIsXG5cdFwibnBhclwiOiBcIuKIplwiLFxuXHRcIm5wYXJzbFwiOiBcIuKrveKDpVwiLFxuXHRcIm5wYXJ0XCI6IFwi4oiCzLhcIixcblx0XCJucG9saW50XCI6IFwi4qiUXCIsXG5cdFwibnByXCI6IFwi4oqAXCIsXG5cdFwibnByY3VlXCI6IFwi4ougXCIsXG5cdFwibnByZWNcIjogXCLiioBcIixcblx0XCJucHJlY2VxXCI6IFwi4qqvzLhcIixcblx0XCJucHJlXCI6IFwi4qqvzLhcIixcblx0XCJucmFycmNcIjogXCLipLPMuFwiLFxuXHRcIm5yYXJyXCI6IFwi4oabXCIsXG5cdFwibnJBcnJcIjogXCLih49cIixcblx0XCJucmFycndcIjogXCLihp3MuFwiLFxuXHRcIm5yaWdodGFycm93XCI6IFwi4oabXCIsXG5cdFwiblJpZ2h0YXJyb3dcIjogXCLih49cIixcblx0XCJucnRyaVwiOiBcIuKLq1wiLFxuXHRcIm5ydHJpZVwiOiBcIuKLrVwiLFxuXHRcIm5zY1wiOiBcIuKKgVwiLFxuXHRcIm5zY2N1ZVwiOiBcIuKLoVwiLFxuXHRcIm5zY2VcIjogXCLiqrDMuFwiLFxuXHRcIk5zY3JcIjogXCLwnZKpXCIsXG5cdFwibnNjclwiOiBcIvCdk4NcIixcblx0XCJuc2hvcnRtaWRcIjogXCLiiKRcIixcblx0XCJuc2hvcnRwYXJhbGxlbFwiOiBcIuKIplwiLFxuXHRcIm5zaW1cIjogXCLiiYFcIixcblx0XCJuc2ltZVwiOiBcIuKJhFwiLFxuXHRcIm5zaW1lcVwiOiBcIuKJhFwiLFxuXHRcIm5zbWlkXCI6IFwi4oikXCIsXG5cdFwibnNwYXJcIjogXCLiiKZcIixcblx0XCJuc3FzdWJlXCI6IFwi4ouiXCIsXG5cdFwibnNxc3VwZVwiOiBcIuKLo1wiLFxuXHRcIm5zdWJcIjogXCLiioRcIixcblx0XCJuc3ViRVwiOiBcIuKrhcy4XCIsXG5cdFwibnN1YmVcIjogXCLiiohcIixcblx0XCJuc3Vic2V0XCI6IFwi4oqC4oOSXCIsXG5cdFwibnN1YnNldGVxXCI6IFwi4oqIXCIsXG5cdFwibnN1YnNldGVxcVwiOiBcIuKrhcy4XCIsXG5cdFwibnN1Y2NcIjogXCLiioFcIixcblx0XCJuc3VjY2VxXCI6IFwi4qqwzLhcIixcblx0XCJuc3VwXCI6IFwi4oqFXCIsXG5cdFwibnN1cEVcIjogXCLiq4bMuFwiLFxuXHRcIm5zdXBlXCI6IFwi4oqJXCIsXG5cdFwibnN1cHNldFwiOiBcIuKKg+KDklwiLFxuXHRcIm5zdXBzZXRlcVwiOiBcIuKKiVwiLFxuXHRcIm5zdXBzZXRlcXFcIjogXCLiq4bMuFwiLFxuXHRcIm50Z2xcIjogXCLiiblcIixcblx0XCJOdGlsZGVcIjogXCLDkVwiLFxuXHRcIm50aWxkZVwiOiBcIsOxXCIsXG5cdFwibnRsZ1wiOiBcIuKJuFwiLFxuXHRcIm50cmlhbmdsZWxlZnRcIjogXCLii6pcIixcblx0XCJudHJpYW5nbGVsZWZ0ZXFcIjogXCLii6xcIixcblx0XCJudHJpYW5nbGVyaWdodFwiOiBcIuKLq1wiLFxuXHRcIm50cmlhbmdsZXJpZ2h0ZXFcIjogXCLii61cIixcblx0XCJOdVwiOiBcIs6dXCIsXG5cdFwibnVcIjogXCLOvVwiLFxuXHRcIm51bVwiOiBcIiNcIixcblx0XCJudW1lcm9cIjogXCLihJZcIixcblx0XCJudW1zcFwiOiBcIuKAh1wiLFxuXHRcIm52YXBcIjogXCLiiY3ig5JcIixcblx0XCJudmRhc2hcIjogXCLiiqxcIixcblx0XCJudkRhc2hcIjogXCLiiq1cIixcblx0XCJuVmRhc2hcIjogXCLiiq5cIixcblx0XCJuVkRhc2hcIjogXCLiiq9cIixcblx0XCJudmdlXCI6IFwi4oml4oOSXCIsXG5cdFwibnZndFwiOiBcIj7ig5JcIixcblx0XCJudkhhcnJcIjogXCLipIRcIixcblx0XCJudmluZmluXCI6IFwi4qeeXCIsXG5cdFwibnZsQXJyXCI6IFwi4qSCXCIsXG5cdFwibnZsZVwiOiBcIuKJpOKDklwiLFxuXHRcIm52bHRcIjogXCI84oOSXCIsXG5cdFwibnZsdHJpZVwiOiBcIuKKtOKDklwiLFxuXHRcIm52ckFyclwiOiBcIuKkg1wiLFxuXHRcIm52cnRyaWVcIjogXCLiirXig5JcIixcblx0XCJudnNpbVwiOiBcIuKIvOKDklwiLFxuXHRcIm53YXJoa1wiOiBcIuKko1wiLFxuXHRcIm53YXJyXCI6IFwi4oaWXCIsXG5cdFwibndBcnJcIjogXCLih5ZcIixcblx0XCJud2Fycm93XCI6IFwi4oaWXCIsXG5cdFwibnduZWFyXCI6IFwi4qSnXCIsXG5cdFwiT2FjdXRlXCI6IFwiw5NcIixcblx0XCJvYWN1dGVcIjogXCLDs1wiLFxuXHRcIm9hc3RcIjogXCLiiptcIixcblx0XCJPY2lyY1wiOiBcIsOUXCIsXG5cdFwib2NpcmNcIjogXCLDtFwiLFxuXHRcIm9jaXJcIjogXCLiippcIixcblx0XCJPY3lcIjogXCLQnlwiLFxuXHRcIm9jeVwiOiBcItC+XCIsXG5cdFwib2Rhc2hcIjogXCLiip1cIixcblx0XCJPZGJsYWNcIjogXCLFkFwiLFxuXHRcIm9kYmxhY1wiOiBcIsWRXCIsXG5cdFwib2RpdlwiOiBcIuKouFwiLFxuXHRcIm9kb3RcIjogXCLiiplcIixcblx0XCJvZHNvbGRcIjogXCLiprxcIixcblx0XCJPRWxpZ1wiOiBcIsWSXCIsXG5cdFwib2VsaWdcIjogXCLFk1wiLFxuXHRcIm9mY2lyXCI6IFwi4qa/XCIsXG5cdFwiT2ZyXCI6IFwi8J2UklwiLFxuXHRcIm9mclwiOiBcIvCdlKxcIixcblx0XCJvZ29uXCI6IFwiy5tcIixcblx0XCJPZ3JhdmVcIjogXCLDklwiLFxuXHRcIm9ncmF2ZVwiOiBcIsOyXCIsXG5cdFwib2d0XCI6IFwi4qeBXCIsXG5cdFwib2hiYXJcIjogXCLiprVcIixcblx0XCJvaG1cIjogXCLOqVwiLFxuXHRcIm9pbnRcIjogXCLiiK5cIixcblx0XCJvbGFyclwiOiBcIuKGulwiLFxuXHRcIm9sY2lyXCI6IFwi4qa+XCIsXG5cdFwib2xjcm9zc1wiOiBcIuKmu1wiLFxuXHRcIm9saW5lXCI6IFwi4oC+XCIsXG5cdFwib2x0XCI6IFwi4qeAXCIsXG5cdFwiT21hY3JcIjogXCLFjFwiLFxuXHRcIm9tYWNyXCI6IFwixY1cIixcblx0XCJPbWVnYVwiOiBcIs6pXCIsXG5cdFwib21lZ2FcIjogXCLPiVwiLFxuXHRcIk9taWNyb25cIjogXCLOn1wiLFxuXHRcIm9taWNyb25cIjogXCLOv1wiLFxuXHRcIm9taWRcIjogXCLiprZcIixcblx0XCJvbWludXNcIjogXCLiipZcIixcblx0XCJPb3BmXCI6IFwi8J2VhlwiLFxuXHRcIm9vcGZcIjogXCLwnZWgXCIsXG5cdFwib3BhclwiOiBcIuKmt1wiLFxuXHRcIk9wZW5DdXJseURvdWJsZVF1b3RlXCI6IFwi4oCcXCIsXG5cdFwiT3BlbkN1cmx5UXVvdGVcIjogXCLigJhcIixcblx0XCJvcGVycFwiOiBcIuKmuVwiLFxuXHRcIm9wbHVzXCI6IFwi4oqVXCIsXG5cdFwib3JhcnJcIjogXCLihrtcIixcblx0XCJPclwiOiBcIuKplFwiLFxuXHRcIm9yXCI6IFwi4oioXCIsXG5cdFwib3JkXCI6IFwi4qmdXCIsXG5cdFwib3JkZXJcIjogXCLihLRcIixcblx0XCJvcmRlcm9mXCI6IFwi4oS0XCIsXG5cdFwib3JkZlwiOiBcIsKqXCIsXG5cdFwib3JkbVwiOiBcIsK6XCIsXG5cdFwib3JpZ29mXCI6IFwi4oq2XCIsXG5cdFwib3JvclwiOiBcIuKpllwiLFxuXHRcIm9yc2xvcGVcIjogXCLiqZdcIixcblx0XCJvcnZcIjogXCLiqZtcIixcblx0XCJvU1wiOiBcIuKTiFwiLFxuXHRcIk9zY3JcIjogXCLwnZKqXCIsXG5cdFwib3NjclwiOiBcIuKEtFwiLFxuXHRcIk9zbGFzaFwiOiBcIsOYXCIsXG5cdFwib3NsYXNoXCI6IFwiw7hcIixcblx0XCJvc29sXCI6IFwi4oqYXCIsXG5cdFwiT3RpbGRlXCI6IFwiw5VcIixcblx0XCJvdGlsZGVcIjogXCLDtVwiLFxuXHRcIm90aW1lc2FzXCI6IFwi4qi2XCIsXG5cdFwiT3RpbWVzXCI6IFwi4qi3XCIsXG5cdFwib3RpbWVzXCI6IFwi4oqXXCIsXG5cdFwiT3VtbFwiOiBcIsOWXCIsXG5cdFwib3VtbFwiOiBcIsO2XCIsXG5cdFwib3ZiYXJcIjogXCLijL1cIixcblx0XCJPdmVyQmFyXCI6IFwi4oC+XCIsXG5cdFwiT3ZlckJyYWNlXCI6IFwi4o+eXCIsXG5cdFwiT3ZlckJyYWNrZXRcIjogXCLijrRcIixcblx0XCJPdmVyUGFyZW50aGVzaXNcIjogXCLij5xcIixcblx0XCJwYXJhXCI6IFwiwrZcIixcblx0XCJwYXJhbGxlbFwiOiBcIuKIpVwiLFxuXHRcInBhclwiOiBcIuKIpVwiLFxuXHRcInBhcnNpbVwiOiBcIuKrs1wiLFxuXHRcInBhcnNsXCI6IFwi4qu9XCIsXG5cdFwicGFydFwiOiBcIuKIglwiLFxuXHRcIlBhcnRpYWxEXCI6IFwi4oiCXCIsXG5cdFwiUGN5XCI6IFwi0J9cIixcblx0XCJwY3lcIjogXCLQv1wiLFxuXHRcInBlcmNudFwiOiBcIiVcIixcblx0XCJwZXJpb2RcIjogXCIuXCIsXG5cdFwicGVybWlsXCI6IFwi4oCwXCIsXG5cdFwicGVycFwiOiBcIuKKpVwiLFxuXHRcInBlcnRlbmtcIjogXCLigLFcIixcblx0XCJQZnJcIjogXCLwnZSTXCIsXG5cdFwicGZyXCI6IFwi8J2UrVwiLFxuXHRcIlBoaVwiOiBcIs6mXCIsXG5cdFwicGhpXCI6IFwiz4ZcIixcblx0XCJwaGl2XCI6IFwiz5VcIixcblx0XCJwaG1tYXRcIjogXCLihLNcIixcblx0XCJwaG9uZVwiOiBcIuKYjlwiLFxuXHRcIlBpXCI6IFwizqBcIixcblx0XCJwaVwiOiBcIs+AXCIsXG5cdFwicGl0Y2hmb3JrXCI6IFwi4ouUXCIsXG5cdFwicGl2XCI6IFwiz5ZcIixcblx0XCJwbGFuY2tcIjogXCLihI9cIixcblx0XCJwbGFuY2toXCI6IFwi4oSOXCIsXG5cdFwicGxhbmt2XCI6IFwi4oSPXCIsXG5cdFwicGx1c2FjaXJcIjogXCLiqKNcIixcblx0XCJwbHVzYlwiOiBcIuKKnlwiLFxuXHRcInBsdXNjaXJcIjogXCLiqKJcIixcblx0XCJwbHVzXCI6IFwiK1wiLFxuXHRcInBsdXNkb1wiOiBcIuKIlFwiLFxuXHRcInBsdXNkdVwiOiBcIuKopVwiLFxuXHRcInBsdXNlXCI6IFwi4qmyXCIsXG5cdFwiUGx1c01pbnVzXCI6IFwiwrFcIixcblx0XCJwbHVzbW5cIjogXCLCsVwiLFxuXHRcInBsdXNzaW1cIjogXCLiqKZcIixcblx0XCJwbHVzdHdvXCI6IFwi4qinXCIsXG5cdFwicG1cIjogXCLCsVwiLFxuXHRcIlBvaW5jYXJlcGxhbmVcIjogXCLihIxcIixcblx0XCJwb2ludGludFwiOiBcIuKolVwiLFxuXHRcInBvcGZcIjogXCLwnZWhXCIsXG5cdFwiUG9wZlwiOiBcIuKEmVwiLFxuXHRcInBvdW5kXCI6IFwiwqNcIixcblx0XCJwcmFwXCI6IFwi4qq3XCIsXG5cdFwiUHJcIjogXCLiqrtcIixcblx0XCJwclwiOiBcIuKJulwiLFxuXHRcInByY3VlXCI6IFwi4om8XCIsXG5cdFwicHJlY2FwcHJveFwiOiBcIuKqt1wiLFxuXHRcInByZWNcIjogXCLiibpcIixcblx0XCJwcmVjY3VybHllcVwiOiBcIuKJvFwiLFxuXHRcIlByZWNlZGVzXCI6IFwi4om6XCIsXG5cdFwiUHJlY2VkZXNFcXVhbFwiOiBcIuKqr1wiLFxuXHRcIlByZWNlZGVzU2xhbnRFcXVhbFwiOiBcIuKJvFwiLFxuXHRcIlByZWNlZGVzVGlsZGVcIjogXCLiib5cIixcblx0XCJwcmVjZXFcIjogXCLiqq9cIixcblx0XCJwcmVjbmFwcHJveFwiOiBcIuKquVwiLFxuXHRcInByZWNuZXFxXCI6IFwi4qq1XCIsXG5cdFwicHJlY25zaW1cIjogXCLii6hcIixcblx0XCJwcmVcIjogXCLiqq9cIixcblx0XCJwckVcIjogXCLiqrNcIixcblx0XCJwcmVjc2ltXCI6IFwi4om+XCIsXG5cdFwicHJpbWVcIjogXCLigLJcIixcblx0XCJQcmltZVwiOiBcIuKAs1wiLFxuXHRcInByaW1lc1wiOiBcIuKEmVwiLFxuXHRcInBybmFwXCI6IFwi4qq5XCIsXG5cdFwicHJuRVwiOiBcIuKqtVwiLFxuXHRcInBybnNpbVwiOiBcIuKLqFwiLFxuXHRcInByb2RcIjogXCLiiI9cIixcblx0XCJQcm9kdWN0XCI6IFwi4oiPXCIsXG5cdFwicHJvZmFsYXJcIjogXCLijK5cIixcblx0XCJwcm9mbGluZVwiOiBcIuKMklwiLFxuXHRcInByb2ZzdXJmXCI6IFwi4oyTXCIsXG5cdFwicHJvcFwiOiBcIuKInVwiLFxuXHRcIlByb3BvcnRpb25hbFwiOiBcIuKInVwiLFxuXHRcIlByb3BvcnRpb25cIjogXCLiiLdcIixcblx0XCJwcm9wdG9cIjogXCLiiJ1cIixcblx0XCJwcnNpbVwiOiBcIuKJvlwiLFxuXHRcInBydXJlbFwiOiBcIuKKsFwiLFxuXHRcIlBzY3JcIjogXCLwnZKrXCIsXG5cdFwicHNjclwiOiBcIvCdk4VcIixcblx0XCJQc2lcIjogXCLOqFwiLFxuXHRcInBzaVwiOiBcIs+IXCIsXG5cdFwicHVuY3NwXCI6IFwi4oCIXCIsXG5cdFwiUWZyXCI6IFwi8J2UlFwiLFxuXHRcInFmclwiOiBcIvCdlK5cIixcblx0XCJxaW50XCI6IFwi4qiMXCIsXG5cdFwicW9wZlwiOiBcIvCdlaJcIixcblx0XCJRb3BmXCI6IFwi4oSaXCIsXG5cdFwicXByaW1lXCI6IFwi4oGXXCIsXG5cdFwiUXNjclwiOiBcIvCdkqxcIixcblx0XCJxc2NyXCI6IFwi8J2ThlwiLFxuXHRcInF1YXRlcm5pb25zXCI6IFwi4oSNXCIsXG5cdFwicXVhdGludFwiOiBcIuKollwiLFxuXHRcInF1ZXN0XCI6IFwiP1wiLFxuXHRcInF1ZXN0ZXFcIjogXCLiiZ9cIixcblx0XCJxdW90XCI6IFwiXFxcIlwiLFxuXHRcIlFVT1RcIjogXCJcXFwiXCIsXG5cdFwickFhcnJcIjogXCLih5tcIixcblx0XCJyYWNlXCI6IFwi4oi9zLFcIixcblx0XCJSYWN1dGVcIjogXCLFlFwiLFxuXHRcInJhY3V0ZVwiOiBcIsWVXCIsXG5cdFwicmFkaWNcIjogXCLiiJpcIixcblx0XCJyYWVtcHR5dlwiOiBcIuKms1wiLFxuXHRcInJhbmdcIjogXCLin6lcIixcblx0XCJSYW5nXCI6IFwi4p+rXCIsXG5cdFwicmFuZ2RcIjogXCLippJcIixcblx0XCJyYW5nZVwiOiBcIuKmpVwiLFxuXHRcInJhbmdsZVwiOiBcIuKfqVwiLFxuXHRcInJhcXVvXCI6IFwiwrtcIixcblx0XCJyYXJyYXBcIjogXCLipbVcIixcblx0XCJyYXJyYlwiOiBcIuKHpVwiLFxuXHRcInJhcnJiZnNcIjogXCLipKBcIixcblx0XCJyYXJyY1wiOiBcIuKks1wiLFxuXHRcInJhcnJcIjogXCLihpJcIixcblx0XCJSYXJyXCI6IFwi4oagXCIsXG5cdFwickFyclwiOiBcIuKHklwiLFxuXHRcInJhcnJmc1wiOiBcIuKknlwiLFxuXHRcInJhcnJoa1wiOiBcIuKGqlwiLFxuXHRcInJhcnJscFwiOiBcIuKGrFwiLFxuXHRcInJhcnJwbFwiOiBcIuKlhVwiLFxuXHRcInJhcnJzaW1cIjogXCLipbRcIixcblx0XCJSYXJydGxcIjogXCLipJZcIixcblx0XCJyYXJydGxcIjogXCLihqNcIixcblx0XCJyYXJyd1wiOiBcIuKGnVwiLFxuXHRcInJhdGFpbFwiOiBcIuKkmlwiLFxuXHRcInJBdGFpbFwiOiBcIuKknFwiLFxuXHRcInJhdGlvXCI6IFwi4oi2XCIsXG5cdFwicmF0aW9uYWxzXCI6IFwi4oSaXCIsXG5cdFwicmJhcnJcIjogXCLipI1cIixcblx0XCJyQmFyclwiOiBcIuKkj1wiLFxuXHRcIlJCYXJyXCI6IFwi4qSQXCIsXG5cdFwicmJicmtcIjogXCLinbNcIixcblx0XCJyYnJhY2VcIjogXCJ9XCIsXG5cdFwicmJyYWNrXCI6IFwiXVwiLFxuXHRcInJicmtlXCI6IFwi4qaMXCIsXG5cdFwicmJya3NsZFwiOiBcIuKmjlwiLFxuXHRcInJicmtzbHVcIjogXCLippBcIixcblx0XCJSY2Fyb25cIjogXCLFmFwiLFxuXHRcInJjYXJvblwiOiBcIsWZXCIsXG5cdFwiUmNlZGlsXCI6IFwixZZcIixcblx0XCJyY2VkaWxcIjogXCLFl1wiLFxuXHRcInJjZWlsXCI6IFwi4oyJXCIsXG5cdFwicmN1YlwiOiBcIn1cIixcblx0XCJSY3lcIjogXCLQoFwiLFxuXHRcInJjeVwiOiBcItGAXCIsXG5cdFwicmRjYVwiOiBcIuKkt1wiLFxuXHRcInJkbGRoYXJcIjogXCLipalcIixcblx0XCJyZHF1b1wiOiBcIuKAnVwiLFxuXHRcInJkcXVvclwiOiBcIuKAnVwiLFxuXHRcInJkc2hcIjogXCLihrNcIixcblx0XCJyZWFsXCI6IFwi4oScXCIsXG5cdFwicmVhbGluZVwiOiBcIuKEm1wiLFxuXHRcInJlYWxwYXJ0XCI6IFwi4oScXCIsXG5cdFwicmVhbHNcIjogXCLihJ1cIixcblx0XCJSZVwiOiBcIuKEnFwiLFxuXHRcInJlY3RcIjogXCLilq1cIixcblx0XCJyZWdcIjogXCLCrlwiLFxuXHRcIlJFR1wiOiBcIsKuXCIsXG5cdFwiUmV2ZXJzZUVsZW1lbnRcIjogXCLiiItcIixcblx0XCJSZXZlcnNlRXF1aWxpYnJpdW1cIjogXCLih4tcIixcblx0XCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOiBcIuKlr1wiLFxuXHRcInJmaXNodFwiOiBcIuKlvVwiLFxuXHRcInJmbG9vclwiOiBcIuKMi1wiLFxuXHRcInJmclwiOiBcIvCdlK9cIixcblx0XCJSZnJcIjogXCLihJxcIixcblx0XCJySGFyXCI6IFwi4qWkXCIsXG5cdFwicmhhcmRcIjogXCLih4FcIixcblx0XCJyaGFydVwiOiBcIuKHgFwiLFxuXHRcInJoYXJ1bFwiOiBcIuKlrFwiLFxuXHRcIlJob1wiOiBcIs6hXCIsXG5cdFwicmhvXCI6IFwiz4FcIixcblx0XCJyaG92XCI6IFwiz7FcIixcblx0XCJSaWdodEFuZ2xlQnJhY2tldFwiOiBcIuKfqVwiLFxuXHRcIlJpZ2h0QXJyb3dCYXJcIjogXCLih6VcIixcblx0XCJyaWdodGFycm93XCI6IFwi4oaSXCIsXG5cdFwiUmlnaHRBcnJvd1wiOiBcIuKGklwiLFxuXHRcIlJpZ2h0YXJyb3dcIjogXCLih5JcIixcblx0XCJSaWdodEFycm93TGVmdEFycm93XCI6IFwi4oeEXCIsXG5cdFwicmlnaHRhcnJvd3RhaWxcIjogXCLihqNcIixcblx0XCJSaWdodENlaWxpbmdcIjogXCLijIlcIixcblx0XCJSaWdodERvdWJsZUJyYWNrZXRcIjogXCLin6dcIixcblx0XCJSaWdodERvd25UZWVWZWN0b3JcIjogXCLipZ1cIixcblx0XCJSaWdodERvd25WZWN0b3JCYXJcIjogXCLipZVcIixcblx0XCJSaWdodERvd25WZWN0b3JcIjogXCLih4JcIixcblx0XCJSaWdodEZsb29yXCI6IFwi4oyLXCIsXG5cdFwicmlnaHRoYXJwb29uZG93blwiOiBcIuKHgVwiLFxuXHRcInJpZ2h0aGFycG9vbnVwXCI6IFwi4oeAXCIsXG5cdFwicmlnaHRsZWZ0YXJyb3dzXCI6IFwi4oeEXCIsXG5cdFwicmlnaHRsZWZ0aGFycG9vbnNcIjogXCLih4xcIixcblx0XCJyaWdodHJpZ2h0YXJyb3dzXCI6IFwi4oeJXCIsXG5cdFwicmlnaHRzcXVpZ2Fycm93XCI6IFwi4oadXCIsXG5cdFwiUmlnaHRUZWVBcnJvd1wiOiBcIuKGplwiLFxuXHRcIlJpZ2h0VGVlXCI6IFwi4oqiXCIsXG5cdFwiUmlnaHRUZWVWZWN0b3JcIjogXCLipZtcIixcblx0XCJyaWdodHRocmVldGltZXNcIjogXCLii4xcIixcblx0XCJSaWdodFRyaWFuZ2xlQmFyXCI6IFwi4qeQXCIsXG5cdFwiUmlnaHRUcmlhbmdsZVwiOiBcIuKKs1wiLFxuXHRcIlJpZ2h0VHJpYW5nbGVFcXVhbFwiOiBcIuKKtVwiLFxuXHRcIlJpZ2h0VXBEb3duVmVjdG9yXCI6IFwi4qWPXCIsXG5cdFwiUmlnaHRVcFRlZVZlY3RvclwiOiBcIuKlnFwiLFxuXHRcIlJpZ2h0VXBWZWN0b3JCYXJcIjogXCLipZRcIixcblx0XCJSaWdodFVwVmVjdG9yXCI6IFwi4oa+XCIsXG5cdFwiUmlnaHRWZWN0b3JCYXJcIjogXCLipZNcIixcblx0XCJSaWdodFZlY3RvclwiOiBcIuKHgFwiLFxuXHRcInJpbmdcIjogXCLLmlwiLFxuXHRcInJpc2luZ2RvdHNlcVwiOiBcIuKJk1wiLFxuXHRcInJsYXJyXCI6IFwi4oeEXCIsXG5cdFwicmxoYXJcIjogXCLih4xcIixcblx0XCJybG1cIjogXCLigI9cIixcblx0XCJybW91c3RhY2hlXCI6IFwi4o6xXCIsXG5cdFwicm1vdXN0XCI6IFwi4o6xXCIsXG5cdFwicm5taWRcIjogXCLiq65cIixcblx0XCJyb2FuZ1wiOiBcIuKfrVwiLFxuXHRcInJvYXJyXCI6IFwi4oe+XCIsXG5cdFwicm9icmtcIjogXCLin6dcIixcblx0XCJyb3BhclwiOiBcIuKmhlwiLFxuXHRcInJvcGZcIjogXCLwnZWjXCIsXG5cdFwiUm9wZlwiOiBcIuKEnVwiLFxuXHRcInJvcGx1c1wiOiBcIuKorlwiLFxuXHRcInJvdGltZXNcIjogXCLiqLVcIixcblx0XCJSb3VuZEltcGxpZXNcIjogXCLipbBcIixcblx0XCJycGFyXCI6IFwiKVwiLFxuXHRcInJwYXJndFwiOiBcIuKmlFwiLFxuXHRcInJwcG9saW50XCI6IFwi4qiSXCIsXG5cdFwicnJhcnJcIjogXCLih4lcIixcblx0XCJScmlnaHRhcnJvd1wiOiBcIuKHm1wiLFxuXHRcInJzYXF1b1wiOiBcIuKAulwiLFxuXHRcInJzY3JcIjogXCLwnZOHXCIsXG5cdFwiUnNjclwiOiBcIuKEm1wiLFxuXHRcInJzaFwiOiBcIuKGsVwiLFxuXHRcIlJzaFwiOiBcIuKGsVwiLFxuXHRcInJzcWJcIjogXCJdXCIsXG5cdFwicnNxdW9cIjogXCLigJlcIixcblx0XCJyc3F1b3JcIjogXCLigJlcIixcblx0XCJydGhyZWVcIjogXCLii4xcIixcblx0XCJydGltZXNcIjogXCLii4pcIixcblx0XCJydHJpXCI6IFwi4pa5XCIsXG5cdFwicnRyaWVcIjogXCLiirVcIixcblx0XCJydHJpZlwiOiBcIuKWuFwiLFxuXHRcInJ0cmlsdHJpXCI6IFwi4qeOXCIsXG5cdFwiUnVsZURlbGF5ZWRcIjogXCLip7RcIixcblx0XCJydWx1aGFyXCI6IFwi4qWoXCIsXG5cdFwicnhcIjogXCLihJ5cIixcblx0XCJTYWN1dGVcIjogXCLFmlwiLFxuXHRcInNhY3V0ZVwiOiBcIsWbXCIsXG5cdFwic2JxdW9cIjogXCLigJpcIixcblx0XCJzY2FwXCI6IFwi4qq4XCIsXG5cdFwiU2Nhcm9uXCI6IFwixaBcIixcblx0XCJzY2Fyb25cIjogXCLFoVwiLFxuXHRcIlNjXCI6IFwi4qq8XCIsXG5cdFwic2NcIjogXCLiibtcIixcblx0XCJzY2N1ZVwiOiBcIuKJvVwiLFxuXHRcInNjZVwiOiBcIuKqsFwiLFxuXHRcInNjRVwiOiBcIuKqtFwiLFxuXHRcIlNjZWRpbFwiOiBcIsWeXCIsXG5cdFwic2NlZGlsXCI6IFwixZ9cIixcblx0XCJTY2lyY1wiOiBcIsWcXCIsXG5cdFwic2NpcmNcIjogXCLFnVwiLFxuXHRcInNjbmFwXCI6IFwi4qq6XCIsXG5cdFwic2NuRVwiOiBcIuKqtlwiLFxuXHRcInNjbnNpbVwiOiBcIuKLqVwiLFxuXHRcInNjcG9saW50XCI6IFwi4qiTXCIsXG5cdFwic2NzaW1cIjogXCLiib9cIixcblx0XCJTY3lcIjogXCLQoVwiLFxuXHRcInNjeVwiOiBcItGBXCIsXG5cdFwic2RvdGJcIjogXCLiiqFcIixcblx0XCJzZG90XCI6IFwi4ouFXCIsXG5cdFwic2RvdGVcIjogXCLiqaZcIixcblx0XCJzZWFyaGtcIjogXCLipKVcIixcblx0XCJzZWFyclwiOiBcIuKGmFwiLFxuXHRcInNlQXJyXCI6IFwi4oeYXCIsXG5cdFwic2VhcnJvd1wiOiBcIuKGmFwiLFxuXHRcInNlY3RcIjogXCLCp1wiLFxuXHRcInNlbWlcIjogXCI7XCIsXG5cdFwic2Vzd2FyXCI6IFwi4qSpXCIsXG5cdFwic2V0bWludXNcIjogXCLiiJZcIixcblx0XCJzZXRtblwiOiBcIuKIllwiLFxuXHRcInNleHRcIjogXCLinLZcIixcblx0XCJTZnJcIjogXCLwnZSWXCIsXG5cdFwic2ZyXCI6IFwi8J2UsFwiLFxuXHRcInNmcm93blwiOiBcIuKMolwiLFxuXHRcInNoYXJwXCI6IFwi4pmvXCIsXG5cdFwiU0hDSGN5XCI6IFwi0KlcIixcblx0XCJzaGNoY3lcIjogXCLRiVwiLFxuXHRcIlNIY3lcIjogXCLQqFwiLFxuXHRcInNoY3lcIjogXCLRiFwiLFxuXHRcIlNob3J0RG93bkFycm93XCI6IFwi4oaTXCIsXG5cdFwiU2hvcnRMZWZ0QXJyb3dcIjogXCLihpBcIixcblx0XCJzaG9ydG1pZFwiOiBcIuKIo1wiLFxuXHRcInNob3J0cGFyYWxsZWxcIjogXCLiiKVcIixcblx0XCJTaG9ydFJpZ2h0QXJyb3dcIjogXCLihpJcIixcblx0XCJTaG9ydFVwQXJyb3dcIjogXCLihpFcIixcblx0XCJzaHlcIjogXCLCrVwiLFxuXHRcIlNpZ21hXCI6IFwizqNcIixcblx0XCJzaWdtYVwiOiBcIs+DXCIsXG5cdFwic2lnbWFmXCI6IFwiz4JcIixcblx0XCJzaWdtYXZcIjogXCLPglwiLFxuXHRcInNpbVwiOiBcIuKIvFwiLFxuXHRcInNpbWRvdFwiOiBcIuKpqlwiLFxuXHRcInNpbWVcIjogXCLiiYNcIixcblx0XCJzaW1lcVwiOiBcIuKJg1wiLFxuXHRcInNpbWdcIjogXCLiqp5cIixcblx0XCJzaW1nRVwiOiBcIuKqoFwiLFxuXHRcInNpbWxcIjogXCLiqp1cIixcblx0XCJzaW1sRVwiOiBcIuKqn1wiLFxuXHRcInNpbW5lXCI6IFwi4omGXCIsXG5cdFwic2ltcGx1c1wiOiBcIuKopFwiLFxuXHRcInNpbXJhcnJcIjogXCLipbJcIixcblx0XCJzbGFyclwiOiBcIuKGkFwiLFxuXHRcIlNtYWxsQ2lyY2xlXCI6IFwi4oiYXCIsXG5cdFwic21hbGxzZXRtaW51c1wiOiBcIuKIllwiLFxuXHRcInNtYXNocFwiOiBcIuKos1wiLFxuXHRcInNtZXBhcnNsXCI6IFwi4qekXCIsXG5cdFwic21pZFwiOiBcIuKIo1wiLFxuXHRcInNtaWxlXCI6IFwi4oyjXCIsXG5cdFwic210XCI6IFwi4qqqXCIsXG5cdFwic210ZVwiOiBcIuKqrFwiLFxuXHRcInNtdGVzXCI6IFwi4qqs77iAXCIsXG5cdFwiU09GVGN5XCI6IFwi0KxcIixcblx0XCJzb2Z0Y3lcIjogXCLRjFwiLFxuXHRcInNvbGJhclwiOiBcIuKMv1wiLFxuXHRcInNvbGJcIjogXCLip4RcIixcblx0XCJzb2xcIjogXCIvXCIsXG5cdFwiU29wZlwiOiBcIvCdlYpcIixcblx0XCJzb3BmXCI6IFwi8J2VpFwiLFxuXHRcInNwYWRlc1wiOiBcIuKZoFwiLFxuXHRcInNwYWRlc3VpdFwiOiBcIuKZoFwiLFxuXHRcInNwYXJcIjogXCLiiKVcIixcblx0XCJzcWNhcFwiOiBcIuKKk1wiLFxuXHRcInNxY2Fwc1wiOiBcIuKKk++4gFwiLFxuXHRcInNxY3VwXCI6IFwi4oqUXCIsXG5cdFwic3FjdXBzXCI6IFwi4oqU77iAXCIsXG5cdFwiU3FydFwiOiBcIuKImlwiLFxuXHRcInNxc3ViXCI6IFwi4oqPXCIsXG5cdFwic3FzdWJlXCI6IFwi4oqRXCIsXG5cdFwic3FzdWJzZXRcIjogXCLiio9cIixcblx0XCJzcXN1YnNldGVxXCI6IFwi4oqRXCIsXG5cdFwic3FzdXBcIjogXCLiipBcIixcblx0XCJzcXN1cGVcIjogXCLiipJcIixcblx0XCJzcXN1cHNldFwiOiBcIuKKkFwiLFxuXHRcInNxc3Vwc2V0ZXFcIjogXCLiipJcIixcblx0XCJzcXVhcmVcIjogXCLilqFcIixcblx0XCJTcXVhcmVcIjogXCLilqFcIixcblx0XCJTcXVhcmVJbnRlcnNlY3Rpb25cIjogXCLiipNcIixcblx0XCJTcXVhcmVTdWJzZXRcIjogXCLiio9cIixcblx0XCJTcXVhcmVTdWJzZXRFcXVhbFwiOiBcIuKKkVwiLFxuXHRcIlNxdWFyZVN1cGVyc2V0XCI6IFwi4oqQXCIsXG5cdFwiU3F1YXJlU3VwZXJzZXRFcXVhbFwiOiBcIuKKklwiLFxuXHRcIlNxdWFyZVVuaW9uXCI6IFwi4oqUXCIsXG5cdFwic3F1YXJmXCI6IFwi4paqXCIsXG5cdFwic3F1XCI6IFwi4pahXCIsXG5cdFwic3F1ZlwiOiBcIuKWqlwiLFxuXHRcInNyYXJyXCI6IFwi4oaSXCIsXG5cdFwiU3NjclwiOiBcIvCdkq5cIixcblx0XCJzc2NyXCI6IFwi8J2TiFwiLFxuXHRcInNzZXRtblwiOiBcIuKIllwiLFxuXHRcInNzbWlsZVwiOiBcIuKMo1wiLFxuXHRcInNzdGFyZlwiOiBcIuKLhlwiLFxuXHRcIlN0YXJcIjogXCLii4ZcIixcblx0XCJzdGFyXCI6IFwi4piGXCIsXG5cdFwic3RhcmZcIjogXCLimIVcIixcblx0XCJzdHJhaWdodGVwc2lsb25cIjogXCLPtVwiLFxuXHRcInN0cmFpZ2h0cGhpXCI6IFwiz5VcIixcblx0XCJzdHJuc1wiOiBcIsKvXCIsXG5cdFwic3ViXCI6IFwi4oqCXCIsXG5cdFwiU3ViXCI6IFwi4ouQXCIsXG5cdFwic3ViZG90XCI6IFwi4qq9XCIsXG5cdFwic3ViRVwiOiBcIuKrhVwiLFxuXHRcInN1YmVcIjogXCLiioZcIixcblx0XCJzdWJlZG90XCI6IFwi4quDXCIsXG5cdFwic3VibXVsdFwiOiBcIuKrgVwiLFxuXHRcInN1Ym5FXCI6IFwi4quLXCIsXG5cdFwic3VibmVcIjogXCLiiopcIixcblx0XCJzdWJwbHVzXCI6IFwi4qq/XCIsXG5cdFwic3VicmFyclwiOiBcIuKluVwiLFxuXHRcInN1YnNldFwiOiBcIuKKglwiLFxuXHRcIlN1YnNldFwiOiBcIuKLkFwiLFxuXHRcInN1YnNldGVxXCI6IFwi4oqGXCIsXG5cdFwic3Vic2V0ZXFxXCI6IFwi4quFXCIsXG5cdFwiU3Vic2V0RXF1YWxcIjogXCLiioZcIixcblx0XCJzdWJzZXRuZXFcIjogXCLiiopcIixcblx0XCJzdWJzZXRuZXFxXCI6IFwi4quLXCIsXG5cdFwic3Vic2ltXCI6IFwi4quHXCIsXG5cdFwic3Vic3ViXCI6IFwi4quVXCIsXG5cdFwic3Vic3VwXCI6IFwi4quTXCIsXG5cdFwic3VjY2FwcHJveFwiOiBcIuKquFwiLFxuXHRcInN1Y2NcIjogXCLiibtcIixcblx0XCJzdWNjY3VybHllcVwiOiBcIuKJvVwiLFxuXHRcIlN1Y2NlZWRzXCI6IFwi4om7XCIsXG5cdFwiU3VjY2VlZHNFcXVhbFwiOiBcIuKqsFwiLFxuXHRcIlN1Y2NlZWRzU2xhbnRFcXVhbFwiOiBcIuKJvVwiLFxuXHRcIlN1Y2NlZWRzVGlsZGVcIjogXCLiib9cIixcblx0XCJzdWNjZXFcIjogXCLiqrBcIixcblx0XCJzdWNjbmFwcHJveFwiOiBcIuKqulwiLFxuXHRcInN1Y2NuZXFxXCI6IFwi4qq2XCIsXG5cdFwic3VjY25zaW1cIjogXCLii6lcIixcblx0XCJzdWNjc2ltXCI6IFwi4om/XCIsXG5cdFwiU3VjaFRoYXRcIjogXCLiiItcIixcblx0XCJzdW1cIjogXCLiiJFcIixcblx0XCJTdW1cIjogXCLiiJFcIixcblx0XCJzdW5nXCI6IFwi4pmqXCIsXG5cdFwic3VwMVwiOiBcIsK5XCIsXG5cdFwic3VwMlwiOiBcIsKyXCIsXG5cdFwic3VwM1wiOiBcIsKzXCIsXG5cdFwic3VwXCI6IFwi4oqDXCIsXG5cdFwiU3VwXCI6IFwi4ouRXCIsXG5cdFwic3VwZG90XCI6IFwi4qq+XCIsXG5cdFwic3VwZHN1YlwiOiBcIuKrmFwiLFxuXHRcInN1cEVcIjogXCLiq4ZcIixcblx0XCJzdXBlXCI6IFwi4oqHXCIsXG5cdFwic3VwZWRvdFwiOiBcIuKrhFwiLFxuXHRcIlN1cGVyc2V0XCI6IFwi4oqDXCIsXG5cdFwiU3VwZXJzZXRFcXVhbFwiOiBcIuKKh1wiLFxuXHRcInN1cGhzb2xcIjogXCLin4lcIixcblx0XCJzdXBoc3ViXCI6IFwi4quXXCIsXG5cdFwic3VwbGFyclwiOiBcIuKlu1wiLFxuXHRcInN1cG11bHRcIjogXCLiq4JcIixcblx0XCJzdXBuRVwiOiBcIuKrjFwiLFxuXHRcInN1cG5lXCI6IFwi4oqLXCIsXG5cdFwic3VwcGx1c1wiOiBcIuKrgFwiLFxuXHRcInN1cHNldFwiOiBcIuKKg1wiLFxuXHRcIlN1cHNldFwiOiBcIuKLkVwiLFxuXHRcInN1cHNldGVxXCI6IFwi4oqHXCIsXG5cdFwic3Vwc2V0ZXFxXCI6IFwi4quGXCIsXG5cdFwic3Vwc2V0bmVxXCI6IFwi4oqLXCIsXG5cdFwic3Vwc2V0bmVxcVwiOiBcIuKrjFwiLFxuXHRcInN1cHNpbVwiOiBcIuKriFwiLFxuXHRcInN1cHN1YlwiOiBcIuKrlFwiLFxuXHRcInN1cHN1cFwiOiBcIuKrllwiLFxuXHRcInN3YXJoa1wiOiBcIuKkplwiLFxuXHRcInN3YXJyXCI6IFwi4oaZXCIsXG5cdFwic3dBcnJcIjogXCLih5lcIixcblx0XCJzd2Fycm93XCI6IFwi4oaZXCIsXG5cdFwic3dud2FyXCI6IFwi4qSqXCIsXG5cdFwic3psaWdcIjogXCLDn1wiLFxuXHRcIlRhYlwiOiBcIlxcdFwiLFxuXHRcInRhcmdldFwiOiBcIuKMllwiLFxuXHRcIlRhdVwiOiBcIs6kXCIsXG5cdFwidGF1XCI6IFwiz4RcIixcblx0XCJ0YnJrXCI6IFwi4o60XCIsXG5cdFwiVGNhcm9uXCI6IFwixaRcIixcblx0XCJ0Y2Fyb25cIjogXCLFpVwiLFxuXHRcIlRjZWRpbFwiOiBcIsWiXCIsXG5cdFwidGNlZGlsXCI6IFwixaNcIixcblx0XCJUY3lcIjogXCLQolwiLFxuXHRcInRjeVwiOiBcItGCXCIsXG5cdFwidGRvdFwiOiBcIuKDm1wiLFxuXHRcInRlbHJlY1wiOiBcIuKMlVwiLFxuXHRcIlRmclwiOiBcIvCdlJdcIixcblx0XCJ0ZnJcIjogXCLwnZSxXCIsXG5cdFwidGhlcmU0XCI6IFwi4oi0XCIsXG5cdFwidGhlcmVmb3JlXCI6IFwi4oi0XCIsXG5cdFwiVGhlcmVmb3JlXCI6IFwi4oi0XCIsXG5cdFwiVGhldGFcIjogXCLOmFwiLFxuXHRcInRoZXRhXCI6IFwizrhcIixcblx0XCJ0aGV0YXN5bVwiOiBcIs+RXCIsXG5cdFwidGhldGF2XCI6IFwiz5FcIixcblx0XCJ0aGlja2FwcHJveFwiOiBcIuKJiFwiLFxuXHRcInRoaWNrc2ltXCI6IFwi4oi8XCIsXG5cdFwiVGhpY2tTcGFjZVwiOiBcIuKBn+KAilwiLFxuXHRcIlRoaW5TcGFjZVwiOiBcIuKAiVwiLFxuXHRcInRoaW5zcFwiOiBcIuKAiVwiLFxuXHRcInRoa2FwXCI6IFwi4omIXCIsXG5cdFwidGhrc2ltXCI6IFwi4oi8XCIsXG5cdFwiVEhPUk5cIjogXCLDnlwiLFxuXHRcInRob3JuXCI6IFwiw75cIixcblx0XCJ0aWxkZVwiOiBcIsucXCIsXG5cdFwiVGlsZGVcIjogXCLiiLxcIixcblx0XCJUaWxkZUVxdWFsXCI6IFwi4omDXCIsXG5cdFwiVGlsZGVGdWxsRXF1YWxcIjogXCLiiYVcIixcblx0XCJUaWxkZVRpbGRlXCI6IFwi4omIXCIsXG5cdFwidGltZXNiYXJcIjogXCLiqLFcIixcblx0XCJ0aW1lc2JcIjogXCLiiqBcIixcblx0XCJ0aW1lc1wiOiBcIsOXXCIsXG5cdFwidGltZXNkXCI6IFwi4qiwXCIsXG5cdFwidGludFwiOiBcIuKIrVwiLFxuXHRcInRvZWFcIjogXCLipKhcIixcblx0XCJ0b3Bib3RcIjogXCLijLZcIixcblx0XCJ0b3BjaXJcIjogXCLiq7FcIixcblx0XCJ0b3BcIjogXCLiiqRcIixcblx0XCJUb3BmXCI6IFwi8J2Vi1wiLFxuXHRcInRvcGZcIjogXCLwnZWlXCIsXG5cdFwidG9wZm9ya1wiOiBcIuKrmlwiLFxuXHRcInRvc2FcIjogXCLipKlcIixcblx0XCJ0cHJpbWVcIjogXCLigLRcIixcblx0XCJ0cmFkZVwiOiBcIuKEolwiLFxuXHRcIlRSQURFXCI6IFwi4oSiXCIsXG5cdFwidHJpYW5nbGVcIjogXCLilrVcIixcblx0XCJ0cmlhbmdsZWRvd25cIjogXCLilr9cIixcblx0XCJ0cmlhbmdsZWxlZnRcIjogXCLil4NcIixcblx0XCJ0cmlhbmdsZWxlZnRlcVwiOiBcIuKKtFwiLFxuXHRcInRyaWFuZ2xlcVwiOiBcIuKJnFwiLFxuXHRcInRyaWFuZ2xlcmlnaHRcIjogXCLilrlcIixcblx0XCJ0cmlhbmdsZXJpZ2h0ZXFcIjogXCLiirVcIixcblx0XCJ0cmlkb3RcIjogXCLil6xcIixcblx0XCJ0cmllXCI6IFwi4omcXCIsXG5cdFwidHJpbWludXNcIjogXCLiqLpcIixcblx0XCJUcmlwbGVEb3RcIjogXCLig5tcIixcblx0XCJ0cmlwbHVzXCI6IFwi4qi5XCIsXG5cdFwidHJpc2JcIjogXCLip41cIixcblx0XCJ0cml0aW1lXCI6IFwi4qi7XCIsXG5cdFwidHJwZXppdW1cIjogXCLij6JcIixcblx0XCJUc2NyXCI6IFwi8J2Sr1wiLFxuXHRcInRzY3JcIjogXCLwnZOJXCIsXG5cdFwiVFNjeVwiOiBcItCmXCIsXG5cdFwidHNjeVwiOiBcItGGXCIsXG5cdFwiVFNIY3lcIjogXCLQi1wiLFxuXHRcInRzaGN5XCI6IFwi0ZtcIixcblx0XCJUc3Ryb2tcIjogXCLFplwiLFxuXHRcInRzdHJva1wiOiBcIsWnXCIsXG5cdFwidHdpeHRcIjogXCLiiaxcIixcblx0XCJ0d29oZWFkbGVmdGFycm93XCI6IFwi4oaeXCIsXG5cdFwidHdvaGVhZHJpZ2h0YXJyb3dcIjogXCLihqBcIixcblx0XCJVYWN1dGVcIjogXCLDmlwiLFxuXHRcInVhY3V0ZVwiOiBcIsO6XCIsXG5cdFwidWFyclwiOiBcIuKGkVwiLFxuXHRcIlVhcnJcIjogXCLihp9cIixcblx0XCJ1QXJyXCI6IFwi4oeRXCIsXG5cdFwiVWFycm9jaXJcIjogXCLipYlcIixcblx0XCJVYnJjeVwiOiBcItCOXCIsXG5cdFwidWJyY3lcIjogXCLRnlwiLFxuXHRcIlVicmV2ZVwiOiBcIsWsXCIsXG5cdFwidWJyZXZlXCI6IFwixa1cIixcblx0XCJVY2lyY1wiOiBcIsObXCIsXG5cdFwidWNpcmNcIjogXCLDu1wiLFxuXHRcIlVjeVwiOiBcItCjXCIsXG5cdFwidWN5XCI6IFwi0YNcIixcblx0XCJ1ZGFyclwiOiBcIuKHhVwiLFxuXHRcIlVkYmxhY1wiOiBcIsWwXCIsXG5cdFwidWRibGFjXCI6IFwixbFcIixcblx0XCJ1ZGhhclwiOiBcIuKlrlwiLFxuXHRcInVmaXNodFwiOiBcIuKlvlwiLFxuXHRcIlVmclwiOiBcIvCdlJhcIixcblx0XCJ1ZnJcIjogXCLwnZSyXCIsXG5cdFwiVWdyYXZlXCI6IFwiw5lcIixcblx0XCJ1Z3JhdmVcIjogXCLDuVwiLFxuXHRcInVIYXJcIjogXCLipaNcIixcblx0XCJ1aGFybFwiOiBcIuKGv1wiLFxuXHRcInVoYXJyXCI6IFwi4oa+XCIsXG5cdFwidWhibGtcIjogXCLiloBcIixcblx0XCJ1bGNvcm5cIjogXCLijJxcIixcblx0XCJ1bGNvcm5lclwiOiBcIuKMnFwiLFxuXHRcInVsY3JvcFwiOiBcIuKMj1wiLFxuXHRcInVsdHJpXCI6IFwi4pe4XCIsXG5cdFwiVW1hY3JcIjogXCLFqlwiLFxuXHRcInVtYWNyXCI6IFwixatcIixcblx0XCJ1bWxcIjogXCLCqFwiLFxuXHRcIlVuZGVyQmFyXCI6IFwiX1wiLFxuXHRcIlVuZGVyQnJhY2VcIjogXCLij59cIixcblx0XCJVbmRlckJyYWNrZXRcIjogXCLijrVcIixcblx0XCJVbmRlclBhcmVudGhlc2lzXCI6IFwi4o+dXCIsXG5cdFwiVW5pb25cIjogXCLii4NcIixcblx0XCJVbmlvblBsdXNcIjogXCLiio5cIixcblx0XCJVb2dvblwiOiBcIsWyXCIsXG5cdFwidW9nb25cIjogXCLFs1wiLFxuXHRcIlVvcGZcIjogXCLwnZWMXCIsXG5cdFwidW9wZlwiOiBcIvCdlaZcIixcblx0XCJVcEFycm93QmFyXCI6IFwi4qSSXCIsXG5cdFwidXBhcnJvd1wiOiBcIuKGkVwiLFxuXHRcIlVwQXJyb3dcIjogXCLihpFcIixcblx0XCJVcGFycm93XCI6IFwi4oeRXCIsXG5cdFwiVXBBcnJvd0Rvd25BcnJvd1wiOiBcIuKHhVwiLFxuXHRcInVwZG93bmFycm93XCI6IFwi4oaVXCIsXG5cdFwiVXBEb3duQXJyb3dcIjogXCLihpVcIixcblx0XCJVcGRvd25hcnJvd1wiOiBcIuKHlVwiLFxuXHRcIlVwRXF1aWxpYnJpdW1cIjogXCLipa5cIixcblx0XCJ1cGhhcnBvb25sZWZ0XCI6IFwi4oa/XCIsXG5cdFwidXBoYXJwb29ucmlnaHRcIjogXCLihr5cIixcblx0XCJ1cGx1c1wiOiBcIuKKjlwiLFxuXHRcIlVwcGVyTGVmdEFycm93XCI6IFwi4oaWXCIsXG5cdFwiVXBwZXJSaWdodEFycm93XCI6IFwi4oaXXCIsXG5cdFwidXBzaVwiOiBcIs+FXCIsXG5cdFwiVXBzaVwiOiBcIs+SXCIsXG5cdFwidXBzaWhcIjogXCLPklwiLFxuXHRcIlVwc2lsb25cIjogXCLOpVwiLFxuXHRcInVwc2lsb25cIjogXCLPhVwiLFxuXHRcIlVwVGVlQXJyb3dcIjogXCLihqVcIixcblx0XCJVcFRlZVwiOiBcIuKKpVwiLFxuXHRcInVwdXBhcnJvd3NcIjogXCLih4hcIixcblx0XCJ1cmNvcm5cIjogXCLijJ1cIixcblx0XCJ1cmNvcm5lclwiOiBcIuKMnVwiLFxuXHRcInVyY3JvcFwiOiBcIuKMjlwiLFxuXHRcIlVyaW5nXCI6IFwixa5cIixcblx0XCJ1cmluZ1wiOiBcIsWvXCIsXG5cdFwidXJ0cmlcIjogXCLil7lcIixcblx0XCJVc2NyXCI6IFwi8J2SsFwiLFxuXHRcInVzY3JcIjogXCLwnZOKXCIsXG5cdFwidXRkb3RcIjogXCLii7BcIixcblx0XCJVdGlsZGVcIjogXCLFqFwiLFxuXHRcInV0aWxkZVwiOiBcIsWpXCIsXG5cdFwidXRyaVwiOiBcIuKWtVwiLFxuXHRcInV0cmlmXCI6IFwi4pa0XCIsXG5cdFwidXVhcnJcIjogXCLih4hcIixcblx0XCJVdW1sXCI6IFwiw5xcIixcblx0XCJ1dW1sXCI6IFwiw7xcIixcblx0XCJ1d2FuZ2xlXCI6IFwi4qanXCIsXG5cdFwidmFuZ3J0XCI6IFwi4qacXCIsXG5cdFwidmFyZXBzaWxvblwiOiBcIs+1XCIsXG5cdFwidmFya2FwcGFcIjogXCLPsFwiLFxuXHRcInZhcm5vdGhpbmdcIjogXCLiiIVcIixcblx0XCJ2YXJwaGlcIjogXCLPlVwiLFxuXHRcInZhcnBpXCI6IFwiz5ZcIixcblx0XCJ2YXJwcm9wdG9cIjogXCLiiJ1cIixcblx0XCJ2YXJyXCI6IFwi4oaVXCIsXG5cdFwidkFyclwiOiBcIuKHlVwiLFxuXHRcInZhcnJob1wiOiBcIs+xXCIsXG5cdFwidmFyc2lnbWFcIjogXCLPglwiLFxuXHRcInZhcnN1YnNldG5lcVwiOiBcIuKKiu+4gFwiLFxuXHRcInZhcnN1YnNldG5lcXFcIjogXCLiq4vvuIBcIixcblx0XCJ2YXJzdXBzZXRuZXFcIjogXCLiiovvuIBcIixcblx0XCJ2YXJzdXBzZXRuZXFxXCI6IFwi4quM77iAXCIsXG5cdFwidmFydGhldGFcIjogXCLPkVwiLFxuXHRcInZhcnRyaWFuZ2xlbGVmdFwiOiBcIuKKslwiLFxuXHRcInZhcnRyaWFuZ2xlcmlnaHRcIjogXCLiirNcIixcblx0XCJ2QmFyXCI6IFwi4quoXCIsXG5cdFwiVmJhclwiOiBcIuKrq1wiLFxuXHRcInZCYXJ2XCI6IFwi4qupXCIsXG5cdFwiVmN5XCI6IFwi0JJcIixcblx0XCJ2Y3lcIjogXCLQslwiLFxuXHRcInZkYXNoXCI6IFwi4oqiXCIsXG5cdFwidkRhc2hcIjogXCLiiqhcIixcblx0XCJWZGFzaFwiOiBcIuKKqVwiLFxuXHRcIlZEYXNoXCI6IFwi4oqrXCIsXG5cdFwiVmRhc2hsXCI6IFwi4qumXCIsXG5cdFwidmVlYmFyXCI6IFwi4oq7XCIsXG5cdFwidmVlXCI6IFwi4oioXCIsXG5cdFwiVmVlXCI6IFwi4ouBXCIsXG5cdFwidmVlZXFcIjogXCLiiZpcIixcblx0XCJ2ZWxsaXBcIjogXCLii65cIixcblx0XCJ2ZXJiYXJcIjogXCJ8XCIsXG5cdFwiVmVyYmFyXCI6IFwi4oCWXCIsXG5cdFwidmVydFwiOiBcInxcIixcblx0XCJWZXJ0XCI6IFwi4oCWXCIsXG5cdFwiVmVydGljYWxCYXJcIjogXCLiiKNcIixcblx0XCJWZXJ0aWNhbExpbmVcIjogXCJ8XCIsXG5cdFwiVmVydGljYWxTZXBhcmF0b3JcIjogXCLinZhcIixcblx0XCJWZXJ0aWNhbFRpbGRlXCI6IFwi4omAXCIsXG5cdFwiVmVyeVRoaW5TcGFjZVwiOiBcIuKAilwiLFxuXHRcIlZmclwiOiBcIvCdlJlcIixcblx0XCJ2ZnJcIjogXCLwnZSzXCIsXG5cdFwidmx0cmlcIjogXCLiirJcIixcblx0XCJ2bnN1YlwiOiBcIuKKguKDklwiLFxuXHRcInZuc3VwXCI6IFwi4oqD4oOSXCIsXG5cdFwiVm9wZlwiOiBcIvCdlY1cIixcblx0XCJ2b3BmXCI6IFwi8J2Vp1wiLFxuXHRcInZwcm9wXCI6IFwi4oidXCIsXG5cdFwidnJ0cmlcIjogXCLiirNcIixcblx0XCJWc2NyXCI6IFwi8J2SsVwiLFxuXHRcInZzY3JcIjogXCLwnZOLXCIsXG5cdFwidnN1Ym5FXCI6IFwi4quL77iAXCIsXG5cdFwidnN1Ym5lXCI6IFwi4oqK77iAXCIsXG5cdFwidnN1cG5FXCI6IFwi4quM77iAXCIsXG5cdFwidnN1cG5lXCI6IFwi4oqL77iAXCIsXG5cdFwiVnZkYXNoXCI6IFwi4oqqXCIsXG5cdFwidnppZ3phZ1wiOiBcIuKmmlwiLFxuXHRcIldjaXJjXCI6IFwixbRcIixcblx0XCJ3Y2lyY1wiOiBcIsW1XCIsXG5cdFwid2VkYmFyXCI6IFwi4qmfXCIsXG5cdFwid2VkZ2VcIjogXCLiiKdcIixcblx0XCJXZWRnZVwiOiBcIuKLgFwiLFxuXHRcIndlZGdlcVwiOiBcIuKJmVwiLFxuXHRcIndlaWVycFwiOiBcIuKEmFwiLFxuXHRcIldmclwiOiBcIvCdlJpcIixcblx0XCJ3ZnJcIjogXCLwnZS0XCIsXG5cdFwiV29wZlwiOiBcIvCdlY5cIixcblx0XCJ3b3BmXCI6IFwi8J2VqFwiLFxuXHRcIndwXCI6IFwi4oSYXCIsXG5cdFwid3JcIjogXCLiiYBcIixcblx0XCJ3cmVhdGhcIjogXCLiiYBcIixcblx0XCJXc2NyXCI6IFwi8J2SslwiLFxuXHRcIndzY3JcIjogXCLwnZOMXCIsXG5cdFwieGNhcFwiOiBcIuKLglwiLFxuXHRcInhjaXJjXCI6IFwi4pevXCIsXG5cdFwieGN1cFwiOiBcIuKLg1wiLFxuXHRcInhkdHJpXCI6IFwi4pa9XCIsXG5cdFwiWGZyXCI6IFwi8J2Um1wiLFxuXHRcInhmclwiOiBcIvCdlLVcIixcblx0XCJ4aGFyclwiOiBcIuKft1wiLFxuXHRcInhoQXJyXCI6IFwi4p+6XCIsXG5cdFwiWGlcIjogXCLOnlwiLFxuXHRcInhpXCI6IFwizr5cIixcblx0XCJ4bGFyclwiOiBcIuKftVwiLFxuXHRcInhsQXJyXCI6IFwi4p+4XCIsXG5cdFwieG1hcFwiOiBcIuKfvFwiLFxuXHRcInhuaXNcIjogXCLii7tcIixcblx0XCJ4b2RvdFwiOiBcIuKogFwiLFxuXHRcIlhvcGZcIjogXCLwnZWPXCIsXG5cdFwieG9wZlwiOiBcIvCdlalcIixcblx0XCJ4b3BsdXNcIjogXCLiqIFcIixcblx0XCJ4b3RpbWVcIjogXCLiqIJcIixcblx0XCJ4cmFyclwiOiBcIuKftlwiLFxuXHRcInhyQXJyXCI6IFwi4p+5XCIsXG5cdFwiWHNjclwiOiBcIvCdkrNcIixcblx0XCJ4c2NyXCI6IFwi8J2TjVwiLFxuXHRcInhzcWN1cFwiOiBcIuKohlwiLFxuXHRcInh1cGx1c1wiOiBcIuKohFwiLFxuXHRcInh1dHJpXCI6IFwi4pazXCIsXG5cdFwieHZlZVwiOiBcIuKLgVwiLFxuXHRcInh3ZWRnZVwiOiBcIuKLgFwiLFxuXHRcIllhY3V0ZVwiOiBcIsOdXCIsXG5cdFwieWFjdXRlXCI6IFwiw71cIixcblx0XCJZQWN5XCI6IFwi0K9cIixcblx0XCJ5YWN5XCI6IFwi0Y9cIixcblx0XCJZY2lyY1wiOiBcIsW2XCIsXG5cdFwieWNpcmNcIjogXCLFt1wiLFxuXHRcIlljeVwiOiBcItCrXCIsXG5cdFwieWN5XCI6IFwi0YtcIixcblx0XCJ5ZW5cIjogXCLCpVwiLFxuXHRcIllmclwiOiBcIvCdlJxcIixcblx0XCJ5ZnJcIjogXCLwnZS2XCIsXG5cdFwiWUljeVwiOiBcItCHXCIsXG5cdFwieWljeVwiOiBcItGXXCIsXG5cdFwiWW9wZlwiOiBcIvCdlZBcIixcblx0XCJ5b3BmXCI6IFwi8J2VqlwiLFxuXHRcIllzY3JcIjogXCLwnZK0XCIsXG5cdFwieXNjclwiOiBcIvCdk45cIixcblx0XCJZVWN5XCI6IFwi0K5cIixcblx0XCJ5dWN5XCI6IFwi0Y5cIixcblx0XCJ5dW1sXCI6IFwiw79cIixcblx0XCJZdW1sXCI6IFwixbhcIixcblx0XCJaYWN1dGVcIjogXCLFuVwiLFxuXHRcInphY3V0ZVwiOiBcIsW6XCIsXG5cdFwiWmNhcm9uXCI6IFwixb1cIixcblx0XCJ6Y2Fyb25cIjogXCLFvlwiLFxuXHRcIlpjeVwiOiBcItCXXCIsXG5cdFwiemN5XCI6IFwi0LdcIixcblx0XCJaZG90XCI6IFwixbtcIixcblx0XCJ6ZG90XCI6IFwixbxcIixcblx0XCJ6ZWV0cmZcIjogXCLihKhcIixcblx0XCJaZXJvV2lkdGhTcGFjZVwiOiBcIuKAi1wiLFxuXHRcIlpldGFcIjogXCLOllwiLFxuXHRcInpldGFcIjogXCLOtlwiLFxuXHRcInpmclwiOiBcIvCdlLdcIixcblx0XCJaZnJcIjogXCLihKhcIixcblx0XCJaSGN5XCI6IFwi0JZcIixcblx0XCJ6aGN5XCI6IFwi0LZcIixcblx0XCJ6aWdyYXJyXCI6IFwi4oedXCIsXG5cdFwiem9wZlwiOiBcIvCdlatcIixcblx0XCJab3BmXCI6IFwi4oSkXCIsXG5cdFwiWnNjclwiOiBcIvCdkrVcIixcblx0XCJ6c2NyXCI6IFwi8J2Tj1wiLFxuXHRcInp3alwiOiBcIuKAjVwiLFxuXHRcInp3bmpcIjogXCLigIxcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=