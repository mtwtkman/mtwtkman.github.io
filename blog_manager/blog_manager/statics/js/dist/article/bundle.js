/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 20);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Utilities
//


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(9);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(7);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(13);
exports.lib.ucmicro = __webpack_require__(87);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

;(function () {
	"use strict";

	function Vnode(tag, key, attrs0, children, text, dom) {
		return { tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false };
	}
	Vnode.normalize = function (node) {
		if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined);
		if (node != null && (typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined);
		return node;
	};
	Vnode.normalizeChildren = function normalizeChildren(children) {
		for (var i = 0; i < children.length; i++) {
			children[i] = Vnode.normalize(children[i]);
		}
		return children;
	};
	var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
	var selectorCache = {};
	var hasOwn = {}.hasOwnProperty;
	function compileSelector(selector) {
		var match,
		    tag = "div",
		    classes = [],
		    attrs = {};
		while (match = selectorParser.exec(selector)) {
			var type = match[1],
			    value = match[2];
			if (type === "" && value !== "") tag = value;else if (type === "#") attrs.id = value;else if (type === ".") classes.push(value);else if (match[3][0] === "[") {
				var attrValue = match[6];
				if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
				if (match[4] === "class") classes.push(attrValue);else attrs[match[4]] = attrValue || true;
			}
		}
		if (classes.length > 0) attrs.className = classes.join(" ");
		return selectorCache[selector] = { tag: tag, attrs: attrs };
	}
	function execSelector(state, attrs, children) {
		var hasAttrs = false,
		    childList,
		    text;
		var className = attrs.className || attrs.class;
		for (var key in state.attrs) {
			if (hasOwn.call(state.attrs, key)) {
				attrs[key] = state.attrs[key];
			}
		}
		if (className !== undefined) {
			if (attrs.class !== undefined) {
				attrs.class = undefined;
				attrs.className = className;
			}
			if (state.attrs.className != null) {
				attrs.className = state.attrs.className + " " + className;
			}
		}
		for (var key in attrs) {
			if (hasOwn.call(attrs, key) && key !== "key") {
				hasAttrs = true;
				break;
			}
		}
		if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
			text = children[0].children;
		} else {
			childList = children;
		}
		return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text);
	}
	function hyperscript(selector) {
		// Because sloppy mode sucks
		var attrs = arguments[1],
		    start = 2,
		    children;
		if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
			throw Error("The selector must be either a string or a component.");
		}
		if (typeof selector === "string") {
			var cached = selectorCache[selector] || compileSelector(selector);
		}
		if (attrs == null) {
			attrs = {};
		} else if ((typeof attrs === "undefined" ? "undefined" : _typeof(attrs)) !== "object" || attrs.tag != null || Array.isArray(attrs)) {
			attrs = {};
			start = 1;
		}
		if (arguments.length === start + 1) {
			children = arguments[start];
			if (!Array.isArray(children)) children = [children];
		} else {
			children = [];
			while (start < arguments.length) {
				children.push(arguments[start++]);
			}
		}
		var normalized = Vnode.normalizeChildren(children);
		if (typeof selector === "string") {
			return execSelector(cached, attrs, normalized);
		} else {
			return Vnode(selector, attrs.key, attrs, normalized);
		}
	}
	hyperscript.trust = function (html) {
		if (html == null) html = "";
		return Vnode("<", undefined, undefined, html, undefined, undefined);
	};
	hyperscript.fragment = function (attrs1, children) {
		return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined);
	};
	var m = hyperscript;
	/** @constructor */
	var PromisePolyfill = function PromisePolyfill(executor) {
		if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`");
		if (typeof executor !== "function") throw new TypeError("executor must be a function");
		var self = this,
		    resolvers = [],
		    rejectors = [],
		    resolveCurrent = handler(resolvers, true),
		    rejectCurrent = handler(rejectors, false);
		var instance = self._instance = { resolvers: resolvers, rejectors: rejectors };
		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function handler(list, shouldAbsorb) {
			return function execute(value) {
				var then;
				try {
					if (shouldAbsorb && value != null && ((typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
						if (value === self) throw new TypeError("Promise can't be resolved w/ itself");
						executeOnce(then.bind(value));
					} else {
						callAsync(function () {
							if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value);
							for (var i = 0; i < list.length; i++) {
								list[i](value);
							}resolvers.length = 0, rejectors.length = 0;
							instance.state = shouldAbsorb;
							instance.retry = function () {
								execute(value);
							};
						});
					}
				} catch (e) {
					rejectCurrent(e);
				}
			};
		}
		function executeOnce(then) {
			var runs = 0;
			function run(fn) {
				return function (value) {
					if (runs++ > 0) return;
					fn(value);
				};
			}
			var onerror = run(rejectCurrent);
			try {
				then(run(resolveCurrent), onerror);
			} catch (e) {
				onerror(e);
			}
		}
		executeOnce(executor);
	};
	PromisePolyfill.prototype.then = function (onFulfilled, onRejection) {
		var self = this,
		    instance = self._instance;
		function handle(callback, list, next, state) {
			list.push(function (value) {
				if (typeof callback !== "function") next(value);else try {
					resolveNext(callback(value));
				} catch (e) {
					if (rejectNext) rejectNext(e);
				}
			});
			if (typeof instance.retry === "function" && state === instance.state) instance.retry();
		}
		var resolveNext, rejectNext;
		var promise = new PromisePolyfill(function (resolve, reject) {
			resolveNext = resolve, rejectNext = reject;
		});
		handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
		return promise;
	};
	PromisePolyfill.prototype.catch = function (onRejection) {
		return this.then(null, onRejection);
	};
	PromisePolyfill.resolve = function (value) {
		if (value instanceof PromisePolyfill) return value;
		return new PromisePolyfill(function (resolve) {
			resolve(value);
		});
	};
	PromisePolyfill.reject = function (value) {
		return new PromisePolyfill(function (resolve, reject) {
			reject(value);
		});
	};
	PromisePolyfill.all = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			var total = list.length,
			    count = 0,
			    values = [];
			if (list.length === 0) resolve([]);else for (var i = 0; i < list.length; i++) {
				(function (i) {
					function consume(value) {
						count++;
						values[i] = value;
						if (count === total) resolve(values);
					}
					if (list[i] != null && (_typeof(list[i]) === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
						list[i].then(consume, reject);
					} else consume(list[i]);
				})(i);
			}
		});
	};
	PromisePolyfill.race = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			for (var i = 0; i < list.length; i++) {
				list[i].then(resolve, reject);
			}
		});
	};
	if (typeof window !== "undefined") {
		if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill;
		var PromisePolyfill = window.Promise;
	} else if (typeof global !== "undefined") {
		if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill;
		var PromisePolyfill = global.Promise;
	} else {}
	var buildQueryString = function buildQueryString(object) {
		if (Object.prototype.toString.call(object) !== "[object Object]") return "";
		var args = [];
		for (var key0 in object) {
			destructure(key0, object[key0]);
		}
		return args.join("&");
		function destructure(key0, value) {
			if (Array.isArray(value)) {
				for (var i = 0; i < value.length; i++) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else if (Object.prototype.toString.call(value) === "[object Object]") {
				for (var i in value) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
		}
	};
	var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i");
	var _8 = function _8($window, Promise) {
		var callbackCount = 0;
		var oncompletion;
		function setCompletionCallback(callback) {
			oncompletion = callback;
		}
		function finalizer() {
			var count = 0;
			function complete() {
				if (--count === 0 && typeof oncompletion === "function") oncompletion();
			}
			return function finalize(promise0) {
				var then0 = promise0.then;
				promise0.then = function () {
					count++;
					var next = then0.apply(promise0, arguments);
					next.then(complete, function (e) {
						complete();
						if (count === 0) throw e;
					});
					return finalize(next);
				};
				return promise0;
			};
		}
		function normalize(args, extra) {
			if (typeof args === "string") {
				var url = args;
				args = extra || {};
				if (args.url == null) args.url = url;
			}
			return args;
		}
		function request(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				if (args.method == null) args.method = "GET";
				args.method = args.method.toUpperCase();
				var useBody = args.method === "GET" || args.method === "TRACE" ? false : typeof args.useBody === "boolean" ? args.useBody : true;
				if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function (value) {
					return value;
				} : JSON.stringify;
				if (typeof args.deserialize !== "function") args.deserialize = deserialize;
				if (typeof args.extract !== "function") args.extract = extract;
				args.url = interpolate(args.url, args.data);
				if (useBody) args.data = args.serialize(args.data);else args.url = assemble(args.url, args.data);
				var xhr = new $window.XMLHttpRequest(),
				    aborted = false,
				    _abort = xhr.abort;
				xhr.abort = function abort() {
					aborted = true;
					_abort.call(xhr);
				};
				xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);
				if (args.serialize === JSON.stringify && useBody) {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
				}
				if (args.deserialize === deserialize) {
					xhr.setRequestHeader("Accept", "application/json, text/*");
				}
				if (args.withCredentials) xhr.withCredentials = args.withCredentials;
				for (var key in args.headers) {
					if ({}.hasOwnProperty.call(args.headers, key)) {
						xhr.setRequestHeader(key, args.headers[key]);
					}
				}if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr;
				xhr.onreadystatechange = function () {
					// Don't throw errors on xhr.abort().
					if (aborted) return;
					if (xhr.readyState === 4) {
						try {
							var response = args.extract !== extract ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args));
							if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
								resolve(cast(args.type, response));
							} else {
								var error = new Error(xhr.responseText);
								for (var key in response) {
									error[key] = response[key];
								}reject(error);
							}
						} catch (e) {
							reject(e);
						}
					}
				};
				if (useBody && args.data != null) xhr.send(args.data);else xhr.send();
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function jsonp(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
				var script = $window.document.createElement("script");
				$window[callbackName] = function (data) {
					script.parentNode.removeChild(script);
					resolve(cast(args.type, data));
					delete $window[callbackName];
				};
				script.onerror = function () {
					script.parentNode.removeChild(script);
					reject(new Error("JSONP request failed"));
					delete $window[callbackName];
				};
				if (args.data == null) args.data = {};
				args.url = interpolate(args.url, args.data);
				args.data[args.callbackKey || "callback"] = callbackName;
				script.src = assemble(args.url, args.data);
				$window.document.documentElement.appendChild(script);
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function interpolate(url, data) {
			if (data == null) return url;
			var tokens = url.match(/:[^\/]+/gi) || [];
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1);
				if (data[key] != null) {
					url = url.replace(tokens[i], data[key]);
				}
			}
			return url;
		}
		function assemble(url, data) {
			var querystring = buildQueryString(data);
			if (querystring !== "") {
				var prefix = url.indexOf("?") < 0 ? "?" : "&";
				url += prefix + querystring;
			}
			return url;
		}
		function deserialize(data) {
			try {
				return data !== "" ? JSON.parse(data) : null;
			} catch (e) {
				throw new Error(data);
			}
		}
		function extract(xhr) {
			return xhr.responseText;
		}
		function cast(type0, data) {
			if (typeof type0 === "function") {
				if (Array.isArray(data)) {
					for (var i = 0; i < data.length; i++) {
						data[i] = new type0(data[i]);
					}
				} else return new type0(data);
			}
			return data;
		}
		return { request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback };
	};
	var requestService = _8(window, PromisePolyfill);
	var coreRenderer = function coreRenderer($window) {
		var $doc = $window.document;
		var $emptyFragment = $doc.createDocumentFragment();
		var onevent;
		function setEventCallback(callback) {
			return onevent = callback;
		}
		//create
		function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					createNode(parent, vnode, hooks, ns, nextSibling);
				}
			}
		}
		function createNode(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			if (typeof tag === "string") {
				vnode.state = {};
				if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
				switch (tag) {
					case "#":
						return createText(parent, vnode, nextSibling);
					case "<":
						return createHTML(parent, vnode, nextSibling);
					case "[":
						return createFragment(parent, vnode, hooks, ns, nextSibling);
					default:
						return createElement(parent, vnode, hooks, ns, nextSibling);
				}
			} else return createComponent(parent, vnode, hooks, ns, nextSibling);
		}
		function createText(parent, vnode, nextSibling) {
			vnode.dom = $doc.createTextNode(vnode.children);
			insertNode(parent, vnode.dom, nextSibling);
			return vnode.dom;
		}
		function createHTML(parent, vnode, nextSibling) {
			var match1 = vnode.children.match(/^\s*?<(\w+)/im) || [];
			var parent1 = { caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup" }[match1[1]] || "div";
			var temp = $doc.createElement(parent1);
			temp.innerHTML = vnode.children;
			vnode.dom = temp.firstChild;
			vnode.domSize = temp.childNodes.length;
			var fragment = $doc.createDocumentFragment();
			var child;
			while (child = temp.firstChild) {
				fragment.appendChild(child);
			}
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createFragment(parent, vnode, hooks, ns, nextSibling) {
			var fragment = $doc.createDocumentFragment();
			if (vnode.children != null) {
				var children = vnode.children;
				createNodes(fragment, children, 0, children.length, hooks, null, ns);
			}
			vnode.dom = fragment.firstChild;
			vnode.domSize = fragment.childNodes.length;
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createElement(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			var attrs2 = vnode.attrs;
			var is = attrs2 && attrs2.is;
			var element = ns ? is ? $doc.createElementNS(ns, tag, { is: is }) : $doc.createElementNS(ns, tag) : is ? $doc.createElement(tag, { is: is }) : $doc.createElement(tag);
			vnode.dom = element;
			if (attrs2 != null) {
				setAttrs(vnode, attrs2, ns);
			}
			insertNode(parent, element, nextSibling);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else {
				if (vnode.text != null) {
					if (vnode.text !== "") element.textContent = vnode.text;else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				}
				if (vnode.children != null) {
					var children = vnode.children;
					createNodes(element, children, 0, children.length, hooks, null, ns);
					setLateAttrs(vnode);
				}
			}
			return element;
		}
		function initComponent(vnode, hooks) {
			var sentinel;
			if (typeof vnode.tag.view === "function") {
				vnode.state = Object.create(vnode.tag);
				sentinel = vnode.state.view;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
			} else {
				vnode.state = void 0;
				sentinel = vnode.tag;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
				vnode.state = vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function" ? new vnode.tag(vnode) : vnode.tag(vnode);
			}
			vnode._state = vnode.state;
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
			initLifecycle(vnode._state, vnode, hooks);
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
			sentinel.$$reentrantLock$$ = null;
		}
		function createComponent(parent, vnode, hooks, ns, nextSibling) {
			initComponent(vnode, hooks);
			if (vnode.instance != null) {
				var element = createNode(parent, vnode.instance, hooks, ns, nextSibling);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
				insertNode(parent, element, nextSibling);
				return element;
			} else {
				vnode.domSize = 0;
				return $emptyFragment;
			}
		}
		//update
		function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
			if (old === vnodes || old == null && vnodes == null) return;else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined);else if (vnodes == null) removeNodes(old, 0, old.length, vnodes);else {
				if (old.length === vnodes.length) {
					var isUnkeyed = false;
					for (var i = 0; i < vnodes.length; i++) {
						if (vnodes[i] != null && old[i] != null) {
							isUnkeyed = vnodes[i].key == null && old[i].key == null;
							break;
						}
					}
					if (isUnkeyed) {
						for (var i = 0; i < old.length; i++) {
							if (old[i] === vnodes[i]) continue;else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling));else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes);else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns);
						}
						return;
					}
				}
				recycling = recycling || isRecyclable(old, vnodes);
				if (recycling) {
					var pool = old.pool;
					old = old.concat(old.pool);
				}
				var oldStart = 0,
				    start = 0,
				    oldEnd = old.length - 1,
				    end = vnodes.length - 1,
				    map;
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldStart],
					    v = vnodes[start];
					if (o === v && !recycling) oldStart++, start++;else if (o == null) oldStart++;else if (v == null) start++;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldStart >= old.length - pool.length || pool == null && recycling;
						oldStart++, start++;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
					} else {
						var o = old[oldEnd];
						if (o === v && !recycling) oldEnd--, start++;else if (o == null) oldEnd--;else if (v == null) start++;else if (o.key === v.key) {
							var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
							updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
							if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling));
							oldEnd--, start++;
						} else break;
					}
				}
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldEnd],
					    v = vnodes[end];
					if (o === v && !recycling) oldEnd--, end--;else if (o == null) oldEnd--;else if (v == null) end--;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
						if (o.dom != null) nextSibling = o.dom;
						oldEnd--, end--;
					} else {
						if (!map) map = getKeyMap(old, oldEnd);
						if (v != null) {
							var oldIndex = map[v.key];
							if (oldIndex != null) {
								var movable = old[oldIndex];
								var shouldRecycle = pool != null && oldIndex >= old.length - pool.length || pool == null && recycling;
								updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns);
								insertNode(parent, toFragment(movable), nextSibling);
								old[oldIndex].skip = true;
								if (movable.dom != null) nextSibling = movable.dom;
							} else {
								var dom = createNode(parent, v, hooks, undefined, nextSibling);
								nextSibling = dom;
							}
						}
						end--;
					}
					if (end < start) break;
				}
				createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
				removeNodes(old, oldStart, oldEnd + 1, vnodes);
			}
		}
		function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			var oldTag = old.tag,
			    tag = vnode.tag;
			if (oldTag === tag) {
				vnode.state = old.state;
				vnode._state = old._state;
				vnode.events = old.events;
				if (!recycling && shouldNotUpdate(vnode, old)) return;
				if (typeof oldTag === "string") {
					if (vnode.attrs != null) {
						if (recycling) {
							vnode.state = {};
							initLifecycle(vnode.attrs, vnode, hooks);
						} else updateLifecycle(vnode.attrs, vnode, hooks);
					}
					switch (oldTag) {
						case "#":
							updateText(old, vnode);break;
						case "<":
							updateHTML(parent, old, vnode, nextSibling);break;
						case "[":
							updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns);break;
						default:
							updateElement(old, vnode, recycling, hooks, ns);
					}
				} else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns);
			} else {
				removeNode(old, null);
				createNode(parent, vnode, hooks, ns, nextSibling);
			}
		}
		function updateText(old, vnode) {
			if (old.children.toString() !== vnode.children.toString()) {
				old.dom.nodeValue = vnode.children;
			}
			vnode.dom = old.dom;
		}
		function updateHTML(parent, old, vnode, nextSibling) {
			if (old.children !== vnode.children) {
				toFragment(old);
				createHTML(parent, vnode, nextSibling);
			} else vnode.dom = old.dom, vnode.domSize = old.domSize;
		}
		function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
			updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns);
			var domSize = 0,
			    children = vnode.children;
			vnode.dom = null;
			if (children != null) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i];
					if (child != null && child.dom != null) {
						if (vnode.dom == null) vnode.dom = child.dom;
						domSize += child.domSize || 1;
					}
				}
				if (domSize !== 1) vnode.domSize = domSize;
			}
		}
		function updateElement(old, vnode, recycling, hooks, ns) {
			var element = vnode.dom = old.dom;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			if (vnode.tag === "textarea") {
				if (vnode.attrs == null) vnode.attrs = {};
				if (vnode.text != null) {
					vnode.attrs.value = vnode.text; //FIXME handle0 multiple children
					vnode.text = undefined;
				}
			}
			updateAttrs(vnode, old.attrs, vnode.attrs, ns);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else if (old.text != null && vnode.text != null && vnode.text !== "") {
				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text;
			} else {
				if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)];
				if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns);
			}
		}
		function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			if (recycling) {
				initComponent(vnode, hooks);
			} else {
				vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
				if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
				if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);
				updateLifecycle(vnode._state, vnode, hooks);
			}
			if (vnode.instance != null) {
				if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.instance.domSize;
			} else if (old.instance != null) {
				removeNode(old.instance, null);
				vnode.dom = undefined;
				vnode.domSize = 0;
			} else {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
			}
		}
		function isRecyclable(old, vnodes) {
			if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
				var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0;
				var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0;
				var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0;
				if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
					return true;
				}
			}
			return false;
		}
		function getKeyMap(vnodes, end) {
			var map = {},
			    i = 0;
			for (var i = 0; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					var key2 = vnode.key;
					if (key2 != null) map[key2] = i;
				}
			}
			return map;
		}
		function toFragment(vnode) {
			var count0 = vnode.domSize;
			if (count0 != null || vnode.dom == null) {
				var fragment = $doc.createDocumentFragment();
				if (count0 > 0) {
					var dom = vnode.dom;
					while (--count0) {
						fragment.appendChild(dom.nextSibling);
					}fragment.insertBefore(dom, fragment.firstChild);
				}
				return fragment;
			} else return vnode.dom;
		}
		function getNextSibling(vnodes, i, nextSibling) {
			for (; i < vnodes.length; i++) {
				if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom;
			}
			return nextSibling;
		}
		function insertNode(parent, dom, nextSibling) {
			if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling);else parent.appendChild(dom);
		}
		function setContentEditable(vnode) {
			var children = vnode.children;
			if (children != null && children.length === 1 && children[0].tag === "<") {
				var content = children[0].children;
				if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;
			} else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted");
		}
		//remove
		function removeNodes(vnodes, start, end, context) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					if (vnode.skip) vnode.skip = false;else removeNode(vnode, context);
				}
			}
		}
		function removeNode(vnode, context) {
			var expected = 1,
			    called = 0;
			if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
				var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
				var result = vnode._state.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			continuation();
			function continuation() {
				if (++called === expected) {
					onremove(vnode);
					if (vnode.dom) {
						var count0 = vnode.domSize || 1;
						if (count0 > 1) {
							var dom = vnode.dom;
							while (--count0) {
								removeNodeFromDOM(dom.nextSibling);
							}
						}
						removeNodeFromDOM(vnode.dom);
						if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") {
							//TODO test custom elements
							if (!context.pool) context.pool = [vnode];else context.pool.push(vnode);
						}
					}
				}
			}
		}
		function removeNodeFromDOM(node) {
			var parent = node.parentNode;
			if (parent != null) parent.removeChild(node);
		}
		function onremove(vnode) {
			if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode);
			if (vnode.instance != null) onremove(vnode.instance);else {
				var children = vnode.children;
				if (Array.isArray(children)) {
					for (var i = 0; i < children.length; i++) {
						var child = children[i];
						if (child != null) onremove(child);
					}
				}
			}
		}
		//attrs2
		function setAttrs(vnode, attrs2, ns) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, null, attrs2[key2], ns);
			}
		}
		function setAttr(vnode, key2, old, value, ns) {
			var element = vnode.dom;
			if (key2 === "key" || key2 === "is" || old === value && !isFormAttribute(vnode, key2) && (typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return;
			var nsLastIndex = key2.indexOf(":");
			if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
				element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value);
			} else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value);else if (key2 === "style") updateStyle(element, old, value);else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if (vnode.tag === "input" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && key2 === "value" && vnode.dom.value == value) return;
				// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
				if (vnode.tag === "input" && key2 === "type") {
					element.setAttribute(key2, value);
					return;
				}
				element[key2] = value;
			} else {
				if (typeof value === "boolean") {
					if (value) element.setAttribute(key2, "");else element.removeAttribute(key2);
				} else element.setAttribute(key2 === "className" ? "class" : key2, value);
			}
		}
		function setLateAttrs(vnode) {
			var attrs2 = vnode.attrs;
			if (vnode.tag === "select" && attrs2 != null) {
				if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined);
				if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined);
			}
		}
		function updateAttrs(vnode, old, attrs2, ns) {
			if (attrs2 != null) {
				for (var key2 in attrs2) {
					setAttr(vnode, key2, old && old[key2], attrs2[key2], ns);
				}
			}
			if (old != null) {
				for (var key2 in old) {
					if (attrs2 == null || !(key2 in attrs2)) {
						if (key2 === "className") key2 = "class";
						if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined);else if (key2 !== "key") vnode.dom.removeAttribute(key2);
					}
				}
			}
		}
		function isFormAttribute(vnode, attr) {
			return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement;
		}
		function isLifecycleMethod(attr) {
			return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate";
		}
		function isAttribute(attr) {
			return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"; // || attr === "type"
		}
		function isCustomElement(vnode) {
			return vnode.attrs.is || vnode.tag.indexOf("-") > -1;
		}
		function hasIntegrationMethods(source) {
			return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove);
		}
		//style
		function updateStyle(element, old, style) {
			if (old === style) element.style.cssText = "", old = null;
			if (style == null) element.style.cssText = "";else if (typeof style === "string") element.style.cssText = style;else {
				if (typeof old === "string") element.style.cssText = "";
				for (var key2 in style) {
					element.style[key2] = style[key2];
				}
				if (old != null && typeof old !== "string") {
					for (var key2 in old) {
						if (!(key2 in style)) element.style[key2] = "";
					}
				}
			}
		}
		//event
		function updateEvent(vnode, key2, value) {
			var element = vnode.dom;
			var callback = typeof onevent !== "function" ? value : function (e) {
				var result = value.call(element, e);
				onevent.call(element, e);
				return result;
			};
			if (key2 in element) element[key2] = typeof value === "function" ? callback : null;else {
				var eventName = key2.slice(2);
				if (vnode.events === undefined) vnode.events = {};
				if (vnode.events[key2] === callback) return;
				if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false);
				if (typeof value === "function") {
					vnode.events[key2] = callback;
					element.addEventListener(eventName, vnode.events[key2], false);
				}
			}
		}
		//lifecycle
		function initLifecycle(source, vnode, hooks) {
			if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode);
			if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode));
		}
		function updateLifecycle(source, vnode, hooks) {
			if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode));
		}
		function shouldNotUpdate(vnode, old) {
			var forceVnodeUpdate, forceComponentUpdate;
			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old);
			if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
				vnode.instance = old.instance;
				return true;
			}
			return false;
		}
		function render(dom, vnodes) {
			if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");
			var hooks = [];
			var active = $doc.activeElement;
			// First time0 rendering into a node clears it out
			if (dom.vnodes == null) dom.textContent = "";
			if (!Array.isArray(vnodes)) vnodes = [vnodes];
			updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined);
			dom.vnodes = vnodes;
			for (var i = 0; i < hooks.length; i++) {
				hooks[i]();
			}if ($doc.activeElement !== active) active.focus();
		}
		return { render: render, setEventCallback: setEventCallback };
	};
	function throttle(callback) {
		//60fps translates to 16.6ms, round it down since setTimeout requires int
		var time = 16;
		var last = 0,
		    pending = null;
		var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout;
		return function () {
			var now = Date.now();
			if (last === 0 || now - last >= time) {
				last = now;
				callback();
			} else if (pending === null) {
				pending = timeout(function () {
					pending = null;
					callback();
					last = Date.now();
				}, time - (now - last));
			}
		};
	}
	var _11 = function _11($window) {
		var renderService = coreRenderer($window);
		renderService.setEventCallback(function (e) {
			if (e.redraw !== false) redraw();
		});
		var callbacks = [];
		function subscribe(key1, callback) {
			unsubscribe(key1);
			callbacks.push(key1, throttle(callback));
		}
		function unsubscribe(key1) {
			var index = callbacks.indexOf(key1);
			if (index > -1) callbacks.splice(index, 2);
		}
		function redraw() {
			for (var i = 1; i < callbacks.length; i += 2) {
				callbacks[i]();
			}
		}
		return { subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render };
	};
	var redrawService = _11(window);
	requestService.setCompletionCallback(redrawService.redraw);
	var _16 = function _16(redrawService0) {
		return function (root, component) {
			if (component === null) {
				redrawService0.render(root, []);
				redrawService0.unsubscribe(root);
				return;
			}

			if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode");

			var run0 = function run0() {
				redrawService0.render(root, Vnode(component));
			};
			redrawService0.subscribe(root, run0);
			redrawService0.redraw();
		};
	};
	m.mount = _16(redrawService);
	var Promise = PromisePolyfill;
	var parseQueryString = function parseQueryString(string) {
		if (string === "" || string == null) return {};
		if (string.charAt(0) === "?") string = string.slice(1);
		var entries = string.split("&"),
		    data0 = {},
		    counters = {};
		for (var i = 0; i < entries.length; i++) {
			var entry = entries[i].split("=");
			var key5 = decodeURIComponent(entry[0]);
			var value = entry.length === 2 ? decodeURIComponent(entry[1]) : "";
			if (value === "true") value = true;else if (value === "false") value = false;
			var levels = key5.split(/\]\[?|\[/);
			var cursor = data0;
			if (key5.indexOf("[") > -1) levels.pop();
			for (var j = 0; j < levels.length; j++) {
				var level = levels[j],
				    nextLevel = levels[j + 1];
				var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
				var isValue = j === levels.length - 1;
				if (level === "") {
					var key5 = levels.slice(0, j).join();
					if (counters[key5] == null) counters[key5] = 0;
					level = counters[key5]++;
				}
				if (cursor[level] == null) {
					cursor[level] = isValue ? value : isNumber ? [] : {};
				}
				cursor = cursor[level];
			}
		}
		return data0;
	};
	var coreRouter = function coreRouter($window) {
		var supportsPushState = typeof $window.history.pushState === "function";
		var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function normalize1(fragment0) {
			var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent);
			if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data;
			return data;
		}
		var asyncId;
		function debounceAsync(callback0) {
			return function () {
				if (asyncId != null) return;
				asyncId = callAsync0(function () {
					asyncId = null;
					callback0();
				});
			};
		}
		function parsePath(path, queryData, hashData) {
			var queryIndex = path.indexOf("?");
			var hashIndex = path.indexOf("#");
			var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length;
			if (queryIndex > -1) {
				var queryEnd = hashIndex > -1 ? hashIndex : path.length;
				var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd));
				for (var key4 in queryParams) {
					queryData[key4] = queryParams[key4];
				}
			}
			if (hashIndex > -1) {
				var hashParams = parseQueryString(path.slice(hashIndex + 1));
				for (var key4 in hashParams) {
					hashData[key4] = hashParams[key4];
				}
			}
			return path.slice(0, pathEnd);
		}
		var router = { prefix: "#!" };
		router.getPath = function () {
			var type2 = router.prefix.charAt(0);
			switch (type2) {
				case "#":
					return normalize1("hash").slice(router.prefix.length);
				case "?":
					return normalize1("search").slice(router.prefix.length) + normalize1("hash");
				default:
					return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash");
			}
		};
		router.setPath = function (path, data, options) {
			var queryData = {},
			    hashData = {};
			path = parsePath(path, queryData, hashData);
			if (data != null) {
				for (var key4 in data) {
					queryData[key4] = data[key4];
				}path = path.replace(/:([^\/]+)/g, function (match2, token) {
					delete queryData[token];
					return data[token];
				});
			}
			var query = buildQueryString(queryData);
			if (query) path += "?" + query;
			var hash = buildQueryString(hashData);
			if (hash) path += "#" + hash;
			if (supportsPushState) {
				var state = options ? options.state : null;
				var title = options ? options.title : null;
				$window.onpopstate();
				if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path);else $window.history.pushState(state, title, router.prefix + path);
			} else $window.location.href = router.prefix + path;
		};
		router.defineRoutes = function (routes, resolve, reject) {
			function resolveRoute() {
				var path = router.getPath();
				var params = {};
				var pathname = parsePath(path, params, params);
				var state = $window.history.state;
				if (state != null) {
					for (var k in state) {
						params[k] = state[k];
					}
				}
				for (var route0 in routes) {
					var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");
					if (matcher.test(pathname)) {
						pathname.replace(matcher, function () {
							var keys = route0.match(/:[^\/]+/g) || [];
							var values = [].slice.call(arguments, 1, -2);
							for (var i = 0; i < keys.length; i++) {
								params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i]);
							}
							resolve(routes[route0], params, path, route0);
						});
						return;
					}
				}
				reject(path, params);
			}
			if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute);else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute;
			resolveRoute();
		};
		return router;
	};
	var _20 = function _20($window, redrawService0) {
		var routeService = coreRouter($window);
		var identity = function identity(v) {
			return v;
		};
		var render1, component, attrs3, currentPath, _lastUpdate;
		var route = function route(root, defaultRoute, routes) {
			if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined");
			var run1 = function run1() {
				if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)));
			};
			var bail = function bail(path) {
				if (path !== defaultRoute) routeService.setPath(defaultRoute, null, { replace: true });else throw new Error("Could not resolve default route " + defaultRoute);
			};
			routeService.defineRoutes(routes, function (payload, params, path) {
				var update = _lastUpdate = function lastUpdate(routeResolver, comp) {
					if (update !== _lastUpdate) return;
					component = comp != null && (typeof comp.view === "function" || typeof comp === "function") ? comp : "div";
					attrs3 = params, currentPath = path, _lastUpdate = null;
					render1 = (routeResolver.render || identity).bind(routeResolver);
					run1();
				};
				if (payload.view || typeof payload === "function") update({}, payload);else {
					if (payload.onmatch) {
						Promise.resolve(payload.onmatch(params, path)).then(function (resolved) {
							update(payload, resolved);
						}, bail);
					} else update(payload, "div");
				}
			}, bail);
			redrawService0.subscribe(root, run1);
		};
		route.set = function (path, data, options) {
			if (_lastUpdate != null) options = { replace: true };
			_lastUpdate = null;
			routeService.setPath(path, data, options);
		};
		route.get = function () {
			return currentPath;
		};
		route.prefix = function (prefix0) {
			routeService.prefix = prefix0;
		};
		route.link = function (vnode1) {
			vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href);
			vnode1.dom.onclick = function (e) {
				if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return;
				e.preventDefault();
				e.redraw = false;
				var href = this.getAttribute("href");
				if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length);
				route.set(href, undefined, undefined);
			};
		};
		route.param = function (key3) {
			if (typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3];
			return attrs3;
		};
		return route;
	};
	m.route = _20(window, redrawService);
	m.withAttr = function (attrName, callback1, context) {
		return function (e) {
			callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName));
		};
	};
	var _28 = coreRenderer(window);
	m.render = _28.render;
	m.redraw = redrawService.redraw;
	m.request = requestService.request;
	m.jsonp = requestService.jsonp;
	m.parseQueryString = parseQueryString;
	m.buildQueryString = buildQueryString;
	m.version = "1.1.1";
	m.vnode = Vnode;
	if (true) module["exports"] = m;else window.m = m;
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(85).setImmediate, __webpack_require__(3)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.span = vnode.attrs.span;
    vnode.state.cls = vnode.attrs.cls;
  },
  view: function view(vnode) {
    return (0, _mithril2.default)(
      'div',
      { className: 'mdl-cell mdl-cell--' + vnode.state.span + '-col ' + vnode.state.cls },
      vnode.attrs.inner
    );
  }
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(90);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(17)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/


/**
 * new Ruler()
 **/

function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typorgapher replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Token class



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/

function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27).Buffer))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML5 entities map: { name -> utf16string }
//


/*eslint quotes:0*/

module.exports = __webpack_require__(91);

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = '';
      state.tokens[delimiters[startDelim.end - 1].token].content = '';
      i++;
    }
  }
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ~~strike through~~
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports.encode = __webpack_require__(78);
module.exports.decode = __webpack_require__(77);
module.exports.format = __webpack_require__(79);
module.exports.parse = __webpack_require__(80);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(84);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 18 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Save = undefined;

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _model = __webpack_require__(21);

var _model2 = _interopRequireDefault(_model);

var _styles = __webpack_require__(92);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

var _title = __webpack_require__(25);

var _title2 = _interopRequireDefault(_title);

var _tags = __webpack_require__(24);

var _tags2 = _interopRequireDefault(_tags);

var _editor = __webpack_require__(22);

var _editor2 = _interopRequireDefault(_editor);

var _preview = __webpack_require__(23);

var _preview2 = _interopRequireDefault(_preview);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Save = exports.Save = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
  },
  view: function view(vnode) {
    var model = vnode.state.model;
    var inner = (0, _mithril2.default)(
      'button',
      {
        className: 'mdl-button mdl-js-button mdl-button--raised mdl-button--colored',
        onclick: model.save },
      'save'
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, cls: _styles2.default.saveButton, inner: inner });
  }
};

exports.default = {
  oninit: function oninit(vnode) {
    _model2.default.fetch();
  },
  view: function view(vnode) {
    if (_model2.default.fetched) {
      return (0, _mithril2.default)(
        'div',
        { className: 'mdl-grid' },
        (0, _mithril2.default)(_title2.default, { model: _model2.default }),
        (0, _mithril2.default)(_tags2.default, { model: _model2.default }),
        (0, _mithril2.default)(
          'div',
          { className: _styles2.default.editorWrap },
          (0, _mithril2.default)(_editor2.default, { key: 'editor', model: _model2.default }),
          (0, _mithril2.default)(_preview2.default, { key: 'preview', body: _model2.default.mdBody() })
        ),
        (0, _mithril2.default)(Save, { model: _model2.default })
      );
    }
    return (0, _mithril2.default)(
      'div',
      null,
      '\u30C7\u30FC\u30BF\u53D6\u5F97\u4E2D...'
    );
  }
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _component = __webpack_require__(19);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_mithril2.default.mount(document.getElementById('main'), _component2.default);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _markdownIt = __webpack_require__(32);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md = new _markdownIt2.default();
var url = '/api/articles/' + location.href.split('/').slice(4).join('/');

var Model = {
  data: {},
  fetched: false,
  fetch: function fetch() {
    return _mithril2.default.request({
      method: 'GET',
      url: url
    }).then(function (response) {
      Model.fetched = true;
      Model.data = response;
    });
  },
  save: function save() {
    return _mithril2.default.request({
      method: 'POST',
      url: url
    }).then(function (response) {
      Model.data = response;
    });
  },
  mdBody: function mdBody() {
    return md.render(Model.data.body);
  }
};

exports.default = Model;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(4);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.oninput = function (v) {
      vnode.state.model.data.body = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'textarea',
      {
        className: _styles2.default.textarea,
        oninput: _mithril2.default.withAttr('value', vnode.state.oninput) },
      vnode.state.model.data.body
    );
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorLeftSide, inner: inner });
  }
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(4);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(vnode) {
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorRightSide,
      inner: _mithril2.default.trust(vnode.attrs.body) });
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(4);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.tags = v.split(',');
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.tags,
      onchange: _mithril2.default.withAttr('value', vnode.state.onchanage),
      value: vnode.state.model.data.tags.join(',')
    });
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

var _styles = __webpack_require__(4);

var _styles2 = _interopRequireDefault(_styles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.title = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.title,
      onchange: _mithril2.default.withAttr('value', vnode.state.onchange),
      value: vnode.state.model.data.title
    });
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(26);
var ieee754 = __webpack_require__(28);
var isArray = __webpack_require__(29);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//

function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(31)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(16).source;
  re.src_Cc = __webpack_require__(14).source;
  re.src_Z = __webpack_require__(15).source;
  re.src_P = __webpack_require__(7).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(38);

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Just a shortcut for bulk export


exports.parseLinkLabel = __webpack_require__(36);
exports.parseLinkDestination = __webpack_require__(35);
exports.parseLinkTitle = __webpack_require__(37);

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link destination
//


var isSpace = __webpack_require__(0).isSpace;
var unescapeAll = __webpack_require__(0).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
        if (level > 1) {
          break;
        }
      }

    if (code === 0x29 /* ) */) {
        level--;
        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//


module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link title
//


var unescapeAll = __webpack_require__(0).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Main parser class



var utils = __webpack_require__(0);
var helpers = __webpack_require__(34);
var Renderer = __webpack_require__(45);
var ParserCore = __webpack_require__(40);
var ParserBlock = __webpack_require__(39);
var ParserInline = __webpack_require__(41);
var LinkifyIt = __webpack_require__(30);
var mdurl = __webpack_require__(13);
var punycode = __webpack_require__(82);

var config = {
  'default': __webpack_require__(43),
  zero: __webpack_require__(44),
  commonmark: __webpack_require__(42)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - ``, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `''` for Russian, `''` for German, and
 *   `['\xA0', '\xA0', '\xA0', '\xA0']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/


var Ruler = __webpack_require__(5);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(57), ['paragraph', 'reference']], ['code', __webpack_require__(47)], ['fence', __webpack_require__(48), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(46), ['paragraph', 'reference', 'list']], ['hr', __webpack_require__(50), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(53), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(55)], ['heading', __webpack_require__(49), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(52)], ['html_block', __webpack_require__(51), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(54)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(56);

module.exports = ParserBlock;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/


var Ruler = __webpack_require__(5);

var _rules = [['normalize', __webpack_require__(61)], ['block', __webpack_require__(58)], ['inline', __webpack_require__(59)], ['linkify', __webpack_require__(60)], ['replacements', __webpack_require__(62)], ['smartquotes', __webpack_require__(63)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(64);

module.exports = Core;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/


var Ruler = __webpack_require__(5);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(75)], ['newline', __webpack_require__(73)], ['escape', __webpack_require__(69)], ['backticks', __webpack_require__(66)], ['strikethrough', __webpack_require__(12).tokenize], ['emphasis', __webpack_require__(11).tokenize], ['link', __webpack_require__(72)], ['image', __webpack_require__(71)], ['autolink', __webpack_require__(65)], ['html_inline', __webpack_require__(70)], ['entity', __webpack_require__(68)]];

var _rules2 = [['balance_pairs', __webpack_require__(67)], ['strikethrough', __webpack_require__(12).postProcess], ['emphasis', __webpack_require__(11).postProcess], ['text_collapse', __webpack_require__(76)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(74);

module.exports = ParserInline;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /*  */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// markdown-it default options



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /*  */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /*  */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign = __webpack_require__(0).assign;
var unescapeAll = __webpack_require__(0).unescapeAll;
var escapeHtml = __webpack_require__(0).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without mudofying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes



var isSpace = __webpack_require__(0).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      isOutdented,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    if (isOutdented) break;

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)



var isSpace = __webpack_require__(0).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule



var isSpace = __webpack_require__(0).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block



var block_names = __webpack_require__(33);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(10).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists



var isSpace = __webpack_require__(0).isSpace;

// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finilize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class



var Token = __webpack_require__(6);
var isSpace = __webpack_require__(0).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard



var isSpace = __webpack_require__(0).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//


var arrayReplaceAt = __webpack_require__(0).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Normalize input string



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographyc replacements
//
// (c) (C)  
// (tm) (TM)  
// (r) (R)  
// +-  
// (p) (P) -> 
// ...   (also ?....  ?.., !....  !..)
// ????????  ???, !!!!!  !!!, `,,`  `,`
// --  &ndash;, ---  &mdash;
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> , , 
// - miltiplication 2 x 4 -> 2  4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '',
  r: '',
  p: '',
  tm: ''
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '')
        // .., ..., ....... -> 
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '').replace(/([?!])/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//


var isWhiteSpace = __webpack_require__(0).isWhiteSpace;
var isPunctChar = __webpack_require__(0).isPunctChar;
var isMdAsciiPunct = __webpack_require__(0).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /*  */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Core state object
//


var Token = __webpack_require__(6);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'



/*eslint max-len:0*/

var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// For each opening emphasis-like marker find a matching closing one
//


module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities = __webpack_require__(9);
var has = __webpack_require__(0).has;
var isValidEntityCode = __webpack_require__(0).isValidEntityCode;
var fromCodePoint = __webpack_require__(0).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess escaped chars and hardbreaks



var isSpace = __webpack_require__(0).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags



var HTML_TAG_RE = __webpack_require__(10).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ![image](<src> "title")



var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [link](<to> "stuff")



var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'



var isSpace = __webpack_require__(0).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state



var Token = __webpack_require__(6);
var isWhiteSpace = __webpack_require__(0).isWhiteSpace;
var isPunctChar = __webpack_require__(0).isPunctChar;
var isMdAsciiPunct = __webpack_require__(0).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Merge adjacent text nodes into one, and re-calculate all token levels
//


module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(18)) == 'object' && __webpack_require__(18)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(88)(module), __webpack_require__(3)))

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(81)))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(83);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Any = __webpack_require__(16);
exports.Cc = __webpack_require__(14);
exports.Cf = __webpack_require__(86);
exports.P = __webpack_require__(7);
exports.Z = __webpack_require__(15);

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(8)(undefined);
// imports


// module
exports.push([module.i, "._2YrKEmruSXq-LY8HT9gjcA{position:relative;width:100%;height:calc(100% - 230px)}._3L5NEB84KxPflxBZveysdd{text-align:right;margin-top:15px}", ""]);

// exports
exports.locals = {
	"editorWrap": "_2YrKEmruSXq-LY8HT9gjcA",
	"saveButton": "_3L5NEB84KxPflxBZveysdd"
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(8)(undefined);
// imports


// module
exports.push([module.i, ".ZeW3HIwa_BWIGW0yZJi5G{width:100%;font-size:24pt;padding-left:10px}.ZcsaZvcof0txWdeqikCGZ{width:100%;font-size:18pt;padding-left:10px}._1ouasj646M7i9oKw-0Q_55{position:relative;width:100%;height:calc(100% - 230px)}._2MLWR8W_pHfNBkBmp0ni08{position:absolute;top:0;background:#fcfcfc;padding:10px;overflow:auto;height:100%}.GJYonSHLOXZJhPSUwZdvb{left:0}.u_RSyvBLD7b0Z12hpK8D4{left:50%;background-color:#fff}._2gAtgm9oADOrZYt1udmcJR{text-align:right;margin-top:15px}._3NBbIr4WlHyUQc29YW6bSX{width:100%;height:100%;resize:none;background-color:#fcfcfc;border:none;font-size:10pt}", ""]);

// exports
exports.locals = {
	"title": "ZeW3HIwa_BWIGW0yZJi5G",
	"tags": "ZcsaZvcof0txWdeqikCGZ",
	"editorWrap": "_1ouasj646M7i9oKw-0Q_55",
	"editor": "_2MLWR8W_pHfNBkBmp0ni08",
	"editorLeftSide": "GJYonSHLOXZJhPSUwZdvb",
	"editorRightSide": "u_RSyvBLD7b0Z12hpK8D4",
	"saveButton": "_2gAtgm9oADOrZYt1udmcJR",
	"textarea": "_3NBbIr4WlHyUQc29YW6bSX"
};

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = {
	"Aacute": "",
	"aacute": "",
	"Abreve": "",
	"abreve": "",
	"ac": "",
	"acd": "",
	"acE": "",
	"Acirc": "",
	"acirc": "",
	"acute": "",
	"Acy": "",
	"acy": "",
	"AElig": "",
	"aelig": "",
	"af": "",
	"Afr": "",
	"afr": "",
	"Agrave": "",
	"agrave": "",
	"alefsym": "",
	"aleph": "",
	"Alpha": "",
	"alpha": "",
	"Amacr": "",
	"amacr": "",
	"amalg": "",
	"amp": "&",
	"AMP": "&",
	"andand": "",
	"And": "",
	"and": "",
	"andd": "",
	"andslope": "",
	"andv": "",
	"ang": "",
	"ange": "",
	"angle": "",
	"angmsdaa": "",
	"angmsdab": "",
	"angmsdac": "",
	"angmsdad": "",
	"angmsdae": "",
	"angmsdaf": "",
	"angmsdag": "",
	"angmsdah": "",
	"angmsd": "",
	"angrt": "",
	"angrtvb": "",
	"angrtvbd": "",
	"angsph": "",
	"angst": "",
	"angzarr": "",
	"Aogon": "",
	"aogon": "",
	"Aopf": "",
	"aopf": "",
	"apacir": "",
	"ap": "",
	"apE": "",
	"ape": "",
	"apid": "",
	"apos": "'",
	"ApplyFunction": "",
	"approx": "",
	"approxeq": "",
	"Aring": "",
	"aring": "",
	"Ascr": "",
	"ascr": "",
	"Assign": "",
	"ast": "*",
	"asymp": "",
	"asympeq": "",
	"Atilde": "",
	"atilde": "",
	"Auml": "",
	"auml": "",
	"awconint": "",
	"awint": "",
	"backcong": "",
	"backepsilon": "",
	"backprime": "",
	"backsim": "",
	"backsimeq": "",
	"Backslash": "",
	"Barv": "",
	"barvee": "",
	"barwed": "",
	"Barwed": "",
	"barwedge": "",
	"bbrk": "",
	"bbrktbrk": "",
	"bcong": "",
	"Bcy": "",
	"bcy": "",
	"bdquo": "",
	"becaus": "",
	"because": "",
	"Because": "",
	"bemptyv": "",
	"bepsi": "",
	"bernou": "",
	"Bernoullis": "",
	"Beta": "",
	"beta": "",
	"beth": "",
	"between": "",
	"Bfr": "",
	"bfr": "",
	"bigcap": "",
	"bigcirc": "",
	"bigcup": "",
	"bigodot": "",
	"bigoplus": "",
	"bigotimes": "",
	"bigsqcup": "",
	"bigstar": "",
	"bigtriangledown": "",
	"bigtriangleup": "",
	"biguplus": "",
	"bigvee": "",
	"bigwedge": "",
	"bkarow": "",
	"blacklozenge": "",
	"blacksquare": "",
	"blacktriangle": "",
	"blacktriangledown": "",
	"blacktriangleleft": "",
	"blacktriangleright": "",
	"blank": "",
	"blk12": "",
	"blk14": "",
	"blk34": "",
	"block": "",
	"bne": "=",
	"bnequiv": "",
	"bNot": "",
	"bnot": "",
	"Bopf": "",
	"bopf": "",
	"bot": "",
	"bottom": "",
	"bowtie": "",
	"boxbox": "",
	"boxdl": "",
	"boxdL": "",
	"boxDl": "",
	"boxDL": "",
	"boxdr": "",
	"boxdR": "",
	"boxDr": "",
	"boxDR": "",
	"boxh": "",
	"boxH": "",
	"boxhd": "",
	"boxHd": "",
	"boxhD": "",
	"boxHD": "",
	"boxhu": "",
	"boxHu": "",
	"boxhU": "",
	"boxHU": "",
	"boxminus": "",
	"boxplus": "",
	"boxtimes": "",
	"boxul": "",
	"boxuL": "",
	"boxUl": "",
	"boxUL": "",
	"boxur": "",
	"boxuR": "",
	"boxUr": "",
	"boxUR": "",
	"boxv": "",
	"boxV": "",
	"boxvh": "",
	"boxvH": "",
	"boxVh": "",
	"boxVH": "",
	"boxvl": "",
	"boxvL": "",
	"boxVl": "",
	"boxVL": "",
	"boxvr": "",
	"boxvR": "",
	"boxVr": "",
	"boxVR": "",
	"bprime": "",
	"breve": "",
	"Breve": "",
	"brvbar": "",
	"bscr": "",
	"Bscr": "",
	"bsemi": "",
	"bsim": "",
	"bsime": "",
	"bsolb": "",
	"bsol": "\\",
	"bsolhsub": "",
	"bull": "",
	"bullet": "",
	"bump": "",
	"bumpE": "",
	"bumpe": "",
	"Bumpeq": "",
	"bumpeq": "",
	"Cacute": "",
	"cacute": "",
	"capand": "",
	"capbrcup": "",
	"capcap": "",
	"cap": "",
	"Cap": "",
	"capcup": "",
	"capdot": "",
	"CapitalDifferentialD": "",
	"caps": "",
	"caret": "",
	"caron": "",
	"Cayleys": "",
	"ccaps": "",
	"Ccaron": "",
	"ccaron": "",
	"Ccedil": "",
	"ccedil": "",
	"Ccirc": "",
	"ccirc": "",
	"Cconint": "",
	"ccups": "",
	"ccupssm": "",
	"Cdot": "",
	"cdot": "",
	"cedil": "",
	"Cedilla": "",
	"cemptyv": "",
	"cent": "",
	"centerdot": "",
	"CenterDot": "",
	"cfr": "",
	"Cfr": "",
	"CHcy": "",
	"chcy": "",
	"check": "",
	"checkmark": "",
	"Chi": "",
	"chi": "",
	"circ": "",
	"circeq": "",
	"circlearrowleft": "",
	"circlearrowright": "",
	"circledast": "",
	"circledcirc": "",
	"circleddash": "",
	"CircleDot": "",
	"circledR": "",
	"circledS": "",
	"CircleMinus": "",
	"CirclePlus": "",
	"CircleTimes": "",
	"cir": "",
	"cirE": "",
	"cire": "",
	"cirfnint": "",
	"cirmid": "",
	"cirscir": "",
	"ClockwiseContourIntegral": "",
	"CloseCurlyDoubleQuote": "",
	"CloseCurlyQuote": "",
	"clubs": "",
	"clubsuit": "",
	"colon": ":",
	"Colon": "",
	"Colone": "",
	"colone": "",
	"coloneq": "",
	"comma": ",",
	"commat": "@",
	"comp": "",
	"compfn": "",
	"complement": "",
	"complexes": "",
	"cong": "",
	"congdot": "",
	"Congruent": "",
	"conint": "",
	"Conint": "",
	"ContourIntegral": "",
	"copf": "",
	"Copf": "",
	"coprod": "",
	"Coproduct": "",
	"copy": "",
	"COPY": "",
	"copysr": "",
	"CounterClockwiseContourIntegral": "",
	"crarr": "",
	"cross": "",
	"Cross": "",
	"Cscr": "",
	"cscr": "",
	"csub": "",
	"csube": "",
	"csup": "",
	"csupe": "",
	"ctdot": "",
	"cudarrl": "",
	"cudarrr": "",
	"cuepr": "",
	"cuesc": "",
	"cularr": "",
	"cularrp": "",
	"cupbrcap": "",
	"cupcap": "",
	"CupCap": "",
	"cup": "",
	"Cup": "",
	"cupcup": "",
	"cupdot": "",
	"cupor": "",
	"cups": "",
	"curarr": "",
	"curarrm": "",
	"curlyeqprec": "",
	"curlyeqsucc": "",
	"curlyvee": "",
	"curlywedge": "",
	"curren": "",
	"curvearrowleft": "",
	"curvearrowright": "",
	"cuvee": "",
	"cuwed": "",
	"cwconint": "",
	"cwint": "",
	"cylcty": "",
	"dagger": "",
	"Dagger": "",
	"daleth": "",
	"darr": "",
	"Darr": "",
	"dArr": "",
	"dash": "",
	"Dashv": "",
	"dashv": "",
	"dbkarow": "",
	"dblac": "",
	"Dcaron": "",
	"dcaron": "",
	"Dcy": "",
	"dcy": "",
	"ddagger": "",
	"ddarr": "",
	"DD": "",
	"dd": "",
	"DDotrahd": "",
	"ddotseq": "",
	"deg": "",
	"Del": "",
	"Delta": "",
	"delta": "",
	"demptyv": "",
	"dfisht": "",
	"Dfr": "",
	"dfr": "",
	"dHar": "",
	"dharl": "",
	"dharr": "",
	"DiacriticalAcute": "",
	"DiacriticalDot": "",
	"DiacriticalDoubleAcute": "",
	"DiacriticalGrave": "`",
	"DiacriticalTilde": "",
	"diam": "",
	"diamond": "",
	"Diamond": "",
	"diamondsuit": "",
	"diams": "",
	"die": "",
	"DifferentialD": "",
	"digamma": "",
	"disin": "",
	"div": "",
	"divide": "",
	"divideontimes": "",
	"divonx": "",
	"DJcy": "",
	"djcy": "",
	"dlcorn": "",
	"dlcrop": "",
	"dollar": "$",
	"Dopf": "",
	"dopf": "",
	"Dot": "",
	"dot": "",
	"DotDot": "",
	"doteq": "",
	"doteqdot": "",
	"DotEqual": "",
	"dotminus": "",
	"dotplus": "",
	"dotsquare": "",
	"doublebarwedge": "",
	"DoubleContourIntegral": "",
	"DoubleDot": "",
	"DoubleDownArrow": "",
	"DoubleLeftArrow": "",
	"DoubleLeftRightArrow": "",
	"DoubleLeftTee": "",
	"DoubleLongLeftArrow": "",
	"DoubleLongLeftRightArrow": "",
	"DoubleLongRightArrow": "",
	"DoubleRightArrow": "",
	"DoubleRightTee": "",
	"DoubleUpArrow": "",
	"DoubleUpDownArrow": "",
	"DoubleVerticalBar": "",
	"DownArrowBar": "",
	"downarrow": "",
	"DownArrow": "",
	"Downarrow": "",
	"DownArrowUpArrow": "",
	"DownBreve": "",
	"downdownarrows": "",
	"downharpoonleft": "",
	"downharpoonright": "",
	"DownLeftRightVector": "",
	"DownLeftTeeVector": "",
	"DownLeftVectorBar": "",
	"DownLeftVector": "",
	"DownRightTeeVector": "",
	"DownRightVectorBar": "",
	"DownRightVector": "",
	"DownTeeArrow": "",
	"DownTee": "",
	"drbkarow": "",
	"drcorn": "",
	"drcrop": "",
	"Dscr": "",
	"dscr": "",
	"DScy": "",
	"dscy": "",
	"dsol": "",
	"Dstrok": "",
	"dstrok": "",
	"dtdot": "",
	"dtri": "",
	"dtrif": "",
	"duarr": "",
	"duhar": "",
	"dwangle": "",
	"DZcy": "",
	"dzcy": "",
	"dzigrarr": "",
	"Eacute": "",
	"eacute": "",
	"easter": "",
	"Ecaron": "",
	"ecaron": "",
	"Ecirc": "",
	"ecirc": "",
	"ecir": "",
	"ecolon": "",
	"Ecy": "",
	"ecy": "",
	"eDDot": "",
	"Edot": "",
	"edot": "",
	"eDot": "",
	"ee": "",
	"efDot": "",
	"Efr": "",
	"efr": "",
	"eg": "",
	"Egrave": "",
	"egrave": "",
	"egs": "",
	"egsdot": "",
	"el": "",
	"Element": "",
	"elinters": "",
	"ell": "",
	"els": "",
	"elsdot": "",
	"Emacr": "",
	"emacr": "",
	"empty": "",
	"emptyset": "",
	"EmptySmallSquare": "",
	"emptyv": "",
	"EmptyVerySmallSquare": "",
	"emsp13": "",
	"emsp14": "",
	"emsp": "",
	"ENG": "",
	"eng": "",
	"ensp": "",
	"Eogon": "",
	"eogon": "",
	"Eopf": "",
	"eopf": "",
	"epar": "",
	"eparsl": "",
	"eplus": "",
	"epsi": "",
	"Epsilon": "",
	"epsilon": "",
	"epsiv": "",
	"eqcirc": "",
	"eqcolon": "",
	"eqsim": "",
	"eqslantgtr": "",
	"eqslantless": "",
	"Equal": "",
	"equals": "=",
	"EqualTilde": "",
	"equest": "",
	"Equilibrium": "",
	"equiv": "",
	"equivDD": "",
	"eqvparsl": "",
	"erarr": "",
	"erDot": "",
	"escr": "",
	"Escr": "",
	"esdot": "",
	"Esim": "",
	"esim": "",
	"Eta": "",
	"eta": "",
	"ETH": "",
	"eth": "",
	"Euml": "",
	"euml": "",
	"euro": "",
	"excl": "!",
	"exist": "",
	"Exists": "",
	"expectation": "",
	"exponentiale": "",
	"ExponentialE": "",
	"fallingdotseq": "",
	"Fcy": "",
	"fcy": "",
	"female": "",
	"ffilig": "",
	"fflig": "",
	"ffllig": "",
	"Ffr": "",
	"ffr": "",
	"filig": "",
	"FilledSmallSquare": "",
	"FilledVerySmallSquare": "",
	"fjlig": "fj",
	"flat": "",
	"fllig": "",
	"fltns": "",
	"fnof": "",
	"Fopf": "",
	"fopf": "",
	"forall": "",
	"ForAll": "",
	"fork": "",
	"forkv": "",
	"Fouriertrf": "",
	"fpartint": "",
	"frac12": "",
	"frac13": "",
	"frac14": "",
	"frac15": "",
	"frac16": "",
	"frac18": "",
	"frac23": "",
	"frac25": "",
	"frac34": "",
	"frac35": "",
	"frac38": "",
	"frac45": "",
	"frac56": "",
	"frac58": "",
	"frac78": "",
	"frasl": "",
	"frown": "",
	"fscr": "",
	"Fscr": "",
	"gacute": "",
	"Gamma": "",
	"gamma": "",
	"Gammad": "",
	"gammad": "",
	"gap": "",
	"Gbreve": "",
	"gbreve": "",
	"Gcedil": "",
	"Gcirc": "",
	"gcirc": "",
	"Gcy": "",
	"gcy": "",
	"Gdot": "",
	"gdot": "",
	"ge": "",
	"gE": "",
	"gEl": "",
	"gel": "",
	"geq": "",
	"geqq": "",
	"geqslant": "",
	"gescc": "",
	"ges": "",
	"gesdot": "",
	"gesdoto": "",
	"gesdotol": "",
	"gesl": "",
	"gesles": "",
	"Gfr": "",
	"gfr": "",
	"gg": "",
	"Gg": "",
	"ggg": "",
	"gimel": "",
	"GJcy": "",
	"gjcy": "",
	"gla": "",
	"gl": "",
	"glE": "",
	"glj": "",
	"gnap": "",
	"gnapprox": "",
	"gne": "",
	"gnE": "",
	"gneq": "",
	"gneqq": "",
	"gnsim": "",
	"Gopf": "",
	"gopf": "",
	"grave": "`",
	"GreaterEqual": "",
	"GreaterEqualLess": "",
	"GreaterFullEqual": "",
	"GreaterGreater": "",
	"GreaterLess": "",
	"GreaterSlantEqual": "",
	"GreaterTilde": "",
	"Gscr": "",
	"gscr": "",
	"gsim": "",
	"gsime": "",
	"gsiml": "",
	"gtcc": "",
	"gtcir": "",
	"gt": ">",
	"GT": ">",
	"Gt": "",
	"gtdot": "",
	"gtlPar": "",
	"gtquest": "",
	"gtrapprox": "",
	"gtrarr": "",
	"gtrdot": "",
	"gtreqless": "",
	"gtreqqless": "",
	"gtrless": "",
	"gtrsim": "",
	"gvertneqq": "",
	"gvnE": "",
	"Hacek": "",
	"hairsp": "",
	"half": "",
	"hamilt": "",
	"HARDcy": "",
	"hardcy": "",
	"harrcir": "",
	"harr": "",
	"hArr": "",
	"harrw": "",
	"Hat": "^",
	"hbar": "",
	"Hcirc": "",
	"hcirc": "",
	"hearts": "",
	"heartsuit": "",
	"hellip": "",
	"hercon": "",
	"hfr": "",
	"Hfr": "",
	"HilbertSpace": "",
	"hksearow": "",
	"hkswarow": "",
	"hoarr": "",
	"homtht": "",
	"hookleftarrow": "",
	"hookrightarrow": "",
	"hopf": "",
	"Hopf": "",
	"horbar": "",
	"HorizontalLine": "",
	"hscr": "",
	"Hscr": "",
	"hslash": "",
	"Hstrok": "",
	"hstrok": "",
	"HumpDownHump": "",
	"HumpEqual": "",
	"hybull": "",
	"hyphen": "",
	"Iacute": "",
	"iacute": "",
	"ic": "",
	"Icirc": "",
	"icirc": "",
	"Icy": "",
	"icy": "",
	"Idot": "",
	"IEcy": "",
	"iecy": "",
	"iexcl": "",
	"iff": "",
	"ifr": "",
	"Ifr": "",
	"Igrave": "",
	"igrave": "",
	"ii": "",
	"iiiint": "",
	"iiint": "",
	"iinfin": "",
	"iiota": "",
	"IJlig": "",
	"ijlig": "",
	"Imacr": "",
	"imacr": "",
	"image": "",
	"ImaginaryI": "",
	"imagline": "",
	"imagpart": "",
	"imath": "",
	"Im": "",
	"imof": "",
	"imped": "",
	"Implies": "",
	"incare": "",
	"in": "",
	"infin": "",
	"infintie": "",
	"inodot": "",
	"intcal": "",
	"int": "",
	"Int": "",
	"integers": "",
	"Integral": "",
	"intercal": "",
	"Intersection": "",
	"intlarhk": "",
	"intprod": "",
	"InvisibleComma": "",
	"InvisibleTimes": "",
	"IOcy": "",
	"iocy": "",
	"Iogon": "",
	"iogon": "",
	"Iopf": "",
	"iopf": "",
	"Iota": "",
	"iota": "",
	"iprod": "",
	"iquest": "",
	"iscr": "",
	"Iscr": "",
	"isin": "",
	"isindot": "",
	"isinE": "",
	"isins": "",
	"isinsv": "",
	"isinv": "",
	"it": "",
	"Itilde": "",
	"itilde": "",
	"Iukcy": "",
	"iukcy": "",
	"Iuml": "",
	"iuml": "",
	"Jcirc": "",
	"jcirc": "",
	"Jcy": "",
	"jcy": "",
	"Jfr": "",
	"jfr": "",
	"jmath": "",
	"Jopf": "",
	"jopf": "",
	"Jscr": "",
	"jscr": "",
	"Jsercy": "",
	"jsercy": "",
	"Jukcy": "",
	"jukcy": "",
	"Kappa": "",
	"kappa": "",
	"kappav": "",
	"Kcedil": "",
	"kcedil": "",
	"Kcy": "",
	"kcy": "",
	"Kfr": "",
	"kfr": "",
	"kgreen": "",
	"KHcy": "",
	"khcy": "",
	"KJcy": "",
	"kjcy": "",
	"Kopf": "",
	"kopf": "",
	"Kscr": "",
	"kscr": "",
	"lAarr": "",
	"Lacute": "",
	"lacute": "",
	"laemptyv": "",
	"lagran": "",
	"Lambda": "",
	"lambda": "",
	"lang": "",
	"Lang": "",
	"langd": "",
	"langle": "",
	"lap": "",
	"Laplacetrf": "",
	"laquo": "",
	"larrb": "",
	"larrbfs": "",
	"larr": "",
	"Larr": "",
	"lArr": "",
	"larrfs": "",
	"larrhk": "",
	"larrlp": "",
	"larrpl": "",
	"larrsim": "",
	"larrtl": "",
	"latail": "",
	"lAtail": "",
	"lat": "",
	"late": "",
	"lates": "",
	"lbarr": "",
	"lBarr": "",
	"lbbrk": "",
	"lbrace": "{",
	"lbrack": "[",
	"lbrke": "",
	"lbrksld": "",
	"lbrkslu": "",
	"Lcaron": "",
	"lcaron": "",
	"Lcedil": "",
	"lcedil": "",
	"lceil": "",
	"lcub": "{",
	"Lcy": "",
	"lcy": "",
	"ldca": "",
	"ldquo": "",
	"ldquor": "",
	"ldrdhar": "",
	"ldrushar": "",
	"ldsh": "",
	"le": "",
	"lE": "",
	"LeftAngleBracket": "",
	"LeftArrowBar": "",
	"leftarrow": "",
	"LeftArrow": "",
	"Leftarrow": "",
	"LeftArrowRightArrow": "",
	"leftarrowtail": "",
	"LeftCeiling": "",
	"LeftDoubleBracket": "",
	"LeftDownTeeVector": "",
	"LeftDownVectorBar": "",
	"LeftDownVector": "",
	"LeftFloor": "",
	"leftharpoondown": "",
	"leftharpoonup": "",
	"leftleftarrows": "",
	"leftrightarrow": "",
	"LeftRightArrow": "",
	"Leftrightarrow": "",
	"leftrightarrows": "",
	"leftrightharpoons": "",
	"leftrightsquigarrow": "",
	"LeftRightVector": "",
	"LeftTeeArrow": "",
	"LeftTee": "",
	"LeftTeeVector": "",
	"leftthreetimes": "",
	"LeftTriangleBar": "",
	"LeftTriangle": "",
	"LeftTriangleEqual": "",
	"LeftUpDownVector": "",
	"LeftUpTeeVector": "",
	"LeftUpVectorBar": "",
	"LeftUpVector": "",
	"LeftVectorBar": "",
	"LeftVector": "",
	"lEg": "",
	"leg": "",
	"leq": "",
	"leqq": "",
	"leqslant": "",
	"lescc": "",
	"les": "",
	"lesdot": "",
	"lesdoto": "",
	"lesdotor": "",
	"lesg": "",
	"lesges": "",
	"lessapprox": "",
	"lessdot": "",
	"lesseqgtr": "",
	"lesseqqgtr": "",
	"LessEqualGreater": "",
	"LessFullEqual": "",
	"LessGreater": "",
	"lessgtr": "",
	"LessLess": "",
	"lesssim": "",
	"LessSlantEqual": "",
	"LessTilde": "",
	"lfisht": "",
	"lfloor": "",
	"Lfr": "",
	"lfr": "",
	"lg": "",
	"lgE": "",
	"lHar": "",
	"lhard": "",
	"lharu": "",
	"lharul": "",
	"lhblk": "",
	"LJcy": "",
	"ljcy": "",
	"llarr": "",
	"ll": "",
	"Ll": "",
	"llcorner": "",
	"Lleftarrow": "",
	"llhard": "",
	"lltri": "",
	"Lmidot": "",
	"lmidot": "",
	"lmoustache": "",
	"lmoust": "",
	"lnap": "",
	"lnapprox": "",
	"lne": "",
	"lnE": "",
	"lneq": "",
	"lneqq": "",
	"lnsim": "",
	"loang": "",
	"loarr": "",
	"lobrk": "",
	"longleftarrow": "",
	"LongLeftArrow": "",
	"Longleftarrow": "",
	"longleftrightarrow": "",
	"LongLeftRightArrow": "",
	"Longleftrightarrow": "",
	"longmapsto": "",
	"longrightarrow": "",
	"LongRightArrow": "",
	"Longrightarrow": "",
	"looparrowleft": "",
	"looparrowright": "",
	"lopar": "",
	"Lopf": "",
	"lopf": "",
	"loplus": "",
	"lotimes": "",
	"lowast": "",
	"lowbar": "_",
	"LowerLeftArrow": "",
	"LowerRightArrow": "",
	"loz": "",
	"lozenge": "",
	"lozf": "",
	"lpar": "(",
	"lparlt": "",
	"lrarr": "",
	"lrcorner": "",
	"lrhar": "",
	"lrhard": "",
	"lrm": "",
	"lrtri": "",
	"lsaquo": "",
	"lscr": "",
	"Lscr": "",
	"lsh": "",
	"Lsh": "",
	"lsim": "",
	"lsime": "",
	"lsimg": "",
	"lsqb": "[",
	"lsquo": "",
	"lsquor": "",
	"Lstrok": "",
	"lstrok": "",
	"ltcc": "",
	"ltcir": "",
	"lt": "<",
	"LT": "<",
	"Lt": "",
	"ltdot": "",
	"lthree": "",
	"ltimes": "",
	"ltlarr": "",
	"ltquest": "",
	"ltri": "",
	"ltrie": "",
	"ltrif": "",
	"ltrPar": "",
	"lurdshar": "",
	"luruhar": "",
	"lvertneqq": "",
	"lvnE": "",
	"macr": "",
	"male": "",
	"malt": "",
	"maltese": "",
	"Map": "",
	"map": "",
	"mapsto": "",
	"mapstodown": "",
	"mapstoleft": "",
	"mapstoup": "",
	"marker": "",
	"mcomma": "",
	"Mcy": "",
	"mcy": "",
	"mdash": "",
	"mDDot": "",
	"measuredangle": "",
	"MediumSpace": "",
	"Mellintrf": "",
	"Mfr": "",
	"mfr": "",
	"mho": "",
	"micro": "",
	"midast": "*",
	"midcir": "",
	"mid": "",
	"middot": "",
	"minusb": "",
	"minus": "",
	"minusd": "",
	"minusdu": "",
	"MinusPlus": "",
	"mlcp": "",
	"mldr": "",
	"mnplus": "",
	"models": "",
	"Mopf": "",
	"mopf": "",
	"mp": "",
	"mscr": "",
	"Mscr": "",
	"mstpos": "",
	"Mu": "",
	"mu": "",
	"multimap": "",
	"mumap": "",
	"nabla": "",
	"Nacute": "",
	"nacute": "",
	"nang": "",
	"nap": "",
	"napE": "",
	"napid": "",
	"napos": "",
	"napprox": "",
	"natural": "",
	"naturals": "",
	"natur": "",
	"nbsp": "",
	"nbump": "",
	"nbumpe": "",
	"ncap": "",
	"Ncaron": "",
	"ncaron": "",
	"Ncedil": "",
	"ncedil": "",
	"ncong": "",
	"ncongdot": "",
	"ncup": "",
	"Ncy": "",
	"ncy": "",
	"ndash": "",
	"nearhk": "",
	"nearr": "",
	"neArr": "",
	"nearrow": "",
	"ne": "",
	"nedot": "",
	"NegativeMediumSpace": "",
	"NegativeThickSpace": "",
	"NegativeThinSpace": "",
	"NegativeVeryThinSpace": "",
	"nequiv": "",
	"nesear": "",
	"nesim": "",
	"NestedGreaterGreater": "",
	"NestedLessLess": "",
	"NewLine": "\n",
	"nexist": "",
	"nexists": "",
	"Nfr": "",
	"nfr": "",
	"ngE": "",
	"nge": "",
	"ngeq": "",
	"ngeqq": "",
	"ngeqslant": "",
	"nges": "",
	"nGg": "",
	"ngsim": "",
	"nGt": "",
	"ngt": "",
	"ngtr": "",
	"nGtv": "",
	"nharr": "",
	"nhArr": "",
	"nhpar": "",
	"ni": "",
	"nis": "",
	"nisd": "",
	"niv": "",
	"NJcy": "",
	"njcy": "",
	"nlarr": "",
	"nlArr": "",
	"nldr": "",
	"nlE": "",
	"nle": "",
	"nleftarrow": "",
	"nLeftarrow": "",
	"nleftrightarrow": "",
	"nLeftrightarrow": "",
	"nleq": "",
	"nleqq": "",
	"nleqslant": "",
	"nles": "",
	"nless": "",
	"nLl": "",
	"nlsim": "",
	"nLt": "",
	"nlt": "",
	"nltri": "",
	"nltrie": "",
	"nLtv": "",
	"nmid": "",
	"NoBreak": "",
	"NonBreakingSpace": "",
	"nopf": "",
	"Nopf": "",
	"Not": "",
	"not": "",
	"NotCongruent": "",
	"NotCupCap": "",
	"NotDoubleVerticalBar": "",
	"NotElement": "",
	"NotEqual": "",
	"NotEqualTilde": "",
	"NotExists": "",
	"NotGreater": "",
	"NotGreaterEqual": "",
	"NotGreaterFullEqual": "",
	"NotGreaterGreater": "",
	"NotGreaterLess": "",
	"NotGreaterSlantEqual": "",
	"NotGreaterTilde": "",
	"NotHumpDownHump": "",
	"NotHumpEqual": "",
	"notin": "",
	"notindot": "",
	"notinE": "",
	"notinva": "",
	"notinvb": "",
	"notinvc": "",
	"NotLeftTriangleBar": "",
	"NotLeftTriangle": "",
	"NotLeftTriangleEqual": "",
	"NotLess": "",
	"NotLessEqual": "",
	"NotLessGreater": "",
	"NotLessLess": "",
	"NotLessSlantEqual": "",
	"NotLessTilde": "",
	"NotNestedGreaterGreater": "",
	"NotNestedLessLess": "",
	"notni": "",
	"notniva": "",
	"notnivb": "",
	"notnivc": "",
	"NotPrecedes": "",
	"NotPrecedesEqual": "",
	"NotPrecedesSlantEqual": "",
	"NotReverseElement": "",
	"NotRightTriangleBar": "",
	"NotRightTriangle": "",
	"NotRightTriangleEqual": "",
	"NotSquareSubset": "",
	"NotSquareSubsetEqual": "",
	"NotSquareSuperset": "",
	"NotSquareSupersetEqual": "",
	"NotSubset": "",
	"NotSubsetEqual": "",
	"NotSucceeds": "",
	"NotSucceedsEqual": "",
	"NotSucceedsSlantEqual": "",
	"NotSucceedsTilde": "",
	"NotSuperset": "",
	"NotSupersetEqual": "",
	"NotTilde": "",
	"NotTildeEqual": "",
	"NotTildeFullEqual": "",
	"NotTildeTilde": "",
	"NotVerticalBar": "",
	"nparallel": "",
	"npar": "",
	"nparsl": "",
	"npart": "",
	"npolint": "",
	"npr": "",
	"nprcue": "",
	"nprec": "",
	"npreceq": "",
	"npre": "",
	"nrarrc": "",
	"nrarr": "",
	"nrArr": "",
	"nrarrw": "",
	"nrightarrow": "",
	"nRightarrow": "",
	"nrtri": "",
	"nrtrie": "",
	"nsc": "",
	"nsccue": "",
	"nsce": "",
	"Nscr": "",
	"nscr": "",
	"nshortmid": "",
	"nshortparallel": "",
	"nsim": "",
	"nsime": "",
	"nsimeq": "",
	"nsmid": "",
	"nspar": "",
	"nsqsube": "",
	"nsqsupe": "",
	"nsub": "",
	"nsubE": "",
	"nsube": "",
	"nsubset": "",
	"nsubseteq": "",
	"nsubseteqq": "",
	"nsucc": "",
	"nsucceq": "",
	"nsup": "",
	"nsupE": "",
	"nsupe": "",
	"nsupset": "",
	"nsupseteq": "",
	"nsupseteqq": "",
	"ntgl": "",
	"Ntilde": "",
	"ntilde": "",
	"ntlg": "",
	"ntriangleleft": "",
	"ntrianglelefteq": "",
	"ntriangleright": "",
	"ntrianglerighteq": "",
	"Nu": "",
	"nu": "",
	"num": "#",
	"numero": "",
	"numsp": "",
	"nvap": "",
	"nvdash": "",
	"nvDash": "",
	"nVdash": "",
	"nVDash": "",
	"nvge": "",
	"nvgt": ">",
	"nvHarr": "",
	"nvinfin": "",
	"nvlArr": "",
	"nvle": "",
	"nvlt": "<",
	"nvltrie": "",
	"nvrArr": "",
	"nvrtrie": "",
	"nvsim": "",
	"nwarhk": "",
	"nwarr": "",
	"nwArr": "",
	"nwarrow": "",
	"nwnear": "",
	"Oacute": "",
	"oacute": "",
	"oast": "",
	"Ocirc": "",
	"ocirc": "",
	"ocir": "",
	"Ocy": "",
	"ocy": "",
	"odash": "",
	"Odblac": "",
	"odblac": "",
	"odiv": "",
	"odot": "",
	"odsold": "",
	"OElig": "",
	"oelig": "",
	"ofcir": "",
	"Ofr": "",
	"ofr": "",
	"ogon": "",
	"Ograve": "",
	"ograve": "",
	"ogt": "",
	"ohbar": "",
	"ohm": "",
	"oint": "",
	"olarr": "",
	"olcir": "",
	"olcross": "",
	"oline": "",
	"olt": "",
	"Omacr": "",
	"omacr": "",
	"Omega": "",
	"omega": "",
	"Omicron": "",
	"omicron": "",
	"omid": "",
	"ominus": "",
	"Oopf": "",
	"oopf": "",
	"opar": "",
	"OpenCurlyDoubleQuote": "",
	"OpenCurlyQuote": "",
	"operp": "",
	"oplus": "",
	"orarr": "",
	"Or": "",
	"or": "",
	"ord": "",
	"order": "",
	"orderof": "",
	"ordf": "",
	"ordm": "",
	"origof": "",
	"oror": "",
	"orslope": "",
	"orv": "",
	"oS": "",
	"Oscr": "",
	"oscr": "",
	"Oslash": "",
	"oslash": "",
	"osol": "",
	"Otilde": "",
	"otilde": "",
	"otimesas": "",
	"Otimes": "",
	"otimes": "",
	"Ouml": "",
	"ouml": "",
	"ovbar": "",
	"OverBar": "",
	"OverBrace": "",
	"OverBracket": "",
	"OverParenthesis": "",
	"para": "",
	"parallel": "",
	"par": "",
	"parsim": "",
	"parsl": "",
	"part": "",
	"PartialD": "",
	"Pcy": "",
	"pcy": "",
	"percnt": "%",
	"period": ".",
	"permil": "",
	"perp": "",
	"pertenk": "",
	"Pfr": "",
	"pfr": "",
	"Phi": "",
	"phi": "",
	"phiv": "",
	"phmmat": "",
	"phone": "",
	"Pi": "",
	"pi": "",
	"pitchfork": "",
	"piv": "",
	"planck": "",
	"planckh": "",
	"plankv": "",
	"plusacir": "",
	"plusb": "",
	"pluscir": "",
	"plus": "+",
	"plusdo": "",
	"plusdu": "",
	"pluse": "",
	"PlusMinus": "",
	"plusmn": "",
	"plussim": "",
	"plustwo": "",
	"pm": "",
	"Poincareplane": "",
	"pointint": "",
	"popf": "",
	"Popf": "",
	"pound": "",
	"prap": "",
	"Pr": "",
	"pr": "",
	"prcue": "",
	"precapprox": "",
	"prec": "",
	"preccurlyeq": "",
	"Precedes": "",
	"PrecedesEqual": "",
	"PrecedesSlantEqual": "",
	"PrecedesTilde": "",
	"preceq": "",
	"precnapprox": "",
	"precneqq": "",
	"precnsim": "",
	"pre": "",
	"prE": "",
	"precsim": "",
	"prime": "",
	"Prime": "",
	"primes": "",
	"prnap": "",
	"prnE": "",
	"prnsim": "",
	"prod": "",
	"Product": "",
	"profalar": "",
	"profline": "",
	"profsurf": "",
	"prop": "",
	"Proportional": "",
	"Proportion": "",
	"propto": "",
	"prsim": "",
	"prurel": "",
	"Pscr": "",
	"pscr": "",
	"Psi": "",
	"psi": "",
	"puncsp": "",
	"Qfr": "",
	"qfr": "",
	"qint": "",
	"qopf": "",
	"Qopf": "",
	"qprime": "",
	"Qscr": "",
	"qscr": "",
	"quaternions": "",
	"quatint": "",
	"quest": "?",
	"questeq": "",
	"quot": "\"",
	"QUOT": "\"",
	"rAarr": "",
	"race": "",
	"Racute": "",
	"racute": "",
	"radic": "",
	"raemptyv": "",
	"rang": "",
	"Rang": "",
	"rangd": "",
	"range": "",
	"rangle": "",
	"raquo": "",
	"rarrap": "",
	"rarrb": "",
	"rarrbfs": "",
	"rarrc": "",
	"rarr": "",
	"Rarr": "",
	"rArr": "",
	"rarrfs": "",
	"rarrhk": "",
	"rarrlp": "",
	"rarrpl": "",
	"rarrsim": "",
	"Rarrtl": "",
	"rarrtl": "",
	"rarrw": "",
	"ratail": "",
	"rAtail": "",
	"ratio": "",
	"rationals": "",
	"rbarr": "",
	"rBarr": "",
	"RBarr": "",
	"rbbrk": "",
	"rbrace": "}",
	"rbrack": "]",
	"rbrke": "",
	"rbrksld": "",
	"rbrkslu": "",
	"Rcaron": "",
	"rcaron": "",
	"Rcedil": "",
	"rcedil": "",
	"rceil": "",
	"rcub": "}",
	"Rcy": "",
	"rcy": "",
	"rdca": "",
	"rdldhar": "",
	"rdquo": "",
	"rdquor": "",
	"rdsh": "",
	"real": "",
	"realine": "",
	"realpart": "",
	"reals": "",
	"Re": "",
	"rect": "",
	"reg": "",
	"REG": "",
	"ReverseElement": "",
	"ReverseEquilibrium": "",
	"ReverseUpEquilibrium": "",
	"rfisht": "",
	"rfloor": "",
	"rfr": "",
	"Rfr": "",
	"rHar": "",
	"rhard": "",
	"rharu": "",
	"rharul": "",
	"Rho": "",
	"rho": "",
	"rhov": "",
	"RightAngleBracket": "",
	"RightArrowBar": "",
	"rightarrow": "",
	"RightArrow": "",
	"Rightarrow": "",
	"RightArrowLeftArrow": "",
	"rightarrowtail": "",
	"RightCeiling": "",
	"RightDoubleBracket": "",
	"RightDownTeeVector": "",
	"RightDownVectorBar": "",
	"RightDownVector": "",
	"RightFloor": "",
	"rightharpoondown": "",
	"rightharpoonup": "",
	"rightleftarrows": "",
	"rightleftharpoons": "",
	"rightrightarrows": "",
	"rightsquigarrow": "",
	"RightTeeArrow": "",
	"RightTee": "",
	"RightTeeVector": "",
	"rightthreetimes": "",
	"RightTriangleBar": "",
	"RightTriangle": "",
	"RightTriangleEqual": "",
	"RightUpDownVector": "",
	"RightUpTeeVector": "",
	"RightUpVectorBar": "",
	"RightUpVector": "",
	"RightVectorBar": "",
	"RightVector": "",
	"ring": "",
	"risingdotseq": "",
	"rlarr": "",
	"rlhar": "",
	"rlm": "",
	"rmoustache": "",
	"rmoust": "",
	"rnmid": "",
	"roang": "",
	"roarr": "",
	"robrk": "",
	"ropar": "",
	"ropf": "",
	"Ropf": "",
	"roplus": "",
	"rotimes": "",
	"RoundImplies": "",
	"rpar": ")",
	"rpargt": "",
	"rppolint": "",
	"rrarr": "",
	"Rrightarrow": "",
	"rsaquo": "",
	"rscr": "",
	"Rscr": "",
	"rsh": "",
	"Rsh": "",
	"rsqb": "]",
	"rsquo": "",
	"rsquor": "",
	"rthree": "",
	"rtimes": "",
	"rtri": "",
	"rtrie": "",
	"rtrif": "",
	"rtriltri": "",
	"RuleDelayed": "",
	"ruluhar": "",
	"rx": "",
	"Sacute": "",
	"sacute": "",
	"sbquo": "",
	"scap": "",
	"Scaron": "",
	"scaron": "",
	"Sc": "",
	"sc": "",
	"sccue": "",
	"sce": "",
	"scE": "",
	"Scedil": "",
	"scedil": "",
	"Scirc": "",
	"scirc": "",
	"scnap": "",
	"scnE": "",
	"scnsim": "",
	"scpolint": "",
	"scsim": "",
	"Scy": "",
	"scy": "",
	"sdotb": "",
	"sdot": "",
	"sdote": "",
	"searhk": "",
	"searr": "",
	"seArr": "",
	"searrow": "",
	"sect": "",
	"semi": ";",
	"seswar": "",
	"setminus": "",
	"setmn": "",
	"sext": "",
	"Sfr": "",
	"sfr": "",
	"sfrown": "",
	"sharp": "",
	"SHCHcy": "",
	"shchcy": "",
	"SHcy": "",
	"shcy": "",
	"ShortDownArrow": "",
	"ShortLeftArrow": "",
	"shortmid": "",
	"shortparallel": "",
	"ShortRightArrow": "",
	"ShortUpArrow": "",
	"shy": "",
	"Sigma": "",
	"sigma": "",
	"sigmaf": "",
	"sigmav": "",
	"sim": "",
	"simdot": "",
	"sime": "",
	"simeq": "",
	"simg": "",
	"simgE": "",
	"siml": "",
	"simlE": "",
	"simne": "",
	"simplus": "",
	"simrarr": "",
	"slarr": "",
	"SmallCircle": "",
	"smallsetminus": "",
	"smashp": "",
	"smeparsl": "",
	"smid": "",
	"smile": "",
	"smt": "",
	"smte": "",
	"smtes": "",
	"SOFTcy": "",
	"softcy": "",
	"solbar": "",
	"solb": "",
	"sol": "/",
	"Sopf": "",
	"sopf": "",
	"spades": "",
	"spadesuit": "",
	"spar": "",
	"sqcap": "",
	"sqcaps": "",
	"sqcup": "",
	"sqcups": "",
	"Sqrt": "",
	"sqsub": "",
	"sqsube": "",
	"sqsubset": "",
	"sqsubseteq": "",
	"sqsup": "",
	"sqsupe": "",
	"sqsupset": "",
	"sqsupseteq": "",
	"square": "",
	"Square": "",
	"SquareIntersection": "",
	"SquareSubset": "",
	"SquareSubsetEqual": "",
	"SquareSuperset": "",
	"SquareSupersetEqual": "",
	"SquareUnion": "",
	"squarf": "",
	"squ": "",
	"squf": "",
	"srarr": "",
	"Sscr": "",
	"sscr": "",
	"ssetmn": "",
	"ssmile": "",
	"sstarf": "",
	"Star": "",
	"star": "",
	"starf": "",
	"straightepsilon": "",
	"straightphi": "",
	"strns": "",
	"sub": "",
	"Sub": "",
	"subdot": "",
	"subE": "",
	"sube": "",
	"subedot": "",
	"submult": "",
	"subnE": "",
	"subne": "",
	"subplus": "",
	"subrarr": "",
	"subset": "",
	"Subset": "",
	"subseteq": "",
	"subseteqq": "",
	"SubsetEqual": "",
	"subsetneq": "",
	"subsetneqq": "",
	"subsim": "",
	"subsub": "",
	"subsup": "",
	"succapprox": "",
	"succ": "",
	"succcurlyeq": "",
	"Succeeds": "",
	"SucceedsEqual": "",
	"SucceedsSlantEqual": "",
	"SucceedsTilde": "",
	"succeq": "",
	"succnapprox": "",
	"succneqq": "",
	"succnsim": "",
	"succsim": "",
	"SuchThat": "",
	"sum": "",
	"Sum": "",
	"sung": "",
	"sup1": "",
	"sup2": "",
	"sup3": "",
	"sup": "",
	"Sup": "",
	"supdot": "",
	"supdsub": "",
	"supE": "",
	"supe": "",
	"supedot": "",
	"Superset": "",
	"SupersetEqual": "",
	"suphsol": "",
	"suphsub": "",
	"suplarr": "",
	"supmult": "",
	"supnE": "",
	"supne": "",
	"supplus": "",
	"supset": "",
	"Supset": "",
	"supseteq": "",
	"supseteqq": "",
	"supsetneq": "",
	"supsetneqq": "",
	"supsim": "",
	"supsub": "",
	"supsup": "",
	"swarhk": "",
	"swarr": "",
	"swArr": "",
	"swarrow": "",
	"swnwar": "",
	"szlig": "",
	"Tab": "\t",
	"target": "",
	"Tau": "",
	"tau": "",
	"tbrk": "",
	"Tcaron": "",
	"tcaron": "",
	"Tcedil": "",
	"tcedil": "",
	"Tcy": "",
	"tcy": "",
	"tdot": "",
	"telrec": "",
	"Tfr": "",
	"tfr": "",
	"there4": "",
	"therefore": "",
	"Therefore": "",
	"Theta": "",
	"theta": "",
	"thetasym": "",
	"thetav": "",
	"thickapprox": "",
	"thicksim": "",
	"ThickSpace": "",
	"ThinSpace": "",
	"thinsp": "",
	"thkap": "",
	"thksim": "",
	"THORN": "",
	"thorn": "",
	"tilde": "",
	"Tilde": "",
	"TildeEqual": "",
	"TildeFullEqual": "",
	"TildeTilde": "",
	"timesbar": "",
	"timesb": "",
	"times": "",
	"timesd": "",
	"tint": "",
	"toea": "",
	"topbot": "",
	"topcir": "",
	"top": "",
	"Topf": "",
	"topf": "",
	"topfork": "",
	"tosa": "",
	"tprime": "",
	"trade": "",
	"TRADE": "",
	"triangle": "",
	"triangledown": "",
	"triangleleft": "",
	"trianglelefteq": "",
	"triangleq": "",
	"triangleright": "",
	"trianglerighteq": "",
	"tridot": "",
	"trie": "",
	"triminus": "",
	"TripleDot": "",
	"triplus": "",
	"trisb": "",
	"tritime": "",
	"trpezium": "",
	"Tscr": "",
	"tscr": "",
	"TScy": "",
	"tscy": "",
	"TSHcy": "",
	"tshcy": "",
	"Tstrok": "",
	"tstrok": "",
	"twixt": "",
	"twoheadleftarrow": "",
	"twoheadrightarrow": "",
	"Uacute": "",
	"uacute": "",
	"uarr": "",
	"Uarr": "",
	"uArr": "",
	"Uarrocir": "",
	"Ubrcy": "",
	"ubrcy": "",
	"Ubreve": "",
	"ubreve": "",
	"Ucirc": "",
	"ucirc": "",
	"Ucy": "",
	"ucy": "",
	"udarr": "",
	"Udblac": "",
	"udblac": "",
	"udhar": "",
	"ufisht": "",
	"Ufr": "",
	"ufr": "",
	"Ugrave": "",
	"ugrave": "",
	"uHar": "",
	"uharl": "",
	"uharr": "",
	"uhblk": "",
	"ulcorn": "",
	"ulcorner": "",
	"ulcrop": "",
	"ultri": "",
	"Umacr": "",
	"umacr": "",
	"uml": "",
	"UnderBar": "_",
	"UnderBrace": "",
	"UnderBracket": "",
	"UnderParenthesis": "",
	"Union": "",
	"UnionPlus": "",
	"Uogon": "",
	"uogon": "",
	"Uopf": "",
	"uopf": "",
	"UpArrowBar": "",
	"uparrow": "",
	"UpArrow": "",
	"Uparrow": "",
	"UpArrowDownArrow": "",
	"updownarrow": "",
	"UpDownArrow": "",
	"Updownarrow": "",
	"UpEquilibrium": "",
	"upharpoonleft": "",
	"upharpoonright": "",
	"uplus": "",
	"UpperLeftArrow": "",
	"UpperRightArrow": "",
	"upsi": "",
	"Upsi": "",
	"upsih": "",
	"Upsilon": "",
	"upsilon": "",
	"UpTeeArrow": "",
	"UpTee": "",
	"upuparrows": "",
	"urcorn": "",
	"urcorner": "",
	"urcrop": "",
	"Uring": "",
	"uring": "",
	"urtri": "",
	"Uscr": "",
	"uscr": "",
	"utdot": "",
	"Utilde": "",
	"utilde": "",
	"utri": "",
	"utrif": "",
	"uuarr": "",
	"Uuml": "",
	"uuml": "",
	"uwangle": "",
	"vangrt": "",
	"varepsilon": "",
	"varkappa": "",
	"varnothing": "",
	"varphi": "",
	"varpi": "",
	"varpropto": "",
	"varr": "",
	"vArr": "",
	"varrho": "",
	"varsigma": "",
	"varsubsetneq": "",
	"varsubsetneqq": "",
	"varsupsetneq": "",
	"varsupsetneqq": "",
	"vartheta": "",
	"vartriangleleft": "",
	"vartriangleright": "",
	"vBar": "",
	"Vbar": "",
	"vBarv": "",
	"Vcy": "",
	"vcy": "",
	"vdash": "",
	"vDash": "",
	"Vdash": "",
	"VDash": "",
	"Vdashl": "",
	"veebar": "",
	"vee": "",
	"Vee": "",
	"veeeq": "",
	"vellip": "",
	"verbar": "|",
	"Verbar": "",
	"vert": "|",
	"Vert": "",
	"VerticalBar": "",
	"VerticalLine": "|",
	"VerticalSeparator": "",
	"VerticalTilde": "",
	"VeryThinSpace": "",
	"Vfr": "",
	"vfr": "",
	"vltri": "",
	"vnsub": "",
	"vnsup": "",
	"Vopf": "",
	"vopf": "",
	"vprop": "",
	"vrtri": "",
	"Vscr": "",
	"vscr": "",
	"vsubnE": "",
	"vsubne": "",
	"vsupnE": "",
	"vsupne": "",
	"Vvdash": "",
	"vzigzag": "",
	"Wcirc": "",
	"wcirc": "",
	"wedbar": "",
	"wedge": "",
	"Wedge": "",
	"wedgeq": "",
	"weierp": "",
	"Wfr": "",
	"wfr": "",
	"Wopf": "",
	"wopf": "",
	"wp": "",
	"wr": "",
	"wreath": "",
	"Wscr": "",
	"wscr": "",
	"xcap": "",
	"xcirc": "",
	"xcup": "",
	"xdtri": "",
	"Xfr": "",
	"xfr": "",
	"xharr": "",
	"xhArr": "",
	"Xi": "",
	"xi": "",
	"xlarr": "",
	"xlArr": "",
	"xmap": "",
	"xnis": "",
	"xodot": "",
	"Xopf": "",
	"xopf": "",
	"xoplus": "",
	"xotime": "",
	"xrarr": "",
	"xrArr": "",
	"Xscr": "",
	"xscr": "",
	"xsqcup": "",
	"xuplus": "",
	"xutri": "",
	"xvee": "",
	"xwedge": "",
	"Yacute": "",
	"yacute": "",
	"YAcy": "",
	"yacy": "",
	"Ycirc": "",
	"ycirc": "",
	"Ycy": "",
	"ycy": "",
	"yen": "",
	"Yfr": "",
	"yfr": "",
	"YIcy": "",
	"yicy": "",
	"Yopf": "",
	"yopf": "",
	"Yscr": "",
	"yscr": "",
	"YUcy": "",
	"yucy": "",
	"yuml": "",
	"Yuml": "",
	"Zacute": "",
	"zacute": "",
	"Zcaron": "",
	"zcaron": "",
	"Zcy": "",
	"zcy": "",
	"Zdot": "",
	"zdot": "",
	"zeetrf": "",
	"ZeroWidthSpace": "",
	"Zeta": "",
	"zeta": "",
	"zfr": "",
	"Zfr": "",
	"ZHcy": "",
	"zhcy": "",
	"zigrarr": "",
	"zopf": "",
	"Zopf": "",
	"Zscr": "",
	"zscr": "",
	"zwj": "",
	"zwnj": ""
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(89);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(17)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZmZlMTk0MzMzOGMxMzg5NTk3NWQiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9taXRocmlsL21pdGhyaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvY29tcG9uZW50cy9jZWxsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvY29tcG9uZW50cy9zdHlsZXMuY3NzPzE0YzkiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2VudHJ5LmpzIiwid2VicGFjazovLy8uL21vZGVsLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvZWRpdG9yLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvcHJldmlldy5qcyIsIndlYnBhY2s6Ly8vLi4vbGlicy9jb21wb25lbnRzL3RhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvY29tcG9uZW50cy90aXRsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2xpbmtpZnktaXQvbGliL3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2xhYmVsLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9odG1sX2lubGluZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZW5jb2RlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zdHlsZXMuY3NzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvc3R5bGVzLmNzcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzLmNzcz8yMjNhIl0sIm5hbWVzIjpbIl9jbGFzcyIsIm9iaiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzU3RyaW5nIiwiX2hhc093blByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJoYXMiLCJvYmplY3QiLCJrZXkiLCJhc3NpZ24iLCJzb3VyY2VzIiwiQXJyYXkiLCJzbGljZSIsImFyZ3VtZW50cyIsImZvckVhY2giLCJzb3VyY2UiLCJUeXBlRXJyb3IiLCJrZXlzIiwiYXJyYXlSZXBsYWNlQXQiLCJzcmMiLCJwb3MiLCJuZXdFbGVtZW50cyIsImNvbmNhdCIsImlzVmFsaWRFbnRpdHlDb2RlIiwiYyIsImZyb21Db2RlUG9pbnQiLCJzdXJyb2dhdGUxIiwic3Vycm9nYXRlMiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIlVORVNDQVBFX01EX1JFIiwiRU5USVRZX1JFIiwiVU5FU0NBUEVfQUxMX1JFIiwiUmVnRXhwIiwiRElHSVRBTF9FTlRJVFlfVEVTVF9SRSIsImVudGl0aWVzIiwicmVxdWlyZSIsInJlcGxhY2VFbnRpdHlQYXR0ZXJuIiwibWF0Y2giLCJuYW1lIiwiY29kZSIsImNoYXJDb2RlQXQiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJwYXJzZUludCIsInVuZXNjYXBlTWQiLCJzdHIiLCJpbmRleE9mIiwicmVwbGFjZSIsInVuZXNjYXBlQWxsIiwiZXNjYXBlZCIsImVudGl0eSIsIkhUTUxfRVNDQVBFX1RFU1RfUkUiLCJIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFIiwiSFRNTF9SRVBMQUNFTUVOVFMiLCJyZXBsYWNlVW5zYWZlQ2hhciIsImNoIiwiZXNjYXBlSHRtbCIsIlJFR0VYUF9FU0NBUEVfUkUiLCJlc2NhcGVSRSIsImlzU3BhY2UiLCJpc1doaXRlU3BhY2UiLCJVTklDT0RFX1BVTkNUX1JFIiwiaXNQdW5jdENoYXIiLCJpc01kQXNjaWlQdW5jdCIsIm5vcm1hbGl6ZVJlZmVyZW5jZSIsInRyaW0iLCJ0b1VwcGVyQ2FzZSIsImV4cG9ydHMiLCJsaWIiLCJtZHVybCIsInVjbWljcm8iLCJWbm9kZSIsInRhZyIsImF0dHJzMCIsImNoaWxkcmVuIiwidGV4dCIsImRvbSIsImF0dHJzIiwiZG9tU2l6ZSIsInVuZGVmaW5lZCIsInN0YXRlIiwiX3N0YXRlIiwiZXZlbnRzIiwiaW5zdGFuY2UiLCJza2lwIiwibm9ybWFsaXplIiwibm9kZSIsImlzQXJyYXkiLCJub3JtYWxpemVDaGlsZHJlbiIsImkiLCJsZW5ndGgiLCJzZWxlY3RvclBhcnNlciIsInNlbGVjdG9yQ2FjaGUiLCJoYXNPd24iLCJjb21waWxlU2VsZWN0b3IiLCJzZWxlY3RvciIsImNsYXNzZXMiLCJleGVjIiwidHlwZSIsInZhbHVlIiwiaWQiLCJwdXNoIiwiYXR0clZhbHVlIiwiY2xhc3NOYW1lIiwiam9pbiIsImV4ZWNTZWxlY3RvciIsImhhc0F0dHJzIiwiY2hpbGRMaXN0IiwiY2xhc3MiLCJoeXBlcnNjcmlwdCIsInN0YXJ0IiwidmlldyIsIkVycm9yIiwiY2FjaGVkIiwibm9ybWFsaXplZCIsInRydXN0IiwiaHRtbCIsImZyYWdtZW50IiwiYXR0cnMxIiwibSIsIlByb21pc2VQb2x5ZmlsbCIsImV4ZWN1dG9yIiwic2VsZiIsInJlc29sdmVycyIsInJlamVjdG9ycyIsInJlc29sdmVDdXJyZW50IiwiaGFuZGxlciIsInJlamVjdEN1cnJlbnQiLCJfaW5zdGFuY2UiLCJjYWxsQXN5bmMiLCJzZXRJbW1lZGlhdGUiLCJzZXRUaW1lb3V0IiwibGlzdCIsInNob3VsZEFic29yYiIsImV4ZWN1dGUiLCJ0aGVuIiwiZXhlY3V0ZU9uY2UiLCJiaW5kIiwiY29uc29sZSIsImVycm9yIiwicmV0cnkiLCJlIiwicnVucyIsInJ1biIsImZuIiwib25lcnJvciIsIm9uRnVsZmlsbGVkIiwib25SZWplY3Rpb24iLCJoYW5kbGUiLCJjYWxsYmFjayIsIm5leHQiLCJyZXNvbHZlTmV4dCIsInJlamVjdE5leHQiLCJwcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhdGNoIiwiYWxsIiwidG90YWwiLCJjb3VudCIsInZhbHVlcyIsImNvbnN1bWUiLCJyYWNlIiwid2luZG93IiwiUHJvbWlzZSIsImdsb2JhbCIsImJ1aWxkUXVlcnlTdHJpbmciLCJhcmdzIiwia2V5MCIsImRlc3RydWN0dXJlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiRklMRV9QUk9UT0NPTF9SRUdFWCIsIl84IiwiJHdpbmRvdyIsImNhbGxiYWNrQ291bnQiLCJvbmNvbXBsZXRpb24iLCJzZXRDb21wbGV0aW9uQ2FsbGJhY2siLCJmaW5hbGl6ZXIiLCJjb21wbGV0ZSIsImZpbmFsaXplIiwicHJvbWlzZTAiLCJ0aGVuMCIsImFwcGx5IiwiZXh0cmEiLCJ1cmwiLCJyZXF1ZXN0IiwibWV0aG9kIiwidXNlQm9keSIsInNlcmlhbGl6ZSIsIkZvcm1EYXRhIiwiZGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZXNlcmlhbGl6ZSIsImV4dHJhY3QiLCJpbnRlcnBvbGF0ZSIsImFzc2VtYmxlIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJhYm9ydGVkIiwiX2Fib3J0IiwiYWJvcnQiLCJvcGVuIiwiYXN5bmMiLCJ1c2VyIiwicGFzc3dvcmQiLCJzZXRSZXF1ZXN0SGVhZGVyIiwid2l0aENyZWRlbnRpYWxzIiwiaGVhZGVycyIsImNvbmZpZyIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJyZXNwb25zZSIsInN0YXR1cyIsImNhc3QiLCJyZXNwb25zZVRleHQiLCJzZW5kIiwiYmFja2dyb3VuZCIsImpzb25wIiwiY2FsbGJhY2tOYW1lIiwiTWF0aCIsInJvdW5kIiwicmFuZG9tIiwic2NyaXB0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY2FsbGJhY2tLZXkiLCJkb2N1bWVudEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsInRva2VucyIsInF1ZXJ5c3RyaW5nIiwicHJlZml4IiwicGFyc2UiLCJ0eXBlMCIsInJlcXVlc3RTZXJ2aWNlIiwiY29yZVJlbmRlcmVyIiwiJGRvYyIsIiRlbXB0eUZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIm9uZXZlbnQiLCJzZXRFdmVudENhbGxiYWNrIiwiY3JlYXRlTm9kZXMiLCJwYXJlbnQiLCJ2bm9kZXMiLCJlbmQiLCJob29rcyIsIm5leHRTaWJsaW5nIiwibnMiLCJ2bm9kZSIsImNyZWF0ZU5vZGUiLCJpbml0TGlmZWN5Y2xlIiwiY3JlYXRlVGV4dCIsImNyZWF0ZUhUTUwiLCJjcmVhdGVGcmFnbWVudCIsImNyZWF0ZUNvbXBvbmVudCIsImNyZWF0ZVRleHROb2RlIiwiaW5zZXJ0Tm9kZSIsIm1hdGNoMSIsInBhcmVudDEiLCJjYXB0aW9uIiwidGhlYWQiLCJ0Ym9keSIsInRmb290IiwidHIiLCJ0aCIsInRkIiwiY29sZ3JvdXAiLCJjb2wiLCJ0ZW1wIiwiaW5uZXJIVE1MIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJjaGlsZCIsImF0dHJzMiIsImlzIiwiZWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInNldEF0dHJzIiwiY29udGVudGVkaXRhYmxlIiwic2V0Q29udGVudEVkaXRhYmxlIiwidGV4dENvbnRlbnQiLCJzZXRMYXRlQXR0cnMiLCJpbml0Q29tcG9uZW50Iiwic2VudGluZWwiLCJjcmVhdGUiLCIkJHJlZW50cmFudExvY2skJCIsInVwZGF0ZU5vZGVzIiwib2xkIiwicmVjeWNsaW5nIiwicmVtb3ZlTm9kZXMiLCJpc1Vua2V5ZWQiLCJnZXROZXh0U2libGluZyIsInVwZGF0ZU5vZGUiLCJpc1JlY3ljbGFibGUiLCJwb29sIiwib2xkU3RhcnQiLCJvbGRFbmQiLCJtYXAiLCJvIiwidiIsInNob3VsZFJlY3ljbGUiLCJ0b0ZyYWdtZW50IiwiZ2V0S2V5TWFwIiwib2xkSW5kZXgiLCJtb3ZhYmxlIiwib2xkVGFnIiwic2hvdWxkTm90VXBkYXRlIiwidXBkYXRlTGlmZWN5Y2xlIiwidXBkYXRlVGV4dCIsInVwZGF0ZUhUTUwiLCJ1cGRhdGVGcmFnbWVudCIsInVwZGF0ZUVsZW1lbnQiLCJ1cGRhdGVDb21wb25lbnQiLCJyZW1vdmVOb2RlIiwibm9kZVZhbHVlIiwidXBkYXRlQXR0cnMiLCJhYnMiLCJvbGRDaGlsZHJlbkxlbmd0aCIsInBvb2xDaGlsZHJlbkxlbmd0aCIsInZub2Rlc0NoaWxkcmVuTGVuZ3RoIiwia2V5MiIsImNvdW50MCIsImluc2VydEJlZm9yZSIsImNvbnRlbnQiLCJjb250ZXh0IiwiZXhwZWN0ZWQiLCJjYWxsZWQiLCJvbmJlZm9yZXJlbW92ZSIsInJlc3VsdCIsImNvbnRpbnVhdGlvbiIsIm9ucmVtb3ZlIiwicmVtb3ZlTm9kZUZyb21ET00iLCJoYXNJbnRlZ3JhdGlvbk1ldGhvZHMiLCJzZXRBdHRyIiwiaXNGb3JtQXR0cmlidXRlIiwiaXNMaWZlY3ljbGVNZXRob2QiLCJuc0xhc3RJbmRleCIsInN1YnN0ciIsInNldEF0dHJpYnV0ZU5TIiwidXBkYXRlRXZlbnQiLCJ1cGRhdGVTdHlsZSIsImlzQXR0cmlidXRlIiwiaXNDdXN0b21FbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNlbGVjdGVkSW5kZXgiLCJhdHRyIiwib25jcmVhdGUiLCJvbnVwZGF0ZSIsInN0eWxlIiwiY3NzVGV4dCIsImV2ZW50TmFtZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25pbml0IiwiZm9yY2VWbm9kZVVwZGF0ZSIsImZvcmNlQ29tcG9uZW50VXBkYXRlIiwib25iZWZvcmV1cGRhdGUiLCJyZW5kZXIiLCJhY3RpdmUiLCJmb2N1cyIsInRocm90dGxlIiwidGltZSIsImxhc3QiLCJwZW5kaW5nIiwidGltZW91dCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5vdyIsIkRhdGUiLCJfMTEiLCJyZW5kZXJTZXJ2aWNlIiwicmVkcmF3IiwiY2FsbGJhY2tzIiwic3Vic2NyaWJlIiwia2V5MSIsInVuc3Vic2NyaWJlIiwiaW5kZXgiLCJzcGxpY2UiLCJyZWRyYXdTZXJ2aWNlIiwiXzE2IiwicmVkcmF3U2VydmljZTAiLCJyb290IiwiY29tcG9uZW50IiwicnVuMCIsIm1vdW50IiwicGFyc2VRdWVyeVN0cmluZyIsInN0cmluZyIsImNoYXJBdCIsImVudHJpZXMiLCJzcGxpdCIsImRhdGEwIiwiY291bnRlcnMiLCJlbnRyeSIsImtleTUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJsZXZlbHMiLCJjdXJzb3IiLCJwb3AiLCJqIiwibGV2ZWwiLCJuZXh0TGV2ZWwiLCJpc051bWJlciIsImlzTmFOIiwiaXNWYWx1ZSIsImNvcmVSb3V0ZXIiLCJzdXBwb3J0c1B1c2hTdGF0ZSIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJjYWxsQXN5bmMwIiwibm9ybWFsaXplMSIsImZyYWdtZW50MCIsImxvY2F0aW9uIiwiYXN5bmNJZCIsImRlYm91bmNlQXN5bmMiLCJjYWxsYmFjazAiLCJwYXJzZVBhdGgiLCJwYXRoIiwicXVlcnlEYXRhIiwiaGFzaERhdGEiLCJxdWVyeUluZGV4IiwiaGFzaEluZGV4IiwicGF0aEVuZCIsInF1ZXJ5RW5kIiwicXVlcnlQYXJhbXMiLCJrZXk0IiwiaGFzaFBhcmFtcyIsInJvdXRlciIsImdldFBhdGgiLCJ0eXBlMiIsInNldFBhdGgiLCJvcHRpb25zIiwibWF0Y2gyIiwidG9rZW4iLCJxdWVyeSIsImhhc2giLCJ0aXRsZSIsIm9ucG9wc3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJocmVmIiwiZGVmaW5lUm91dGVzIiwicm91dGVzIiwicmVzb2x2ZVJvdXRlIiwicGFyYW1zIiwicGF0aG5hbWUiLCJrIiwicm91dGUwIiwibWF0Y2hlciIsIm9uaGFzaGNoYW5nZSIsIl8yMCIsInJvdXRlU2VydmljZSIsImlkZW50aXR5IiwicmVuZGVyMSIsImF0dHJzMyIsImN1cnJlbnRQYXRoIiwibGFzdFVwZGF0ZSIsInJvdXRlIiwiZGVmYXVsdFJvdXRlIiwicnVuMSIsImJhaWwiLCJwYXlsb2FkIiwidXBkYXRlIiwicm91dGVSZXNvbHZlciIsImNvbXAiLCJvbm1hdGNoIiwicmVzb2x2ZWQiLCJzZXQiLCJnZXQiLCJwcmVmaXgwIiwibGluayIsInZub2RlMSIsIm9uY2xpY2siLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5Iiwid2hpY2giLCJwcmV2ZW50RGVmYXVsdCIsImdldEF0dHJpYnV0ZSIsInBhcmFtIiwia2V5MyIsIndpdGhBdHRyIiwiYXR0ck5hbWUiLCJjYWxsYmFjazEiLCJjdXJyZW50VGFyZ2V0IiwiXzI4IiwidmVyc2lvbiIsIm1vZHVsZSIsInNwYW4iLCJjbHMiLCJpbm5lciIsImciLCJGdW5jdGlvbiIsImV2YWwiLCJSdWxlciIsIl9fcnVsZXNfXyIsIl9fY2FjaGVfXyIsIl9fZmluZF9fIiwiX19jb21waWxlX18iLCJjaGFpbnMiLCJydWxlIiwiZW5hYmxlZCIsImFsdCIsImFsdE5hbWUiLCJjaGFpbiIsImF0Iiwib3B0IiwiYmVmb3JlIiwiYmVmb3JlTmFtZSIsInJ1bGVOYW1lIiwiYWZ0ZXIiLCJhZnRlck5hbWUiLCJlbmFibGUiLCJpZ25vcmVJbnZhbGlkIiwiaWR4IiwiZW5hYmxlT25seSIsImRpc2FibGUiLCJnZXRSdWxlcyIsImNoYWluTmFtZSIsIlRva2VuIiwibmVzdGluZyIsIm1hcmt1cCIsImluZm8iLCJtZXRhIiwiYmxvY2siLCJoaWRkZW4iLCJhdHRySW5kZXgiLCJsZW4iLCJhdHRyUHVzaCIsImF0dHJEYXRhIiwiYXR0clNldCIsImF0dHJHZXQiLCJhdHRySm9pbiIsInVzZVNvdXJjZU1hcCIsIml0ZW0iLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwiY3NzTWFwcGluZyIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlUm9vdCIsInNvdXJjZU1hcCIsImJhc2U2NCIsIkJ1ZmZlciIsImF0dHJfbmFtZSIsInVucXVvdGVkIiwic2luZ2xlX3F1b3RlZCIsImRvdWJsZV9xdW90ZWQiLCJhdHRyX3ZhbHVlIiwiYXR0cmlidXRlIiwib3Blbl90YWciLCJjbG9zZV90YWciLCJjb21tZW50IiwicHJvY2Vzc2luZyIsImRlY2xhcmF0aW9uIiwiY2RhdGEiLCJIVE1MX1RBR19SRSIsIkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUiLCJ0b2tlbml6ZSIsImVtcGhhc2lzIiwic2lsZW50Iiwic2Nhbm5lZCIsIm1hcmtlciIsInNjYW5EZWxpbXMiLCJkZWxpbWl0ZXJzIiwianVtcCIsImNhbl9vcGVuIiwiY2xvc2UiLCJjYW5fY2xvc2UiLCJwb3N0UHJvY2VzcyIsInN0YXJ0RGVsaW0iLCJlbmREZWxpbSIsImlzU3Ryb25nIiwibWF4Iiwic3RyaWtldGhyb3VnaCIsImxvbmVNYXJrZXJzIiwiZW5jb2RlIiwiZGVjb2RlIiwiZm9ybWF0IiwiU2F2ZSIsIm1vZGVsIiwic2F2ZSIsInNhdmVCdXR0b24iLCJmZXRjaCIsImZldGNoZWQiLCJlZGl0b3JXcmFwIiwibWRCb2R5IiwiZ2V0RWxlbWVudEJ5SWQiLCJtZCIsIk1vZGVsIiwiYm9keSIsIm9uaW5wdXQiLCJ0ZXh0YXJlYSIsImVkaXRvciIsImVkaXRvckxlZnRTaWRlIiwiZWRpdG9yUmlnaHRTaWRlIiwib25jaGFuZ2UiLCJ0YWdzIiwib25jaGFuYWdlIiwiYnl0ZUxlbmd0aCIsInRvQnl0ZUFycmF5IiwiZnJvbUJ5dGVBcnJheSIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsIlVpbnQ4QXJyYXkiLCJwbGFjZUhvbGRlcnNDb3VudCIsImI2NCIsImwiLCJ0bXAiLCJwbGFjZUhvbGRlcnMiLCJhcnIiLCJMIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsIm91dHB1dCIsImV4dHJhQnl0ZXMiLCJwYXJ0cyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsImllZWU3NTQiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJrTWF4TGVuZ3RoIiwiX19wcm90b19fIiwiZm9vIiwic3ViYXJyYXkiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiUmFuZ2VFcnJvciIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsIlN5bWJvbCIsInNwZWNpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93IiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwiZnJvbUFycmF5TGlrZSIsImFycmF5IiwiYnl0ZU9mZnNldCIsImlzQnVmZmVyIiwiY29weSIsImJ1ZmZlciIsImlzbmFuIiwiYiIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwieCIsInkiLCJtaW4iLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwibiIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImVxdWFscyIsImluc3BlY3QiLCJ0YXJnZXQiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJ2YWwiLCJkaXIiLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwib2Zmc2V0IiwiTnVtYmVyIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VkIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIl9hcnIiLCJyZXMiLCJmaXJzdEJ5dGUiLCJjb2RlUG9pbnQiLCJieXRlc1BlclNlcXVlbmNlIiwic2Vjb25kQnl0ZSIsInRoaXJkQnl0ZSIsImZvdXJ0aEJ5dGUiLCJ0ZW1wQ29kZVBvaW50IiwiZGVjb2RlQ29kZVBvaW50c0FycmF5IiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJjb2RlUG9pbnRzIiwicmV0Iiwib3V0IiwidG9IZXgiLCJieXRlcyIsIm5ld0J1ZiIsInNsaWNlTGVuIiwiY2hlY2tPZmZzZXQiLCJleHQiLCJyZWFkVUludExFIiwibm9Bc3NlcnQiLCJtdWwiLCJyZWFkVUludEJFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludExFIiwicG93IiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJmbG9vciIsIm9iamVjdFdyaXRlVUludDE2IiwibGl0dGxlRW5kaWFuIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVUludDE2QkUiLCJvYmplY3RXcml0ZVVJbnQzMiIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsImxpbWl0Iiwic3ViIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJJTlZBTElEX0JBU0U2NF9SRSIsImJhc2U2NGNsZWFuIiwic3RyaW5ndHJpbSIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsImRzdCIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiZCIsInMiLCJOYU4iLCJydCIsImxvZyIsIkxOMiIsImlzT2JqZWN0IiwiaXNSZWdFeHAiLCJpc0Z1bmN0aW9uIiwiZGVmYXVsdE9wdGlvbnMiLCJmdXp6eUxpbmsiLCJmdXp6eUVtYWlsIiwiZnV6enlJUCIsImlzT3B0aW9uc09iaiIsInJlZHVjZSIsImFjYyIsImRlZmF1bHRTY2hlbWFzIiwidmFsaWRhdGUiLCJ0YWlsIiwicmUiLCJodHRwIiwic3JjX2F1dGgiLCJzcmNfaG9zdF9wb3J0X3N0cmljdCIsInNyY19wYXRoIiwibm9faHR0cCIsInNyY19kb21haW4iLCJzcmNfZG9tYWluX3Jvb3QiLCJzcmNfcG9ydCIsInNyY19ob3N0X3Rlcm1pbmF0b3IiLCJtYWlsdG8iLCJzcmNfZW1haWxfbmFtZSIsInNyY19ob3N0X3N0cmljdCIsInRsZHNfMmNoX3NyY19yZSIsInRsZHNfZGVmYXVsdCIsInJlc2V0U2NhbkNhY2hlIiwiX19pbmRleF9fIiwiX190ZXh0X2NhY2hlX18iLCJjcmVhdGVWYWxpZGF0b3IiLCJjcmVhdGVOb3JtYWxpemVyIiwiY29tcGlsZSIsIl9fb3B0c19fIiwidGxkcyIsIl9fdGxkc19fIiwib25Db21waWxlIiwiX190bGRzX3JlcGxhY2VkX18iLCJzcmNfeG4iLCJzcmNfdGxkcyIsInVudHBsIiwidHBsIiwiZW1haWxfZnV6enkiLCJ0cGxfZW1haWxfZnV6enkiLCJsaW5rX2Z1enp5IiwidHBsX2xpbmtfZnV6enkiLCJsaW5rX25vX2lwX2Z1enp5IiwidHBsX2xpbmtfbm9faXBfZnV6enkiLCJob3N0X2Z1enp5X3Rlc3QiLCJ0cGxfaG9zdF9mdXp6eV90ZXN0IiwiYWxpYXNlcyIsIl9fY29tcGlsZWRfXyIsInNjaGVtYUVycm9yIiwiX19zY2hlbWFzX18iLCJjb21waWxlZCIsImFsaWFzIiwic2xpc3QiLCJmaWx0ZXIiLCJzY2hlbWFfdGVzdCIsInNyY19aUENjIiwic2NoZW1hX3NlYXJjaCIsInByZXRlc3QiLCJNYXRjaCIsInNoaWZ0IiwiX19sYXN0X2luZGV4X18iLCJzY2hlbWEiLCJfX3NjaGVtYV9fIiwibGFzdEluZGV4IiwicmF3IiwiY3JlYXRlTWF0Y2giLCJMaW5raWZ5SXQiLCJzY2hlbWFzIiwiYWRkIiwiZGVmaW5pdGlvbiIsIm1sIiwibWUiLCJ0bGRfcG9zIiwiYXRfcG9zIiwidGVzdFNjaGVtYUF0Iiwic2VhcmNoIiwia2VlcE9sZCIsInNvcnQiLCJlbCIsInJldmVyc2UiLCJvcHRzIiwic3JjX0FueSIsInNyY19DYyIsInNyY19aIiwic3JjX1AiLCJzcmNfWkNjIiwidGV4dF9zZXBhcmF0b3JzIiwic3JjX3BzZXVkb19sZXR0ZXIiLCJzcmNfaXA0Iiwic3JjX2hvc3QiLCJ0cGxfaG9zdF9mdXp6eSIsInRwbF9ob3N0X25vX2lwX2Z1enp5IiwidHBsX2hvc3RfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QiLCJ0cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCIsInBhcnNlTGlua0xhYmVsIiwicGFyc2VMaW5rRGVzdGluYXRpb24iLCJwYXJzZUxpbmtUaXRsZSIsImxpbmVzIiwib2siLCJkaXNhYmxlTmVzdGVkIiwicHJldlBvcyIsImxhYmVsRW5kIiwicG9zTWF4Iiwib2xkUG9zIiwiaW5saW5lIiwic2tpcFRva2VuIiwidXRpbHMiLCJoZWxwZXJzIiwiUmVuZGVyZXIiLCJQYXJzZXJDb3JlIiwiUGFyc2VyQmxvY2siLCJQYXJzZXJJbmxpbmUiLCJwdW55Y29kZSIsInplcm8iLCJjb21tb25tYXJrIiwiQkFEX1BST1RPX1JFIiwiR09PRF9EQVRBX1JFIiwidmFsaWRhdGVMaW5rIiwiUkVDT0RFX0hPU1ROQU1FX0ZPUiIsIm5vcm1hbGl6ZUxpbmsiLCJob3N0bmFtZSIsInByb3RvY29sIiwidG9BU0NJSSIsImVyIiwibm9ybWFsaXplTGlua1RleHQiLCJ0b1VuaWNvZGUiLCJNYXJrZG93bkl0IiwicHJlc2V0TmFtZSIsImNvcmUiLCJyZW5kZXJlciIsImxpbmtpZnkiLCJjb25maWd1cmUiLCJwcmVzZXRzIiwiY29tcG9uZW50cyIsInJ1bGVzIiwicnVsZXIiLCJydWxlczIiLCJydWxlcjIiLCJtaXNzZWQiLCJ1c2UiLCJwbHVnaW4iLCJlbnYiLCJTdGF0ZSIsInByb2Nlc3MiLCJwYXJzZUlubGluZSIsImlubGluZU1vZGUiLCJyZW5kZXJJbmxpbmUiLCJfcnVsZXMiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibGluZSIsImhhc0VtcHR5TGluZXMiLCJtYXhOZXN0aW5nIiwic2tpcEVtcHR5TGluZXMiLCJzQ291bnQiLCJibGtJbmRlbnQiLCJ0aWdodCIsImlzRW1wdHkiLCJvdXRUb2tlbnMiLCJsaW5lTWF4IiwiQ29yZSIsIl9ydWxlczIiLCJjYWNoZSIsInB1c2hQZW5kaW5nIiwieGh0bWxPdXQiLCJicmVha3MiLCJsYW5nUHJlZml4IiwidHlwb2dyYXBoZXIiLCJxdW90ZXMiLCJoaWdobGlnaHQiLCJkZWZhdWx0X3J1bGVzIiwiY29kZV9pbmxpbmUiLCJzbGYiLCJyZW5kZXJBdHRycyIsImNvZGVfYmxvY2siLCJmZW5jZSIsImxhbmdOYW1lIiwiaGlnaGxpZ2h0ZWQiLCJ0bXBBdHRycyIsInRtcFRva2VuIiwiaW1hZ2UiLCJyZW5kZXJJbmxpbmVBc1RleHQiLCJyZW5kZXJUb2tlbiIsImhhcmRicmVhayIsInNvZnRicmVhayIsImh0bWxfYmxvY2siLCJodG1sX2lubGluZSIsIm5leHRUb2tlbiIsIm5lZWRMZiIsImJsb2NrcXVvdGUiLCJhZGp1c3RUYWIiLCJpbml0aWFsIiwiaXNPdXRkZW50ZWQiLCJsYXN0TGluZUVtcHR5IiwibmV4dExpbmUiLCJvbGRCTWFya3MiLCJvbGRCU0NvdW50Iiwib2xkSW5kZW50Iiwib2xkUGFyZW50VHlwZSIsIm9sZFNDb3VudCIsIm9sZFRTaGlmdCIsInNwYWNlQWZ0ZXJNYXJrZXIiLCJ0ZXJtaW5hdGUiLCJ0ZXJtaW5hdG9yUnVsZXMiLCJvbGRMaW5lTWF4IiwiYk1hcmtzIiwidFNoaWZ0IiwiZU1hcmtzIiwiYnNDb3VudCIsInBhcmVudFR5cGUiLCJnZXRMaW5lcyIsIm1lbSIsImhhdmVFbmRNYXJrZXIiLCJza2lwQ2hhcnMiLCJza2lwU3BhY2VzIiwiaGVhZGluZyIsInNraXBTcGFjZXNCYWNrIiwic2tpcENoYXJzQmFjayIsImhyIiwiY250IiwiYmxvY2tfbmFtZXMiLCJIVE1MX1NFUVVFTkNFUyIsImxpbmVUZXh0IiwibGhlYWRpbmciLCJza2lwQnVsbGV0TGlzdE1hcmtlciIsInNraXBPcmRlcmVkTGlzdE1hcmtlciIsIm1hcmtUaWdodFBhcmFncmFwaHMiLCJjb250ZW50U3RhcnQiLCJpbmRlbnQiLCJpbmRlbnRBZnRlck1hcmtlciIsImlzT3JkZXJlZCIsIml0ZW1MaW5lcyIsImxpc3RMaW5lcyIsImxpc3RUb2tJZHgiLCJtYXJrZXJDaGFyQ29kZSIsIm1hcmtlclZhbHVlIiwib2xkTEluZGVudCIsIm9sZFRpZ2h0IiwicG9zQWZ0ZXJNYXJrZXIiLCJwcmV2RW1wdHlFbmQiLCJpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoIiwicGFyYWdyYXBoIiwicmVmZXJlbmNlIiwiX2VuZExpbmUiLCJkZXN0RW5kUG9zIiwiZGVzdEVuZExpbmVObyIsImxhYmVsIiwicmVmZXJlbmNlcyIsIlN0YXRlQmxvY2siLCJpbmRlbnRfZm91bmQiLCJkZEluZGVudCIsImJlZ2luIiwia2VlcExhc3RMRiIsImxpbmVJbmRlbnQiLCJmaXJzdCIsInF1ZXVlIiwibGluZVN0YXJ0IiwiZ2V0TGluZSIsImVzY2FwZWRTcGxpdCIsImVzY2FwZXMiLCJsYXN0UG9zIiwiYmFja1RpY2tlZCIsImxhc3RCYWNrVGljayIsInN1YnN0cmluZyIsInRhYmxlIiwiY29sdW1ucyIsImNvbHVtbkNvdW50IiwiYWxpZ25zIiwidCIsInRhYmxlTGluZXMiLCJ0Ym9keUxpbmVzIiwidG9rIiwiaXNMaW5rT3BlbiIsImlzTGlua0Nsb3NlIiwiY3VycmVudFRva2VuIiwibm9kZXMiLCJsbiIsImh0bWxMaW5rTGV2ZWwiLCJmdWxsVXJsIiwidXJsVGV4dCIsImJsb2NrVG9rZW5zIiwibGlua3MiLCJORVdMSU5FU19SRSIsIk5VTExfUkUiLCJSQVJFX1JFIiwiU0NPUEVEX0FCQlJfVEVTVF9SRSIsIlNDT1BFRF9BQkJSX1JFIiwiU0NPUEVEX0FCQlIiLCJyIiwicCIsInRtIiwicmVwbGFjZUZuIiwicmVwbGFjZV9zY29wZWQiLCJpbmxpbmVUb2tlbnMiLCJpbnNpZGVfYXV0b2xpbmsiLCJyZXBsYWNlX3JhcmUiLCJibGtJZHgiLCJRVU9URV9URVNUX1JFIiwiUVVPVEVfUkUiLCJBUE9TVFJPUEhFIiwicmVwbGFjZUF0IiwicHJvY2Vzc19pbmxpbmVzIiwidGhpc0xldmVsIiwibGFzdENoYXIiLCJuZXh0Q2hhciIsImlzTGFzdFB1bmN0Q2hhciIsImlzTmV4dFB1bmN0Q2hhciIsImlzTGFzdFdoaXRlU3BhY2UiLCJpc05leHRXaGl0ZVNwYWNlIiwiY2FuT3BlbiIsImNhbkNsb3NlIiwiaXNTaW5nbGUiLCJzdGFjayIsIm9wZW5RdW90ZSIsImNsb3NlUXVvdGUiLCJPVVRFUiIsInNpbmdsZSIsInNtYXJ0cXVvdGVzIiwiU3RhdGVDb3JlIiwiRU1BSUxfUkUiLCJBVVRPTElOS19SRSIsImF1dG9saW5rIiwibGlua01hdGNoIiwiZW1haWxNYXRjaCIsImJhY2t0aWNrIiwibWF0Y2hTdGFydCIsIm1hdGNoRW5kIiwibGlua19wYWlycyIsImxhc3REZWxpbSIsImN1cnJEZWxpbSIsIm9kZF9tYXRjaCIsIkRJR0lUQUxfUkUiLCJOQU1FRF9SRSIsIkVTQ0FQRUQiLCJlc2NhcGUiLCJpc0xldHRlciIsImxjIiwibGFiZWxTdGFydCIsInJlZiIsInBhcnNlUmVmZXJlbmNlIiwibmV3bGluZSIsInBtYXgiLCJTdGF0ZUlubGluZSIsInBlbmRpbmdMZXZlbCIsImNhblNwbGl0V29yZCIsImxlZnRfZmxhbmtpbmciLCJyaWdodF9mbGFua2luZyIsImlzVGVybWluYXRvckNoYXIiLCJ0ZXh0X2NvbGxhcHNlIiwiY3VyciIsImRlY29kZUNhY2hlIiwiZ2V0RGVjb2RlQ2FjaGUiLCJleGNsdWRlIiwiZGVmYXVsdENoYXJzIiwic2VxIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJjaHIiLCJjb21wb25lbnRDaGFycyIsImVuY29kZUNhY2hlIiwiZ2V0RW5jb2RlQ2FjaGUiLCJrZWVwRXNjYXBlZCIsIm5leHRDb2RlIiwic2xhc2hlcyIsImF1dGgiLCJwb3J0IiwiVXJsIiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsImhvc3RsZXNzUHJvdG9jb2wiLCJzbGFzaGVkUHJvdG9jb2wiLCJ1cmxQYXJzZSIsInNsYXNoZXNEZW5vdGVIb3N0IiwidSIsImxvd2VyUHJvdG8iLCJoZWMiLCJyZXN0Iiwic2ltcGxlUGF0aCIsInByb3RvIiwiaG9zdEVuZCIsImF0U2lnbiIsImhvc3QiLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwidW5zaGlmdCIsInFtIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJuZXh0VGljayIsIkl0ZW0iLCJicm93c2VyIiwiYXJndiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJtYXhJbnQiLCJiYXNlIiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJtYXBEb21haW4iLCJsYWJlbHMiLCJlbmNvZGVkIiwidWNzMmRlY29kZSIsImNvdW50ZXIiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJiaWFzIiwiYmFzaWMiLCJvbGRpIiwidyIsImJhc2VNaW51c1QiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwicSIsImN1cnJlbnRWYWx1ZSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInFNaW51c1QiLCJkZWZpbmUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJvbkdsb2JhbE1lc3NhZ2UiLCJldmVudCIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsImdldFByb3RvdHlwZU9mIiwiY3NzIiwiYmFzZVVybCIsImN1cnJlbnREaXIiLCJmaXhlZENzcyIsImZ1bGxNYXRjaCIsIm9yaWdVcmwiLCJ1bnF1b3RlZE9yaWdVcmwiLCIkMSIsIm5ld1VybCIsIlRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsImVucm9sbCIsIm1zZWNzIiwiX2lkbGVUaW1lb3V0SWQiLCJfaWRsZVRpbWVvdXQiLCJ1bmVucm9sbCIsIl91bnJlZkFjdGl2ZSIsIm9uVGltZW91dCIsIl9vblRpbWVvdXQiLCJBbnkiLCJDYyIsIkNmIiwiUCIsIloiLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsImVudW1lcmFibGUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUM5a0VBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBmZmUxOTQzMzM4YzEzODk1OTc1ZCIsIi8vIFV0aWxpdGllc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJzsgfVxuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8vIFJlbW92ZSBlbGVtZW50IGZyb20gYXJyYXkgYW5kIHB1dCBhbm90aGVyIGFycmF5IGF0IHRob3NlIHBvc2l0aW9uLlxuLy8gVXNlZnVsIGZvciBzb21lIG9wZXJhdGlvbnMgd2l0aCB0b2tlbnNcbmZ1bmN0aW9uIGFycmF5UmVwbGFjZUF0KHNyYywgcG9zLCBuZXdFbGVtZW50cykge1xuICByZXR1cm4gW10uY29uY2F0KHNyYy5zbGljZSgwLCBwb3MpLCBuZXdFbGVtZW50cywgc3JjLnNsaWNlKHBvcyArIDEpKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNWYWxpZEVudGl0eUNvZGUoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICAvLyBicm9rZW4gc2VxdWVuY2VcbiAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhERkZGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBuZXZlciB1c2VkXG4gIGlmIChjID49IDB4RkREMCAmJiBjIDw9IDB4RkRFRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKChjICYgMHhGRkZGKSA9PT0gMHhGRkZGIHx8IChjICYgMHhGRkZGKSA9PT0gMHhGRkZFKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBjb250cm9sIGNvZGVzXG4gIGlmIChjID49IDB4MDAgJiYgYyA8PSAweDA4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA9PT0gMHgwQikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPj0gMHgwRSAmJiBjIDw9IDB4MUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4N0YgJiYgYyA8PSAweDlGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBvdXQgb2YgcmFuZ2VcbiAgaWYgKGMgPiAweDEwRkZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICBpZiAoYyA+IDB4ZmZmZikge1xuICAgIGMgLT0gMHgxMDAwMDtcbiAgICB2YXIgc3Vycm9nYXRlMSA9IDB4ZDgwMCArIChjID4+IDEwKSxcbiAgICAgICAgc3Vycm9nYXRlMiA9IDB4ZGMwMCArIChjICYgMHgzZmYpO1xuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoc3Vycm9nYXRlMSwgc3Vycm9nYXRlMik7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG59XG5cblxudmFyIFVORVNDQVBFX01EX1JFICA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLlxcLzo7PD0+P0BbXFxcXFxcXV5fYHt8fX5dKS9nO1xudmFyIEVOVElUWV9SRSAgICAgICA9IC8mKFthLXojXVthLXowLTldezEsMzF9KTsvZ2k7XG52YXIgVU5FU0NBUEVfQUxMX1JFID0gbmV3IFJlZ0V4cChVTkVTQ0FQRV9NRF9SRS5zb3VyY2UgKyAnfCcgKyBFTlRJVFlfUkUuc291cmNlLCAnZ2knKTtcblxudmFyIERJR0lUQUxfRU5USVRZX1RFU1RfUkUgPSAvXiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpL2k7XG5cbnZhciBlbnRpdGllcyA9IHJlcXVpcmUoJy4vZW50aXRpZXMnKTtcblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIG5hbWUpIHtcbiAgdmFyIGNvZGUgPSAwO1xuXG4gIGlmIChoYXMoZW50aXRpZXMsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGVudGl0aWVzW25hbWVdO1xuICB9XG5cbiAgaWYgKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyMy8qICMgKi8gJiYgRElHSVRBTF9FTlRJVFlfVEVTVF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgY29kZSA9IG5hbWVbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMiksIDE2KVxuICAgIDpcbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMSksIDEwKTtcbiAgICBpZiAoaXNWYWxpZEVudGl0eUNvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuLypmdW5jdGlvbiByZXBsYWNlRW50aXRpZXMoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKEVOVElUWV9SRSwgcmVwbGFjZUVudGl0eVBhdHRlcm4pO1xufSovXG5cbmZ1bmN0aW9uIHVuZXNjYXBlTWQoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgJyQxJyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQWxsKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDAgJiYgc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9BTExfUkUsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgZW50aXR5KSB7XG4gICAgaWYgKGVzY2FwZWQpIHsgcmV0dXJuIGVzY2FwZWQ7IH1cbiAgICByZXR1cm4gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIGVudGl0eSk7XG4gIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgSFRNTF9FU0NBUEVfVEVTVF9SRSA9IC9bJjw+XCJdLztcbnZhciBIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFID0gL1smPD5cIl0vZztcbnZhciBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihjaCkge1xuICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBSRUdFWFBfRVNDQVBFX1JFID0gL1suPyorXiRbXFxdXFxcXCgpe318LV0vZztcblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzU3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6XG4gICAgY2FzZSAweDIwOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBacyAodW5pY29kZSBjbGFzcykgfHwgW1xcdFxcZlxcdlxcclxcbl1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjb2RlKSB7XG4gIGlmIChjb2RlID49IDB4MjAwMCAmJiBjb2RlIDw9IDB4MjAwQSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6IC8vIFxcdFxuICAgIGNhc2UgMHgwQTogLy8gXFxuXG4gICAgY2FzZSAweDBCOiAvLyBcXHZcbiAgICBjYXNlIDB4MEM6IC8vIFxcZlxuICAgIGNhc2UgMHgwRDogLy8gXFxyXG4gICAgY2FzZSAweDIwOlxuICAgIGNhc2UgMHhBMDpcbiAgICBjYXNlIDB4MTY4MDpcbiAgICBjYXNlIDB4MjAyRjpcbiAgICBjYXNlIDB4MjA1RjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cbnZhciBVTklDT0RFX1BVTkNUX1JFID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5cbi8vIEN1cnJlbnRseSB3aXRob3V0IGFzdHJhbCBjaGFyYWN0ZXJzIHN1cHBvcnQuXG5mdW5jdGlvbiBpc1B1bmN0Q2hhcihjaCkge1xuICByZXR1cm4gVU5JQ09ERV9QVU5DVF9SRS50ZXN0KGNoKTtcbn1cblxuXG4vLyBNYXJrZG93biBBU0NJSSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzLlxuLy9cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG4vL1xuLy8gRG9uJ3QgY29uZnVzZSB3aXRoIHVuaWNvZGUgcHVuY3R1YXRpb24gISEhIEl0IGxhY2tzIHNvbWUgY2hhcnMgaW4gYXNjaWkgcmFuZ2UuXG4vL1xuZnVuY3Rpb24gaXNNZEFzY2lpUHVuY3QoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIyLyogXCIgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MjcvKiAnICovOlxuICAgIGNhc2UgMHgyOC8qICggKi86XG4gICAgY2FzZSAweDI5LyogKSAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJDLyogLCAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgyRS8qIC4gKi86XG4gICAgY2FzZSAweDJGLyogLyAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQi8qIDsgKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDNGLyogPyAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3Qy8qIHwgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZXBsZXIgdG8gdW5pZnkgW3JlZmVyZW5jZSBsYWJlbHNdLlxuLy9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgLy8gdXNlIC50b1VwcGVyQ2FzZSgpIGluc3RlYWQgb2YgLnRvTG93ZXJDYXNlKClcbiAgLy8gaGVyZSB0byBhdm9pZCBhIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZVxuICAvLyBtZW1iZXJzIChtb3N0IG5vdGFibHksIGBfX3Byb3RvX19gKVxuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykudG9VcHBlckNhc2UoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUmUtZXhwb3J0IGxpYnJhcmllcyBjb21tb25seSB1c2VkIGluIGJvdGggbWFya2Rvd24taXQgYW5kIGl0cyBwbHVnaW5zLFxuLy8gc28gcGx1Z2lucyB3b24ndCBoYXZlIHRvIGRlcGVuZCBvbiB0aGVtIGV4cGxpY2l0bHksIHdoaWNoIHJlZHVjZXMgdGhlaXJcbi8vIGJ1bmRsZWQgc2l6ZSAoZS5nLiBhIGJyb3dzZXIgYnVpbGQpLlxuLy9cbmV4cG9ydHMubGliICAgICAgICAgICAgICAgICA9IHt9O1xuZXhwb3J0cy5saWIubWR1cmwgICAgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbmV4cG9ydHMubGliLnVjbWljcm8gICAgICAgICA9IHJlcXVpcmUoJ3VjLm1pY3JvJyk7XG5cbmV4cG9ydHMuYXNzaWduICAgICAgICAgICAgICA9IGFzc2lnbjtcbmV4cG9ydHMuaXNTdHJpbmcgICAgICAgICAgICA9IGlzU3RyaW5nO1xuZXhwb3J0cy5oYXMgICAgICAgICAgICAgICAgID0gaGFzO1xuZXhwb3J0cy51bmVzY2FwZU1kICAgICAgICAgID0gdW5lc2NhcGVNZDtcbmV4cG9ydHMudW5lc2NhcGVBbGwgICAgICAgICA9IHVuZXNjYXBlQWxsO1xuZXhwb3J0cy5pc1ZhbGlkRW50aXR5Q29kZSAgID0gaXNWYWxpZEVudGl0eUNvZGU7XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgICAgICAgPSBmcm9tQ29kZVBvaW50O1xuLy8gZXhwb3J0cy5yZXBsYWNlRW50aXRpZXMgICAgID0gcmVwbGFjZUVudGl0aWVzO1xuZXhwb3J0cy5lc2NhcGVIdG1sICAgICAgICAgID0gZXNjYXBlSHRtbDtcbmV4cG9ydHMuYXJyYXlSZXBsYWNlQXQgICAgICA9IGFycmF5UmVwbGFjZUF0O1xuZXhwb3J0cy5pc1NwYWNlICAgICAgICAgICAgID0gaXNTcGFjZTtcbmV4cG9ydHMuaXNXaGl0ZVNwYWNlICAgICAgICA9IGlzV2hpdGVTcGFjZTtcbmV4cG9ydHMuaXNNZEFzY2lpUHVuY3QgICAgICA9IGlzTWRBc2NpaVB1bmN0O1xuZXhwb3J0cy5pc1B1bmN0Q2hhciAgICAgICAgID0gaXNQdW5jdENoYXI7XG5leHBvcnRzLmVzY2FwZVJFICAgICAgICAgICAgPSBlc2NhcGVSRTtcbmV4cG9ydHMubm9ybWFsaXplUmVmZXJlbmNlICA9IG5vcm1hbGl6ZVJlZmVyZW5jZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMuanMiLCI7KGZ1bmN0aW9uKCkge1xuXCJ1c2Ugc3RyaWN0XCJcbmZ1bmN0aW9uIFZub2RlKHRhZywga2V5LCBhdHRyczAsIGNoaWxkcmVuLCB0ZXh0LCBkb20pIHtcblx0cmV0dXJuIHt0YWc6IHRhZywga2V5OiBrZXksIGF0dHJzOiBhdHRyczAsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dDogdGV4dCwgZG9tOiBkb20sIGRvbVNpemU6IHVuZGVmaW5lZCwgc3RhdGU6IHVuZGVmaW5lZCwgX3N0YXRlOiB1bmRlZmluZWQsIGV2ZW50czogdW5kZWZpbmVkLCBpbnN0YW5jZTogdW5kZWZpbmVkLCBza2lwOiBmYWxzZX1cbn1cblZub2RlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHJldHVybiBWbm9kZShcIltcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKG5vZGUpLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0aWYgKG5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIFZub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbm9kZSA9PT0gZmFsc2UgPyBcIlwiIDogbm9kZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdHJldHVybiBub2RlXG59XG5Wbm9kZS5ub3JtYWxpemVDaGlsZHJlbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZHJlbltpXSA9IFZub2RlLm5vcm1hbGl6ZShjaGlsZHJlbltpXSlcblx0fVxuXHRyZXR1cm4gY2hpbGRyZW5cbn1cbnZhciBzZWxlY3RvclBhcnNlciA9IC8oPzooXnwjfFxcLikoW14jXFwuXFxbXFxdXSspKXwoXFxbKC4rPykoPzpcXHMqPVxccyooXCJ8J3wpKCg/OlxcXFxbXCInXFxdXXwuKSo/KVxcNSk/XFxdKS9nXG52YXIgc2VsZWN0b3JDYWNoZSA9IHt9XG52YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHlcbmZ1bmN0aW9uIGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcikge1xuXHR2YXIgbWF0Y2gsIHRhZyA9IFwiZGl2XCIsIGNsYXNzZXMgPSBbXSwgYXR0cnMgPSB7fVxuXHR3aGlsZSAobWF0Y2ggPSBzZWxlY3RvclBhcnNlci5leGVjKHNlbGVjdG9yKSkge1xuXHRcdHZhciB0eXBlID0gbWF0Y2hbMV0sIHZhbHVlID0gbWF0Y2hbMl1cblx0XHRpZiAodHlwZSA9PT0gXCJcIiAmJiB2YWx1ZSAhPT0gXCJcIikgdGFnID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIiNcIikgYXR0cnMuaWQgPSB2YWx1ZVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwiLlwiKSBjbGFzc2VzLnB1c2godmFsdWUpXG5cdFx0ZWxzZSBpZiAobWF0Y2hbM11bMF0gPT09IFwiW1wiKSB7XG5cdFx0XHR2YXIgYXR0clZhbHVlID0gbWF0Y2hbNl1cblx0XHRcdGlmIChhdHRyVmFsdWUpIGF0dHJWYWx1ZSA9IGF0dHJWYWx1ZS5yZXBsYWNlKC9cXFxcKFtcIiddKS9nLCBcIiQxXCIpLnJlcGxhY2UoL1xcXFxcXFxcL2csIFwiXFxcXFwiKVxuXHRcdFx0aWYgKG1hdGNoWzRdID09PSBcImNsYXNzXCIpIGNsYXNzZXMucHVzaChhdHRyVmFsdWUpXG5cdFx0XHRlbHNlIGF0dHJzW21hdGNoWzRdXSA9IGF0dHJWYWx1ZSB8fCB0cnVlXG5cdFx0fVxuXHR9XG5cdGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcIiBcIilcblx0cmV0dXJuIHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdID0ge3RhZzogdGFnLCBhdHRyczogYXR0cnN9XG59XG5mdW5jdGlvbiBleGVjU2VsZWN0b3Ioc3RhdGUsIGF0dHJzLCBjaGlsZHJlbikge1xuXHR2YXIgaGFzQXR0cnMgPSBmYWxzZSwgY2hpbGRMaXN0LCB0ZXh0XG5cdHZhciBjbGFzc05hbWUgPSBhdHRycy5jbGFzc05hbWUgfHwgYXR0cnMuY2xhc3Ncblx0Zm9yICh2YXIga2V5IGluIHN0YXRlLmF0dHJzKSB7XG5cdFx0aWYgKGhhc093bi5jYWxsKHN0YXRlLmF0dHJzLCBrZXkpKSB7XG5cdFx0XHRhdHRyc1trZXldID0gc3RhdGUuYXR0cnNba2V5XVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoYXR0cnMuY2xhc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXR0cnMuY2xhc3MgPSB1bmRlZmluZWRcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuXHRcdH1cblx0XHRpZiAoc3RhdGUuYXR0cnMuY2xhc3NOYW1lICE9IG51bGwpIHtcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IHN0YXRlLmF0dHJzLmNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NOYW1lXG5cdFx0fVxuXHR9XG5cdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSAmJiBrZXkgIT09IFwia2V5XCIpIHtcblx0XHRcdGhhc0F0dHJzID0gdHJ1ZVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdH1cblx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXSAhPSBudWxsICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCIjXCIpIHtcblx0XHR0ZXh0ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0fSBlbHNlIHtcblx0XHRjaGlsZExpc3QgPSBjaGlsZHJlblxuXHR9XG5cdHJldHVybiBWbm9kZShzdGF0ZS50YWcsIGF0dHJzLmtleSwgaGFzQXR0cnMgPyBhdHRycyA6IHVuZGVmaW5lZCwgY2hpbGRMaXN0LCB0ZXh0KVxufVxuZnVuY3Rpb24gaHlwZXJzY3JpcHQoc2VsZWN0b3IpIHtcblx0Ly8gQmVjYXVzZSBzbG9wcHkgbW9kZSBzdWNrc1xuXHR2YXIgYXR0cnMgPSBhcmd1bWVudHNbMV0sIHN0YXJ0ID0gMiwgY2hpbGRyZW5cblx0aWYgKHNlbGVjdG9yID09IG51bGwgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzZWxlY3Rvci52aWV3ICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR0aHJvdyBFcnJvcihcIlRoZSBzZWxlY3RvciBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhIGNvbXBvbmVudC5cIik7XG5cdH1cblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHZhciBjYWNoZWQgPSBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSB8fCBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpXG5cdH1cblx0aWYgKGF0dHJzID09IG51bGwpIHtcblx0XHRhdHRycyA9IHt9XG5cdH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzICE9PSBcIm9iamVjdFwiIHx8IGF0dHJzLnRhZyAhPSBudWxsIHx8IEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHRcdHN0YXJ0ID0gMVxuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSBzdGFydCArIDEpIHtcblx0XHRjaGlsZHJlbiA9IGFyZ3VtZW50c1tzdGFydF1cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSBjaGlsZHJlbiA9IFtjaGlsZHJlbl1cblx0fSBlbHNlIHtcblx0XHRjaGlsZHJlbiA9IFtdXG5cdFx0d2hpbGUgKHN0YXJ0IDwgYXJndW1lbnRzLmxlbmd0aCkgY2hpbGRyZW4ucHVzaChhcmd1bWVudHNbc3RhcnQrK10pXG5cdH1cblx0dmFyIG5vcm1hbGl6ZWQgPSBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbilcblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBleGVjU2VsZWN0b3IoY2FjaGVkLCBhdHRycywgbm9ybWFsaXplZClcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gVm5vZGUoc2VsZWN0b3IsIGF0dHJzLmtleSwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH1cbn1cbmh5cGVyc2NyaXB0LnRydXN0ID0gZnVuY3Rpb24oaHRtbCkge1xuXHRpZiAoaHRtbCA9PSBudWxsKSBodG1sID0gXCJcIlxuXHRyZXR1cm4gVm5vZGUoXCI8XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBodG1sLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbmh5cGVyc2NyaXB0LmZyYWdtZW50ID0gZnVuY3Rpb24oYXR0cnMxLCBjaGlsZHJlbikge1xuXHRyZXR1cm4gVm5vZGUoXCJbXCIsIGF0dHJzMS5rZXksIGF0dHJzMSwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbnZhciBtID0gaHlwZXJzY3JpcHRcbi8qKiBAY29uc3RydWN0b3IgKi9cbnZhciBQcm9taXNlUG9seWZpbGwgPSBmdW5jdGlvbihleGVjdXRvcikge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGBuZXdgXCIpXG5cdGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvblwiKVxuXHR2YXIgc2VsZiA9IHRoaXMsIHJlc29sdmVycyA9IFtdLCByZWplY3RvcnMgPSBbXSwgcmVzb2x2ZUN1cnJlbnQgPSBoYW5kbGVyKHJlc29sdmVycywgdHJ1ZSksIHJlamVjdEN1cnJlbnQgPSBoYW5kbGVyKHJlamVjdG9ycywgZmFsc2UpXG5cdHZhciBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlID0ge3Jlc29sdmVyczogcmVzb2x2ZXJzLCByZWplY3RvcnM6IHJlamVjdG9yc31cblx0dmFyIGNhbGxBc3luYyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gaGFuZGxlcihsaXN0LCBzaG91bGRBYnNvcmIpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXhlY3V0ZSh2YWx1ZSkge1xuXHRcdFx0dmFyIHRoZW5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChzaG91bGRBYnNvcmIgJiYgdmFsdWUgIT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgKHRoZW4gPSB2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBzZWxmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCB3LyBpdHNlbGZcIilcblx0XHRcdFx0XHRleGVjdXRlT25jZSh0aGVuLmJpbmQodmFsdWUpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxBc3luYyhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICghc2hvdWxkQWJzb3JiICYmIGxpc3QubGVuZ3RoID09PSAwKSBjb25zb2xlLmVycm9yKFwiUG9zc2libGUgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOlwiLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgbGlzdFtpXSh2YWx1ZSlcblx0XHRcdFx0XHRcdHJlc29sdmVycy5sZW5ndGggPSAwLCByZWplY3RvcnMubGVuZ3RoID0gMFxuXHRcdFx0XHRcdFx0aW5zdGFuY2Uuc3RhdGUgPSBzaG91bGRBYnNvcmJcblx0XHRcdFx0XHRcdGluc3RhbmNlLnJldHJ5ID0gZnVuY3Rpb24oKSB7ZXhlY3V0ZSh2YWx1ZSl9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVqZWN0Q3VycmVudChlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBleGVjdXRlT25jZSh0aGVuKSB7XG5cdFx0dmFyIHJ1bnMgPSAwXG5cdFx0ZnVuY3Rpb24gcnVuKGZuKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKHJ1bnMrKyA+IDApIHJldHVyblxuXHRcdFx0XHRmbih2YWx1ZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIG9uZXJyb3IgPSBydW4ocmVqZWN0Q3VycmVudClcblx0XHR0cnkge3RoZW4ocnVuKHJlc29sdmVDdXJyZW50KSwgb25lcnJvcil9IGNhdGNoIChlKSB7b25lcnJvcihlKX1cblx0fVxuXHRleGVjdXRlT25jZShleGVjdXRvcilcbn1cblByb21pc2VQb2x5ZmlsbC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGlvbikge1xuXHR2YXIgc2VsZiA9IHRoaXMsIGluc3RhbmNlID0gc2VsZi5faW5zdGFuY2Vcblx0ZnVuY3Rpb24gaGFuZGxlKGNhbGxiYWNrLCBsaXN0LCBuZXh0LCBzdGF0ZSkge1xuXHRcdGxpc3QucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSBuZXh0KHZhbHVlKVxuXHRcdFx0ZWxzZSB0cnkge3Jlc29sdmVOZXh0KGNhbGxiYWNrKHZhbHVlKSl9IGNhdGNoIChlKSB7aWYgKHJlamVjdE5leHQpIHJlamVjdE5leHQoZSl9XG5cdFx0fSlcblx0XHRpZiAodHlwZW9mIGluc3RhbmNlLnJldHJ5ID09PSBcImZ1bmN0aW9uXCIgJiYgc3RhdGUgPT09IGluc3RhbmNlLnN0YXRlKSBpbnN0YW5jZS5yZXRyeSgpXG5cdH1cblx0dmFyIHJlc29sdmVOZXh0LCByZWplY3ROZXh0XG5cdHZhciBwcm9taXNlID0gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZXNvbHZlTmV4dCA9IHJlc29sdmUsIHJlamVjdE5leHQgPSByZWplY3R9KVxuXHRoYW5kbGUob25GdWxmaWxsZWQsIGluc3RhbmNlLnJlc29sdmVycywgcmVzb2x2ZU5leHQsIHRydWUpLCBoYW5kbGUob25SZWplY3Rpb24sIGluc3RhbmNlLnJlamVjdG9ycywgcmVqZWN0TmV4dCwgZmFsc2UpXG5cdHJldHVybiBwcm9taXNlXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcblx0cmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbilcbn1cblByb21pc2VQb2x5ZmlsbC5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSByZXR1cm4gdmFsdWVcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSkge3Jlc29sdmUodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZWplY3QodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5hbGwgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdHZhciB0b3RhbCA9IGxpc3QubGVuZ3RoLCBjb3VudCA9IDAsIHZhbHVlcyA9IFtdXG5cdFx0aWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKVxuXHRcdGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQoZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRmdW5jdGlvbiBjb25zdW1lKHZhbHVlKSB7XG5cdFx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSB0b3RhbCkgcmVzb2x2ZSh2YWx1ZXMpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxpc3RbaV0gIT0gbnVsbCAmJiAodHlwZW9mIGxpc3RbaV0gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGxpc3RbaV0gPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mIGxpc3RbaV0udGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0bGlzdFtpXS50aGVuKGNvbnN1bWUsIHJlamVjdClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGNvbnN1bWUobGlzdFtpXSlcblx0XHRcdH0pKGkpXG5cdFx0fVxuXHR9KVxufVxuUHJvbWlzZVBvbHlmaWxsLnJhY2UgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGlzdFtpXS50aGVuKHJlc29sdmUsIHJlamVjdClcblx0XHR9XG5cdH0pXG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRpZiAodHlwZW9mIHdpbmRvdy5Qcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSB3aW5kb3cuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR2YXIgUHJvbWlzZVBvbHlmaWxsID0gd2luZG93LlByb21pc2Vcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRpZiAodHlwZW9mIGdsb2JhbC5Qcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSBnbG9iYWwuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR2YXIgUHJvbWlzZVBvbHlmaWxsID0gZ2xvYmFsLlByb21pc2Vcbn0gZWxzZSB7XG59XG52YXIgYnVpbGRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHJldHVybiBcIlwiXG5cdHZhciBhcmdzID0gW11cblx0Zm9yICh2YXIga2V5MCBpbiBvYmplY3QpIHtcblx0XHRkZXN0cnVjdHVyZShrZXkwLCBvYmplY3Rba2V5MF0pXG5cdH1cblx0cmV0dXJuIGFyZ3Muam9pbihcIiZcIilcblx0ZnVuY3Rpb24gZGVzdHJ1Y3R1cmUoa2V5MCwgdmFsdWUpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRkZXN0cnVjdHVyZShrZXkwICsgXCJbXCIgKyBpICsgXCJdXCIsIHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGFyZ3MucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5MCkgKyAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gXCJcIiA/IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IFwiXCIpKVxuXHR9XG59XG52YXIgRklMRV9QUk9UT0NPTF9SRUdFWCA9IG5ldyBSZWdFeHAoXCJeZmlsZTovL1wiLCBcImlcIilcbnZhciBfOCA9IGZ1bmN0aW9uKCR3aW5kb3csIFByb21pc2UpIHtcblx0dmFyIGNhbGxiYWNrQ291bnQgPSAwXG5cdHZhciBvbmNvbXBsZXRpb25cblx0ZnVuY3Rpb24gc2V0Q29tcGxldGlvbkNhbGxiYWNrKGNhbGxiYWNrKSB7b25jb21wbGV0aW9uID0gY2FsbGJhY2t9XG5cdGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcblx0XHR2YXIgY291bnQgPSAwXG5cdFx0ZnVuY3Rpb24gY29tcGxldGUoKSB7aWYgKC0tY291bnQgPT09IDAgJiYgdHlwZW9mIG9uY29tcGxldGlvbiA9PT0gXCJmdW5jdGlvblwiKSBvbmNvbXBsZXRpb24oKX1cblx0XHRyZXR1cm4gZnVuY3Rpb24gZmluYWxpemUocHJvbWlzZTApIHtcblx0XHRcdHZhciB0aGVuMCA9IHByb21pc2UwLnRoZW5cblx0XHRcdHByb21pc2UwLnRoZW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHR2YXIgbmV4dCA9IHRoZW4wLmFwcGx5KHByb21pc2UwLCBhcmd1bWVudHMpXG5cdFx0XHRcdG5leHQudGhlbihjb21wbGV0ZSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGNvbXBsZXRlKClcblx0XHRcdFx0XHRpZiAoY291bnQgPT09IDApIHRocm93IGVcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuIGZpbmFsaXplKG5leHQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTBcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmdzID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgdXJsID0gYXJnc1xuXHRcdFx0YXJncyA9IGV4dHJhIHx8IHt9XG5cdFx0XHRpZiAoYXJncy51cmwgPT0gbnVsbCkgYXJncy51cmwgPSB1cmxcblx0XHR9XG5cdFx0cmV0dXJuIGFyZ3Ncblx0fVxuXHRmdW5jdGlvbiByZXF1ZXN0KGFyZ3MsIGV4dHJhKSB7XG5cdFx0dmFyIGZpbmFsaXplID0gZmluYWxpemVyKClcblx0XHRhcmdzID0gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKVxuXHRcdHZhciBwcm9taXNlMCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0aWYgKGFyZ3MubWV0aG9kID09IG51bGwpIGFyZ3MubWV0aG9kID0gXCJHRVRcIlxuXHRcdFx0YXJncy5tZXRob2QgPSBhcmdzLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG5cdFx0XHR2YXIgdXNlQm9keSA9IChhcmdzLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBhcmdzLm1ldGhvZCA9PT0gXCJUUkFDRVwiKSA/IGZhbHNlIDogKHR5cGVvZiBhcmdzLnVzZUJvZHkgPT09IFwiYm9vbGVhblwiID8gYXJncy51c2VCb2R5IDogdHJ1ZSlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5zZXJpYWxpemUgIT09IFwiZnVuY3Rpb25cIikgYXJncy5zZXJpYWxpemUgPSB0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJncy5kYXRhIGluc3RhbmNlb2YgRm9ybURhdGEgPyBmdW5jdGlvbih2YWx1ZSkge3JldHVybiB2YWx1ZX0gOiBKU09OLnN0cmluZ2lmeVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmRlc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmV4dHJhY3QgIT09IFwiZnVuY3Rpb25cIikgYXJncy5leHRyYWN0ID0gZXh0cmFjdFxuXHRcdFx0YXJncy51cmwgPSBpbnRlcnBvbGF0ZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0aWYgKHVzZUJvZHkpIGFyZ3MuZGF0YSA9IGFyZ3Muc2VyaWFsaXplKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgYXJncy51cmwgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0dmFyIHhociA9IG5ldyAkd2luZG93LlhNTEh0dHBSZXF1ZXN0KCksXG5cdFx0XHRcdGFib3J0ZWQgPSBmYWxzZSxcblx0XHRcdFx0X2Fib3J0ID0geGhyLmFib3J0XG5cdFx0XHR4aHIuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcblx0XHRcdFx0YWJvcnRlZCA9IHRydWVcblx0XHRcdFx0X2Fib3J0LmNhbGwoeGhyKVxuXHRcdFx0fVxuXHRcdFx0eGhyLm9wZW4oYXJncy5tZXRob2QsIGFyZ3MudXJsLCB0eXBlb2YgYXJncy5hc3luYyA9PT0gXCJib29sZWFuXCIgPyBhcmdzLmFzeW5jIDogdHJ1ZSwgdHlwZW9mIGFyZ3MudXNlciA9PT0gXCJzdHJpbmdcIiA/IGFyZ3MudXNlciA6IHVuZGVmaW5lZCwgdHlwZW9mIGFyZ3MucGFzc3dvcmQgPT09IFwic3RyaW5nXCIgPyBhcmdzLnBhc3N3b3JkIDogdW5kZWZpbmVkKVxuXHRcdFx0aWYgKGFyZ3Muc2VyaWFsaXplID09PSBKU09OLnN0cmluZ2lmeSAmJiB1c2VCb2R5KSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MuZGVzZXJpYWxpemUgPT09IGRlc2VyaWFsaXplKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC8qXCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy53aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSBhcmdzLndpdGhDcmVkZW50aWFsc1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZ3MuaGVhZGVycykgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXJncy5oZWFkZXJzLCBrZXkpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgYXJncy5oZWFkZXJzW2tleV0pXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuY29uZmlnID09PSBcImZ1bmN0aW9uXCIpIHhociA9IGFyZ3MuY29uZmlnKHhociwgYXJncykgfHwgeGhyXG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIERvbid0IHRocm93IGVycm9ycyBvbiB4aHIuYWJvcnQoKS5cblx0XHRcdFx0aWYoYWJvcnRlZCkgcmV0dXJuXG5cdFx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVzcG9uc2UgPSAoYXJncy5leHRyYWN0ICE9PSBleHRyYWN0KSA/IGFyZ3MuZXh0cmFjdCh4aHIsIGFyZ3MpIDogYXJncy5kZXNlcmlhbGl6ZShhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSlcblx0XHRcdFx0XHRcdGlmICgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PT0gMzA0IHx8IEZJTEVfUFJPVE9DT0xfUkVHRVgudGVzdChhcmdzLnVybCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShjYXN0KGFyZ3MudHlwZSwgcmVzcG9uc2UpKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcih4aHIucmVzcG9uc2VUZXh0KVxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UpIGVycm9yW2tleV0gPSByZXNwb25zZVtrZXldXG5cdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZUJvZHkgJiYgKGFyZ3MuZGF0YSAhPSBudWxsKSkgeGhyLnNlbmQoYXJncy5kYXRhKVxuXHRcdFx0ZWxzZSB4aHIuc2VuZCgpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlID8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBqc29ucChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHZhciBjYWxsYmFja05hbWUgPSBhcmdzLmNhbGxiYWNrTmFtZSB8fCBcIl9taXRocmlsX1wiICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxNikgKyBcIl9cIiArIGNhbGxiYWNrQ291bnQrK1xuXHRcdFx0dmFyIHNjcmlwdCA9ICR3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKVxuXHRcdFx0JHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIGRhdGEpKVxuXHRcdFx0XHRkZWxldGUgJHdpbmRvd1tjYWxsYmFja05hbWVdXG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJKU09OUCByZXF1ZXN0IGZhaWxlZFwiKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MuZGF0YSA9PSBudWxsKSBhcmdzLmRhdGEgPSB7fVxuXHRcdFx0YXJncy51cmwgPSBpbnRlcnBvbGF0ZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0YXJncy5kYXRhW2FyZ3MuY2FsbGJhY2tLZXkgfHwgXCJjYWxsYmFja1wiXSA9IGNhbGxiYWNrTmFtZVxuXHRcdFx0c2NyaXB0LnNyYyA9IGFzc2VtYmxlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHQkd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlPyBwcm9taXNlMCA6IGZpbmFsaXplKHByb21pc2UwKVxuXHR9XG5cdGZ1bmN0aW9uIGludGVycG9sYXRlKHVybCwgZGF0YSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHJldHVybiB1cmxcblx0XHR2YXIgdG9rZW5zID0gdXJsLm1hdGNoKC86W15cXC9dKy9naSkgfHwgW11cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IHRva2Vuc1tpXS5zbGljZSgxKVxuXHRcdFx0aWYgKGRhdGFba2V5XSAhPSBudWxsKSB7XG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHRva2Vuc1tpXSwgZGF0YVtrZXldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXJsXG5cdH1cblx0ZnVuY3Rpb24gYXNzZW1ibGUodXJsLCBkYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5c3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZyhkYXRhKVxuXHRcdGlmIChxdWVyeXN0cmluZyAhPT0gXCJcIikge1xuXHRcdFx0dmFyIHByZWZpeCA9IHVybC5pbmRleE9mKFwiP1wiKSA8IDAgPyBcIj9cIiA6IFwiJlwiXG5cdFx0XHR1cmwgKz0gcHJlZml4ICsgcXVlcnlzdHJpbmdcblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGRlc2VyaWFsaXplKGRhdGEpIHtcblx0XHR0cnkge3JldHVybiBkYXRhICE9PSBcIlwiID8gSlNPTi5wYXJzZShkYXRhKSA6IG51bGx9XG5cdFx0Y2F0Y2ggKGUpIHt0aHJvdyBuZXcgRXJyb3IoZGF0YSl9XG5cdH1cblx0ZnVuY3Rpb24gZXh0cmFjdCh4aHIpIHtyZXR1cm4geGhyLnJlc3BvbnNlVGV4dH1cblx0ZnVuY3Rpb24gY2FzdCh0eXBlMCwgZGF0YSkge1xuXHRcdGlmICh0eXBlb2YgdHlwZTAgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YVtpXSA9IG5ldyB0eXBlMChkYXRhW2ldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHJldHVybiBuZXcgdHlwZTAoZGF0YSlcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHRyZXR1cm4ge3JlcXVlc3Q6IHJlcXVlc3QsIGpzb25wOiBqc29ucCwgc2V0Q29tcGxldGlvbkNhbGxiYWNrOiBzZXRDb21wbGV0aW9uQ2FsbGJhY2t9XG59XG52YXIgcmVxdWVzdFNlcnZpY2UgPSBfOCh3aW5kb3csIFByb21pc2VQb2x5ZmlsbClcbnZhciBjb3JlUmVuZGVyZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciAkZG9jID0gJHdpbmRvdy5kb2N1bWVudFxuXHR2YXIgJGVtcHR5RnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHR2YXIgb25ldmVudFxuXHRmdW5jdGlvbiBzZXRFdmVudENhbGxiYWNrKGNhbGxiYWNrKSB7cmV0dXJuIG9uZXZlbnQgPSBjYWxsYmFja31cblx0Ly9jcmVhdGVcblx0ZnVuY3Rpb24gY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAodHlwZW9mIHRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHN3aXRjaCAodGFnKSB7XG5cdFx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiPFwiOiByZXR1cm4gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIltcIjogcmV0dXJuIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGRlZmF1bHQ6IHJldHVybiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2bm9kZS5kb20gPSAkZG9jLmNyZWF0ZVRleHROb2RlKHZub2RlLmNoaWxkcmVuKVxuXHRcdGluc2VydE5vZGUocGFyZW50LCB2bm9kZS5kb20sIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIG1hdGNoMSA9IHZub2RlLmNoaWxkcmVuLm1hdGNoKC9eXFxzKj88KFxcdyspL2ltKSB8fCBbXVxuXHRcdHZhciBwYXJlbnQxID0ge2NhcHRpb246IFwidGFibGVcIiwgdGhlYWQ6IFwidGFibGVcIiwgdGJvZHk6IFwidGFibGVcIiwgdGZvb3Q6IFwidGFibGVcIiwgdHI6IFwidGJvZHlcIiwgdGg6IFwidHJcIiwgdGQ6IFwidHJcIiwgY29sZ3JvdXA6IFwidGFibGVcIiwgY29sOiBcImNvbGdyb3VwXCJ9W21hdGNoMVsxXV0gfHwgXCJkaXZcIlxuXHRcdHZhciB0ZW1wID0gJGRvYy5jcmVhdGVFbGVtZW50KHBhcmVudDEpXG5cdFx0dGVtcC5pbm5lckhUTUwgPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IHRlbXAuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSB0ZW1wLmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHR2YXIgY2hpbGRcblx0XHR3aGlsZSAoY2hpbGQgPSB0ZW1wLmZpcnN0Q2hpbGQpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0Y3JlYXRlTm9kZXMoZnJhZ21lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gZnJhZ21lbnQuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdHN3aXRjaCAodm5vZGUudGFnKSB7XG5cdFx0XHRjYXNlIFwic3ZnXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiOyBicmVha1xuXHRcdFx0Y2FzZSBcIm1hdGhcIjogbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjsgYnJlYWtcblx0XHR9XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCB1bmRlZmluZWQpXG5cdFx0ZWxzZSBpZiAodm5vZGVzID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgMCwgb2xkLmxlbmd0aCwgdm5vZGVzKVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC5sZW5ndGggPT09IHZub2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlzVW5rZXllZCA9IGZhbHNlXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIG9sZFtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpc1Vua2V5ZWQgPSB2bm9kZXNbaV0ua2V5ID09IG51bGwgJiYgb2xkW2ldLmtleSA9PSBudWxsXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNVbmtleWVkKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChvbGRbaV0gPT09IHZub2Rlc1tpXSkgY29udGludWVcblx0XHRcdFx0XHRcdGVsc2UgaWYgKG9sZFtpXSA9PSBudWxsICYmIHZub2Rlc1tpXSAhPSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGVzW2ldLCBob29rcywgbnMsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHZub2Rlc1tpXSA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIGksIGkgKyAxLCB2bm9kZXMpXG5cdFx0XHRcdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGRbaV0sIHZub2Rlc1tpXSwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlY3ljbGluZyA9IHJlY3ljbGluZyB8fCBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpXG5cdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdHZhciBwb29sID0gb2xkLnBvb2xcblx0XHRcdFx0b2xkID0gb2xkLmNvbmNhdChvbGQucG9vbClcblx0XHRcdH1cblx0XHRcdHZhciBvbGRTdGFydCA9IDAsIHN0YXJ0ID0gMCwgb2xkRW5kID0gb2xkLmxlbmd0aCAtIDEsIGVuZCA9IHZub2Rlcy5sZW5ndGggLSAxLCBtYXBcblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZFN0YXJ0XSwgdiA9IHZub2Rlc1tzdGFydF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZFN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRTdGFydCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0b2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF1cblx0XHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0XHRpZiAocmVjeWNsaW5nIHx8IHN0YXJ0IDwgZW5kKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0b2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdLCB2ID0gdm5vZGVzW2VuZF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdGlmIChvLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG8uZG9tXG5cdFx0XHRcdFx0b2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCFtYXApIG1hcCA9IGdldEtleU1hcChvbGQsIG9sZEVuZClcblx0XHRcdFx0XHRpZiAodiAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHR2YXIgb2xkSW5kZXggPSBtYXBbdi5rZXldXG5cdFx0XHRcdFx0XHRpZiAob2xkSW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbW92YWJsZSA9IG9sZFtvbGRJbmRleF1cblx0XHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEluZGV4ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG1vdmFibGUsIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobW92YWJsZSksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRvbGRbb2xkSW5kZXhdLnNraXAgPSB0cnVlXG5cdFx0XHRcdFx0XHRcdGlmIChtb3ZhYmxlLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG1vdmFibGUuZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRvbSA9IGNyZWF0ZU5vZGUocGFyZW50LCB2LCBob29rcywgdW5kZWZpbmVkLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0bmV4dFNpYmxpbmcgPSBkb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZW5kIDwgc3RhcnQpIGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCArIDEsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHRyZW1vdmVOb2RlcyhvbGQsIG9sZFN0YXJ0LCBvbGRFbmQgKyAxLCB2bm9kZXMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHR2YXIgb2xkVGFnID0gb2xkLnRhZywgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKG9sZFRhZyA9PT0gdGFnKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IG9sZC5zdGF0ZVxuXHRcdFx0dm5vZGUuX3N0YXRlID0gb2xkLl9zdGF0ZVxuXHRcdFx0dm5vZGUuZXZlbnRzID0gb2xkLmV2ZW50c1xuXHRcdFx0aWYgKCFyZWN5Y2xpbmcgJiYgc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpKSByZXR1cm5cblx0XHRcdGlmICh0eXBlb2Ygb2xkVGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0XHRcdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAob2xkVGFnKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIiNcIjogdXBkYXRlVGV4dChvbGQsIHZub2RlKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiPFwiOiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCJbXCI6IHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKTsgYnJlYWtcblx0XHRcdFx0XHRkZWZhdWx0OiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5zKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZCwgbnVsbClcblx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlVGV4dChvbGQsIHZub2RlKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbi50b1N0cmluZygpICE9PSB2bm9kZS5jaGlsZHJlbi50b1N0cmluZygpKSB7XG5cdFx0XHRvbGQuZG9tLm5vZGVWYWx1ZSA9IHZub2RlLmNoaWxkcmVuXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuICE9PSB2bm9kZS5jaGlsZHJlbikge1xuXHRcdFx0dG9GcmFnbWVudChvbGQpXG5cdFx0XHRjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0XHRlbHNlIHZub2RlLmRvbSA9IG9sZC5kb20sIHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0dXBkYXRlTm9kZXMocGFyZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0dmFyIGRvbVNpemUgPSAwLCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gbnVsbFxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLmRvbSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHZub2RlLmRvbSA9PSBudWxsKSB2bm9kZS5kb20gPSBjaGlsZC5kb21cblx0XHRcdFx0XHRkb21TaXplICs9IGNoaWxkLmRvbVNpemUgfHwgMVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9tU2l6ZSAhPT0gMSkgdm5vZGUuZG9tU2l6ZSA9IGRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdHN3aXRjaCAodm5vZGUudGFnKSB7XG5cdFx0XHRjYXNlIFwic3ZnXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiOyBicmVha1xuXHRcdFx0Y2FzZSBcIm1hdGhcIjogbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjsgYnJlYWtcblx0XHR9XG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgPT0gbnVsbCkgdm5vZGUuYXR0cnMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5hdHRycy52YWx1ZSA9IHZub2RlLnRleHQgLy9GSVhNRSBoYW5kbGUwIG11bHRpcGxlIGNoaWxkcmVuXG5cdFx0XHRcdHZub2RlLnRleHQgPSB1bmRlZmluZWRcblx0XHRcdH1cblx0XHR9XG5cdFx0dXBkYXRlQXR0cnModm5vZGUsIG9sZC5hdHRycywgdm5vZGUuYXR0cnMsIG5zKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT09IFwiXCIpIHtcblx0XHRcdGlmIChvbGQudGV4dC50b1N0cmluZygpICE9PSB2bm9kZS50ZXh0LnRvU3RyaW5nKCkpIG9sZC5kb20uZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB2bm9kZS50ZXh0XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC50ZXh0ICE9IG51bGwpIG9sZC5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZC50ZXh0LCB1bmRlZmluZWQsIG9sZC5kb20uZmlyc3RDaGlsZCldXG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdHVwZGF0ZU5vZGVzKGVsZW1lbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR9XG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdGlmIChvbGQuaW5zdGFuY2UgPT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLmluc3RhbmNlLCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQuaW5zdGFuY2UsIG51bGwpXG5cdFx0XHR2bm9kZS5kb20gPSB1bmRlZmluZWRcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcykge1xuXHRcdGlmIChvbGQucG9vbCAhPSBudWxsICYmIE1hdGguYWJzKG9sZC5wb29sLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpIDw9IE1hdGguYWJzKG9sZC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSkge1xuXHRcdFx0dmFyIG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkWzBdICYmIG9sZFswXS5jaGlsZHJlbiAmJiBvbGRbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciBwb29sQ2hpbGRyZW5MZW5ndGggPSBvbGQucG9vbFswXSAmJiBvbGQucG9vbFswXS5jaGlsZHJlbiAmJiBvbGQucG9vbFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHZub2Rlc0NoaWxkcmVuTGVuZ3RoID0gdm5vZGVzWzBdICYmIHZub2Rlc1swXS5jaGlsZHJlbiAmJiB2bm9kZXNbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdGlmIChNYXRoLmFicyhwb29sQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkgPD0gTWF0aC5hYnMob2xkQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gZ2V0S2V5TWFwKHZub2RlcywgZW5kKSB7XG5cdFx0dmFyIG1hcCA9IHt9LCBpID0gMFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGtleTIgPSB2bm9kZS5rZXlcblx0XHRcdFx0aWYgKGtleTIgIT0gbnVsbCkgbWFwW2tleTJdID0gaVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwXG5cdH1cblx0ZnVuY3Rpb24gdG9GcmFnbWVudCh2bm9kZSkge1xuXHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplXG5cdFx0aWYgKGNvdW50MCAhPSBudWxsIHx8IHZub2RlLmRvbSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdFx0aWYgKGNvdW50MCA+IDApIHtcblx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHR3aGlsZSAoLS1jb3VudDApIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0ZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKGRvbSwgZnJhZ21lbnQuZmlyc3RDaGlsZClcblx0XHRcdH1cblx0XHRcdHJldHVybiBmcmFnbWVudFxuXHRcdH1cblx0XHRlbHNlIHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBnZXROZXh0U2libGluZyh2bm9kZXMsIGksIG5leHRTaWJsaW5nKSB7XG5cdFx0Zm9yICg7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiB2bm9kZXNbaV0uZG9tICE9IG51bGwpIHJldHVybiB2bm9kZXNbaV0uZG9tXG5cdFx0fVxuXHRcdHJldHVybiBuZXh0U2libGluZ1xuXHR9XG5cdGZ1bmN0aW9uIGluc2VydE5vZGUocGFyZW50LCBkb20sIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudE5vZGUpIHBhcmVudC5pbnNlcnRCZWZvcmUoZG9tLCBuZXh0U2libGluZylcblx0XHRlbHNlIHBhcmVudC5hcHBlbmRDaGlsZChkb20pXG5cdH1cblx0ZnVuY3Rpb24gc2V0Q29udGVudEVkaXRhYmxlKHZub2RlKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIjxcIikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHRcdFx0aWYgKHZub2RlLmRvbS5pbm5lckhUTUwgIT09IGNvbnRlbnQpIHZub2RlLmRvbS5pbm5lckhUTUwgPSBjb250ZW50XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHZub2RlLnRleHQgIT0gbnVsbCB8fCBjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgbm9kZSBvZiBhIGNvbnRlbnRlZGl0YWJsZSBtdXN0IGJlIHRydXN0ZWRcIilcblx0fVxuXHQvL3JlbW92ZVxuXHRmdW5jdGlvbiByZW1vdmVOb2Rlcyh2bm9kZXMsIHN0YXJ0LCBlbmQsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUuc2tpcCkgdm5vZGUuc2tpcCA9IGZhbHNlXG5cdFx0XHRcdGVsc2UgcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dClcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dCkge1xuXHRcdHZhciBleHBlY3RlZCA9IDEsIGNhbGxlZCA9IDBcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGludWF0aW9uKClcblx0XHRmdW5jdGlvbiBjb250aW51YXRpb24oKSB7XG5cdFx0XHRpZiAoKytjYWxsZWQgPT09IGV4cGVjdGVkKSB7XG5cdFx0XHRcdG9ucmVtb3ZlKHZub2RlKVxuXHRcdFx0XHRpZiAodm5vZGUuZG9tKSB7XG5cdFx0XHRcdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemUgfHwgMVxuXHRcdFx0XHRcdGlmIChjb3VudDAgPiAxKSB7XG5cdFx0XHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1jb3VudDApIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00oZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTSh2bm9kZS5kb20pXG5cdFx0XHRcdFx0aWYgKGNvbnRleHQgIT0gbnVsbCAmJiB2bm9kZS5kb21TaXplID09IG51bGwgJiYgIWhhc0ludGVncmF0aW9uTWV0aG9kcyh2bm9kZS5hdHRycykgJiYgdHlwZW9mIHZub2RlLnRhZyA9PT0gXCJzdHJpbmdcIikgeyAvL1RPRE8gdGVzdCBjdXN0b20gZWxlbWVudHNcblx0XHRcdFx0XHRcdGlmICghY29udGV4dC5wb29sKSBjb250ZXh0LnBvb2wgPSBbdm5vZGVdXG5cdFx0XHRcdFx0XHRlbHNlIGNvbnRleHQucG9vbC5wdXNoKHZub2RlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlRnJvbURPTShub2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZVxuXHRcdGlmIChwYXJlbnQgIT0gbnVsbCkgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpXG5cdH1cblx0ZnVuY3Rpb24gb25yZW1vdmUodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLmF0dHJzLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuX3N0YXRlLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSBvbnJlbW92ZSh2bm9kZS5pbnN0YW5jZSlcblx0XHRlbHNlIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwpIG9ucmVtb3ZlKGNoaWxkKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vYXR0cnMyXG5cdGZ1bmN0aW9uIHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKSB7XG5cdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG51bGwsIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCwgdmFsdWUsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHRpZiAoa2V5MiA9PT0gXCJrZXlcIiB8fCBrZXkyID09PSBcImlzXCIgfHwgKG9sZCA9PT0gdmFsdWUgJiYgIWlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwga2V5MikpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHJldHVyblxuXHRcdHZhciBuc0xhc3RJbmRleCA9IGtleTIuaW5kZXhPZihcIjpcIilcblx0XHRpZiAobnNMYXN0SW5kZXggPiAtMSAmJiBrZXkyLnN1YnN0cigwLCBuc0xhc3RJbmRleCkgPT09IFwieGxpbmtcIikge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwga2V5Mi5zbGljZShuc0xhc3RJbmRleCArIDEpLCB2YWx1ZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyID09PSBcInN0eWxlXCIpIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiBpbiBlbGVtZW50ICYmICFpc0F0dHJpYnV0ZShrZXkyKSAmJiBucyA9PT0gdW5kZWZpbmVkICYmICFpc0N1c3RvbUVsZW1lbnQodm5vZGUpKSB7XG5cdFx0XHQvL3NldHRpbmcgaW5wdXRbdmFsdWVdIHRvIHNhbWUgdmFsdWUgYnkgdHlwaW5nIG9uIGZvY3VzZWQgZWxlbWVudCBtb3ZlcyBjdXJzb3IgdG8gZW5kIGluIENocm9tZVxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIHNlbGVjdFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJvcHRpb25cIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlKSByZXR1cm5cblx0XHRcdC8vIElmIHlvdSBhc3NpZ24gYW4gaW5wdXQgdHlwZTEgdGhhdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFIDExIHdpdGggYW4gYXNzaWdubWVudCBleHByZXNzaW9uLCBhbiBlcnJvcjAgd2lsbCBvY2N1ci5cblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInR5cGVcIikge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50W2tleTJdID0gdmFsdWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRpZiAodmFsdWUpIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIFwiXCIpXG5cdFx0XHRcdGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdH1cblx0XHRcdGVsc2UgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiA9PT0gXCJjbGFzc05hbWVcIiA/IFwiY2xhc3NcIiA6IGtleTIsIHZhbHVlKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRMYXRlQXR0cnModm5vZGUpIHtcblx0XHR2YXIgYXR0cnMyID0gdm5vZGUuYXR0cnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXCJ2YWx1ZVwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJ2YWx1ZVwiLCBudWxsLCBhdHRyczIudmFsdWUsIHVuZGVmaW5lZClcblx0XHRcdGlmIChcInNlbGVjdGVkSW5kZXhcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsLCBhdHRyczIuc2VsZWN0ZWRJbmRleCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVBdHRycyh2bm9kZSwgb2xkLCBhdHRyczIsIG5zKSB7XG5cdFx0aWYgKGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQgJiYgb2xkW2tleTJdLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAob2xkICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gb2xkKSB7XG5cdFx0XHRcdGlmIChhdHRyczIgPT0gbnVsbCB8fCAhKGtleTIgaW4gYXR0cnMyKSkge1xuXHRcdFx0XHRcdGlmIChrZXkyID09PSBcImNsYXNzTmFtZVwiKSBrZXkyID0gXCJjbGFzc1wiXG5cdFx0XHRcdFx0aWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmICFpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHVuZGVmaW5lZClcblx0XHRcdFx0XHRlbHNlIGlmIChrZXkyICE9PSBcImtleVwiKSB2bm9kZS5kb20ucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNGb3JtQXR0cmlidXRlKHZub2RlLCBhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwidmFsdWVcIiB8fCBhdHRyID09PSBcImNoZWNrZWRcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkSW5kZXhcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkXCIgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpc0xpZmVjeWNsZU1ldGhvZChhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwib25pbml0XCIgfHwgYXR0ciA9PT0gXCJvbmNyZWF0ZVwiIHx8IGF0dHIgPT09IFwib251cGRhdGVcIiB8fCBhdHRyID09PSBcIm9ucmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmV1cGRhdGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQXR0cmlidXRlKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJocmVmXCIgfHwgYXR0ciA9PT0gXCJsaXN0XCIgfHwgYXR0ciA9PT0gXCJmb3JtXCIgfHwgYXR0ciA9PT0gXCJ3aWR0aFwiIHx8IGF0dHIgPT09IFwiaGVpZ2h0XCIvLyB8fCBhdHRyID09PSBcInR5cGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudCh2bm9kZSl7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzLmlzIHx8IHZub2RlLnRhZy5pbmRleE9mKFwiLVwiKSA+IC0xXG5cdH1cblx0ZnVuY3Rpb24gaGFzSW50ZWdyYXRpb25NZXRob2RzKHNvdXJjZSkge1xuXHRcdHJldHVybiBzb3VyY2UgIT0gbnVsbCAmJiAoc291cmNlLm9uY3JlYXRlIHx8IHNvdXJjZS5vbnVwZGF0ZSB8fCBzb3VyY2Uub25iZWZvcmVyZW1vdmUgfHwgc291cmNlLm9ucmVtb3ZlKVxuXHR9XG5cdC8vc3R5bGVcblx0ZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCBzdHlsZSkge1xuXHRcdGlmIChvbGQgPT09IHN0eWxlKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiLCBvbGQgPSBudWxsXG5cdFx0aWYgKHN0eWxlID09IG51bGwpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRlbHNlIGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZCA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBzdHlsZSkge1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlW2tleTJdID0gc3R5bGVba2V5Ml1cblx0XHRcdH1cblx0XHRcdGlmIChvbGQgIT0gbnVsbCAmJiB0eXBlb2Ygb2xkICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleTIgaW4gb2xkKSB7XG5cdFx0XHRcdFx0aWYgKCEoa2V5MiBpbiBzdHlsZSkpIGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBcIlwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9ldmVudFxuXHRmdW5jdGlvbiB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdHZhciBjYWxsYmFjayA9IHR5cGVvZiBvbmV2ZW50ICE9PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSA6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWx1ZS5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRvbmV2ZW50LmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9XG5cdFx0aWYgKGtleTIgaW4gZWxlbWVudCkgZWxlbWVudFtrZXkyXSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2FsbGJhY2sgOiBudWxsXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0ga2V5Mi5zbGljZSgyKVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50cyA9PT0gdW5kZWZpbmVkKSB2bm9kZS5ldmVudHMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXkyXSA9PT0gY2FsbGJhY2spIHJldHVyblxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXkyXSAhPSBudWxsKSBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHZub2RlLmV2ZW50c1trZXkyXSA9IGNhbGxiYWNrXG5cdFx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vbGlmZWN5Y2xlXG5cdGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmluaXQgPT09IFwiZnVuY3Rpb25cIikgc291cmNlLm9uaW5pdC5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbmNyZWF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub251cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub251cGRhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSB7XG5cdFx0dmFyIGZvcmNlVm5vZGVVcGRhdGUsIGZvcmNlQ29tcG9uZW50VXBkYXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlVm5vZGVVcGRhdGUgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VDb21wb25lbnRVcGRhdGUgPSB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAoIShmb3JjZVZub2RlVXBkYXRlID09PSB1bmRlZmluZWQgJiYgZm9yY2VDb21wb25lbnRVcGRhdGUgPT09IHVuZGVmaW5lZCkgJiYgIWZvcmNlVm5vZGVVcGRhdGUgJiYgIWZvcmNlQ29tcG9uZW50VXBkYXRlKSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHRcdHZub2RlLmluc3RhbmNlID0gb2xkLmluc3RhbmNlXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiByZW5kZXIoZG9tLCB2bm9kZXMpIHtcblx0XHRpZiAoIWRvbSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCBiZWluZyBwYXNzZWQgdG8gbS5yb3V0ZS9tLm1vdW50L20ucmVuZGVyIGlzIG5vdCB1bmRlZmluZWQuXCIpXG5cdFx0dmFyIGhvb2tzID0gW11cblx0XHR2YXIgYWN0aXZlID0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdFx0Ly8gRmlyc3QgdGltZTAgcmVuZGVyaW5nIGludG8gYSBub2RlIGNsZWFycyBpdCBvdXRcblx0XHRpZiAoZG9tLnZub2RlcyA9PSBudWxsKSBkb20udGV4dENvbnRlbnQgPSBcIlwiXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHZub2RlcykpIHZub2RlcyA9IFt2bm9kZXNdXG5cdFx0dXBkYXRlTm9kZXMoZG9tLCBkb20udm5vZGVzLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbih2bm9kZXMpLCBmYWxzZSwgaG9va3MsIG51bGwsIHVuZGVmaW5lZClcblx0XHRkb20udm5vZGVzID0gdm5vZGVzXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykgaG9va3NbaV0oKVxuXHRcdGlmICgkZG9jLmFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZSkgYWN0aXZlLmZvY3VzKClcblx0fVxuXHRyZXR1cm4ge3JlbmRlcjogcmVuZGVyLCBzZXRFdmVudENhbGxiYWNrOiBzZXRFdmVudENhbGxiYWNrfVxufVxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2spIHtcblx0Ly82MGZwcyB0cmFuc2xhdGVzIHRvIDE2LjZtcywgcm91bmQgaXQgZG93biBzaW5jZSBzZXRUaW1lb3V0IHJlcXVpcmVzIGludFxuXHR2YXIgdGltZSA9IDE2XG5cdHZhciBsYXN0ID0gMCwgcGVuZGluZyA9IG51bGxcblx0dmFyIHRpbWVvdXQgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRUaW1lb3V0XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKVxuXHRcdGlmIChsYXN0ID09PSAwIHx8IG5vdyAtIGxhc3QgPj0gdGltZSkge1xuXHRcdFx0bGFzdCA9IG5vd1xuXHRcdFx0Y2FsbGJhY2soKVxuXHRcdH1cblx0XHRlbHNlIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG5cdFx0XHRwZW5kaW5nID0gdGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0cGVuZGluZyA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2soKVxuXHRcdFx0XHRsYXN0ID0gRGF0ZS5ub3coKVxuXHRcdFx0fSwgdGltZSAtIChub3cgLSBsYXN0KSlcblx0XHR9XG5cdH1cbn1cbnZhciBfMTEgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciByZW5kZXJTZXJ2aWNlID0gY29yZVJlbmRlcmVyKCR3aW5kb3cpXG5cdHJlbmRlclNlcnZpY2Uuc2V0RXZlbnRDYWxsYmFjayhmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGUucmVkcmF3ICE9PSBmYWxzZSkgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIG9wdGlvbnMgPSB7cmVwbGFjZTogdHJ1ZX1cblx0XHRsYXN0VXBkYXRlID0gbnVsbFxuXHRcdHJvdXRlU2VydmljZS5zZXRQYXRoKHBhdGgsIGRhdGEsIG9wdGlvbnMpXG5cdH1cblx0cm91dGUuZ2V0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIGN1cnJlbnRQYXRofVxuXHRyb3V0ZS5wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgwKSB7cm91dGVTZXJ2aWNlLnByZWZpeCA9IHByZWZpeDB9XG5cdHJvdXRlLmxpbmsgPSBmdW5jdGlvbih2bm9kZTEpIHtcblx0XHR2bm9kZTEuZG9tLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgcm91dGVTZXJ2aWNlLnByZWZpeCArIHZub2RlMS5hdHRycy5ocmVmKVxuXHRcdHZub2RlMS5kb20ub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS53aGljaCA9PT0gMikgcmV0dXJuXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KClcblx0XHRcdGUucmVkcmF3ID0gZmFsc2Vcblx0XHRcdHZhciBocmVmID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpXG5cdFx0XHRpZiAoaHJlZi5pbmRleE9mKHJvdXRlU2VydmljZS5wcmVmaXgpID09PSAwKSBocmVmID0gaHJlZi5zbGljZShyb3V0ZVNlcnZpY2UucHJlZml4Lmxlbmd0aClcblx0XHRcdHJvdXRlLnNldChocmVmLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0cm91dGUucGFyYW0gPSBmdW5jdGlvbihrZXkzKSB7XG5cdFx0aWYodHlwZW9mIGF0dHJzMyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Yga2V5MyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGF0dHJzM1trZXkzXVxuXHRcdHJldHVybiBhdHRyczNcblx0fVxuXHRyZXR1cm4gcm91dGVcbn1cbm0ucm91dGUgPSBfMjAod2luZG93LCByZWRyYXdTZXJ2aWNlKVxubS53aXRoQXR0ciA9IGZ1bmN0aW9uKGF0dHJOYW1lLCBjYWxsYmFjazEsIGNvbnRleHQpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRjYWxsYmFjazEuY2FsbChjb250ZXh0IHx8IHRoaXMsIGF0dHJOYW1lIGluIGUuY3VycmVudFRhcmdldCA/IGUuY3VycmVudFRhcmdldFthdHRyTmFtZV0gOiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSlcblx0fVxufVxudmFyIF8yOCA9IGNvcmVSZW5kZXJlcih3aW5kb3cpXG5tLnJlbmRlciA9IF8yOC5yZW5kZXJcbm0ucmVkcmF3ID0gcmVkcmF3U2VydmljZS5yZWRyYXdcbm0ucmVxdWVzdCA9IHJlcXVlc3RTZXJ2aWNlLnJlcXVlc3Rcbm0uanNvbnAgPSByZXF1ZXN0U2VydmljZS5qc29ucFxubS5wYXJzZVF1ZXJ5U3RyaW5nID0gcGFyc2VRdWVyeVN0cmluZ1xubS5idWlsZFF1ZXJ5U3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZ1xubS52ZXJzaW9uID0gXCIxLjEuMVwiXG5tLnZub2RlID0gVm5vZGVcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGVbXCJleHBvcnRzXCJdID0gbVxuZWxzZSB3aW5kb3cubSA9IG1cbn0oKSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWl0aHJpbC9taXRocmlsLmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICB2bm9kZS5zdGF0ZS5zcGFuID0gdm5vZGUuYXR0cnMuc3BhbjtcbiAgICB2bm9kZS5zdGF0ZS5jbHMgPSB2bm9kZS5hdHRycy5jbHM7XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2BtZGwtY2VsbCBtZGwtY2VsbC0tJHt2bm9kZS5zdGF0ZS5zcGFufS1jb2wgJHt2bm9kZS5zdGF0ZS5jbHN9YH0+XG4gICAgICB7dm5vZGUuYXR0cnMuaW5uZXJ9XG4gICAgPC9kaXY+XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9saWJzL2NvbXBvbmVudHMvY2VsbC5qcyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9saWJzL2NvbXBvbmVudHMvc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGNsYXNzIFJ1bGVyXG4gKlxuICogSGVscGVyIGNsYXNzLCB1c2VkIGJ5IFtbTWFya2Rvd25JdCNjb3JlXV0sIFtbTWFya2Rvd25JdCNibG9ja11dIGFuZFxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XG4gKlxuICogLSBrZWVwIHJ1bGVzIGluIGRlZmluZWQgb3JkZXJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxuICogLSBlbmFibGUvZGlzYWJsZSBydWxlc1xuICogLSBhZGQvcmVwbGFjZSBydWxlc1xuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxuICogLSBjYWNoZWluZyBsaXN0cyBvZiBhY3RpdmUgcnVsZXNcbiAqXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXG4gKiBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dLCBbW01hcmtkb3duSXQuZW5hYmxlXV0gYW5kXG4gKiBbW01hcmtkb3duSXQudXNlXV0uXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIG5hbWU6IFhYWCxcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxuICAvLyAgIGZuOiBGdW5jdGlvbigpLFxuICAvLyAgIGFsdDogWyBuYW1lMiwgbmFtZTMgXVxuICAvLyB9XG4gIC8vXG4gIHRoaXMuX19ydWxlc19fID0gW107XG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG5cblxuLy8gRmluZCBydWxlIGluZGV4IGJ5IG5hbWVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hdChuYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSBuYW1lIHRvIHJlcGxhY2UuXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBuZXcgcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxuICogZm91bmQuXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9yZ2FwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLmF0KCdyZXBsYWNlbWVudHMnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5mbiA9IGZuO1xuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmJlZm9yZShiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBiZWZvcmUgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdwYXJhZ3JhcGgnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGVPbmx5KGxpc3QgWywgaWdub3JlSW52YWxpZF0pXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUgKHdoaXRlbGlzdCkuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcywgYW5kIGRpc2FibGUgZXZlcnl0aGluZyBlbHNlLiBJZiBhbnkgcnVsZSBuYW1lXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlXV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB0aGlzLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7IHJ1bGUuZW5hYmxlZCA9IGZhbHNlOyB9KTtcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5kaXNhYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5lbmFibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gZmFsc2U7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gIH1cblxuICAvLyBDaGFpbiBjYW4gYmUgZW1wdHksIGlmIHJ1bGVzIGRpc2FibGVkLiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byByZXR1cm4gQXJyYXkuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlci5qcyIsIi8vIFRva2VuIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKipcbiAqIGNsYXNzIFRva2VuXG4gKiovXG5cbi8qKlxuICogbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZylcbiAqXG4gKiBDcmVhdGUgbmV3IHRva2VuIGFuZCBmaWxsIHBhc3NlZCBwcm9wZXJ0aWVzLlxuICoqL1xuZnVuY3Rpb24gVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIC8qKlxuICAgKiBUb2tlbiN0eXBlIC0+IFN0cmluZ1xuICAgKlxuICAgKiBUeXBlIG9mIHRoZSB0b2tlbiAoc3RyaW5nLCBlLmcuIFwicGFyYWdyYXBoX29wZW5cIilcbiAgICoqL1xuICB0aGlzLnR5cGUgICAgID0gdHlwZTtcblxuICAvKipcbiAgICogVG9rZW4jdGFnIC0+IFN0cmluZ1xuICAgKlxuICAgKiBodG1sIHRhZyBuYW1lLCBlLmcuIFwicFwiXG4gICAqKi9cbiAgdGhpcy50YWcgICAgICA9IHRhZztcblxuICAvKipcbiAgICogVG9rZW4jYXR0cnMgLT4gQXJyYXlcbiAgICpcbiAgICogSHRtbCBhdHRyaWJ1dGVzLiBGb3JtYXQ6IGBbIFsgbmFtZTEsIHZhbHVlMSBdLCBbIG5hbWUyLCB2YWx1ZTIgXSBdYFxuICAgKiovXG4gIHRoaXMuYXR0cnMgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtYXAgLT4gQXJyYXlcbiAgICpcbiAgICogU291cmNlIG1hcCBpbmZvLiBGb3JtYXQ6IGBbIGxpbmVfYmVnaW4sIGxpbmVfZW5kIF1gXG4gICAqKi9cbiAgdGhpcy5tYXAgICAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI25lc3RpbmcgLT4gTnVtYmVyXG4gICAqXG4gICAqIExldmVsIGNoYW5nZSAobnVtYmVyIGluIHstMSwgMCwgMX0gc2V0KSwgd2hlcmU6XG4gICAqXG4gICAqIC0gIGAxYCBtZWFucyB0aGUgdGFnIGlzIG9wZW5pbmdcbiAgICogLSAgYDBgIG1lYW5zIHRoZSB0YWcgaXMgc2VsZi1jbG9zaW5nXG4gICAqIC0gYC0xYCBtZWFucyB0aGUgdGFnIGlzIGNsb3NpbmdcbiAgICoqL1xuICB0aGlzLm5lc3RpbmcgID0gbmVzdGluZztcblxuICAvKipcbiAgICogVG9rZW4jbGV2ZWwgLT4gTnVtYmVyXG4gICAqXG4gICAqIG5lc3RpbmcgbGV2ZWwsIHRoZSBzYW1lIGFzIGBzdGF0ZS5sZXZlbGBcbiAgICoqL1xuICB0aGlzLmxldmVsICAgID0gMDtcblxuICAvKipcbiAgICogVG9rZW4jY2hpbGRyZW4gLT4gQXJyYXlcbiAgICpcbiAgICogQW4gYXJyYXkgb2YgY2hpbGQgbm9kZXMgKGlubGluZSBhbmQgaW1nIHRva2VucylcbiAgICoqL1xuICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jY29udGVudCAtPiBTdHJpbmdcbiAgICpcbiAgICogSW4gYSBjYXNlIG9mIHNlbGYtY2xvc2luZyB0YWcgKGNvZGUsIGh0bWwsIGZlbmNlLCBldGMuKSxcbiAgICogaXQgaGFzIGNvbnRlbnRzIG9mIHRoaXMgdGFnLlxuICAgKiovXG4gIHRoaXMuY29udGVudCAgPSAnJztcblxuICAvKipcbiAgICogVG9rZW4jbWFya3VwIC0+IFN0cmluZ1xuICAgKlxuICAgKiAnKicgb3IgJ18nIGZvciBlbXBoYXNpcywgZmVuY2Ugc3RyaW5nIGZvciBmZW5jZSwgZXRjLlxuICAgKiovXG4gIHRoaXMubWFya3VwICAgPSAnJztcblxuICAvKipcbiAgICogVG9rZW4jaW5mbyAtPiBTdHJpbmdcbiAgICpcbiAgICogZmVuY2UgaW5mb3N0cmluZ1xuICAgKiovXG4gIHRoaXMuaW5mbyAgICAgPSAnJztcblxuICAvKipcbiAgICogVG9rZW4jbWV0YSAtPiBPYmplY3RcbiAgICpcbiAgICogQSBwbGFjZSBmb3IgcGx1Z2lucyB0byBzdG9yZSBhbiBhcmJpdHJhcnkgZGF0YVxuICAgKiovXG4gIHRoaXMubWV0YSAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNibG9jayAtPiBCb29sZWFuXG4gICAqXG4gICAqIFRydWUgZm9yIGJsb2NrLWxldmVsIHRva2VucywgZmFsc2UgZm9yIGlubGluZSB0b2tlbnMuXG4gICAqIFVzZWQgaW4gcmVuZGVyZXIgdG8gY2FsY3VsYXRlIGxpbmUgYnJlYWtzXG4gICAqKi9cbiAgdGhpcy5ibG9jayAgICA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNoaWRkZW4gLT4gQm9vbGVhblxuICAgKlxuICAgKiBJZiBpdCdzIHRydWUsIGlnbm9yZSB0aGlzIGVsZW1lbnQgd2hlbiByZW5kZXJpbmcuIFVzZWQgZm9yIHRpZ2h0IGxpc3RzXG4gICAqIHRvIGhpZGUgcGFyYWdyYXBocy5cbiAgICoqL1xuICB0aGlzLmhpZGRlbiAgID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySW5kZXgobmFtZSkgLT4gTnVtYmVyXG4gKlxuICogU2VhcmNoIGF0dHJpYnV0ZSBpbmRleCBieSBuYW1lLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJJbmRleCA9IGZ1bmN0aW9uIGF0dHJJbmRleChuYW1lKSB7XG4gIHZhciBhdHRycywgaSwgbGVuO1xuXG4gIGlmICghdGhpcy5hdHRycykgeyByZXR1cm4gLTE7IH1cblxuICBhdHRycyA9IHRoaXMuYXR0cnM7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gYXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXR0cnNbaV1bMF0gPT09IG5hbWUpIHsgcmV0dXJuIGk7IH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clB1c2goYXR0ckRhdGEpXG4gKlxuICogQWRkIGBbIG5hbWUsIHZhbHVlIF1gIGF0dHJpYnV0ZSB0byBsaXN0LiBJbml0IGF0dHJzIGlmIG5lY2Vzc2FyeVxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJQdXNoID0gZnVuY3Rpb24gYXR0clB1c2goYXR0ckRhdGEpIHtcbiAgaWYgKHRoaXMuYXR0cnMpIHtcbiAgICB0aGlzLmF0dHJzLnB1c2goYXR0ckRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnMgPSBbIGF0dHJEYXRhIF07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyU2V0KG5hbWUsIHZhbHVlKVxuICpcbiAqIFNldCBgbmFtZWAgYXR0cmlidXRlIHRvIGB2YWx1ZWAuIE92ZXJyaWRlIG9sZCB2YWx1ZSBpZiBleGlzdHMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0clNldCA9IGZ1bmN0aW9uIGF0dHJTZXQobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLFxuICAgICAgYXR0ckRhdGEgPSBbIG5hbWUsIHZhbHVlIF07XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzW2lkeF0gPSBhdHRyRGF0YTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJHZXQobmFtZSlcbiAqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGF0dHJpYnV0ZSBgbmFtZWAsIG9yIG51bGwgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckdldCA9IGZ1bmN0aW9uIGF0dHJHZXQobmFtZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksIHZhbHVlID0gbnVsbDtcbiAgaWYgKGlkeCA+PSAwKSB7XG4gICAgdmFsdWUgPSB0aGlzLmF0dHJzW2lkeF1bMV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJKb2luKG5hbWUsIHZhbHVlKVxuICpcbiAqIEpvaW4gdmFsdWUgdG8gZXhpc3RpbmcgYXR0cmlidXRlIHZpYSBzcGFjZS4gT3IgY3JlYXRlIG5ldyBhdHRyaWJ1dGUgaWYgbm90XG4gKiBleGlzdHMuIFVzZWZ1bCB0byBvcGVyYXRlIHdpdGggdG9rZW4gY2xhc3Nlcy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySm9pbiA9IGZ1bmN0aW9uIGF0dHJKb2luKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKTtcblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goWyBuYW1lLCB2YWx1ZSBdKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzW2lkeF1bMV0gPSB0aGlzLmF0dHJzW2lkeF1bMV0gKyAnICcgKyB2YWx1ZTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRva2VuO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3Rva2VuLmpzIiwibW9kdWxlLmV4cG9ydHM9L1shLSMlLVxcKiwtLzo7XFw/QFxcWy1cXF1fXFx7XFx9XFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0NFxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM5XFx1RERDRFxcdUREREJcXHVERERELVxcdUREREZcXHVERTM4LVxcdURFM0RcXHVERUE5XXxcXHVEODA1W1xcdURDNEItXFx1REM0RlxcdURDNUJcXHVEQzVEXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURFNjAtXFx1REU2Q1xcdURGM0MtXFx1REYzRV18XFx1RDgwN1tcXHVEQzQxLVxcdURDNDVcXHVEQzcwXFx1REM3MV18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4M0FbXFx1REQ1RVxcdURENUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleC5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICB2YXIgYmFzZTY0ID0gbmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cbiAgcmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwiLy8gSFRNTDUgZW50aXRpZXMgbWFwOiB7IG5hbWUgLT4gdXRmMTZzdHJpbmcgfVxuLy9cbid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQgcXVvdGVzOjAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdlbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vZW50aXRpZXMuanMiLCIvLyBSZWdleHBzIHRvIG1hdGNoIGh0bWwgZWxlbWVudHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXR0cl9uYW1lICAgICA9ICdbYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKic7XG5cbnZhciB1bnF1b3RlZCAgICAgID0gJ1teXCJcXCc9PD5gXFxcXHgwMC1cXFxceDIwXSsnO1xudmFyIHNpbmdsZV9xdW90ZWQgPSBcIidbXiddKidcIjtcbnZhciBkb3VibGVfcXVvdGVkID0gJ1wiW15cIl0qXCInO1xuXG52YXIgYXR0cl92YWx1ZSAgPSAnKD86JyArIHVucXVvdGVkICsgJ3wnICsgc2luZ2xlX3F1b3RlZCArICd8JyArIGRvdWJsZV9xdW90ZWQgKyAnKSc7XG5cbnZhciBhdHRyaWJ1dGUgICA9ICcoPzpcXFxccysnICsgYXR0cl9uYW1lICsgJyg/OlxcXFxzKj1cXFxccyonICsgYXR0cl92YWx1ZSArICcpPyknO1xuXG52YXIgb3Blbl90YWcgICAgPSAnPFtBLVphLXpdW0EtWmEtejAtOVxcXFwtXSonICsgYXR0cmlidXRlICsgJypcXFxccypcXFxcLz8+JztcblxudmFyIGNsb3NlX3RhZyAgID0gJzxcXFxcL1tBLVphLXpdW0EtWmEtejAtOVxcXFwtXSpcXFxccyo+JztcbnZhciBjb21tZW50ICAgICA9ICc8IS0tLS0+fDwhLS0oPzotP1tePi1dKSg/Oi0/W14tXSkqLS0+JztcbnZhciBwcm9jZXNzaW5nICA9ICc8Wz9dLio/Wz9dPic7XG52YXIgZGVjbGFyYXRpb24gPSAnPCFbQS1aXStcXFxccytbXj5dKj4nO1xudmFyIGNkYXRhICAgICAgID0gJzwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPic7XG5cbnZhciBIVE1MX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnfCcgKyBjb21tZW50ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHByb2Nlc3NpbmcgKyAnfCcgKyBkZWNsYXJhdGlvbiArICd8JyArIGNkYXRhICsgJyknKTtcbnZhciBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFID0gbmV3IFJlZ0V4cCgnXig/OicgKyBvcGVuX3RhZyArICd8JyArIGNsb3NlX3RhZyArICcpJyk7XG5cbm1vZHVsZS5leHBvcnRzLkhUTUxfVEFHX1JFID0gSFRNTF9UQUdfUkU7XG5tb2R1bGUuZXhwb3J0cy5IVE1MX09QRU5fQ0xPU0VfVEFHX1JFID0gSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qcyIsIi8vIFByb2Nlc3MgKnRoaXMqIGFuZCBfdGhhdF9cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChtYXJrZXIgIT09IDB4NUYgLyogXyAqLyAmJiBtYXJrZXIgIT09IDB4MkEgLyogKiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIG1hcmtlciA9PT0gMHgyQSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNjYW5uZWQubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgIC8vIENoYXIgY29kZSBvZiB0aGUgc3RhcnRpbmcgbWFya2VyIChudW1iZXIpLlxuICAgICAgLy9cbiAgICAgIG1hcmtlcjogbWFya2VyLFxuXG4gICAgICAvLyBUb3RhbCBsZW5ndGggb2YgdGhlc2Ugc2VyaWVzIG9mIGRlbGltaXRlcnMuXG4gICAgICAvL1xuICAgICAgbGVuZ3RoOiBzY2FubmVkLmxlbmd0aCxcblxuICAgICAgLy8gQW4gYW1vdW50IG9mIGNoYXJhY3RlcnMgYmVmb3JlIHRoaXMgb25lIHRoYXQncyBlcXVpdmFsZW50IHRvXG4gICAgICAvLyBjdXJyZW50IG9uZS4gSW4gcGxhaW4gRW5nbGlzaDogaWYgdGhpcyBkZWxpbWl0ZXIgZG9lcyBub3Qgb3BlblxuICAgICAgLy8gYW4gZW1waGFzaXMsIG5laXRoZXIgZG8gcHJldmlvdXMgYGp1bXBgIGNoYXJhY3RlcnMuXG4gICAgICAvL1xuICAgICAgLy8gVXNlZCB0byBza2lwIHNlcXVlbmNlcyBsaWtlIFwiKioqKipcIiBpbiBvbmUgc3RlcCwgZm9yIDFzdCBhc3Rlcmlza1xuICAgICAgLy8gdmFsdWUgd2lsbCBiZSAwLCBmb3IgMm5kIGl0J3MgMSBhbmQgc28gb24uXG4gICAgICAvL1xuICAgICAganVtcDogICBpLFxuXG4gICAgICAvLyBBIHBvc2l0aW9uIG9mIHRoZSB0b2tlbiB0aGlzIGRlbGltaXRlciBjb3JyZXNwb25kcyB0by5cbiAgICAgIC8vXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuXG4gICAgICAvLyBUb2tlbiBsZXZlbC5cbiAgICAgIC8vXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuXG4gICAgICAvLyBJZiB0aGlzIGRlbGltaXRlciBpcyBtYXRjaGVkIGFzIGEgdmFsaWQgb3BlbmVyLCBgZW5kYCB3aWxsIGJlXG4gICAgICAvLyBlcXVhbCB0byBpdHMgcG9zaXRpb24sIG90aGVyd2lzZSBpdCdzIGAtMWAuXG4gICAgICAvL1xuICAgICAgZW5kOiAgICAtMSxcblxuICAgICAgLy8gQm9vbGVhbiBmbGFncyB0aGF0IGRldGVybWluZSBpZiB0aGlzIGRlbGltaXRlciBjb3VsZCBvcGVuIG9yIGNsb3NlXG4gICAgICAvLyBhbiBlbXBoYXNpcy5cbiAgICAgIC8vXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlKSB7XG4gIHZhciBpLFxuICAgICAgc3RhcnREZWxpbSxcbiAgICAgIGVuZERlbGltLFxuICAgICAgdG9rZW4sXG4gICAgICBjaCxcbiAgICAgIGlzU3Ryb25nLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBzdGFydERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg1Ri8qIF8gKi8gJiYgc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4MkEvKiAqICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIG9ubHkgb3BlbmluZyBtYXJrZXJzXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIC8vIElmIHRoZSBuZXh0IGRlbGltaXRlciBoYXMgdGhlIHNhbWUgbWFya2VyIGFuZCBpcyBhZGphY2VudCB0byB0aGlzIG9uZSxcbiAgICAvLyBtZXJnZSB0aG9zZSBpbnRvIG9uZSBzdHJvbmcgZGVsaW1pdGVyLlxuICAgIC8vXG4gICAgLy8gYDxlbT48ZW0+d2hhdGV2ZXI8L2VtPjwvZW0+YCAtPiBgPHN0cm9uZz53aGF0ZXZlcjwvc3Ryb25nPmBcbiAgICAvL1xuICAgIGlzU3Ryb25nID0gaSArIDEgPCBtYXggJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSArIDFdLmVuZCA9PT0gc3RhcnREZWxpbS5lbmQgLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS50b2tlbiA9PT0gc3RhcnREZWxpbS50b2tlbiArIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgLSAxXS50b2tlbiA9PT0gZW5kRGVsaW0udG9rZW4gLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS5tYXJrZXIgPT09IHN0YXJ0RGVsaW0ubWFya2VyO1xuXG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0RGVsaW0ubWFya2VyKTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19vcGVuJyA6ICdlbV9vcGVuJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfY2xvc2UnIDogJ2VtX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoaXNTdHJvbmcpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW2kgKyAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgLSAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanMiLCIvLyB+fnN0cmlrZSB0aHJvdWdofn5cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbiwgbGVuLCBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCB0cnVlKTtcbiAgbGVuID0gc2Nhbm5lZC5sZW5ndGg7XG4gIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIGlmIChsZW4gPCAyKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChsZW4gJSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoO1xuICAgIGxlbi0tO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoICsgY2g7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICBqdW1wOiAgIGksXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcbiAgICAgIGVuZDogICAgLTEsXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIHN0cmlrZXRocm91Z2goc3RhdGUpIHtcbiAgdmFyIGksIGosXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGxvbmVNYXJrZXJzID0gW10sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDdFLyogfiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLmNvbnRlbnQgPT09ICd+Jykge1xuXG4gICAgICBsb25lTWFya2Vycy5wdXNoKGVuZERlbGltLnRva2VuIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSBtYXJrZXIgc2VxdWVuY2UgaGFzIGFuIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgaXQncyBzcGxpdHRlZFxuICAvLyBsaWtlIHRoaXM6IGB+fn5+fmAgLT4gYH5gICsgYH5+YCArIGB+fmAsIGxlYXZpbmcgb25lIG1hcmtlciBhdCB0aGVcbiAgLy8gc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAvL1xuICAvLyBTbywgd2UgaGF2ZSB0byBtb3ZlIGFsbCB0aG9zZSBtYXJrZXJzIGFmdGVyIHN1YnNlcXVlbnQgc19jbG9zZSB0YWdzLlxuICAvL1xuICB3aGlsZSAobG9uZU1hcmtlcnMubGVuZ3RoKSB7XG4gICAgaSA9IGxvbmVNYXJrZXJzLnBvcCgpO1xuICAgIGogPSBpICsgMTtcblxuICAgIHdoaWxlIChqIDwgc3RhdGUudG9rZW5zLmxlbmd0aCAmJiBzdGF0ZS50b2tlbnNbal0udHlwZSA9PT0gJ3NfY2xvc2UnKSB7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgai0tO1xuXG4gICAgaWYgKGkgIT09IGopIHtcbiAgICAgIHRva2VuID0gc3RhdGUudG9rZW5zW2pdO1xuICAgICAgc3RhdGUudG9rZW5zW2pdID0gc3RhdGUudG9rZW5zW2ldO1xuICAgICAgc3RhdGUudG9rZW5zW2ldID0gdG9rZW47XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSByZXF1aXJlKCcuL2RlY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlICA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx4MUZcXHg3Ri1cXHg5Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHRcdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0XHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyIFxuXHRcdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHRcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRcdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcblx0fSksXG5cdGdldEVsZW1lbnQgPSAoZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdFx0fTtcblx0fSkoZnVuY3Rpb24gKHN0eWxlVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3R5bGVUYXJnZXQpXG5cdH0pLFxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW10sXG5cdGZpeFVybHMgPSByZXF1aXJlKFwiLi9maXhVcmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRJbnRvID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblx0aWYgKCFzdHlsZVRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgc3R5bGVUYXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHRzdHlsZVRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0c3R5bGVUYXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhzdHlsZUVsZW1lbnQsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGF0dGFjaFRhZ0F0dHJzKGxpbmtFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUYWdBdHRycyhlbGVtZW50LCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKiBJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscyl7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcblxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBtb2RlbCBmcm9tICcuL21vZGVsLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMuY3NzJztcbmltcG9ydCBDZWxsIGZyb20gJ2xpYnMvY29tcG9uZW50cy9jZWxsJztcbmltcG9ydCBUaXRsZSBmcm9tICdsaWJzL2NvbXBvbmVudHMvdGl0bGUnO1xuaW1wb3J0IFRhZ3MgZnJvbSAnbGlicy9jb21wb25lbnRzL3RhZ3MnO1xuaW1wb3J0IEVkaXRvciBmcm9tICdsaWJzL2NvbXBvbmVudHMvZWRpdG9yJztcbmltcG9ydCBQcmV2aWV3IGZyb20gJ2xpYnMvY29tcG9uZW50cy9wcmV2aWV3JztcblxuZXhwb3J0IGNvbnN0IFNhdmUgPSB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBjb25zdCBtb2RlbCA9IHZub2RlLnN0YXRlLm1vZGVsO1xuICAgIGNvbnN0IGlubmVyID0gPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPSdtZGwtYnV0dG9uIG1kbC1qcy1idXR0b24gbWRsLWJ1dHRvbi0tcmFpc2VkIG1kbC1idXR0b24tLWNvbG9yZWQnXG4gICAgICBvbmNsaWNrPXttb2RlbC5zYXZlfT5cbiAgICAgIHNhdmVcbiAgICA8L2J1dHRvbj5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGNscz17c3R5bGVzLnNhdmVCdXR0b259IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICBtb2RlbC5mZXRjaCgpO1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgaWYgKG1vZGVsLmZldGNoZWQpIHtcbiAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nbWRsLWdyaWQnPlxuICAgICAgICA8VGl0bGUgbW9kZWw9e21vZGVsfSAvPlxuICAgICAgICA8VGFncyBtb2RlbD17bW9kZWx9IC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZWRpdG9yV3JhcH0+XG4gICAgICAgICAgPEVkaXRvciBrZXk9J2VkaXRvcicgbW9kZWw9e21vZGVsfSAvPlxuICAgICAgICAgIDxQcmV2aWV3IGtleT0ncHJldmlldycgYm9keT17bW9kZWwubWRCb2R5KCl9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8U2F2ZSBtb2RlbD17bW9kZWx9IC8+XG4gICAgICA8L2Rpdj5cbiAgICB9XG4gICAgcmV0dXJuIDxkaXY+44OH44O844K/5Y+W5b6X5LitLi4uPC9kaXY+XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudC5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50LmpzJ1xuXG5tLm1vdW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJyksIENvbXBvbmVudCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbnRyeS5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXG5pbXBvcnQgTWFya2Rvd25JdCBmcm9tICdtYXJrZG93bi1pdCdcblxuY29uc3QgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuY29uc3QgdXJsID0gIGAvYXBpL2FydGljbGVzLyR7bG9jYXRpb24uaHJlZi5zcGxpdCgnLycpLnNsaWNlKDQpLmpvaW4oJy8nKX1gO1xuXG5jb25zdCBNb2RlbCA9IHtcbiAgZGF0YToge30sXG4gIGZldGNoZWQ6IGZhbHNlLFxuICBmZXRjaDogKCkgPT4ge1xuICAgIHJldHVybiBtLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybDogdXJsLFxuICAgIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgTW9kZWwuZmV0Y2hlZCA9IHRydWU7XG4gICAgICBNb2RlbC5kYXRhID0gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH0sXG4gIHNhdmU6ICgpID0+IHtcbiAgICByZXR1cm4gbS5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiB1cmwsXG4gICAgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBNb2RlbC5kYXRhID0gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH0sXG4gIG1kQm9keTogKCkgPT4ge1xuICAgIHJldHVybiBtZC5yZW5kZXIoTW9kZWwuZGF0YS5ib2R5KTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGVsXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9tb2RlbC5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9jZWxsLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICB2bm9kZS5zdGF0ZS5tb2RlbCA9IHZub2RlLmF0dHJzLm1vZGVsO1xuICAgIHZub2RlLnN0YXRlLm9uaW5wdXQgPSB2ID0+IHtcbiAgICAgIHZub2RlLnN0YXRlLm1vZGVsLmRhdGEuYm9keSA9IHY7XG4gICAgfTtcbiAgfSxcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gPHRleHRhcmVhXG4gICAgICBjbGFzc05hbWU9e3N0eWxlcy50ZXh0YXJlYX1cbiAgICAgIG9uaW5wdXQ9e20ud2l0aEF0dHIoJ3ZhbHVlJywgdm5vZGUuc3RhdGUub25pbnB1dCl9PlxuICAgICAgICB7dm5vZGUuc3RhdGUubW9kZWwuZGF0YS5ib2R5fVxuICAgIDwvdGV4dGFyZWE+XG4gICAgcmV0dXJuIDxDZWxsIHNwYW49ezZ9IGNscz17YCR7c3R5bGVzLmVkaXRvcn0gJHtzdHlsZXMuZWRpdG9yTGVmdFNpZGV9YH0gaW5uZXI9e2lubmVyfSAvPlxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvY29tcG9uZW50cy9lZGl0b3IuanMiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMuY3NzJztcbmltcG9ydCBDZWxsIGZyb20gJy4vY2VsbC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIHJldHVybiA8Q2VsbCBzcGFuPXs2fSBjbHM9e2Ake3N0eWxlcy5lZGl0b3J9ICR7c3R5bGVzLmVkaXRvclJpZ2h0U2lkZX1gfVxuICAgICAgICAgICAgICAgICBpbm5lcj17bS50cnVzdCh2bm9kZS5hdHRycy5ib2R5KX0gLz5cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvY29tcG9uZW50cy9wcmV2aWV3LmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gICAgdm5vZGUuc3RhdGUub25jaGFuZ2UgPSB2ID0+IHtcbiAgICAgIHZub2RlLnN0YXRlLm1vZGVsLmRhdGEudGFncyA9IHYuc3BsaXQoJywnKTtcbiAgICB9O1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSA8aW5wdXQgdHlwZT0ndGV4dCcgY2xhc3NOYW1lPXtzdHlsZXMudGFnc31cbiAgICAgIG9uY2hhbmdlPXttLndpdGhBdHRyKCd2YWx1ZScsIHZub2RlLnN0YXRlLm9uY2hhbmFnZSl9XG4gICAgICB2YWx1ZT17dm5vZGUuc3RhdGUubW9kZWwuZGF0YS50YWdzLmpvaW4oJywnKX1cbiAgICAvPlxuICAgIHJldHVybiA8Q2VsbCBzcGFuPXsxMn0gaW5uZXI9e2lubmVyfSAvPlxuICB9XG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL3RhZ3MuanMiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBDZWxsIGZyb20gJy4vY2VsbC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgdm5vZGUuc3RhdGUubW9kZWwgPSB2bm9kZS5hdHRycy5tb2RlbDtcbiAgICB2bm9kZS5zdGF0ZS5vbmNoYW5nZSA9IHYgPT4ge1xuICAgICAgdm5vZGUuc3RhdGUubW9kZWwuZGF0YS50aXRsZSA9IHY7XG4gICAgfTtcbiAgfSxcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gPGlucHV0IHR5cGU9J3RleHQnIGNsYXNzTmFtZT17c3R5bGVzLnRpdGxlfVxuICAgICAgb25jaGFuZ2U9e20ud2l0aEF0dHIoJ3ZhbHVlJywgdm5vZGUuc3RhdGUub25jaGFuZ2UpfVxuICAgICAgdmFsdWU9e3Zub2RlLnN0YXRlLm1vZGVsLmRhdGEudGl0bGV9XG4gICAgLz5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9saWJzL2NvbXBvbmVudHMvdGl0bGUuanMiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9iYXNlNjQtanMvaW5kZXguanMiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9idWZmZXIvaW5kZXguanMiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2llZWU3NTQvaW5kZXguanMiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2lzYXJyYXkvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlcnNcblxuLy8gTWVyZ2Ugb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJzsgfVxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nOyB9XG5cblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJyk7IH1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZ1enp5TGluazogdHJ1ZSxcbiAgZnV6enlFbWFpbDogdHJ1ZSxcbiAgZnV6enlJUDogZmFsc2Vcbn07XG5cblxuZnVuY3Rpb24gaXNPcHRpb25zT2JqKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaykge1xuICAgIHJldHVybiBhY2MgfHwgZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkoayk7XG4gIH0sIGZhbHNlKTtcbn1cblxuXG52YXIgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICdodHRwOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5odHRwKSB7XG4gICAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUuaHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeXFxcXC9cXFxcLycgKyBzZWxmLnJlLnNyY19hdXRoICsgc2VsZi5yZS5zcmNfaG9zdF9wb3J0X3N0cmljdCArIHNlbGYucmUuc3JjX3BhdGgsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUuaHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUuaHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnaHR0cHM6JzogICdodHRwOicsXG4gICdmdHA6JzogICAgJ2h0dHA6JyxcbiAgJy8vJzogICAgICB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xuICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5ub19odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19hdXRoICtcbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyBzaW5nbGUtbGV2ZWwgZG9tYWlucywgYmVjYXVzZSBvZiBmYWxzZSBwb3NpdGl2ZXMgbGlrZSAnLy90ZXN0J1xuICAgICAgICAgIC8vIHdpdGggY29kZSBjb21tZW50c1xuICAgICAgICAgICcoPzpsb2NhbGhvc3R8KD86KD86JyArIHNlbGYucmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKycgKyBzZWxmLnJlLnNyY19kb21haW5fcm9vdCArICcpJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcG9ydCArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wYXRoLFxuXG4gICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlLm5vX2h0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gICYgYC8vL2AsIHRoYXQgcHJvdGVjdHMgZnJvbSBlcnJvcnMgaW4gcHJvdG9jb2wgbmFtZVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwOyB9XG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnLycpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdtYWlsdG86Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICBzZWxmLnJlLm1haWx0byA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArIHNlbGYucmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyBzZWxmLnJlLnNyY19ob3N0X3N0cmljdCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5tYWlsdG8udGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm1haWx0bylbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG4vLyBSRSBwYXR0ZXJuIGZvciAyLWNoYXJhY3RlciB0bGRzIChhdXRvZ2VuZXJhdGVkIGJ5IC4vc3VwcG9ydC90bGRzXzJjaGFyX2dlbi5qcylcbnZhciB0bGRzXzJjaF9zcmNfcmUgPSAnYVtjZGVmZ2lsbW5vcXJzdHV3eHpdfGJbYWJkZWZnaGlqbW5vcnN0dnd5el18Y1thY2RmZ2hpa2xtbm9ydXZ3eHl6XXxkW2Vqa21vel18ZVtjZWdyc3R1XXxmW2lqa21vcl18Z1thYmRlZmdoaWxtbnBxcnN0dXd5XXxoW2ttbnJ0dV18aVtkZWxtbm9xcnN0XXxqW2Vtb3BdfGtbZWdoaW1ucHJ3eXpdfGxbYWJjaWtyc3R1dnldfG1bYWNkZWdoa2xtbm9wcXJzdHV2d3h5el18blthY2VmZ2lsb3BydXpdfG9tfHBbYWVmZ2hrbG1ucnN0d3ldfHFhfHJbZW9zdXddfHNbYWJjZGVnaGlqa2xtbm9ydHV2eHl6XXx0W2NkZmdoamtsbW5vcnR2d3pdfHVbYWdrc3l6XXx2W2FjZWdpbnVdfHdbZnNdfHlbZXRdfHpbYW13XSc7XG5cbi8vIERPTidUIHRyeSB0byBtYWtlIFBScyB3aXRoIGNoYW5nZXMuIEV4dGVuZCBUTERzIHdpdGggTGlua2lmeUl0LnRsZHMoKSBpbnN0ZWFkXG52YXIgdGxkc19kZWZhdWx0ID0gJ2Jpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEJy5zcGxpdCgnfCcpO1xuXG4vKmVzbGludC1lbmFibGUgbWF4LWxlbiovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHJlc2V0U2NhbkNhY2hlKHNlbGYpIHtcbiAgc2VsZi5fX2luZGV4X18gPSAtMTtcbiAgc2VsZi5fX3RleHRfY2FjaGVfXyAgID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcihyZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIHBvcykge1xuICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgaWYgKHJlLnRlc3QodGFpbCkpIHtcbiAgICAgIHJldHVybiB0YWlsLm1hdGNoKHJlKVswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBzZWxmKSB7XG4gICAgc2VsZi5ub3JtYWxpemUobWF0Y2gpO1xuICB9O1xufVxuXG4vLyBTY2hlbWFzIGNvbXBpbGVyLiBCdWlsZCByZWdleHBzLlxuLy9cbmZ1bmN0aW9uIGNvbXBpbGUoc2VsZikge1xuXG4gIC8vIExvYWQgJiBjbG9uZSBSRSBwYXR0ZXJucy5cbiAgdmFyIHJlID0gc2VsZi5yZSA9IHJlcXVpcmUoJy4vbGliL3JlJykoc2VsZi5fX29wdHNfXyk7XG5cbiAgLy8gRGVmaW5lIGR5bmFtaWMgcGF0dGVybnNcbiAgdmFyIHRsZHMgPSBzZWxmLl9fdGxkc19fLnNsaWNlKCk7XG5cbiAgc2VsZi5vbkNvbXBpbGUoKTtcblxuICBpZiAoIXNlbGYuX190bGRzX3JlcGxhY2VkX18pIHtcbiAgICB0bGRzLnB1c2godGxkc18yY2hfc3JjX3JlKTtcbiAgfVxuICB0bGRzLnB1c2gocmUuc3JjX3huKTtcblxuICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbignfCcpO1xuXG4gIGZ1bmN0aW9uIHVudHBsKHRwbCkgeyByZXR1cm4gdHBsLnJlcGxhY2UoJyVUTERTJScsIHJlLnNyY190bGRzKTsgfVxuXG4gIHJlLmVtYWlsX2Z1enp5ICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2VtYWlsX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19mdXp6eSAgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfbm9faXBfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfbm9faXBfZnV6enkpLCAnaScpO1xuICByZS5ob3N0X2Z1enp5X3Rlc3QgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QpLCAnaScpO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgZWFjaCBzY2hlbWFcbiAgLy9cblxuICB2YXIgYWxpYXNlcyA9IFtdO1xuXG4gIHNlbGYuX19jb21waWxlZF9fID0ge307IC8vIFJlc2V0IGNvbXBpbGVkIGRhdGFcblxuICBmdW5jdGlvbiBzY2hlbWFFcnJvcihuYW1lLCB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xuICB9XG5cbiAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuXG4gICAgLy8gc2tpcCBkaXNhYmxlZCBtZXRob2RzXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblxuICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcblxuICAgIHNlbGYuX19jb21waWxlZF9fW25hbWVdID0gY29tcGlsZWQ7XG5cbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsLm5vcm1hbGl6ZSkpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gdmFsLm5vcm1hbGl6ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5ub3JtYWxpemUpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBwb3N0cG9uZWQgYWxpYXNlc1xuICAvL1xuXG4gIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICBpZiAoIXNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXSkge1xuICAgICAgLy8gU2lsZW50bHkgZmFpbCBvbiBtaXNzZWQgc2NoZW1hcyB0byBhdm9pZCBlcnJvbnMgb24gZGlzYWJsZS5cbiAgICAgIC8vIHNjaGVtYUVycm9yKGFsaWFzLCBzZWxmLl9fc2NoZW1hc19fW2FsaWFzXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLnZhbGlkYXRlID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS52YWxpZGF0ZTtcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10ubm9ybWFsaXplID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS5ub3JtYWxpemU7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIEZha2UgcmVjb3JkIGZvciBndWVzc2VkIGxpbmtzXG4gIC8vXG4gIHNlbGYuX19jb21waWxlZF9fWycnXSA9IHsgdmFsaWRhdGU6IG51bGwsIG5vcm1hbGl6ZTogY3JlYXRlTm9ybWFsaXplcigpIH07XG5cbiAgLy9cbiAgLy8gQnVpbGQgc2NoZW1hIGNvbmRpdGlvblxuICAvL1xuICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXylcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZGlzYWJsZWQgJiBmYWtlIHNjaGVtYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aCA+IDAgJiYgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGVzY2FwZVJFKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gIC8vICg/IV8pIGNhdXNlIDEuNXggc2xvd2Rvd25cbiAgc2VsZi5yZS5zY2hlbWFfdGVzdCAgID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpJyk7XG4gIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKTtcblxuICBzZWxmLnJlLnByZXRlc3QgICAgICAgPSBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzZWxmLnJlLmhvc3RfZnV6enlfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2knKTtcblxuICAvL1xuICAvLyBDbGVhbnVwXG4gIC8vXG5cbiAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XG59XG5cbi8qKlxuICogY2xhc3MgTWF0Y2hcbiAqXG4gKiBNYXRjaCByZXN1bHQuIFNpbmdsZSBlbGVtZW50IG9mIGFycmF5LCByZXR1cm5lZCBieSBbW0xpbmtpZnlJdCNtYXRjaF1dXG4gKiovXG5mdW5jdGlvbiBNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXyxcbiAgICAgIGVuZCAgID0gc2VsZi5fX2xhc3RfaW5kZXhfXyxcbiAgICAgIHRleHQgID0gc2VsZi5fX3RleHRfY2FjaGVfXy5zbGljZShzdGFydCwgZW5kKTtcblxuICAvKipcbiAgICogTWF0Y2gjc2NoZW1hIC0+IFN0cmluZ1xuICAgKlxuICAgKiBQcmVmaXggKHByb3RvY29sKSBmb3IgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5zY2hlbWEgICAgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgLyoqXG4gICAqIE1hdGNoI2luZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBGaXJzdCBwb3NpdGlvbiBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmluZGV4ICAgICA9IHN0YXJ0ICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNsYXN0SW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIE5leHQgcG9zaXRpb24gYWZ0ZXIgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI3JhdyAtPiBTdHJpbmdcbiAgICpcbiAgICogTWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5yYXcgICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdGV4dCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm90bWFsaXplZCB0ZXh0IG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudGV4dCAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3VybCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm9ybWFsaXplZCB1cmwgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy51cmwgICAgICAgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuXG4gIHNlbGYuX19jb21waWxlZF9fW21hdGNoLnNjaGVtYV0ubm9ybWFsaXplKG1hdGNoLCBzZWxmKTtcblxuICByZXR1cm4gbWF0Y2g7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBMaW5raWZ5SXRcbiAqKi9cblxuLyoqXG4gKiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogQ3JlYXRlcyBuZXcgbGlua2lmaWVyIGluc3RhbmNlIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBzY2hlbWFzLlxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdW5kZXJzdGFuZHM6XG4gKlxuICogLSBgaHR0cChzKTovLy4uLmAgLCBgZnRwOi8vLi4uYCwgYG1haWx0bzouLi5gICYgYC8vLi4uYCBsaW5rc1xuICogLSBcImZ1enp5XCIgbGlua3MgYW5kIGVtYWlscyAoZXhhbXBsZS5jb20sIGZvb0BiYXIuY29tKS5cbiAqXG4gKiBgc2NoZW1hc2AgaXMgYW4gb2JqZWN0LCB3aGVyZSBlYWNoIGtleS92YWx1ZSBkZXNjcmliZXMgcHJvdG9jb2wvcnVsZTpcbiAqXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxuICogICBmb3IgZXhhbXBsZSkuIGBsaW5raWZ5LWl0YCBtYWtlcyBzaHVyZSB0aGF0IHByZWZpeCBpcyBub3QgcHJlY2VlZGVkIHdpdGhcbiAqICAgYWxwaGFudW1lcmljIGNoYXIgYW5kIHN5bWJvbHMuIE9ubHkgd2hpdGVzcGFjZXMgYW5kIHB1bmN0dWF0aW9uIGFsbG93ZWQuXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxuICogICAtIF9TdHJpbmdfIC0ganVzdCBhbGlhcyB0byBleGlzdGluZyBydWxlXG4gKiAgIC0gX09iamVjdF9cbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXG4gKiAgICAgICBvciBgUmVnRXhwYC5cbiAqICAgICAtIF9ub3JtYWxpemVfIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbm9ybWFsaXplIHRleHQgJiB1cmwgb2YgbWF0Y2hlZCByZXN1bHRcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cbiAqXG4gKiBgb3B0aW9uc2A6XG4gKlxuICogLSBfX2Z1enp5TGlua19fIC0gcmVjb2duaWdlIFVSTC1zIHdpdGhvdXQgYGh0dHAocyk6YCBwcmVmaXguIERlZmF1bHQgYHRydWVgLlxuICogLSBfX2Z1enp5SVBfXyAtIGFsbG93IElQcyBpbiBmdXp6eSBsaW5rcyBhYm92ZS4gQ2FuIGNvbmZsaWN0IHdpdGggc29tZSB0ZXh0c1xuICogICBsaWtlIHZlcnNpb24gbnVtYmVycy4gRGVmYXVsdCBgZmFsc2VgLlxuICogLSBfX2Z1enp5RW1haWxfXyAtIHJlY29nbml6ZSBlbWFpbHMgd2l0aG91dCBgbWFpbHRvOmAgcHJlZml4LlxuICpcbiAqKi9cbmZ1bmN0aW9uIExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5raWZ5SXQpKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoaXNPcHRpb25zT2JqKHNjaGVtYXMpKSB7XG4gICAgICBvcHRpb25zID0gc2NoZW1hcztcbiAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9fb3B0c19fICAgICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIENhY2hlIGxhc3QgdGVzdGVkIHJlc3VsdC4gVXNlZCB0byBza2lwIHJlcGVhdGluZyBzdGVwcyBvbiBuZXh0IGBtYXRjaGAgY2FsbC5cbiAgdGhpcy5fX2luZGV4X18gICAgICAgICAgPSAtMTtcbiAgdGhpcy5fX2xhc3RfaW5kZXhfXyAgICAgPSAtMTsgLy8gTmV4dCBzY2FuIHBvc2l0aW9uXG4gIHRoaXMuX19zY2hlbWFfXyAgICAgICAgID0gJyc7XG4gIHRoaXMuX190ZXh0X2NhY2hlX18gICAgID0gJyc7XG5cbiAgdGhpcy5fX3NjaGVtYXNfXyAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgdGhpcy5fX2NvbXBpbGVkX18gICAgICAgPSB7fTtcblxuICB0aGlzLl9fdGxkc19fICAgICAgICAgICA9IHRsZHNfZGVmYXVsdDtcbiAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyAgPSBmYWxzZTtcblxuICB0aGlzLnJlID0ge307XG5cbiAgY29tcGlsZSh0aGlzKTtcbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjYWRkKHNjaGVtYSwgZGVmaW5pdGlvbilcbiAqIC0gc2NoZW1hIChTdHJpbmcpOiBydWxlIG5hbWUgKGZpeGVkIHBhdHRlcm4gcHJlZml4KVxuICogLSBkZWZpbml0aW9uIChTdHJpbmd8UmVnRXhwfE9iamVjdCk6IHNjaGVtYSBkZWZpbml0aW9uXG4gKlxuICogQWRkIG5ldyBydWxlIGRlZmluaXRpb24uIFNlZSBjb25zdHJ1Y3RvciBkZXNjcmlwdGlvbiBmb3IgZGV0YWlscy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHNjaGVtYSwgZGVmaW5pdGlvbikge1xuICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3NldChvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIFNldCByZWNvZ25pdGlvbiBvcHRpb25zIGZvciBsaW5rcyB3aXRob3V0IHNjaGVtYS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFNlYXJjaGVzIGxpbmtpZmlhYmxlIHBhdHRlcm4gYW5kIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3Mgb3IgYGZhbHNlYCBvbiBmYWlsLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdCh0ZXh0KSB7XG4gIC8vIFJlc2V0IHNjYW4gY2FjaGVcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHQ7XG4gIHRoaXMuX19pbmRleF9fICAgICAgPSAtMTtcblxuICBpZiAoIXRleHQubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XG5cbiAgLy8gdHJ5IHRvIHNjYW4gZm9yIGxpbmsgd2l0aCBzY2hlbWEgLSB0aGF0J3MgdGhlIG1vc3Qgc2ltcGxlIHJ1bGVcbiAgaWYgKHRoaXMucmUuc2NoZW1hX3Rlc3QudGVzdCh0ZXh0KSkge1xuICAgIHJlID0gdGhpcy5yZS5zY2hlbWFfc2VhcmNoO1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgIGxlbiA9IHRoaXMudGVzdFNjaGVtYUF0KHRleHQsIG1bMl0sIHJlLmxhc3RJbmRleCk7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSBtWzJdO1xuICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoO1xuICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoICsgbGVuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUxpbmsgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ2h0dHA6J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGxpbmtzXG4gICAgdGxkX3BvcyA9IHRleHQuc2VhcmNoKHRoaXMucmUuaG9zdF9mdXp6eV90ZXN0KTtcbiAgICBpZiAodGxkX3BvcyA+PSAwKSB7XG4gICAgICAvLyBpZiB0bGQgaXMgbG9jYXRlZCBhZnRlciBmb3VuZCBsaW5rIC0gbm8gbmVlZCB0byBjaGVjayBmdXp6eSBwYXR0ZXJuXG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICBpZiAoKG1sID0gdGV4dC5tYXRjaCh0aGlzLl9fb3B0c19fLmZ1enp5SVAgPyB0aGlzLnJlLmxpbmtfZnV6enkgOiB0aGlzLnJlLmxpbmtfbm9faXBfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgc2hpZnQgPSBtbC5pbmRleCArIG1sWzFdLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG1sLmluZGV4ICsgbWxbMF0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ21haWx0bzonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgZW1haWxzXG4gICAgYXRfcG9zID0gdGV4dC5pbmRleE9mKCdAJyk7XG4gICAgaWYgKGF0X3BvcyA+PSAwKSB7XG4gICAgICAvLyBXZSBjYW4ndCBza2lwIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhpcyBjYXNlcyBhcmUgcG9zc2libGU6XG4gICAgICAvLyAxOTIuMTY4LjEuMUBnbWFpbC5jb20sIG15LmluQGV4YW1wbGUuY29tXG4gICAgICBpZiAoKG1lID0gdGV4dC5tYXRjaCh0aGlzLnJlLmVtYWlsX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICBuZXh0ICA9IG1lLmluZGV4ICsgbWVbMF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXyB8fFxuICAgICAgICAgICAgKHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykpIHtcbiAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJ21haWx0bzonO1xuICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLl9faW5kZXhfXyA+PSAwO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNwcmV0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBWZXJ5IHF1aWNrIGNoZWNrLCB0aGF0IGNhbiBnaXZlIGZhbHNlIHBvc2l0aXZlcy4gUmV0dXJucyB0cnVlIGlmIGxpbmsgTUFZIEJFXG4gKiBjYW4gZXhpc3RzLiBDYW4gYmUgdXNlZCBmb3Igc3BlZWQgb3B0aW1pemF0aW9uLCB3aGVuIHlvdSBuZWVkIHRvIGNoZWNrIHRoYXRcbiAqIGxpbmsgTk9UIGV4aXN0cy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUucHJldGVzdCA9IGZ1bmN0aW9uIHByZXRlc3QodGV4dCkge1xuICByZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QodGV4dCk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3RTY2hlbWFBdCh0ZXh0LCBuYW1lLCBwb3NpdGlvbikgLT4gTnVtYmVyXG4gKiAtIHRleHQgKFN0cmluZyk6IHRleHQgdG8gc2NhblxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIChzY2hlbWEpIG5hbWVcbiAqIC0gcG9zaXRpb24gKE51bWJlcik6IHRleHQgb2Zmc2V0IHRvIGNoZWNrIGZyb21cbiAqXG4gKiBTaW1pbGFyIHRvIFtbTGlua2lmeUl0I3Rlc3RdXSBidXQgY2hlY2tzIG9ubHkgc3BlY2lmaWMgcHJvdG9jb2wgdGFpbCBleGFjdGx5XG4gKiBhdCBnaXZlbiBwb3NpdGlvbi4gUmV0dXJucyBsZW5ndGggb2YgZm91bmQgcGF0dGVybiAoMCBvbiBmYWlsKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdFNjaGVtYUF0ID0gZnVuY3Rpb24gdGVzdFNjaGVtYUF0KHRleHQsIHNjaGVtYSwgcG9zKSB7XG4gIC8vIElmIG5vdCBzdXBwb3J0ZWQgc2NoZW1hIGNoZWNrIHJlcXVlc3RlZCAtIHRlcm1pbmF0ZVxuICBpZiAoIXRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0udmFsaWRhdGUodGV4dCwgcG9zLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjbWF0Y2godGV4dCkgLT4gQXJyYXl8bnVsbFxuICpcbiAqIFJldHVybnMgYXJyYXkgb2YgZm91bmQgbGluayBkZXNjcmlwdGlvbnMgb3IgYG51bGxgIG9uIGZhaWwuIFdlIHN0cm9uZ2x5XG4gKiByZWNvbW1lbmQgdG8gdXNlIFtbTGlua2lmeUl0I3Rlc3RdXSBmaXJzdCwgZm9yIGJlc3Qgc3BlZWQuXG4gKlxuICogIyMjIyMgUmVzdWx0IG1hdGNoIGRlc2NyaXB0aW9uXG4gKlxuICogLSBfX3NjaGVtYV9fIC0gbGluayBzY2hlbWEsIGNhbiBiZSBlbXB0eSBmb3IgZnV6enkgbGlua3MsIG9yIGAvL2AgZm9yXG4gKiAgIHByb3RvY29sLW5ldXRyYWwgIGxpbmtzLlxuICogLSBfX2luZGV4X18gLSBvZmZzZXQgb2YgbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fbGFzdEluZGV4X18gLSBpbmRleCBvZiBuZXh0IGNoYXIgYWZ0ZXIgbWF0aGNoIGVuZFxuICogLSBfX3Jhd19fIC0gbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fdGV4dF9fIC0gbm9ybWFsaXplZCB0ZXh0XG4gKiAtIF9fdXJsX18gLSBsaW5rLCBnZW5lcmF0ZWQgZnJvbSBtYXRjaGVkIHRleHRcbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0ZXh0KSB7XG4gIHZhciBzaGlmdCA9IDAsIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFRyeSB0byB0YWtlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSBjYWNoZSwgaWYgLnRlc3QoKSBjYWxsZWQgYmVmb3JlXG4gIGlmICh0aGlzLl9faW5kZXhfXyA+PSAwICYmIHRoaXMuX190ZXh0X2NhY2hlX18gPT09IHRleHQpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuICAgIHNoaWZ0ID0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIC8vIEN1dCBoZWFkIGlmIGNhY2hlIHdhcyB1c2VkXG4gIHZhciB0YWlsID0gc2hpZnQgPyB0ZXh0LnNsaWNlKHNoaWZ0KSA6IHRleHQ7XG5cbiAgLy8gU2NhbiBzdHJpbmcgdW50aWwgZW5kIHJlYWNoZWRcbiAgd2hpbGUgKHRoaXMudGVzdCh0YWlsKSkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG5cbiAgICB0YWlsID0gdGFpbC5zbGljZSh0aGlzLl9fbGFzdF9pbmRleF9fKTtcbiAgICBzaGlmdCArPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCN0bGRzKGxpc3QgWywga2VlcE9sZF0pIC0+IHRoaXNcbiAqIC0gbGlzdCAoQXJyYXkpOiBsaXN0IG9mIHRsZHNcbiAqIC0ga2VlcE9sZCAoQm9vbGVhbik6IG1lcmdlIHdpdGggY3VycmVudCBsaXN0IGlmIGB0cnVlYCAoYGZhbHNlYCBieSBkZWZhdWx0KVxuICpcbiAqIExvYWQgKG9yIG1lcmdlKSBuZXcgdGxkcyBsaXN0LiBUaG9zZSBhcmUgdXNlciBmb3IgZnV6enkgbGlua3MgKHdpdGhvdXQgcHJlZml4KVxuICogdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzLiBCeSBkZWZhdWx0IHRoaXMgYWxnb3J5dGhtIHVzZWQ6XG4gKlxuICogLSBob3N0bmFtZSB3aXRoIGFueSAyLWxldHRlciByb290IHpvbmVzIGFyZSBvay5cbiAqIC0gYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcbiAqICAgYXJlIG9rLlxuICogLSBlbmNvZGVkIChgeG4tLS4uLmApIHJvb3Qgem9uZXMgYXJlIG9rLlxuICpcbiAqIElmIGxpc3QgaXMgcmVwbGFjZWQsIHRoZW4gZXhhY3QgbWF0Y2ggZm9yIDItY2hhcnMgcm9vdCB6b25lcyB3aWxsIGJlIGNoZWNrZWQuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiB0bGRzKGxpc3QsIGtlZXBPbGQpIHtcbiAgbGlzdCA9IEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0IDogWyBsaXN0IF07XG5cbiAgaWYgKCFrZWVwT2xkKSB7XG4gICAgdGhpcy5fX3RsZHNfXyA9IGxpc3Quc2xpY2UoKTtcbiAgICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fID0gdHJ1ZTtcbiAgICBjb21waWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fX3RsZHNfXyA9IHRoaXMuX190bGRzX18uY29uY2F0KGxpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsLCBpZHgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsICE9PSBhcnJbaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpO1xuXG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaW5raWZ5SXQjbm9ybWFsaXplKG1hdGNoKVxuICpcbiAqIERlZmF1bHQgbm9ybWFsaXplciAoaWYgc2NoZW1hIGRvZXMgbm90IGRlZmluZSBpdCdzIG93bikuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtYXRjaCkge1xuXG4gIC8vIERvIG1pbmltYWwgcG9zc2libGUgY2hhbmdlcyBieSBkZWZhdWx0LiBOZWVkIHRvIGNvbGxlY3QgZmVlZGJhY2sgcHJpb3JcbiAgLy8gdG8gbW92ZSBmb3J3YXJkIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0L2lzc3Vlcy8xXG5cbiAgaWYgKCFtYXRjaC5zY2hlbWEpIHsgbWF0Y2gudXJsID0gJ2h0dHA6Ly8nICsgbWF0Y2gudXJsOyB9XG5cbiAgaWYgKG1hdGNoLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KG1hdGNoLnVybCkpIHtcbiAgICBtYXRjaC51cmwgPSAnbWFpbHRvOicgKyBtYXRjaC51cmw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjb25Db21waWxlKClcbiAqXG4gKiBPdmVycmlkZSB0byBtb2RpZnkgYmFzaWMgUmVnRXhwLXMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSgpIHtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5raWZ5SXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHJlID0ge307XG5cbiAgLy8gVXNlIGRpcmVjdCBleHRyYWN0IGluc3RlYWQgb2YgYHJlZ2VuZXJhdGVgIHRvIHJlZHVzZSBicm93c2VyaWZpZWQgc2l6ZVxuICByZS5zcmNfQW55ID0gcmVxdWlyZSgndWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19DYyAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfWiAgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfUCAgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jykuc291cmNlO1xuXG4gIC8vIFxccHtcXFpcXFBcXENjXFxDRn0gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wgKyBmb3JtYXQgKyBwdW5jdHVhdGlvbilcbiAgcmUuc3JjX1pQQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfUCwgcmUuc3JjX0NjIF0uam9pbignfCcpO1xuXG4gIC8vIFxccHtcXFpcXENjfSAod2hpdGUgc3BhY2VzICsgY29udHJvbClcbiAgcmUuc3JjX1pDYyA9IFsgcmUuc3JjX1osIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBFeHBlcmltZW50YWwuIExpc3Qgb2YgY2hhcnMsIGNvbXBsZXRlbHkgcHJvaGliaXRlZCBpbiBsaW5rc1xuICAvLyBiZWNhdXNlIGNhbiBzZXBhcmF0ZSBpdCBmcm9tIG90aGVyIHBhcnQgb2YgdGV4dFxuICB2YXIgdGV4dF9zZXBhcmF0b3JzID0gJ1s+PFxcdWZmNWNdJztcblxuICAvLyBBbGwgcG9zc2libGUgd29yZCBjaGFyYWN0ZXJzIChldmVyeXRoaW5nIHdpdGhvdXQgcHVuY3R1YXRpb24sIHNwYWNlcyAmIGNvbnRyb2xzKVxuICAvLyBEZWZpbmVkIHZpYSBwdW5jdHVhdGlvbiAmIHNwYWNlcyB0byBzYXZlIHNwYWNlXG4gIC8vIFNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSBcXHB7XFxMXFxOXFxTXFxNfSAoXFx3IGJ1dCB3aXRob3V0IGBfYClcbiAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgICAgICAgPSAnKD86KD8hJyArIHRleHRfc2VwYXJhdG9ycyArICd8JyArIHJlLnNyY19aUENjICsgJyknICsgcmUuc3JjX0FueSArICcpJztcbiAgLy8gVGhlIHNhbWUgYXMgYWJvdGhlIGJ1dCB3aXRob3V0IFswLTldXG4gIC8vIHZhciBzcmNfcHNldWRvX2xldHRlcl9ub25fZCA9ICcoPzooPyFbMC05XXwnICsgc3JjX1pQQ2MgKyAnKScgKyBzcmNfQW55ICsgJyknO1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgcmUuc3JjX2lwNCA9XG5cbiAgICAnKD86KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXFxcLil7M30oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSc7XG5cbiAgLy8gUHJvaGliaXQgYW55IG9mIFwiQC9bXSgpXCIgaW4gdXNlci9wYXNzIHRvIGF2b2lkIHdyb25nIGRvbWFpbiBmZXRjaC5cbiAgcmUuc3JjX2F1dGggICAgPSAnKD86KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtAL1xcXFxbXFxcXF0oKV0pLikrQCk/JztcblxuICByZS5zcmNfcG9ydCA9XG5cbiAgICAnKD86Oig/OjYoPzpbMC00XVxcXFxkezN9fDUoPzpbMC00XVxcXFxkezJ9fDUoPzpbMC0yXVxcXFxkfDNbMC01XSkpKXxbMS01XT9cXFxcZHsxLDR9KSk/JztcblxuICByZS5zcmNfaG9zdF90ZXJtaW5hdG9yID1cblxuICAgICcoPz0kfCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpKD8hLXxffDpcXFxcZHxcXFxcLi18XFxcXC4oPyEkfCcgKyByZS5zcmNfWlBDYyArICcpKSc7XG5cbiAgcmUuc3JjX3BhdGggPVxuXG4gICAgJyg/OicgK1xuICAgICAgJ1svPyNdJyArXG4gICAgICAgICcoPzonICtcbiAgICAgICAgICAnKD8hJyArIHJlLnNyY19aQ2MgKyAnfCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfFsoKVtcXFxcXXt9LixcIlxcJz8hXFxcXC1dKS58JyArXG4gICAgICAgICAgJ1xcXFxbKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFxcXFxdKS4pKlxcXFxdfCcgK1xuICAgICAgICAgICdcXFxcKCg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbKV0pLikqXFxcXCl8JyArXG4gICAgICAgICAgJ1xcXFx7KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFt9XSkuKSpcXFxcfXwnICtcbiAgICAgICAgICAnXFxcXFwiKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtcIl0pLikrXFxcXFwifCcgK1xuICAgICAgICAgIFwiXFxcXCcoPzooPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbJ10pLikrXFxcXCd8XCIgK1xuICAgICAgICAgIFwiXFxcXCcoPz1cIiArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3xbLV0pLnwnICsgIC8vIGFsbG93IGBJJ21fa2luZ2AgaWYgbm8gcGFpciBmb3VuZFxuICAgICAgICAgICdcXFxcLnsyLDN9W2EtekEtWjAtOSUvXXwnICsgLy8gZ2l0aHViIGhhcyAuLi4gaW4gY29tbWl0IHJhbmdlIGxpbmtzLiBSZXN0cmljdCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gZW5nbGlzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGVyY2VudC1lbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwYXJ0cyBvZiBmaWxlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnRpbCBtb3JlIGV4YW1wbGVzIGZvdW5kLlxuICAgICAgICAgICdcXFxcLig/IScgKyByZS5zcmNfWkNjICsgJ3xbLl0pLnwnICtcbiAgICAgICAgICAob3B0cyAmJiBvcHRzWyctLS0nXSA/XG4gICAgICAgICAgICAnXFxcXC0oPyEtLSg/OlteLV18JCkpKD86LSopfCcgLy8gYC0tLWAgPT4gbG9uZyBkYXNoLCB0ZXJtaW5hdGVcbiAgICAgICAgICA6XG4gICAgICAgICAgICAnXFxcXC0rfCdcbiAgICAgICAgICApICtcbiAgICAgICAgICAnXFxcXCwoPyEnICsgcmUuc3JjX1pDYyArICcpLnwnICsgICAgICAvLyBhbGxvdyBgLCwsYCBpbiBwYXRoc1xuICAgICAgICAgICdcXFxcISg/IScgKyByZS5zcmNfWkNjICsgJ3xbIV0pLnwnICtcbiAgICAgICAgICAnXFxcXD8oPyEnICsgcmUuc3JjX1pDYyArICd8Wz9dKS4nICtcbiAgICAgICAgJykrJyArXG4gICAgICAnfFxcXFwvJyArXG4gICAgJyk/JztcblxuICByZS5zcmNfZW1haWxfbmFtZSA9XG5cbiAgICAnW1xcXFwtOzomPVxcXFwrXFxcXCQsXFxcXFwiXFxcXC5hLXpBLVowLTlfXSsnO1xuXG4gIHJlLnNyY194biA9XG5cbiAgICAneG4tLVthLXowLTlcXFxcLV17MSw1OX0nO1xuXG4gIC8vIE1vcmUgdG8gcmVhZCBhYm91dCBkb21haW4gbmFtZXNcbiAgLy8gaHR0cDovL3NlcnZlcmZhdWx0LmNvbS9xdWVzdGlvbnMvNjM4MjYwL1xuXG4gIHJlLnNyY19kb21haW5fcm9vdCA9XG5cbiAgICAvLyBBbGxvdyBsZXR0ZXJzICYgZGlnaXRzIChodHRwOi8vdGVzdDEpXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICByZS5zcmNfcHNldWRvX2xldHRlciArICd7MSw2M30nICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2RvbWFpbiA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICAgJ3wnICtcbiAgICAgIC8vIGRvbid0IGFsbG93IGAtLWAgaW4gZG9tYWluIG5hbWVzLCBiZWNhdXNlOlxuICAgICAgLy8gLSB0aGF0IGNhbiBjb25mbGljdCB3aXRoIG1hcmtkb3duICZtZGFzaDsgLyAmbmRhc2g7XG4gICAgICAvLyAtIG5vYm9keSB1c2UgdGhvc2UgYW55d2F5XG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyg/Oi0oPyEtKXwnICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKXswLDYxfScgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19ob3N0ID1cblxuICAgICcoPzonICtcbiAgICAvLyBEb24ndCBuZWVkIElQIGNoZWNrLCBiZWNhdXNlIGRpZ2l0cyBhcmUgYWxyZWFkeSBhbGxvd2VkIGluIG5vcm1hbCBkb21haW4gbmFtZXNcbiAgICAvLyAgIHNyY19pcDQgK1xuICAgIC8vICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSonICsgcmUuc3JjX2RvbWFpbi8qX3Jvb3QqLyArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5ID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY19pcDQgK1xuICAgICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSA9XG5cbiAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKSc7XG5cbiAgcmUuc3JjX2hvc3Rfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnNyY19ob3N0X3BvcnRfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTWFpbiBydWxlc1xuXG4gIC8vIFJ1ZGUgdGVzdCBmdXp6eSBsaW5rcyBieSBob3N0LCBmb3IgcXVpY2sgZGVueVxuICByZS50cGxfaG9zdF9mdXp6eV90ZXN0ID1cblxuICAgICdsb2NhbGhvc3R8d3d3XFxcXC58XFxcXC5cXFxcZHsxLDN9XFxcXC58KD86XFxcXC4oPzolVExEUyUpKD86JyArIHJlLnNyY19aUENjICsgJ3w+fCQpKSc7XG5cbiAgcmUudHBsX2VtYWlsX2Z1enp5ID1cblxuICAgICAgJyhefCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfFxcXFwofCcgKyByZS5zcmNfWkNjICsgJykoJyArIHJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX25vX2lwX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJldHVybiByZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2xpYi9yZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvaW5kZXguanMiLCIvLyBMaXN0IG9mIHZhbGlkIGh0bWwgYmxvY2tzIG5hbWVzLCBhY2NvcnRpbmcgdG8gY29tbW9ubWFyayBzcGVjXG4vLyBodHRwOi8vamdtLmdpdGh1Yi5pby9Db21tb25NYXJrL3NwZWMuaHRtbCNodG1sLWJsb2Nrc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhZGRyZXNzJyxcbiAgJ2FydGljbGUnLFxuICAnYXNpZGUnLFxuICAnYmFzZScsXG4gICdiYXNlZm9udCcsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnY2FwdGlvbicsXG4gICdjZW50ZXInLFxuICAnY29sJyxcbiAgJ2NvbGdyb3VwJyxcbiAgJ2RkJyxcbiAgJ2RldGFpbHMnLFxuICAnZGlhbG9nJyxcbiAgJ2RpcicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZmllbGRzZXQnLFxuICAnZmlnY2FwdGlvbicsXG4gICdmaWd1cmUnLFxuICAnZm9vdGVyJyxcbiAgJ2Zvcm0nLFxuICAnZnJhbWUnLFxuICAnZnJhbWVzZXQnLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnaGVhZCcsXG4gICdoZWFkZXInLFxuICAnaHInLFxuICAnaHRtbCcsXG4gICdpZnJhbWUnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ2xpbmsnLFxuICAnbWFpbicsXG4gICdtZW51JyxcbiAgJ21lbnVpdGVtJyxcbiAgJ21ldGEnLFxuICAnbmF2JyxcbiAgJ25vZnJhbWVzJyxcbiAgJ29sJyxcbiAgJ29wdGdyb3VwJyxcbiAgJ29wdGlvbicsXG4gICdwJyxcbiAgJ3BhcmFtJyxcbiAgJ3ByZScsXG4gICdzZWN0aW9uJyxcbiAgJ3NvdXJjZScsXG4gICd0aXRsZScsXG4gICdzdW1tYXJ5JyxcbiAgJ3RhYmxlJyxcbiAgJ3Rib2R5JyxcbiAgJ3RkJyxcbiAgJ3Rmb290JyxcbiAgJ3RoJyxcbiAgJ3RoZWFkJyxcbiAgJ3RpdGxlJyxcbiAgJ3RyJyxcbiAgJ3RyYWNrJyxcbiAgJ3VsJ1xuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCIvLyBKdXN0IGEgc2hvcnRjdXQgZm9yIGJ1bGsgZXhwb3J0XG4ndXNlIHN0cmljdCc7XG5cblxuZXhwb3J0cy5wYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19sYWJlbCcpO1xuZXhwb3J0cy5wYXJzZUxpbmtEZXN0aW5hdGlvbiA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19kZXN0aW5hdGlvbicpO1xuZXhwb3J0cy5wYXJzZUxpbmtUaXRsZSAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua190aXRsZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCIvLyBQYXJzZSBsaW5rIGRlc3RpbmF0aW9uXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1NwYWNlICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsIGxldmVsLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgzQyAvKiA8ICovKSB7XG4gICAgcG9zKys7XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoY29kZSA9PT0gMHgwQSAvKiBcXG4gKi8gfHwgaXNTcGFjZShjb2RlKSkgeyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICBpZiAoY29kZSA9PT0gMHgzRSAvKiA+ICovKSB7XG4gICAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgLy8gbm8gY2xvc2luZyAnPidcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gdGhpcyBzaG91bGQgYmUgLi4uIH0gZWxzZSB7IC4uLiBicmFuY2hcblxuICBsZXZlbCA9IDA7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjb2RlID09PSAweDIwKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBhc2NpaSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDB4MjAgfHwgY29kZSA9PT0gMHg3RikgeyBicmVhazsgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovKSB7XG4gICAgICBsZXZlbCsrO1xuICAgICAgaWYgKGxldmVsID4gMSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI5IC8qICkgKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICByZXN1bHQucG9zID0gcG9zO1xuICByZXN1bHQub2sgPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24uanMiLCIvLyBQYXJzZSBsaW5rIGxhYmVsXG4vL1xuLy8gdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgZmlyc3QgY2hhcmFjdGVyIChcIltcIikgYWxyZWFkeSBtYXRjaGVzO1xuLy8gcmV0dXJucyB0aGUgZW5kIG9mIHRoZSBsYWJlbFxuLy9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhcnQsIGRpc2FibGVOZXN0ZWQpIHtcbiAgdmFyIGxldmVsLCBmb3VuZCwgbWFya2VyLCBwcmV2UG9zLFxuICAgICAgbGFiZWxFbmQgPSAtMSxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcztcblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG4gIGxldmVsID0gMTtcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XG4gICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKTtcbiAgICBpZiAobWFya2VyID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2UG9zID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLm1kLmlubGluZS5za2lwVG9rZW4oc3RhdGUpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgaWYgKHByZXZQb3MgPT09IHN0YXRlLnBvcyAtIDEpIHtcbiAgICAgICAgLy8gaW5jcmVhc2UgbGV2ZWwgaWYgd2UgZmluZCB0ZXh0IGBbYCwgd2hpY2ggaXMgbm90IGEgcGFydCBvZiBhbnkgdG9rZW5cbiAgICAgICAgbGV2ZWwrKztcbiAgICAgIH0gZWxzZSBpZiAoZGlzYWJsZU5lc3RlZCkge1xuICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZm91bmQpIHtcbiAgICBsYWJlbEVuZCA9IHN0YXRlLnBvcztcbiAgfVxuXG4gIC8vIHJlc3RvcmUgb2xkIHN0YXRlXG4gIHN0YXRlLnBvcyA9IG9sZFBvcztcblxuICByZXR1cm4gbGFiZWxFbmQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcyIsIi8vIFBhcnNlIGxpbmsgdGl0bGVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KSB7XG4gIHZhciBjb2RlLFxuICAgICAgbWFya2VyLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgbWFya2VyID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDIyIC8qIFwiICovICYmIG1hcmtlciAhPT0gMHgyNyAvKiAnICovICYmIG1hcmtlciAhPT0gMHgyOCAvKiAoICovKSB7IHJldHVybiByZXN1bHQ7IH1cblxuICBwb3MrKztcblxuICAvLyBpZiBvcGVuaW5nIG1hcmtlciBpcyBcIihcIiwgc3dpdGNoIGl0IHRvIGNsb3NpbmcgbWFya2VyIFwiKVwiXG4gIGlmIChtYXJrZXIgPT09IDB4MjgpIHsgbWFya2VyID0gMHgyOTsgfVxuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCIvLyBNYWluIHBhcnNlciBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG52YXIgaGVscGVycyAgICAgID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcbnZhciBtZHVybCAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xudmFyIHB1bnljb2RlICAgICA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGNvbmZpZyA9IHtcbiAgJ2RlZmF1bHQnOiByZXF1aXJlKCcuL3ByZXNldHMvZGVmYXVsdCcpLFxuICB6ZXJvOiByZXF1aXJlKCcuL3ByZXNldHMvemVybycpLFxuICBjb21tb25tYXJrOiByZXF1aXJlKCcuL3ByZXNldHMvY29tbW9ubWFyaycpXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vIFRoaXMgdmFsaWRhdG9yIGNhbiBwcm9oaWJpdCBtb3JlIHRoYW4gcmVhbGx5IG5lZWRlZCB0byBwcmV2ZW50IFhTUy4gSXQncyBhXG4vLyB0cmFkZW9mZiB0byBrZWVwIGNvZGUgc2ltcGxlIGFuZCB0byBiZSBzZWN1cmUgYnkgZGVmYXVsdC5cbi8vXG4vLyBJZiB5b3UgbmVlZCBkaWZmZXJlbnQgc2V0dXAgLSBvdmVycmlkZSB2YWxpZGF0b3IgbWV0aG9kIGFzIHlvdSB3aXNoLiBPclxuLy8gcmVwbGFjZSBpdCB3aXRoIGR1bW15IGZ1bmN0aW9uIGFuZCB1c2UgZXh0ZXJuYWwgc2FuaXRpemVyLlxuLy9cblxudmFyIEJBRF9QUk9UT19SRSA9IC9eKHZic2NyaXB0fGphdmFzY3JpcHR8ZmlsZXxkYXRhKTovO1xudmFyIEdPT0RfREFUQV9SRSA9IC9eZGF0YTppbWFnZVxcLyhnaWZ8cG5nfGpwZWd8d2VicCk7LztcblxuZnVuY3Rpb24gdmFsaWRhdGVMaW5rKHVybCkge1xuICAvLyB1cmwgc2hvdWxkIGJlIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludCwgYW5kIGV4aXN0aW5nIGVudGl0aWVzIGFyZSBkZWNvZGVkXG4gIHZhciBzdHIgPSB1cmwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIEJBRF9QUk9UT19SRS50ZXN0KHN0cikgPyAoR09PRF9EQVRBX1JFLnRlc3Qoc3RyKSA/IHRydWUgOiBmYWxzZSkgOiB0cnVlO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBSRUNPREVfSE9TVE5BTUVfRk9SID0gWyAnaHR0cDonLCAnaHR0cHM6JywgJ21haWx0bzonIF07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmsodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvVW5pY29kZShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBNYXJrZG93bkl0XG4gKlxuICogTWFpbiBwYXJzZXIvcmVuZGVyZXIgY2xhc3MuXG4gKlxuICogIyMjIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XG4gKiB2YXIgTWFya2Rvd25JdCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JyksXG4gKiAgICAgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gbm9kZS5qcywgdGhlIHNhbWUsIGJ1dCB3aXRoIHN1Z2FyOlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxuICogLy8gTm90ZSwgdGhlcmUgYXJlIG5vIGRhc2guXG4gKiB2YXIgbWQgPSB3aW5kb3cubWFya2Rvd25pdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKiBgYGBcbiAqXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSgnX19tYXJrZG93bi1pdF9fIHJ1bGV6eiEnKTtcbiAqIGBgYFxuICoqL1xuXG4vKipcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcbiAqIC0gcHJlc2V0TmFtZSAoU3RyaW5nKTogb3B0aW9uYWwsIGBjb21tb25tYXJrYCAvIGB6ZXJvYFxuICogLSBvcHRpb25zIChPYmplY3QpXG4gKlxuICogQ3JlYXRlcyBwYXJzZXIgaW5zdGFuc2Ugd2l0aCBnaXZlbiBjb25maWcuIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YC5cbiAqXG4gKiAjIyMjIyBwcmVzZXROYW1lXG4gKlxuICogTWFya2Rvd25JdCBwcm92aWRlcyBuYW1lZCBwcmVzZXRzIGFzIGEgY29udmVuaWVuY2UgdG8gcXVpY2tseVxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cbiAqXG4gKiAtIFtcImNvbW1vbm1hcmtcIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQuanMpIC1cbiAqICAgc2ltaWxhciB0byBHRk0sIHVzZWQgd2hlbiBubyBwcmVzZXQgbmFtZSBnaXZlbi4gRW5hYmxlcyBhbGwgYXZhaWxhYmxlIHJ1bGVzLFxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXG4gKiAtIFtcInplcm9cIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL3plcm8uanMpIC1cbiAqICAgYWxsIHJ1bGVzIGRpc2FibGVkLiBVc2VmdWwgdG8gcXVpY2tseSBzZXR1cCB5b3VyIGNvbmZpZyB2aWEgYC5lbmFibGUoKWAuXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiAjIyMjIyBvcHRpb25zOlxuICpcbiAqIC0gX19odG1sX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlLiBCZSBjYXJlZnVsIVxuICogICBUaGF0J3Mgbm90IHNhZmUhIFlvdSBtYXkgbmVlZCBleHRlcm5hbCBzYW5pdGl6ZXIgdG8gcHJvdGVjdCBvdXRwdXQgZnJvbSBYU1MuXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxuICogLSBfX3hodG1sT3V0X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGFkZCAnLycgd2hlbiBjbG9zaW5nIHNpbmdsZSB0YWdzXG4gKiAgIChgPGJyIC8+YCkuIFRoaXMgaXMgbmVlZGVkIG9ubHkgZm9yIGZ1bGwgQ29tbW9uTWFyayBjb21wYXRpYmlsaXR5LiBJbiByZWFsXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXG4gKiAtIF9fYnJlYWtzX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGNvbnZlcnQgYFxcbmAgaW4gcGFyYWdyYXBocyBpbnRvIGA8YnI+YC5cbiAqIC0gX19sYW5nUHJlZml4X18gLSBgbGFuZ3VhZ2UtYC4gQ1NTIGxhbmd1YWdlIGNsYXNzIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrcy5cbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxuICogLSBfX2xpbmtpZnlfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dCB0byBsaW5rcy5cbiAqIC0gX190eXBvZ3JhcGhlcl9fICAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIFtzb21lIGxhbmd1YWdlLW5ldXRyYWxcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcbiAgICAgIHByZXNldE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlcklubGluZV1dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW0NvcmVdXSBjaGFpbiBleGVjdXRvci4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tSZW5kZXJlcl1dLiBVc2UgaXQgdG8gbW9kaWZ5IG91dHB1dCBsb29rLiBPciB0byBhZGQgcmVuZGVyaW5nXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBmdW5jdGlvbiBteVRva2VuKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNlbGYpIHtcbiAgICogICAvLy4uLlxuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH07XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxuICAgKiovXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNsaW5raWZ5IC0+IExpbmtpZnlJdFxuICAgKlxuICAgKiBbbGlua2lmeS1pdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQpIGluc3RhbmNlLlxuICAgKiBVc2VkIGJ5IFtsaW5raWZ5XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcylcbiAgICogcnVsZS5cbiAgICoqL1xuICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdmFsaWRhdGVMaW5rKHVybCkgLT4gQm9vbGVhblxuICAgKlxuICAgKiBMaW5rIHZhbGlkYXRpb24gZnVuY3Rpb24uIENvbW1vbk1hcmsgYWxsb3dzIHRvbyBtdWNoIGluIGxpbmtzLiBCeSBkZWZhdWx0XG4gICAqIHdlIGRpc2FibGUgYGphdmFzY3JpcHQ6YCwgYHZic2NyaXB0OmAsIGBmaWxlOmAgc2NoZW1hcywgYW5kIGFsbW9zdCBhbGwgYGRhdGE6Li4uYCBzY2hlbWFzXG4gICAqIGV4Y2VwdCBzb21lIGVtYmVkZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW91cjpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gICAqIG1kLnZhbGlkYXRlTGluayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICogYGBgXG4gICAqKi9cbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRlY29kZSBsaW5rIHVybCB0byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdGBcbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG5cblxuICAvLyBFeHBvc2UgdXRpbHMgJiBoZWxwZXJzIGZvciBlYXN5IGFjY2VzIGZyb20gcGx1Z2luc1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3V0aWxzIC0+IHV0aWxzXG4gICAqXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvY29tbW9uL3V0aWxzLmpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHM7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXG4gICAqXG4gICAqIExpbmsgY29tcG9uZW50cyBwYXJzZXIgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXG4gICAqKi9cbiAgdGhpcy5oZWxwZXJzID0gdXRpbHMuYXNzaWduKHt9LCBoZWxwZXJzKTtcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKTsgfVxufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlLCBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5jb25maWd1cmUocHJlc2V0cylcbiAqXG4gKiBCYXRjaCBsb2FkIG9mIGFsbCBvcHRpb25zIGFuZCBjb21wZW5lbnQgc2V0dGluZ3MuIFRoaXMgaXMgaW50ZXJuYWwgbWV0aG9kLFxuICogYW5kIHlvdSBwcm9iYWJseSB3aWxsIG5vdCBuZWVkIGl0LiBCdXQgaWYgeW91IHdpdGggLSBzZWUgYXZhaWxhYmxlIHByZXNldHNcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgcHJlc2V0cyBpbnN0ZWFkIG9mIGRpcmVjdCBjb25maWcgbG9hZHMuIFRoYXRcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocHJlc2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHByZXNldHMpKSB7XG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgcHJlc2V0cyA9IGNvbmZpZ1twcmVzZXROYW1lXTtcbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJyk7IH1cbiAgfVxuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0LCBjYW5cXCd0IGJlIGVtcHR5Jyk7IH1cblxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBsaXN0IG9yIHJ1bGVzLiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhcHByb3ByaWF0ZSBjb21wb25lbnRzLFxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxuICogbm90IHNldCAtIHRocm93cyBleGNlcHRpb24uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLmVuYWJsZShbJ3N1YicsICdzdXAnXSlcbiAqICAgICAgICAgICAgIC5kaXNhYmxlKCdzbWFydHF1b3RlcycpO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC51c2UocGx1Z2luLCBwYXJhbXMpXG4gKlxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXG4gKiBJdCdzIGp1c3QgYSBzdWdhciB0byBjYWxsIGBwbHVnaW4obWQsIHBhcmFtcylgIHdpdGggY3VycmluZy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAudXNlKGl0ZXJhdG9yLCAnZm9vX3JlcGxhY2UnLCAndGV4dCcsIGZ1bmN0aW9uICh0b2tlbnMsIGlkeCkge1xuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICogICAgICAgICAgICAgfSk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4gLyosIHBhcmFtcywgLi4uICovKSB7XG4gIHZhciBhcmdzID0gWyB0aGlzIF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFBhcnNlIGlucHV0IHN0cmluZyBhbmQgcmV0dXJucyBsaXN0IG9mIGJsb2NrIHRva2VucyAoc3BlY2lhbCB0b2tlbiB0eXBlXG4gKiBcImlubGluZVwiIHdpbGwgY29udGFpbiBsaXN0IG9mIGlubGluZSB0b2tlbnMpLiBZb3Ugc2hvdWxkIG5vdCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBkaXJlY3RseSwgdW50aWwgeW91IHdyaXRlIGN1c3RvbSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIHRvIHByb2R1Y2VcbiAqIEFTVCkuXG4gKlxuICogYGVudmAgaXMgdXNlZCB0byBwYXNzIGRhdGEgYmV0d2VlbiBcImRpc3RyaWJ1dGVkXCIgcnVsZXMgYW5kIHJldHVybiBhZGRpdGlvbmFsXG4gKiBtZXRhZGF0YSBsaWtlIHJlZmVyZW5jZSBpbmZvLCBuZWVkZWQgZm9yIHRoZSByZW5kZXJlci4gSXQgYWxzbyBjYW4gYmUgdXNlZCB0b1xuICogaW5qZWN0IGRhdGEgaW4gc3BlY2lmaWMgY2FzZXMuIFVzdWFsbHksIHlvdSB3aWxsIGJlIG9rIHRvIHBhc3MgYHt9YCxcbiAqIGFuZCB0aGVuIHBhc3MgdXBkYXRlZCBvYmplY3QgdG8gcmVuZGVyZXIuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nJyk7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcihzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBSZW5kZXIgbWFya2Rvd24gc3RyaW5nIGludG8gaHRtbC4gSXQgZG9lcyBhbGwgbWFnaWMgZm9yIHlvdSA6KS5cbiAqXG4gKiBgZW52YCBjYW4gYmUgdXNlZCB0byBpbmplY3QgYWRkaXRpb25hbCBtZXRhZGF0YSAoYHt9YCBieSBkZWZhdWx0KS5cbiAqIEJ1dCB5b3Ugd2lsbCBub3QgbmVlZCBpdCB3aXRoIGhpZ2ggcHJvYmFiaWxpdHkuIFNlZSBhbHNvIGNvbW1lbnRcbiAqIGluIFtbTWFya2Rvd25JdC5wYXJzZV1dLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlSW5saW5lKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LnBhcnNlXV0gYnV0IHNraXAgYWxsIGJsb2NrIHJ1bGVzLiBJdCByZXR1cm5zIHRoZVxuICogYmxvY2sgdG9rZW5zIGxpc3Qgd2l0aCB0aGUgc2luZ2xlIGBpbmxpbmVgIGVsZW1lbnQsIGNvbnRhaW5pbmcgcGFyc2VkIGlubGluZVxuICogdG9rZW5zIGluIGBjaGlsZHJlbmAgcHJvcGVydHkuIEFsc28gdXBkYXRlcyBgZW52YCBvYmplY3QuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICBzdGF0ZS5pbmxpbmVNb2RlID0gdHJ1ZTtcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXJJbmxpbmUoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogU2ltaWxhciB0byBbW01hcmtkb3duSXQucmVuZGVyXV0gYnV0IGZvciBzaW5nbGUgcGFyYWdyYXBoIGNvbnRlbnQuIFJlc3VsdFxuICogd2lsbCBOT1QgYmUgd3JhcHBlZCBpbnRvIGA8cD5gIHRhZ3MuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlSW5saW5lKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaW5kZXguanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIFBhcnNlckJsb2NrXG4gKlxuICogQmxvY2stbGV2ZWwgdG9rZW5pemVyLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgLy8gRmlyc3QgMiBwYXJhbXMgLSBydWxlIG5hbWUgJiBzb3VyY2UuIFNlY29uZGFyeSBhcnJheSAtIGxpc3Qgb2YgcnVsZXMsXG4gIC8vIHdoaWNoIGNhbiBiZSB0ZXJtaW5hdGVkIGJ5IHRoaXMgb25lLlxuICBbICd0YWJsZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay90YWJsZScpLCAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnIF0gXSxcbiAgWyAnY29kZScsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svY29kZScpIF0sXG4gIFsgJ2ZlbmNlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2ZlbmNlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnYmxvY2txdW90ZScsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svYmxvY2txdW90ZScpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2xpc3QnIF0gXSxcbiAgWyAnaHInLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHInKSwgICAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdsaXN0JywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9saXN0JyksICAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdyZWZlcmVuY2UnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9yZWZlcmVuY2UnKSBdLFxuICBbICdoZWFkaW5nJywgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9oZWFkaW5nJyksICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdsaGVhZGluZycsICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9saGVhZGluZycpIF0sXG4gIFsgJ2h0bWxfYmxvY2snLCByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2snKSwgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ3BhcmFncmFwaCcsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3BhcmFncmFwaCcpIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgUGFyc2VyQmxvY2soKVxuICoqL1xuZnVuY3Rpb24gUGFyc2VyQmxvY2soKSB7XG4gIC8qKlxuICAgKiBQYXJzZXJCbG9jayNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBibG9jayBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0sIHsgYWx0OiAoX3J1bGVzW2ldWzJdIHx8IFtdKS5zbGljZSgpIH0pO1xuICB9XG59XG5cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlckJsb2NrLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gIHZhciBvaywgaSxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBsaW5lID0gc3RhcnRMaW5lLFxuICAgICAgaGFzRW1wdHlMaW5lcyA9IGZhbHNlLFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcblxuICB3aGlsZSAobGluZSA8IGVuZExpbmUpIHtcbiAgICBzdGF0ZS5saW5lID0gbGluZSA9IHN0YXRlLnNraXBFbXB0eUxpbmVzKGxpbmUpO1xuICAgIGlmIChsaW5lID49IGVuZExpbmUpIHsgYnJlYWs7IH1cblxuICAgIC8vIFRlcm1pbmF0aW9uIGNvbmRpdGlvbiBmb3IgbmVzdGVkIGNhbGxzLlxuICAgIC8vIE5lc3RlZCBjYWxscyBjdXJyZW50bHkgdXNlZCBmb3IgYmxvY2txdW90ZXMgJiBsaXN0c1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIC8vIElmIG5lc3RpbmcgbGV2ZWwgZXhjZWVkZWQgLSBza2lwIHRhaWwgdG8gdGhlIGVuZC4gVGhhdCdzIG5vdCBvcmRpbmFyeVxuICAgIC8vIHNpdHVhdGlvbiBhbmQgd2Ugc2hvdWxkIG5vdCBjYXJlIGFib3V0IGNvbnRlbnQuXG4gICAgaWYgKHN0YXRlLmxldmVsID49IG1heE5lc3RpbmcpIHtcbiAgICAgIHN0YXRlLmxpbmUgPSBlbmRMaW5lO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCBydWxlIHNob3VsZDpcbiAgICAvL1xuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5saW5lYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBsaW5lLCBlbmRMaW5lLCBmYWxzZSk7XG4gICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBzZXQgc3RhdGUudGlnaHQgaWZmIHdlIGhhZCBhbiBlbXB0eSBsaW5lIGJlZm9yZSBjdXJyZW50IHRhZ1xuICAgIC8vIGkuZS4gbGF0ZXN0IGVtcHR5IGxpbmUgc2hvdWxkIG5vdCBjb3VudFxuICAgIHN0YXRlLnRpZ2h0ID0gIWhhc0VtcHR5TGluZXM7XG5cbiAgICAvLyBwYXJhZ3JhcGggbWlnaHQgXCJlYXRcIiBvbmUgbmV3bGluZSBhZnRlciBpdCBpbiBuZXN0ZWQgbGlzdHNcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xuXG4gICAgaWYgKGxpbmUgPCBlbmRMaW5lICYmIHN0YXRlLmlzRW1wdHkobGluZSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgbGluZSsrO1xuICAgICAgc3RhdGUubGluZSA9IGxpbmU7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VyQmxvY2sucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggYmxvY2sgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlckJsb2NrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzcmMpIHsgcmV0dXJuOyB9XG5cbiAgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSwgc3RhdGUubGluZSwgc3RhdGUubGluZU1heCk7XG59O1xuXG5cblBhcnNlckJsb2NrLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svc3RhdGVfYmxvY2snKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckJsb2NrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9ibG9jay5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgQ29yZVxuICpcbiAqIFRvcC1sZXZlbCBydWxlcyBleGVjdXRvci4gR2x1ZXMgYmxvY2svaW5saW5lIHBhcnNlcnMgYW5kIGRvZXMgaW50ZXJtZWRpYXRlXG4gKiB0cmFuc2Zvcm1hdGlvbnMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICBbICdub3JtYWxpemUnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ub3JtYWxpemUnKSAgICAgIF0sXG4gIFsgJ2Jsb2NrJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2Jsb2NrJykgICAgICAgICAgXSxcbiAgWyAnaW5saW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvaW5saW5lJykgICAgICAgICBdLFxuICBbICdsaW5raWZ5JywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9saW5raWZ5JykgICAgICAgIF0sXG4gIFsgJ3JlcGxhY2VtZW50cycsICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cycpICAgXSxcbiAgWyAnc21hcnRxdW90ZXMnLCAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMnKSAgICBdXG5dO1xuXG5cbi8qKlxuICogbmV3IENvcmUoKVxuICoqL1xuZnVuY3Rpb24gQ29yZSgpIHtcbiAgLyoqXG4gICAqIENvcmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgY29yZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG59XG5cblxuLyoqXG4gKiBDb3JlLnByb2Nlc3Moc3RhdGUpXG4gKlxuICogRXhlY3V0ZXMgY29yZSBjaGFpbiBydWxlcy5cbiAqKi9cbkNvcmUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIGksIGwsIHJ1bGVzO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuQ29yZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc3RhdGVfY29yZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VySW5saW5lXG4gKlxuICogVG9rZW5pemVzIHBhcmFncmFwaCBjb250ZW50LlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFBhcnNlciBydWxlc1xuXG52YXIgX3J1bGVzID0gW1xuICBbICd0ZXh0JywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0JykgXSxcbiAgWyAnbmV3bGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbmV3bGluZScpIF0sXG4gIFsgJ2VzY2FwZScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VzY2FwZScpIF0sXG4gIFsgJ2JhY2t0aWNrcycsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhY2t0aWNrcycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS50b2tlbml6ZSBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnRva2VuaXplIF0sXG4gIFsgJ2xpbmsnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2xpbmsnKSBdLFxuICBbICdpbWFnZScsICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9pbWFnZScpIF0sXG4gIFsgJ2F1dG9saW5rJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2F1dG9saW5rJykgXSxcbiAgWyAnaHRtbF9pbmxpbmUnLCAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUnKSBdLFxuICBbICdlbnRpdHknLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbnRpdHknKSBdXG5dO1xuXG52YXIgX3J1bGVzMiA9IFtcbiAgWyAnYmFsYW5jZV9wYWlycycsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS5wb3N0UHJvY2VzcyBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ3RleHRfY29sbGFwc2UnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlcklubGluZSgpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJJbmxpbmUoKSB7XG4gIHZhciBpO1xuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgaW5saW5lIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gU2Vjb25kIHJ1bGVyIHVzZWQgZm9yIHBvc3QtcHJvY2Vzc2luZ1xuICAgKiAoZS5nLiBpbiBlbXBoYXNpcy1saWtlIHJ1bGVzKS5cbiAgICoqL1xuICB0aGlzLnJ1bGVyMiA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlcjIucHVzaChfcnVsZXMyW2ldWzBdLCBfcnVsZXMyW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8vIFNraXAgc2luZ2xlIHRva2VuIGJ5IHJ1bm5pbmcgYWxsIHJ1bGVzIGluIHZhbGlkYXRpb24gbW9kZTtcbi8vIHJldHVybnMgYHRydWVgIGlmIGFueSBydWxlIHJlcG9ydGVkIHN1Y2Nlc3Ncbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnNraXBUb2tlbiA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgb2ssIGksIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nLFxuICAgICAgY2FjaGUgPSBzdGF0ZS5jYWNoZTtcblxuXG4gIGlmICh0eXBlb2YgY2FjaGVbcG9zXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5wb3MgPSBjYWNoZVtwb3NdO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIEluY3JlbWVudCBzdGF0ZS5sZXZlbCBhbmQgZGVjcmVtZW50IGl0IGxhdGVyIHRvIGxpbWl0IHJlY3Vyc2lvbi5cbiAgICAgIC8vIEl0J3MgaGFybWxlc3MgdG8gZG8gaGVyZSwgYmVjYXVzZSBubyB0b2tlbnMgYXJlIGNyZWF0ZWQuIEJ1dCBpZGVhbGx5LFxuICAgICAgLy8gd2UnZCBuZWVkIGEgc2VwYXJhdGUgcHJpdmF0ZSBzdGF0ZSB2YXJpYWJsZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgLy9cbiAgICAgIHN0YXRlLmxldmVsKys7XG4gICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCB0cnVlKTtcbiAgICAgIHN0YXRlLmxldmVsLS07XG5cbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUb28gbXVjaCBuZXN0aW5nLCBqdXN0IHNraXAgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGFyYWdyYXBoLlxuICAgIC8vXG4gICAgLy8gTk9URTogdGhpcyB3aWxsIGNhdXNlIGxpbmtzIHRvIGJlaGF2ZSBpbmNvcnJlY3RseSBpbiB0aGUgZm9sbG93aW5nIGNhc2UsXG4gICAgLy8gICAgICAgd2hlbiBhbiBhbW91bnQgb2YgYFtgIGlzIGV4YWN0bHkgZXF1YWwgdG8gYG1heE5lc3RpbmcgKyAxYDpcbiAgICAvL1xuICAgIC8vICAgICAgIFtbW1tbW1tbW1tbW1tbW1tbW1tbW2Zvb10oKVxuICAgIC8vXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCB3aGVuIENNIHN0YW5kYXJkIHdpbGwgYWxsb3cgbmVzdGVkIGxpbmtzXG4gICAgLy8gICAgICAgKHdlIGNhbiByZXBsYWNlIGl0IGJ5IHByZXZlbnRpbmcgbGlua3MgZnJvbSBiZWluZyBwYXJzZWQgaW5cbiAgICAvLyAgICAgICB2YWxpZGF0aW9uIG1vZGUpXG4gICAgLy9cbiAgICBzdGF0ZS5wb3MgPSBzdGF0ZS5wb3NNYXg7XG4gIH1cblxuICBpZiAoIW9rKSB7IHN0YXRlLnBvcysrOyB9XG4gIGNhY2hlW3Bvc10gPSBzdGF0ZS5wb3M7XG59O1xuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBlbmQgPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBlbmQpIHtcbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnBvc2BcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvaykge1xuICAgICAgaWYgKHN0YXRlLnBvcyA+PSBlbmQpIHsgYnJlYWs7IH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3N0YXRlLnBvcysrXTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgc3RhdGUucHVzaFBlbmRpbmcoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlcklubGluZS5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBpbmxpbmUgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlcklubGluZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIGksIHJ1bGVzLCBsZW47XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLlN0YXRlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKTtcblxuICB0aGlzLnRva2VuaXplKHN0YXRlKTtcblxuICBydWxlcyA9IHRoaXMucnVsZXIyLmdldFJ1bGVzKCcnKTtcbiAgbGVuID0gcnVsZXMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJJbmxpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qcyIsIi8vIENvbW1vbm1hcmsgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgdHJ1ZSwgICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgdHJ1ZSwgICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYmxvY2txdW90ZScsXG4gICAgICAgICdjb2RlJyxcbiAgICAgICAgJ2ZlbmNlJyxcbiAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAnaHInLFxuICAgICAgICAnaHRtbF9ibG9jaycsXG4gICAgICAgICdsaGVhZGluZycsXG4gICAgICAgICdsaXN0JyxcbiAgICAgICAgJ3JlZmVyZW5jZScsXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2F1dG9saW5rJyxcbiAgICAgICAgJ2JhY2t0aWNrcycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICdlbnRpdHknLFxuICAgICAgICAnZXNjYXBlJyxcbiAgICAgICAgJ2h0bWxfaW5saW5lJyxcbiAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgJ2xpbmsnLFxuICAgICAgICAnbmV3bGluZScsXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMiLCIvLyBtYXJrZG93bi1pdCBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMTAwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge30sXG4gICAgYmxvY2s6IHt9LFxuICAgIGlubGluZToge31cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCIvLyBcIlplcm9cIiBwcmVzZXQsIHdpdGggbm90aGluZyBlbmFibGVkLiBVc2VmdWwgZm9yIG1hbnVhbCBjb25maWd1cmluZyBvZiBzaW1wbGVcbi8vIG1vZGVzLiBGb3IgZXhhbXBsZSwgdG8gcGFyc2UgYm9sZC9pdGFsaWMgb25seS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvemVyby5qcyIsIi8qKlxuICogY2xhc3MgUmVuZGVyZXJcbiAqXG4gKiBHZW5lcmF0ZXMgSFRNTCBmcm9tIHBhcnNlZCB0b2tlbiBzdHJlYW0uIEVhY2ggaW5zdGFuY2UgaGFzIGluZGVwZW5kZW50XG4gKiBjb3B5IG9mIHJ1bGVzLiBUaG9zZSBjYW4gYmUgcmV3cml0dGVuIHdpdGggZWFzZS4gQWxzbywgeW91IGNhbiBhZGQgbmV3XG4gKiBydWxlcyBpZiB5b3UgY3JlYXRlIHBsdWdpbiBhbmQgYWRkcyBuZXcgdG9rZW4gdHlwZXMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGFzc2lnbiAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuYXNzaWduO1xudmFyIHVuZXNjYXBlQWxsICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG52YXIgZXNjYXBlSHRtbCAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5lc2NhcGVIdG1sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBkZWZhdWx0X3J1bGVzID0ge307XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgcmV0dXJuICAnPGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxwcmUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+PGNvZGU+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmZlbmNlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XSxcbiAgICAgIGluZm8gPSB0b2tlbi5pbmZvID8gdW5lc2NhcGVBbGwodG9rZW4uaW5mbykudHJpbSgpIDogJycsXG4gICAgICBsYW5nTmFtZSA9ICcnLFxuICAgICAgaGlnaGxpZ2h0ZWQsIGksIHRtcEF0dHJzLCB0bXBUb2tlbjtcblxuICBpZiAoaW5mbykge1xuICAgIGxhbmdOYW1lID0gaW5mby5zcGxpdCgvXFxzKy9nKVswXTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIGhpZ2hsaWdodGVkID0gb3B0aW9ucy5oaWdobGlnaHQodG9rZW4uY29udGVudCwgbGFuZ05hbWUpIHx8IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9XG5cbiAgaWYgKGhpZ2hsaWdodGVkLmluZGV4T2YoJzxwcmUnKSA9PT0gMCkge1xuICAgIHJldHVybiBoaWdobGlnaHRlZCArICdcXG4nO1xuICB9XG5cbiAgLy8gSWYgbGFuZ3VhZ2UgZXhpc3RzLCBpbmplY3QgY2xhc3MgZ2VudGx5LCB3aXRob3V0IG11ZG9meWluZyBvcmlnaW5hbCB0b2tlbi5cbiAgLy8gTWF5IGJlLCBvbmUgZGF5IHdlIHdpbGwgYWRkIC5jbG9uZSgpIGZvciB0b2tlbiBhbmQgc2ltcGxpZnkgdGhpcyBwYXJ0LCBidXRcbiAgLy8gbm93IHdlIHByZWZlciB0byBrZWVwIHRoaW5ncyBsb2NhbC5cbiAgaWYgKGluZm8pIHtcbiAgICBpICAgICAgICA9IHRva2VuLmF0dHJJbmRleCgnY2xhc3MnKTtcbiAgICB0bXBBdHRycyA9IHRva2VuLmF0dHJzID8gdG9rZW4uYXR0cnMuc2xpY2UoKSA6IFtdO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0bXBBdHRycy5wdXNoKFsgJ2NsYXNzJywgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWUgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcEF0dHJzW2ldWzFdICs9ICcgJyArIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lO1xuICAgIH1cblxuICAgIC8vIEZha2UgdG9rZW4ganVzdCB0byByZW5kZXIgYXR0cmlidXRlc1xuICAgIHRtcFRva2VuID0ge1xuICAgICAgYXR0cnM6IHRtcEF0dHJzXG4gICAgfTtcblxuICAgIHJldHVybiAgJzxwcmU+PGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRtcFRva2VuKSArICc+J1xuICAgICAgICAgICsgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgfVxuXG5cbiAgcmV0dXJuICAnPHByZT48Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz4nXG4gICAgICAgICsgaGlnaGxpZ2h0ZWRcbiAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaW1hZ2UgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIC8vIFwiYWx0XCIgYXR0ciBNVVNUIGJlIHNldCwgZXZlbiBpZiBlbXB0eS4gQmVjYXVzZSBpdCdzIG1hbmRhdG9yeSBhbmRcbiAgLy8gc2hvdWxkIGJlIHBsYWNlZCBvbiBwcm9wZXIgcG9zaXRpb24gZm9yIHRlc3RzLlxuICAvL1xuICAvLyBSZXBsYWNlIGNvbnRlbnQgd2l0aCBhY3R1YWwgdmFsdWVcblxuICB0b2tlbi5hdHRyc1t0b2tlbi5hdHRySW5kZXgoJ2FsdCcpXVsxXSA9XG4gICAgc2xmLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbi5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcblxuICByZXR1cm4gc2xmLnJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKTtcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5oYXJkYnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nO1xufTtcbmRlZmF1bHRfcnVsZXMuc29mdGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMuYnJlYWtzID8gKG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJykgOiAnXFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy50ZXh0ID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCk7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaHRtbF9ibG9jayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xufTtcbmRlZmF1bHRfcnVsZXMuaHRtbF9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5cblxuLyoqXG4gKiBuZXcgUmVuZGVyZXIoKVxuICpcbiAqIENyZWF0ZXMgbmV3IFtbUmVuZGVyZXJdXSBpbnN0YW5jZSBhbmQgZmlsbCBbW1JlbmRlcmVyI3J1bGVzXV0gd2l0aCBkZWZhdWx0cy5cbiAqKi9cbmZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuXG4gIC8qKlxuICAgKiBSZW5kZXJlciNydWxlcyAtPiBPYmplY3RcbiAgICpcbiAgICogQ29udGFpbnMgcmVuZGVyIHJ1bGVzIGZvciB0b2tlbnMuIENhbiBiZSB1cGRhdGVkIGFuZCBleHRlbmRlZC5cbiAgICpcbiAgICogIyMjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICpcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX29wZW4gID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzxiPic7IH07XG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19jbG9zZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8L2I+JzsgfTtcbiAgICpcbiAgICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSguLi4pO1xuICAgKiBgYGBcbiAgICpcbiAgICogRWFjaCBydWxlIGlzIGNhbGxlZCBhcyBpbmRlcGVuZGVkIHN0YXRpYyBmdW5jdGlvbiB3aXRoIGZpeGVkIHNpZ25hdHVyZTpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBmdW5jdGlvbiBteV90b2tlbl9yZW5kZXIodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgcmVuZGVyZXIpIHtcbiAgICogICAvLyAuLi5cbiAgICogICByZXR1cm4gcmVuZGVyZWRIVE1MO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBTZWUgW3NvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3JlbmRlcmVyLmpzKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVzID0gYXNzaWduKHt9LCBkZWZhdWx0X3J1bGVzKTtcbn1cblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlckF0dHJzKHRva2VuKSAtPiBTdHJpbmdcbiAqXG4gKiBSZW5kZXIgdG9rZW4gYXR0cmlidXRlcyB0byBzdHJpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQXR0cnMgPSBmdW5jdGlvbiByZW5kZXJBdHRycyh0b2tlbikge1xuICB2YXIgaSwgbCwgcmVzdWx0O1xuXG4gIGlmICghdG9rZW4uYXR0cnMpIHsgcmV0dXJuICcnOyB9XG5cbiAgcmVzdWx0ID0gJyc7XG5cbiAgZm9yIChpID0gMCwgbCA9IHRva2VuLmF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJlc3VsdCArPSAnICcgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzBdKSArICc9XCInICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVsxXSkgKyAnXCInO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9mIHRva2Vuc1xuICogLSBpZHggKE51bWJlZCk6IHRva2VuIGluZGV4IHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKlxuICogRGVmYXVsdCB0b2tlbiByZW5kZXJlci4gQ2FuIGJlIG92ZXJyaWRlbiBieSBjdXN0b20gZnVuY3Rpb25cbiAqIGluIFtbUmVuZGVyZXIjcnVsZXNdXS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbiA9IGZ1bmN0aW9uIHJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSB7XG4gIHZhciBuZXh0VG9rZW4sXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIG5lZWRMZiA9IGZhbHNlLFxuICAgICAgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBUaWdodCBsaXN0IHBhcmFncmFwaHNcbiAgaWYgKHRva2VuLmhpZGRlbikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEluc2VydCBhIG5ld2xpbmUgYmV0d2VlbiBoaWRkZW4gcGFyYWdyYXBoIGFuZCBzdWJzZXF1ZW50IG9wZW5pbmdcbiAgLy8gYmxvY2stbGV2ZWwgdGFnLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgaGVyZSB3ZSBzaG91bGQgaW5zZXJ0IGEgbmV3bGluZSBiZWZvcmUgYmxvY2txdW90ZTpcbiAgLy8gIC0gYVxuICAvLyAgICA+XG4gIC8vXG4gIGlmICh0b2tlbi5ibG9jayAmJiB0b2tlbi5uZXN0aW5nICE9PSAtMSAmJiBpZHggJiYgdG9rZW5zW2lkeCAtIDFdLmhpZGRlbikge1xuICAgIHJlc3VsdCArPSAnXFxuJztcbiAgfVxuXG4gIC8vIEFkZCB0b2tlbiBuYW1lLCBlLmcuIGA8aW1nYFxuICByZXN1bHQgKz0gKHRva2VuLm5lc3RpbmcgPT09IC0xID8gJzwvJyA6ICc8JykgKyB0b2tlbi50YWc7XG5cbiAgLy8gRW5jb2RlIGF0dHJpYnV0ZXMsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCJgXG4gIHJlc3VsdCArPSB0aGlzLnJlbmRlckF0dHJzKHRva2VuKTtcblxuICAvLyBBZGQgYSBzbGFzaCBmb3Igc2VsZi1jbG9zaW5nIHRhZ3MsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCIgL2BcbiAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDAgJiYgb3B0aW9ucy54aHRtbE91dCkge1xuICAgIHJlc3VsdCArPSAnIC8nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgYSBuZXdsaW5lIGFmdGVyIHRoaXMgdGFnXG4gIGlmICh0b2tlbi5ibG9jaykge1xuICAgIG5lZWRMZiA9IHRydWU7XG5cbiAgICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMSkge1xuICAgICAgaWYgKGlkeCArIDEgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIG5leHRUb2tlbiA9IHRva2Vuc1tpZHggKyAxXTtcblxuICAgICAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09ICdpbmxpbmUnIHx8IG5leHRUb2tlbi5oaWRkZW4pIHtcbiAgICAgICAgICAvLyBCbG9jay1sZXZlbCB0YWcgY29udGFpbmluZyBhbiBpbmxpbmUgdGFnLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0VG9rZW4ubmVzdGluZyA9PT0gLTEgJiYgbmV4dFRva2VuLnRhZyA9PT0gdG9rZW4udGFnKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyB0YWcgKyBjbG9zaW5nIHRhZyBvZiB0aGUgc2FtZSB0eXBlLiBFLmcuIGA8bGk+PC9saT5gLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXN1bHQgKz0gbmVlZExmID8gJz5cXG4nIDogJz4nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVySW5saW5lKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW1JlbmRlcmVyLnJlbmRlcl1dLCBidXQgZm9yIHNpbmdsZSB0b2tlbiBvZiBgaW5saW5lYCB0eXBlLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3R5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogU3BlY2lhbCBrbHVkZ2UgZm9yIGltYWdlIGBhbHRgIGF0dHJpYnV0ZXMgdG8gY29uZm9ybSBDb21tb25NYXJrIHNwZWMuXG4gKiBEb24ndCB0cnkgdG8gdXNlIGl0ISBTcGVjIHJlcXVpcmVzIHRvIHNob3cgYGFsdGAgY29udGVudCB3aXRoIHN0cmlwcGVkIG1hcmt1cCxcbiAqIGluc3RlYWQgb2Ygc2ltcGxlIGVzY2FwaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZUFzVGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICByZXN1bHQgKz0gdG9rZW5zW2ldLmNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lQXNUZXh0KHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlcih0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogVGFrZXMgdG9rZW4gc3RyZWFtIGFuZCBnZW5lcmF0ZXMgSFRNTC4gUHJvYmFibHksIHlvdSB3aWxsIG5ldmVyIG5lZWQgdG8gY2FsbFxuICogdGhpcyBtZXRob2QgZGlyZWN0bHkuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciBpLCBsZW4sIHR5cGUsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICBmb3IgKGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZSh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHQgKz0gcnVsZXNbdG9rZW5zW2ldLnR5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwiLy8gQmxvY2sgcXVvdGVzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2txdW90ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGFkanVzdFRhYixcbiAgICAgIGNoLFxuICAgICAgaSxcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc091dGRlbnRlZCxcbiAgICAgIGwsXG4gICAgICBsYXN0TGluZUVtcHR5LFxuICAgICAgbGluZXMsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEJNYXJrcyxcbiAgICAgIG9sZEJTQ291bnQsXG4gICAgICBvbGRJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkU0NvdW50LFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgc3BhY2VBZnRlck1hcmtlcixcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRva2VuLFxuICAgICAgb2xkTGluZU1heCA9IHN0YXRlLmxpbmVNYXgsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY2hlY2sgdGhlIGJsb2NrIHF1b3RlIG1hcmtlclxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspICE9PSAweDNFLyogPiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyB3ZSBrbm93IHRoYXQgaXQncyBnb2luZyB0byBiZSBhIHZhbGlkIGJsb2NrcXVvdGUsXG4gIC8vIHNvIG5vIHBvaW50IHRyeWluZyB0byBmaW5kIHRoZSBlbmQgb2YgaXQgaW4gc2lsZW50IG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNraXAgc3BhY2VzIGFmdGVyIFwiPlwiIGFuZCByZS1jYWxjdWxhdGUgb2Zmc2V0XG4gIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIHBvcyAtIChzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdKTtcblxuICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjAgLyogc3BhY2UgKi8pIHtcbiAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgcG9zKys7XG4gICAgaW5pdGlhbCsrO1xuICAgIG9mZnNldCsrO1xuICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG5cbiAgICBpZiAoKHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIG9mZnNldCkgJSA0ID09PSAzKSB7XG4gICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgIHBvcysrO1xuICAgICAgaW5pdGlhbCsrO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgIC8vICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICsgc2hpZnQgYnNDb3VudCBzbGlnaHRseVxuICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICB9XG5cbiAgb2xkQk1hcmtzID0gWyBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSA9IHBvcztcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgb2xkQlNDb3VudCA9IFsgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdIF07XG4gIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdICsgMSArIChzcGFjZUFmdGVyTWFya2VyID8gMSA6IDApO1xuXG4gIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4O1xuXG4gIG9sZFNDb3VudCA9IFsgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsO1xuXG4gIG9sZFRTaGlmdCA9IFsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnYmxvY2txdW90ZScpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2Jsb2NrcXVvdGUnO1xuXG4gIC8vIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBibG9ja1xuICAvL1xuICAvLyBCbG9jayBlbmRzIHdpdGggZWl0aGVyOlxuICAvLyAgMS4gYW4gZW1wdHkgbGluZSBvdXRzaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy9cbiAgLy8gICAgIGBgYFxuICAvLyAgMi4gYW4gZW1wdHkgbGluZSBpbnNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID5cbiAgLy8gICAgIHRlc3RcbiAgLy8gICAgIGBgYFxuICAvLyAgMy4gYW5vdGhlciB0YWc6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvLyAgICAgIC0gLSAtXG4gIC8vICAgICBgYGBcbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIC8vIGNoZWNrIGlmIGl0J3Mgb3V0ZGVudGVkLCBpLmUuIGl0J3MgaW5zaWRlIGxpc3QgaXRlbSBhbmQgaW5kZW50ZWRcbiAgICAvLyBsZXNzIHRoYW4gc2FpZCBsaXN0IGl0ZW06XG4gICAgLy9cbiAgICAvLyBgYGBcbiAgICAvLyAxLiBhbnl0aGluZ1xuICAgIC8vICAgID4gY3VycmVudCBibG9ja3F1b3RlXG4gICAgLy8gMi4gY2hlY2tpbmcgdGhpcyBsaW5lXG4gICAgLy8gYGBgXG4gICAgaXNPdXRkZW50ZWQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50O1xuXG4gICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAvLyBDYXNlIDE6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoaXMgbGluZSBpcyBlbXB0eS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgPT09IDB4M0UvKiA+ICovICYmICFpc091dGRlbnRlZCkge1xuICAgICAgLy8gVGhpcyBsaW5lIGlzIGluc2lkZSB0aGUgYmxvY2txdW90ZS5cblxuICAgICAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcblxuICAgICAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgICAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAgICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgICAgICBwb3MrKztcbiAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5iTWFya3NbbmV4dExpbmVdID0gcG9zO1xuXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUudFNoaWZ0W25leHRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tuZXh0TGluZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDYXNlIDI6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoZSBsYXN0IGxpbmUgd2FzIGVtcHR5LlxuICAgIGlmIChsYXN0TGluZUVtcHR5KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBDYXNlIDM6IGFub3RoZXIgdGFnIGZvdW5kLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgLy8gUXVpcmsgdG8gZW5mb3JjZSBcImhhcmQgdGVybWluYXRpb24gbW9kZVwiIGZvciBwYXJhZ3JhcGhzO1xuICAgICAgLy8gbm9ybWFsbHkgaWYgeW91IGNhbGwgYHRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKWAsXG4gICAgICAvLyBwYXJhZ3JhcGhzIHdpbGwgbG9vayBiZWxvdyBuZXh0TGluZSBmb3IgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbixcbiAgICAgIC8vIGJ1dCBpZiBibG9ja3F1b3RlIGlzIHRlcm1pbmF0ZWQgYnkgYW5vdGhlciB0YWcsIHRoZXkgc2hvdWxkbid0XG4gICAgICBzdGF0ZS5saW5lTWF4ID0gbmV4dExpbmU7XG5cbiAgICAgIGlmIChzdGF0ZS5ibGtJbmRlbnQgIT09IDApIHtcbiAgICAgICAgLy8gc3RhdGUuYmxrSW5kZW50IHdhcyBub24temVybywgd2Ugbm93IHNldCBpdCB0byB6ZXJvLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBhbGwgb2Zmc2V0cyB0byBhcHBlYXIgYXNcbiAgICAgICAgLy8gaWYgaW5kZW50IHdhc24ndCBjaGFuZ2VkXG4gICAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLT0gc3RhdGUuYmxrSW5kZW50O1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaXNPdXRkZW50ZWQpIGJyZWFrO1xuXG4gICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcblxuICAgIC8vIEEgbmVnYXRpdmUgaW5kZW50YXRpb24gbWVhbnMgdGhhdCB0aGlzIGlzIGEgcGFyYWdyYXBoIGNvbnRpbnVhdGlvblxuICAgIC8vXG4gICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IC0xO1xuICB9XG5cbiAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICBzdGF0ZS5ibGtJbmRlbnQgPSAwO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfb3BlbicsICdibG9ja3F1b3RlJywgMSk7XG4gIHRva2VuLm1hcmt1cCA9ICc+JztcbiAgdG9rZW4ubWFwICAgID0gbGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX2Nsb3NlJywgJ2Jsb2NrcXVvdGUnLCAtMSk7XG4gIHRva2VuLm1hcmt1cCA9ICc+JztcblxuICBzdGF0ZS5saW5lTWF4ID0gb2xkTGluZU1heDtcbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG4gIGxpbmVzWzFdID0gc3RhdGUubGluZTtcblxuICAvLyBSZXN0b3JlIG9yaWdpbmFsIHRTaGlmdDsgdGhpcyBtaWdodCBub3QgYmUgbmVjZXNzYXJ5IHNpbmNlIHRoZSBwYXJzZXJcbiAgLy8gaGFzIGFscmVhZHkgYmVlbiBoZXJlLCBidXQganVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIGRvIHRoYXQuXG4gIGZvciAoaSA9IDA7IGkgPCBvbGRUU2hpZnQubGVuZ3RoOyBpKyspIHtcbiAgICBzdGF0ZS5iTWFya3NbaSArIHN0YXJ0TGluZV0gPSBvbGRCTWFya3NbaV07XG4gICAgc3RhdGUudFNoaWZ0W2kgKyBzdGFydExpbmVdID0gb2xkVFNoaWZ0W2ldO1xuICAgIHN0YXRlLnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZFNDb3VudFtpXTtcbiAgICBzdGF0ZS5ic0NvdW50W2kgKyBzdGFydExpbmVdID0gb2xkQlNDb3VudFtpXTtcbiAgfVxuICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCIvLyBDb2RlIGJsb2NrICg0IHNwYWNlcyBwYWRkZWQpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvZGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgbmV4dExpbmUsIGxhc3QsIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA8IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFzdCA9IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgaWYgKHN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGxhc3QgPSBuZXh0TGluZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBsYXN0O1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2Jsb2NrJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbGFzdCwgNCArIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLmpzIiwiLy8gZmVuY2VzIChgYGAgbGFuZywgfn5+IGxhbmcpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZlbmNlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBsZW4sIHBhcmFtcywgbmV4dExpbmUsIG1lbSwgdG9rZW4sIG1hcmt1cCxcbiAgICAgIGhhdmVFbmRNYXJrZXIgPSBmYWxzZSxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovICYmIG1hcmtlciAhPT0gMHg2MCAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gc2NhbiBtYXJrZXIgbGVuZ3RoXG4gIG1lbSA9IHBvcztcbiAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICBsZW4gPSBwb3MgLSBtZW07XG5cbiAgaWYgKGxlbiA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya3VwID0gc3RhdGUuc3JjLnNsaWNlKG1lbSwgcG9zKTtcbiAgcGFyYW1zID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBpZiAocGFyYW1zLmluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKSA+PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbmNlIHN0YXJ0IGlzIGZvdW5kLCB3ZSBjYW4gcmVwb3J0IHN1Y2Nlc3MgaGVyZSBpbiB2YWxpZGF0aW9uIG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNlYXJjaCBlbmQgb2YgYmxvY2tcbiAgbmV4dExpbmUgPSBzdGFydExpbmU7XG5cbiAgZm9yICg7Oykge1xuICAgIG5leHRMaW5lKys7XG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHtcbiAgICAgIC8vIHVuY2xvc2VkIGJsb2NrIHNob3VsZCBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBkb2N1bWVudC5cbiAgICAgIC8vIGFsc28gYmxvY2sgc2VlbXMgdG8gYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgcGFyZW50XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MgPSBtZW0gPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAvLyBub24tZW1wdHkgbGluZSB3aXRoIG5lZ2F0aXZlIGluZGVudCBzaG91bGQgc3RvcCB0aGUgbGlzdDpcbiAgICAgIC8vIC0gYGBgXG4gICAgICAvLyAgdGVzdFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IG1hcmtlcikgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgLy8gY2xvc2luZyBmZW5jZSBzaG91bGQgYmUgaW5kZW50ZWQgbGVzcyB0aGFuIDQgc3BhY2VzXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gICAgLy8gY2xvc2luZyBjb2RlIGZlbmNlIG11c3QgYmUgYXQgbGVhc3QgYXMgbG9uZyBhcyB0aGUgb3BlbmluZyBvbmVcbiAgICBpZiAocG9zIC0gbWVtIDwgbGVuKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGFpbCBoYXMgc3BhY2VzIG9ubHlcbiAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICBpZiAocG9zIDwgbWF4KSB7IGNvbnRpbnVlOyB9XG5cbiAgICBoYXZlRW5kTWFya2VyID0gdHJ1ZTtcbiAgICAvLyBmb3VuZCFcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIElmIGEgZmVuY2UgaGFzIGhlYWRpbmcgc3BhY2VzLCB0aGV5IHNob3VsZCBiZSByZW1vdmVkIGZyb20gaXRzIGlubmVyIGJsb2NrXG4gIGxlbiA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIChoYXZlRW5kTWFya2VyID8gMSA6IDApO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdmZW5jZScsICdjb2RlJywgMCk7XG4gIHRva2VuLmluZm8gICAgPSBwYXJhbXM7XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUgKyAxLCBuZXh0TGluZSwgbGVuLCB0cnVlKTtcbiAgdG9rZW4ubWFya3VwICA9IG1hcmt1cDtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzIiwiLy8gaGVhZGluZyAoIywgIyMsIC4uLilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxldmVsLCB0bXAsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoICA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKGNoICE9PSAweDIzLyogIyAqLyB8fCBwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNvdW50IGhlYWRpbmcgbGV2ZWxcbiAgbGV2ZWwgPSAxO1xuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgd2hpbGUgKGNoID09PSAweDIzLyogIyAqLyAmJiBwb3MgPCBtYXggJiYgbGV2ZWwgPD0gNikge1xuICAgIGxldmVsKys7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIH1cblxuICBpZiAobGV2ZWwgPiA2IHx8IChwb3MgPCBtYXggJiYgIWlzU3BhY2UoY2gpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gTGV0J3MgY3V0IHRhaWxzIGxpa2UgJyAgICAjIyMgICcgZnJvbSB0aGUgZW5kIG9mIHN0cmluZ1xuXG4gIG1heCA9IHN0YXRlLnNraXBTcGFjZXNCYWNrKG1heCwgcG9zKTtcbiAgdG1wID0gc3RhdGUuc2tpcENoYXJzQmFjayhtYXgsIDB4MjMsIHBvcyk7IC8vICNcbiAgaWYgKHRtcCA+IHBvcyAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHRtcCAtIDEpKSkge1xuICAgIG1heCA9IHRtcDtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpLnRyaW0oKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwiLy8gSG9yaXpvbnRhbCBydWxlXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGNudCwgY2gsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAvLyBDaGVjayBociBtYXJrZXJcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBtYXJrZXJzIGNhbiBiZSBtaXhlZCB3aXRoIHNwYWNlcywgYnV0IHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCAzIG9mIHRoZW1cblxuICBjbnQgPSAxO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKGNoICE9PSBtYXJrZXIgJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChjaCA9PT0gbWFya2VyKSB7IGNudCsrOyB9XG4gIH1cblxuICBpZiAoY250IDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaHInLCAnaHInLCAwKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4ubWFya3VwID0gQXJyYXkoY250ICsgMSkuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5qcyIsIi8vIEhUTUwgYmxvY2tcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBibG9ja19uYW1lcyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX2Jsb2NrcycpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cbi8vIEFuIGFycmF5IG9mIG9wZW5pbmcgYW5kIGNvcnJlc3BvbmRpbmcgY2xvc2luZyBzZXF1ZW5jZXMgZm9yIGh0bWwgdGFncyxcbi8vIGxhc3QgYXJndW1lbnQgZGVmaW5lcyB3aGV0aGVyIGl0IGNhbiB0ZXJtaW5hdGUgYSBwYXJhZ3JhcGggb3Igbm90XG4vL1xudmFyIEhUTUxfU0VRVUVOQ0VTID0gW1xuICBbIC9ePChzY3JpcHR8cHJlfHN0eWxlKSg/PShcXHN8PnwkKSkvaSwgLzxcXC8oc2NyaXB0fHByZXxzdHlsZSk+L2ksIHRydWUgXSxcbiAgWyAvXjwhLS0vLCAgICAgICAgLy0tPi8sICAgdHJ1ZSBdLFxuICBbIC9ePFxcPy8sICAgICAgICAgL1xcPz4vLCAgIHRydWUgXSxcbiAgWyAvXjwhW0EtWl0vLCAgICAgLz4vLCAgICAgdHJ1ZSBdLFxuICBbIC9ePCFcXFtDREFUQVxcWy8sIC9cXF1cXF0+LywgdHJ1ZSBdLFxuICBbIG5ldyBSZWdFeHAoJ148Lz8oJyArIGJsb2NrX25hbWVzLmpvaW4oJ3wnKSArICcpKD89KFxcXFxzfC8/PnwkKSknLCAnaScpLCAvXiQvLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cChIVE1MX09QRU5fQ0xPU0VfVEFHX1JFLnNvdXJjZSArICdcXFxccyokJyksICAvXiQvLCBmYWxzZSBdXG5dO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9ibG9jayhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGksIG5leHRMaW5lLCB0b2tlbiwgbGluZVRleHQsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBmb3IgKGkgPSAwOyBpIDwgSFRNTF9TRVFVRU5DRVMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoSFRNTF9TRVFVRU5DRVNbaV1bMF0udGVzdChsaW5lVGV4dCkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmIChpID09PSBIVE1MX1NFUVVFTkNFUy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkge1xuICAgIC8vIHRydWUgaWYgdGhpcyBzZXF1ZW5jZSBjYW4gYmUgYSB0ZXJtaW5hdG9yLCBmYWxzZSBvdGhlcndpc2VcbiAgICByZXR1cm4gSFRNTF9TRVFVRU5DRVNbaV1bMl07XG4gIH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gSWYgd2UgYXJlIGhlcmUgLSB3ZSBkZXRlY3RlZCBIVE1MIGJsb2NrLlxuICAvLyBMZXQncyByb2xsIGRvd24gdGlsbCBibG9jayBlbmQuXG4gIGlmICghSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG4gICAgICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoICE9PSAwKSB7IG5leHRMaW5lKys7IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2Jsb2NrJywgJycsIDApO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIG5leHRMaW5lIF07XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwiLy8gbGhlYWRpbmcgKC0tLSwgPT09KVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBwb3MsIG1heCwgbGV2ZWwsIG1hcmtlcixcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSwgb2xkUGFyZW50VHlwZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnOyAvLyB1c2UgcGFyYWdyYXBoIHRvIG1hdGNoIHRlcm1pbmF0b3JSdWxlc1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvL1xuICAgIC8vIENoZWNrIGZvciB1bmRlcmxpbmUgaW4gc2V0ZXh0IGhlYWRlclxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAobWFya2VyID09PSAweDJELyogLSAqLyB8fCBtYXJrZXIgPT09IDB4M0QvKiA9ICovKSB7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICAgICAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgICAgICAgbGV2ZWwgPSAobWFya2VyID09PSAweDNELyogPSAqLyA/IDEgOiAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmICghbGV2ZWwpIHtcbiAgICAvLyBEaWRuJ3QgZmluZCB2YWxpZCB1bmRlcmxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIC0gMSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzIiwiLy8gTGlzdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuLy8gU2VhcmNoIGBbLSsqXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYXJ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBtYXJrZXIsIHBvcywgbWF4LCBjaDtcblxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIC8vIENoZWNrIGJ1bGxldFxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJCLyogKyAqLykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAtdGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbi8vIFNlYXJjaCBgXFxkK1suKV1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFydGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgcG9zID0gc3RhcnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIGNoYXJzIChkaWdpdCArIGRvdClcbiAgaWYgKHBvcyArIDEgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIGlmIChjaCA8IDB4MzAvKiAwICovIHx8IGNoID4gMHgzOS8qIDkgKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgZm9yICg7Oykge1xuICAgIC8vIEVPTCAtPiBmYWlsXG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmIChjaCA+PSAweDMwLyogMCAqLyAmJiBjaCA8PSAweDM5LyogOSAqLykge1xuXG4gICAgICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBubyBtb3JlIHRoYW4gOSBkaWdpdHNcbiAgICAgIC8vIChwcmV2ZW50cyBpbnRlZ2VyIG92ZXJmbG93IGluIGJyb3dzZXJzKVxuICAgICAgaWYgKHBvcyAtIHN0YXJ0ID49IDEwKSB7IHJldHVybiAtMTsgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmb3VuZCB2YWxpZCBtYXJrZXJcbiAgICBpZiAoY2ggPT09IDB4MjkvKiApICovIHx8IGNoID09PSAweDJlLyogLiAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgMS50ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICB2YXIgaSwgbCxcbiAgICAgIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xuXG4gIGZvciAoaSA9IGlkeCArIDIsIGwgPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbaSArIDJdLmhpZGRlbiA9IHRydWU7XG4gICAgICBzdGF0ZS50b2tlbnNbaV0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGkgKz0gMjtcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgIGksXG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRBZnRlck1hcmtlcixcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc09yZGVyZWQsXG4gICAgICBpdGVtTGluZXMsXG4gICAgICBsLFxuICAgICAgbGlzdExpbmVzLFxuICAgICAgbGlzdFRva0lkeCxcbiAgICAgIG1hcmtlckNoYXJDb2RlLFxuICAgICAgbWFya2VyVmFsdWUsXG4gICAgICBtYXgsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZExJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgb2xkVGlnaHQsXG4gICAgICBwb3MsXG4gICAgICBwb3NBZnRlck1hcmtlcixcbiAgICAgIHByZXZFbXB0eUVuZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gZmFsc2UsXG4gICAgICB0aWdodCA9IHRydWU7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc3Vic3RyKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIHN0YXJ0IC0gMSkpO1xuXG4gICAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgb3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gICAgLy8gYSBwYXJhZ3JhcGgsIGl0IHNob3VsZCBzdGFydCB3aXRoIDEuXG4gICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXG4gIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcblxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X29wZW4nLCAnb2wnLCAxKTtcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X29wZW4nLCAndWwnLCAxKTtcbiAgfVxuXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgY29udGVudFN0YXJ0ID0gcG9zO1xuXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXgpIHtcbiAgICAgIC8vIHRyaW1taW5nIHNwYWNlIGluIFwiLSAgICBcXG4gIDNcIiBjYXNlLCBpbmRlbnQgaXMgMSBoZXJlXG4gICAgICBpbmRlbnRBZnRlck1hcmtlciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gb2Zmc2V0IC0gaW5pdGlhbDtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiA0IHNwYWNlcywgdGhlIGluZGVudCBpcyAxXG4gICAgLy8gKHRoZSByZXN0IGlzIGp1c3QgaW5kZW50ZWQgY29kZSBibG9jaylcbiAgICBpZiAoaW5kZW50QWZ0ZXJNYXJrZXIgPiA0KSB7IGluZGVudEFmdGVyTWFya2VyID0gMTsgfVxuXG4gICAgLy8gXCIgIC0gIHRlc3RcIlxuICAgIC8vICBeXl5eXiAtIGNhbGN1bGF0aW5nIHRvdGFsIGxlbmd0aCBvZiB0aGlzIHRoaW5nXG4gICAgaW5kZW50ID0gaW5pdGlhbCArIGluZGVudEFmdGVyTWFya2VyO1xuXG4gICAgLy8gUnVuIHN1YnBhcnNlciAmIHdyaXRlIHRva2Vuc1xuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9vcGVuJywgJ2xpJywgMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG4gICAgdG9rZW4ubWFwICAgID0gaXRlbUxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICAgIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgICBvbGRUaWdodCA9IHN0YXRlLnRpZ2h0O1xuICAgIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG9sZExJbmRlbnQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBpbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQ7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCAmJiBzdGF0ZS5pc0VtcHR5KHN0YXJ0TGluZSArIDEpKSB7XG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciB0aGlzIGNhc2VcbiAgICAgIC8vIChsaXN0IGl0ZW0gaXMgZW1wdHksIGxpc3QgdGVybWluYXRlcyBiZWZvcmUgXCJmb29cIik6XG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgLy8gICAtXG4gICAgICAvL1xuICAgICAgLy8gICAgIGZvb1xuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIHN0YXRlLmxpbmUgPSBNYXRoLm1pbihzdGF0ZS5saW5lICsgMiwgZW5kTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICB0aWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBJdGVtIGJlY29tZSBsb29zZSBpZiBmaW5pc2ggd2l0aCBlbXB0eSBsaW5lLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGQgZmlsdGVyIGxhc3QgZWxlbWVudCwgYmVjYXVzZSBpdCBtZWFucyBsaXN0IGZpbmlzaFxuICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gc3RhcnRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBvbGRUU2hpZnQ7XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvbGRMSW5kZW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fY2xvc2UnLCAnbGknLCAtMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgaXRlbUxpbmVzWzFdID0gbmV4dExpbmU7XG4gICAgY29udGVudFN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy9cbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIHRlcm1pbmF0aW5nIGJsb2NrIGZvdW5kXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiBsaXN0IGhhcyBhbm90aGVyIHR5cGVcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlckNoYXJDb2RlICE9PSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpKSB7IGJyZWFrOyB9XG4gIH1cblxuICAvLyBGaW5pbGl6ZSBsaXN0XG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9jbG9zZScsICdvbCcsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X2Nsb3NlJywgJ3VsJywgLTEpO1xuICB9XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIGxpc3RMaW5lc1sxXSA9IG5leHRMaW5lO1xuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgLy8gbWFyayBwYXJhZ3JhcGhzIHRpZ2h0IGlmIG5lZWRlZFxuICBpZiAodGlnaHQpIHtcbiAgICBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBsaXN0VG9rSWR4KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzIiwiLy8gUGFyYWdyYXBoXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmFncmFwaChzdGF0ZSwgc3RhcnRMaW5lLyosIGVuZExpbmUqLykge1xuICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgb2xkUGFyZW50VHlwZSxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKSxcbiAgICAgIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3BhcmFncmFwaCc7XG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgncGFyYWdyYXBoX29wZW4nLCAncCcsIDEpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgncGFyYWdyYXBoX2Nsb3NlJywgJ3AnLCAtMSk7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVmZXJlbmNlKHN0YXRlLCBzdGFydExpbmUsIF9lbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgZGVzdEVuZFBvcyxcbiAgICAgIGRlc3RFbmRMaW5lTm8sXG4gICAgICBlbmRMaW5lLFxuICAgICAgaHJlZixcbiAgICAgIGksXG4gICAgICBsLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICByZXMsXG4gICAgICBzdGFydCxcbiAgICAgIHN0cixcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW1wbGUgY2hlY2sgdG8gcXVpY2tseSBpbnRlcnJ1cHQgc2NhbiBvbiBbbGlua10odXJsKSBhdCB0aGUgc3RhcnQgb2YgbGluZS5cbiAgLy8gQ2FuIGJlIHVzZWZ1bCBvbiBwcmFjdGljZTogaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2lzc3Vlcy81NFxuICB3aGlsZSAoKytwb3MgPCBtYXgpIHtcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1RCAvKiBdICovICYmXG4gICAgICAgIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyAtIDEpICE9PSAweDVDLyogXFwgKi8pIHtcbiAgICAgIGlmIChwb3MgKyAxID09PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncmVmZXJlbmNlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncmVmZXJlbmNlJztcblxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIHN0ciA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcbiAgbWF4ID0gc3RyLmxlbmd0aDtcblxuICBmb3IgKHBvcyA9IDE7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxhYmVsRW5kID0gcG9zO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgwQSAvKiBcXG4gKi8pIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLykge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZXMrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobGFiZWxFbmQgPCAwIHx8IHN0ci5jaGFyQ29kZUF0KGxhYmVsRW5kICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgXl5eIHNraXAgb3B0aW9uYWwgd2hpdGVzcGFjZSBoZXJlXG4gIGZvciAocG9zID0gbGFiZWxFbmQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICBeXl5eXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCk7XG4gIGlmICghcmVzLm9rKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSByZXMucG9zO1xuICBsaW5lcyArPSByZXMubGluZXM7XG5cbiAgLy8gc2F2ZSBjdXJzb3Igc3RhdGUsIHdlIGNvdWxkIHJlcXVpcmUgdG8gcm9sbGJhY2sgbGF0ZXJcbiAgZGVzdEVuZFBvcyA9IHBvcztcbiAgZGVzdEVuZExpbmVObyA9IGxpbmVzO1xuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBeXl4gc2tpcHBpbmcgdGhvc2Ugc3BhY2VzXG4gIHN0YXJ0ID0gcG9zO1xuICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICBwb3MgPSByZXMucG9zO1xuICAgIGxpbmVzICs9IHJlcy5saW5lcztcbiAgfSBlbHNlIHtcbiAgICB0aXRsZSA9ICcnO1xuICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICB9XG5cbiAgLy8gc2tpcCB0cmFpbGluZyBzcGFjZXMgdW50aWwgdGhlIHJlc3Qgb2YgdGhlIGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSBhZnRlciB0aXRsZSxcbiAgICAgIC8vIGJ1dCBpdCBjb3VsZCBzdGlsbCBiZSBhIHZhbGlkIHJlZmVyZW5jZSBpZiB3ZSByb2xsIGJhY2tcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2Uoc3RyLnNsaWNlKDEsIGxhYmVsRW5kKSk7XG4gIGlmICghbGFiZWwpIHtcbiAgICAvLyBDb21tb25NYXJrIDAuMjAgZGlzYWxsb3dzIGVtcHR5IGxhYmVsc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFJlZmVyZW5jZSBjYW4gbm90IHRlcm1pbmF0ZSBhbnl0aGluZy4gVGhpcyBjaGVjayBpcyBmb3Igc2FmZXR5IG9ubHkuXG4gIC8qaXN0YW5idWwgaWdub3JlIGlmKi9cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXMgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPSB7IHRpdGxlOiB0aXRsZSwgaHJlZjogaHJlZiB9O1xuICB9XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIGxpbmVzICsgMTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5qcyIsIi8vIFBhcnNlciBzdGF0ZSBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gU3RhdGVCbG9jayhzcmMsIG1kLCBlbnYsIHRva2Vucykge1xuICB2YXIgY2gsIHMsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBvZmZzZXQsIGluZGVudF9mb3VuZDtcblxuICB0aGlzLnNyYyA9IHNyYztcblxuICAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxuICB0aGlzLm1kICAgICA9IG1kO1xuXG4gIHRoaXMuZW52ID0gZW52O1xuXG4gIC8vXG4gIC8vIEludGVybmFsIHN0YXRlIHZhcnRpYWJsZXNcbiAgLy9cblxuICB0aGlzLnRva2VucyA9IHRva2VucztcblxuICB0aGlzLmJNYXJrcyA9IFtdOyAgLy8gbGluZSBiZWdpbiBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMuZU1hcmtzID0gW107ICAvLyBsaW5lIGVuZCBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMudFNoaWZ0ID0gW107ICAvLyBvZmZzZXRzIG9mIHRoZSBmaXJzdCBub24tc3BhY2UgY2hhcmFjdGVycyAodGFicyBub3QgZXhwYW5kZWQpXG4gIHRoaXMuc0NvdW50ID0gW107ICAvLyBpbmRlbnRzIGZvciBlYWNoIGxpbmUgKHRhYnMgZXhwYW5kZWQpXG5cbiAgLy8gQW4gYW1vdW50IG9mIHZpcnR1YWwgc3BhY2VzICh0YWJzIGV4cGFuZGVkKSBiZXR3ZWVuIGJlZ2lubmluZ1xuICAvLyBvZiBlYWNoIGxpbmUgKGJNYXJrcykgYW5kIHJlYWwgYmVnaW5uaW5nIG9mIHRoYXQgbGluZS5cbiAgLy9cbiAgLy8gSXQgZXhpc3RzIG9ubHkgYXMgYSBoYWNrIGJlY2F1c2UgYmxvY2txdW90ZXMgb3ZlcnJpZGUgYk1hcmtzXG4gIC8vIGxvc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgcHJvY2Vzcy5cbiAgLy9cbiAgLy8gSXQncyB1c2VkIG9ubHkgd2hlbiBleHBhbmRpbmcgdGFicywgeW91IGNhbiB0aGluayBhYm91dCBpdCBhc1xuICAvLyBhbiBpbml0aWFsIHRhYiBsZW5ndGgsIGUuZy4gYnNDb3VudD0yMSBhcHBsaWVkIHRvIHN0cmluZyBgXFx0MTIzYFxuICAvLyBtZWFucyBmaXJzdCB0YWIgc2hvdWxkIGJlIGV4cGFuZGVkIHRvIDQtMjElNCA9PT0gMyBzcGFjZXMuXG4gIC8vXG4gIHRoaXMuYnNDb3VudCA9IFtdO1xuXG4gIC8vIGJsb2NrIHBhcnNlciB2YXJpYWJsZXNcbiAgdGhpcy5ibGtJbmRlbnQgID0gMDsgLy8gcmVxdWlyZWQgYmxvY2sgY29udGVudCBpbmRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gKGZvciBleGFtcGxlLCBpZiB3ZSBhcmUgaW4gbGlzdClcbiAgdGhpcy5saW5lICAgICAgID0gMDsgLy8gbGluZSBpbmRleCBpbiBzcmNcbiAgdGhpcy5saW5lTWF4ICAgID0gMDsgLy8gbGluZXMgY291bnRcbiAgdGhpcy50aWdodCAgICAgID0gZmFsc2U7ICAvLyBsb29zZS90aWdodCBtb2RlIGZvciBsaXN0c1xuICB0aGlzLmRkSW5kZW50ICAgPSAtMTsgLy8gaW5kZW50IG9mIHRoZSBjdXJyZW50IGRkIGJsb2NrICgtMSBpZiB0aGVyZSBpc24ndCBhbnkpXG5cbiAgLy8gY2FuIGJlICdibG9ja3F1b3RlJywgJ2xpc3QnLCAncm9vdCcsICdwYXJhZ3JhcGgnIG9yICdyZWZlcmVuY2UnXG4gIC8vIHVzZWQgaW4gbGlzdHMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgaW50ZXJydXB0IGEgcGFyYWdyYXBoXG4gIHRoaXMucGFyZW50VHlwZSA9ICdyb290JztcblxuICB0aGlzLmxldmVsID0gMDtcblxuICAvLyByZW5kZXJlclxuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIC8vIENyZWF0ZSBjYWNoZXNcbiAgLy8gR2VuZXJhdGUgbWFya2Vycy5cbiAgcyA9IHRoaXMuc3JjO1xuICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcblxuICBmb3IgKHN0YXJ0ID0gcG9zID0gaW5kZW50ID0gb2Zmc2V0ID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgcG9zKyspIHtcbiAgICBjaCA9IHMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpbmRlbnRfZm91bmQpIHtcbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpbmRlbnQrKztcblxuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNCAtIG9mZnNldCAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlbnRfZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSB8fCBwb3MgPT09IGxlbiAtIDEpIHtcbiAgICAgIGlmIChjaCAhPT0gMHgwQSkgeyBwb3MrKzsgfVxuICAgICAgdGhpcy5iTWFya3MucHVzaChzdGFydCk7XG4gICAgICB0aGlzLmVNYXJrcy5wdXNoKHBvcyk7XG4gICAgICB0aGlzLnRTaGlmdC5wdXNoKGluZGVudCk7XG4gICAgICB0aGlzLnNDb3VudC5wdXNoKG9mZnNldCk7XG4gICAgICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICAgICAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIGZha2UgZW50cnkgdG8gc2ltcGxpZnkgY2FjaGUgYm91bmRzIGNoZWNrc1xuICB0aGlzLmJNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy5lTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMudFNoaWZ0LnB1c2goMCk7XG4gIHRoaXMuc0NvdW50LnB1c2goMCk7XG4gIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gIHRoaXMubGluZU1heCA9IHRoaXMuYk1hcmtzLmxlbmd0aCAtIDE7IC8vIGRvbid0IGNvdW50IGxhc3QgZmFrZSBsaW5lXG59XG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vL1xuU3RhdGVCbG9jay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG4gIHRva2VuLmJsb2NrID0gdHJ1ZTtcblxuICBpZiAobmVzdGluZyA8IDApIHsgdGhpcy5sZXZlbC0tOyB9XG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxuXG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShsaW5lKSB7XG4gIHJldHVybiB0aGlzLmJNYXJrc1tsaW5lXSArIHRoaXMudFNoaWZ0W2xpbmVdID49IHRoaXMuZU1hcmtzW2xpbmVdO1xufTtcblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXMgPSBmdW5jdGlvbiBza2lwRW1wdHlMaW5lcyhmcm9tKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMubGluZU1heDsgZnJvbSA8IG1heDsgZnJvbSsrKSB7XG4gICAgaWYgKHRoaXMuYk1hcmtzW2Zyb21dICsgdGhpcy50U2hpZnRbZnJvbV0gPCB0aGlzLmVNYXJrc1tmcm9tXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tO1xufTtcblxuLy8gU2tpcCBzcGFjZXMgZnJvbSBnaXZlbiBwb3NpdGlvbi5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXMgPSBmdW5jdGlvbiBza2lwU3BhY2VzKHBvcykge1xuICB2YXIgY2g7XG5cbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uIGluIHJldmVyc2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzQmFjayA9IGZ1bmN0aW9uIHNraXBTcGFjZXNCYWNrKHBvcywgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKCFpc1NwYWNlKHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgZnJvbSBnaXZlbiBwb3NpdGlvblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzID0gZnVuY3Rpb24gc2tpcENoYXJzKHBvcywgY29kZSkge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBpZiAodGhpcy5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBjb2RlKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyByZXZlcnNlIGZyb20gZ2l2ZW4gcG9zaXRpb24gLSAxXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnNCYWNrID0gZnVuY3Rpb24gc2tpcENoYXJzQmFjayhwb3MsIGNvZGUsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zOyB9XG5cbiAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgIGlmIChjb2RlICE9PSB0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBjdXQgbGluZXMgcmFuZ2UgZnJvbSBzb3VyY2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5nZXRMaW5lcyA9IGZ1bmN0aW9uIGdldExpbmVzKGJlZ2luLCBlbmQsIGluZGVudCwga2VlcExhc3RMRikge1xuICB2YXIgaSwgbGluZUluZGVudCwgY2gsIGZpcnN0LCBsYXN0LCBxdWV1ZSwgbGluZVN0YXJ0LFxuICAgICAgbGluZSA9IGJlZ2luO1xuXG4gIGlmIChiZWdpbiA+PSBlbmQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBxdWV1ZSA9IG5ldyBBcnJheShlbmQgLSBiZWdpbik7XG5cbiAgZm9yIChpID0gMDsgbGluZSA8IGVuZDsgbGluZSsrLCBpKyspIHtcbiAgICBsaW5lSW5kZW50ID0gMDtcbiAgICBsaW5lU3RhcnQgPSBmaXJzdCA9IHRoaXMuYk1hcmtzW2xpbmVdO1xuXG4gICAgaWYgKGxpbmUgKyAxIDwgZW5kIHx8IGtlZXBMYXN0TEYpIHtcbiAgICAgIC8vIE5vIG5lZWQgZm9yIGJvdW5kcyBjaGVjayBiZWNhdXNlIHdlIGhhdmUgZmFrZSBlbnRyeSBvbiB0YWlsLlxuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdO1xuICAgIH1cblxuICAgIHdoaWxlIChmaXJzdCA8IGxhc3QgJiYgbGluZUluZGVudCA8IGluZGVudCkge1xuICAgICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KGZpcnN0KTtcblxuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIGxpbmVJbmRlbnQgKz0gNCAtIChsaW5lSW5kZW50ICsgdGhpcy5ic0NvdW50W2xpbmVdKSAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0IC0gbGluZVN0YXJ0IDwgdGhpcy50U2hpZnRbbGluZV0pIHtcbiAgICAgICAgLy8gcGF0Y2hlZCB0U2hpZnQgbWFza2VkIGNoYXJhY3RlcnMgdG8gbG9vayBsaWtlIHNwYWNlcyAoYmxvY2txdW90ZXMsIGxpc3QgbWFya2VycylcbiAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0Kys7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVJbmRlbnQgPiBpbmRlbnQpIHtcbiAgICAgIC8vIHBhcnRpYWxseSBleHBhbmRpbmcgdGFicyBpbiBjb2RlIGJsb2NrcywgZS5nICdcXHRcXHRmb29iYXInXG4gICAgICAvLyB3aXRoIGluZGVudD0yIGJlY29tZXMgJyAgXFx0Zm9vYmFyJ1xuICAgICAgcXVldWVbaV0gPSBuZXcgQXJyYXkobGluZUluZGVudCAtIGluZGVudCArIDEpLmpvaW4oJyAnKSArIHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVbaV0gPSB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXVlLmpvaW4oJycpO1xufTtcblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVCbG9jay5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQmxvY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanMiLCIvLyBHRk0gdGFibGUsIG5vbi1zdGFuZGFyZFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBnZXRMaW5lKHN0YXRlLCBsaW5lKSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS5ibGtJbmRlbnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbGluZV07XG5cbiAgcmV0dXJuIHN0YXRlLnNyYy5zdWJzdHIocG9zLCBtYXggLSBwb3MpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkU3BsaXQoc3RyKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHBvcyA9IDAsXG4gICAgICBtYXggPSBzdHIubGVuZ3RoLFxuICAgICAgY2gsXG4gICAgICBlc2NhcGVzID0gMCxcbiAgICAgIGxhc3RQb3MgPSAwLFxuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlLFxuICAgICAgbGFzdEJhY2tUaWNrID0gMDtcblxuICBjaCAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBpZiAoY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgICBpZiAoYmFja1RpY2tlZCkge1xuICAgICAgICAvLyBtYWtlIFxcYCBjbG9zZSBjb2RlIHNlcXVlbmNlLCBidXQgbm90IG9wZW4gaXQ7XG4gICAgICAgIC8vIHRoZSByZWFzb24gaXM6IGBcXGAgaXMgY29ycmVjdCBjb2RlIGJsb2NrXG4gICAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVzICUgMiA9PT0gMCkge1xuICAgICAgICBiYWNrVGlja2VkID0gdHJ1ZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4N2MvKiB8ICovICYmIChlc2NhcGVzICUgMiA9PT0gMCkgJiYgIWJhY2tUaWNrZWQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcywgcG9zKSk7XG4gICAgICBsYXN0UG9zID0gcG9zICsgMTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4NWMvKiBcXCAqLykge1xuICAgICAgZXNjYXBlcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBlc2NhcGVzID0gMDtcbiAgICB9XG5cbiAgICBwb3MrKztcblxuICAgIC8vIElmIHRoZXJlIHdhcyBhbiB1bi1jbG9zZWQgYmFja3RpY2ssIGdvIGJhY2sgdG8ganVzdCBhZnRlclxuICAgIC8vIHRoZSBsYXN0IGJhY2t0aWNrLCBidXQgYXMgaWYgaXQgd2FzIGEgbm9ybWFsIGNoYXJhY3RlclxuICAgIGlmIChwb3MgPT09IG1heCAmJiBiYWNrVGlja2VkKSB7XG4gICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICBwb3MgPSBsYXN0QmFja1RpY2sgKyAxO1xuICAgIH1cblxuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgfVxuXG4gIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcykpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0YWJsZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsaW5lVGV4dCwgcG9zLCBpLCBuZXh0TGluZSwgY29sdW1ucywgY29sdW1uQ291bnQsIHRva2VuLFxuICAgICAgYWxpZ25zLCB0LCB0YWJsZUxpbmVzLCB0Ym9keUxpbmVzO1xuXG4gIC8vIHNob3VsZCBoYXZlIGF0IGxlYXN0IHR3byBsaW5lc1xuICBpZiAoc3RhcnRMaW5lICsgMiA+IGVuZExpbmUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzZWNvbmQgbGluZSBzaG91bGQgYmUgJ3wnLCAnLScsICc6JyxcbiAgLy8gYW5kIG5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQgYnV0IHNwYWNlcztcbiAgLy8gYmFzaWNhbGx5LCB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIC9eWy06fF1bLTp8XFxzXSokLyByZWdleHBcblxuICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgaWYgKHBvcyA+PSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8gJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSArIDEpO1xuXG4gIGNvbHVtbnMgPSBsaW5lVGV4dC5zcGxpdCgnfCcpO1xuICBhbGlnbnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0ID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgaWYgKCF0KSB7XG4gICAgICAvLyBhbGxvdyBlbXB0eSBjb2x1bW5zIGJlZm9yZSBhbmQgYWZ0ZXIgdGFibGUsIGJ1dCBub3QgaW4gYmV0d2VlbiBjb2x1bW5zO1xuICAgICAgLy8gZS5nLiBhbGxvdyBgIHwtLS18IGAsIGRpc2FsbG93IGAgLS0tfHwtLS0gYFxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gY29sdW1ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAxKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8gPyAnY2VudGVyJyA6ICdyaWdodCcpO1xuICAgIH0gZWxzZSBpZiAodC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2goJ2xlZnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ25zLnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lKS50cmltKCk7XG4gIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAvLyBoZWFkZXIgcm93IHdpbGwgZGVmaW5lIGFuIGFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBlbnRpcmUgdGFibGUsXG4gIC8vIGFuZCBhbGlnbiByb3cgc2hvdWxkbid0IGJlIHNtYWxsZXIgdGhhbiB0aGF0ICh0aGUgcmVzdCBvZiB0aGUgcm93cyBjYW4pXG4gIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gIGlmIChjb2x1bW5Db3VudCA+IGFsaWducy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RhYmxlX29wZW4nLCAndGFibGUnLCAxKTtcbiAgdG9rZW4ubWFwID0gdGFibGVMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfb3BlbicsICd0aGVhZCcsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfb3BlbicsICd0aCcsIDEpO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcbiAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICB0b2tlbi5hdHRycyAgPSBbIFsgJ3N0eWxlJywgJ3RleHQtYWxpZ246JyArIGFsaWduc1tpXSBdIF07XG4gICAgfVxuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCAgPSBjb2x1bW5zW2ldLnRyaW0oKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfY2xvc2UnLCAndGgnLCAtMSk7XG4gIH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfY2xvc2UnLCAndGhlYWQnLCAtMSk7XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGJvZHlfb3BlbicsICd0Ym9keScsIDEpO1xuICB0b2tlbi5tYXAgPSB0Ym9keUxpbmVzID0gWyBzdGFydExpbmUgKyAyLCAwIF07XG5cbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDI7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIG5leHRMaW5lKS50cmltKCk7XG4gICAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ3wnKSA9PT0gLTEpIHsgYnJlYWs7IH1cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrOyB9XG4gICAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAgIHRva2VuID0gc3RhdGUucHVzaCgndHJfb3BlbicsICd0cicsIDEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX29wZW4nLCAndGQnLCAxKTtcbiAgICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgICAgfVxuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXSA/IGNvbHVtbnNbaV0udHJpbSgpIDogJyc7XG4gICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX2Nsb3NlJywgJ3RkJywgLTEpO1xuICAgIH1cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX2Nsb3NlJywgJ3RyJywgLTEpO1xuICB9XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGJvZHlfY2xvc2UnLCAndGJvZHknLCAtMSk7XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGFibGVfY2xvc2UnLCAndGFibGUnLCAtMSk7XG5cbiAgdGFibGVMaW5lc1sxXSA9IHRib2R5TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svdGFibGUuanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9jayhzdGF0ZSkge1xuICB2YXIgdG9rZW47XG5cbiAgaWYgKHN0YXRlLmlubGluZU1vZGUpIHtcbiAgICB0b2tlbiAgICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyAwLCAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubWQuYmxvY2sucGFyc2Uoc3RhdGUuc3JjLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5saW5lKHN0YXRlKSB7XG4gIHZhciB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsIHRvaywgaSwgbDtcblxuICAvLyBQYXJzZSBpbmxpbmVzXG4gIGZvciAoaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdG9rID0gdG9rZW5zW2ldO1xuICAgIGlmICh0b2sudHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHN0YXRlLm1kLmlubGluZS5wYXJzZSh0b2suY29udGVudCwgc3RhdGUubWQsIHN0YXRlLmVudiwgdG9rLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCIvLyBSZXBsYWNlIGxpbmstbGlrZSB0ZXh0cyB3aXRoIGxpbmsgbm9kZXMuXG4vL1xuLy8gQ3VycmVudGx5IHJlc3RyaWN0ZWQgYnkgYG1kLnZhbGlkYXRlTGluaygpYCB0byBodHRwL2h0dHBzL2Z0cFxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXJyYXlSZXBsYWNlQXQgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5hcnJheVJlcGxhY2VBdDtcblxuXG5mdW5jdGlvbiBpc0xpbmtPcGVuKHN0cikge1xuICByZXR1cm4gL148YVs+XFxzXS9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzTGlua0Nsb3NlKHN0cikge1xuICByZXR1cm4gL148XFwvYVxccyo+L2kudGVzdChzdHIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua2lmeShzdGF0ZSkge1xuICB2YXIgaSwgaiwgbCwgdG9rZW5zLCB0b2tlbiwgY3VycmVudFRva2VuLCBub2RlcywgbG4sIHRleHQsIHBvcywgbGFzdFBvcyxcbiAgICAgIGxldmVsLCBodG1sTGlua0xldmVsLCB1cmwsIGZ1bGxVcmwsIHVybFRleHQsXG4gICAgICBibG9ja1Rva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIGxpbmtzO1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5saW5raWZ5KSB7IHJldHVybjsgfVxuXG4gIGZvciAoaiA9IDAsIGwgPSBibG9ja1Rva2Vucy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIXN0YXRlLm1kLmxpbmtpZnkucHJldGVzdChibG9ja1Rva2Vuc1tqXS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdG9rZW5zID0gYmxvY2tUb2tlbnNbal0uY2hpbGRyZW47XG5cbiAgICBodG1sTGlua0xldmVsID0gMDtcblxuICAgIC8vIFdlIHNjYW4gZnJvbSB0aGUgZW5kLCB0byBrZWVwIHBvc2l0aW9uIHdoZW4gbmV3IHRhZ3MgYWRkZWQuXG4gICAgLy8gVXNlIHJldmVyc2VkIGxvZ2ljIGluIGxpbmtzIHN0YXJ0L2VuZCBtYXRjaFxuICAgIGZvciAoaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY3VycmVudFRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgbWFya2Rvd24gbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgd2hpbGUgKHRva2Vuc1tpXS5sZXZlbCAhPT0gY3VycmVudFRva2VuLmxldmVsICYmIHRva2Vuc1tpXS50eXBlICE9PSAnbGlua19vcGVuJykge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBjb250ZW50IG9mIGh0bWwgdGFnIGxpbmtzXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICdodG1sX2lubGluZScpIHtcbiAgICAgICAgaWYgKGlzTGlua09wZW4oY3VycmVudFRva2VuLmNvbnRlbnQpICYmIGh0bWxMaW5rTGV2ZWwgPiAwKSB7XG4gICAgICAgICAgaHRtbExpbmtMZXZlbC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpbmtDbG9zZShjdXJyZW50VG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChodG1sTGlua0xldmVsID4gMCkgeyBjb250aW51ZTsgfVxuXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBzdGF0ZS5tZC5saW5raWZ5LnRlc3QoY3VycmVudFRva2VuLmNvbnRlbnQpKSB7XG5cbiAgICAgICAgdGV4dCA9IGN1cnJlbnRUb2tlbi5jb250ZW50O1xuICAgICAgICBsaW5rcyA9IHN0YXRlLm1kLmxpbmtpZnkubWF0Y2godGV4dCk7XG5cbiAgICAgICAgLy8gTm93IHNwbGl0IHN0cmluZyB0byBub2Rlc1xuICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICBsZXZlbCA9IGN1cnJlbnRUb2tlbi5sZXZlbDtcbiAgICAgICAgbGFzdFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsbiA9IDA7IGxuIDwgbGlua3MubGVuZ3RoOyBsbisrKSB7XG5cbiAgICAgICAgICB1cmwgPSBsaW5rc1tsbl0udXJsO1xuICAgICAgICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIHVybFRleHQgPSBsaW5rc1tsbl0udGV4dDtcblxuICAgICAgICAgIC8vIExpbmtpZmllciBtaWdodCBzZW5kIHJhdyBob3N0bmFtZXMgbGlrZSBcImV4YW1wbGUuY29tXCIsIHdoZXJlIHVybFxuICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoIGRvbWFpbiBuYW1lLiBTbyB3ZSBwcmVwZW5kIGh0dHA6Ly8gaW4gdGhvc2UgY2FzZXMsXG4gICAgICAgICAgLy8gYW5kIHJlbW92ZSBpdCBhZnRlcndhcmRzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKCFsaW5rc1tsbl0uc2NoZW1hKSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoJ2h0dHA6Ly8nICsgdXJsVGV4dCkucmVwbGFjZSgvXmh0dHA6XFwvXFwvLywgJycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlua3NbbG5dLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KHVybFRleHQpKSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoJ21haWx0bzonICsgdXJsVGV4dCkucmVwbGFjZSgvXm1haWx0bzovLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmxUZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3MgPSBsaW5rc1tsbl0uaW5kZXg7XG5cbiAgICAgICAgICBpZiAocG9zID4gbGFzdFBvcykge1xuICAgICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MsIHBvcyk7XG4gICAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgICAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWwrKztcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgID0gJ2xpbmtpZnknO1xuICAgICAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB1cmxUZXh0O1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gLS1sZXZlbDtcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgID0gJ2xpbmtpZnknO1xuICAgICAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICBsYXN0UG9zID0gbGlua3NbbG5dLmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFBvcyA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dC5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNlIGN1cnJlbnQgbm9kZVxuICAgICAgICBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbiA9IHRva2VucyA9IGFycmF5UmVwbGFjZUF0KHRva2VucywgaSwgbm9kZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMiLCIvLyBOb3JtYWxpemUgaW5wdXQgc3RyaW5nXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgTkVXTElORVNfUkUgID0gL1xccltcXG5cXHUwMDg1XT98W1xcdTI0MjRcXHUyMDI4XFx1MDA4NV0vZztcbnZhciBOVUxMX1JFICAgICAgPSAvXFx1MDAwMC9nO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5saW5lKHN0YXRlKSB7XG4gIHZhciBzdHI7XG5cbiAgLy8gTm9ybWFsaXplIG5ld2xpbmVzXG4gIHN0ciA9IHN0YXRlLnNyYy5yZXBsYWNlKE5FV0xJTkVTX1JFLCAnXFxuJyk7XG5cbiAgLy8gUmVwbGFjZSBOVUxMIGNoYXJhY3RlcnNcbiAgc3RyID0gc3RyLnJlcGxhY2UoTlVMTF9SRSwgJ1xcdUZGRkQnKTtcblxuICBzdGF0ZS5zcmMgPSBzdHI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwiLy8gU2ltcGxlIHR5cG9ncmFwaHljIHJlcGxhY2VtZW50c1xuLy9cbi8vIChjKSAoQykg4oaSIMKpXG4vLyAodG0pIChUTSkg4oaSIOKEolxuLy8gKHIpIChSKSDihpIgwq5cbi8vICstIOKGkiDCsVxuLy8gKHApIChQKSAtPiDCp1xuLy8gLi4uIOKGkiDigKYgKGFsc28gPy4uLi4g4oaSID8uLiwgIS4uLi4g4oaSICEuLilcbi8vID8/Pz8/Pz8/IOKGkiA/Pz8sICEhISEhIOKGkiAhISEsIGAsLGAg4oaSIGAsYFxuLy8gLS0g4oaSICZuZGFzaDssIC0tLSDihpIgJm1kYXNoO1xuLy9cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzpcbi8vIC0gZnJhY3Rpb25hbHMgMS8yLCAxLzQsIDMvNCAtPiDCvSwgwrwsIMK+XG4vLyAtIG1pbHRpcGxpY2F0aW9uIDIgeCA0IC0+IDIgw5cgNFxuXG52YXIgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS87XG5cbi8vIFdvcmthcm91bmQgZm9yIHBoYW50b21qcyAtIG5lZWQgcmVnZXggd2l0aG91dCAvZyBmbGFnLFxuLy8gb3Igcm9vdCBjaGVjayB3aWxsIGZhaWwgZXZlcnkgc2Vjb25kIHRpbWVcbnZhciBTQ09QRURfQUJCUl9URVNUX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaTtcblxudmFyIFNDT1BFRF9BQkJSX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaWc7XG52YXIgU0NPUEVEX0FCQlIgPSB7XG4gIGM6ICfCqScsXG4gIHI6ICfCricsXG4gIHA6ICfCpycsXG4gIHRtOiAn4oSiJ1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBuYW1lKSB7XG4gIHJldHVybiBTQ09QRURfQUJCUltuYW1lLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlX3Njb3BlZChpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudC5yZXBsYWNlKFNDT1BFRF9BQkJSX1JFLCByZXBsYWNlRm4pO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9yYXJlKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIGlmIChSQVJFX1JFLnRlc3QodG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy0vZywgJ8KxJylcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4sIC4uLiwgLi4uLi4uLiAtPiDigKZcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0ID8uLi4uLiAmICEuLi4uLiAtPiA/Li4gJiAhLi5cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcLnsyLH0vZywgJ+KApicpLnJlcGxhY2UoLyhbPyFdKeKApi9nLCAnJDEuLicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oWz8hXSl7NCx9L2csICckMSQxJDEnKS5yZXBsYWNlKC8sezIsfS9nLCAnLCcpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLV0pLS0tKFteLV18JCkvbWcsICckMVxcdTIwMTQkMicpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFxccyktLShcXHN8JCkvbWcsICckMVxcdTIwMTMkMicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1cXHNdKS0tKFteLVxcc118JCkvbWcsICckMVxcdTIwMTMkMicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWU7IH1cblxuICAgIGlmIChTQ09QRURfQUJCUl9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2Vfc2NvcGVkKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpZiAoUkFSRV9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICByZXBsYWNlX3JhcmUoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwiLy8gQ29udmVydCBzdHJhaWdodCBxdW90YXRpb24gbWFya3MgdG8gdHlwb2dyYXBoaWMgb25lc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xuXG52YXIgUVVPVEVfVEVTVF9SRSA9IC9bJ1wiXS87XG52YXIgUVVPVEVfUkUgPSAvWydcIl0vZztcbnZhciBBUE9TVFJPUEhFID0gJ1xcdTIwMTknOyAvKiDigJkgKi9cblxuXG5mdW5jdGlvbiByZXBsYWNlQXQoc3RyLCBpbmRleCwgY2gpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaW5kZXgpICsgY2ggKyBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NfaW5saW5lcyh0b2tlbnMsIHN0YXRlKSB7XG4gIHZhciBpLCB0b2tlbiwgdGV4dCwgdCwgcG9zLCBtYXgsIHRoaXNMZXZlbCwgaXRlbSwgbGFzdENoYXIsIG5leHRDaGFyLFxuICAgICAgaXNMYXN0UHVuY3RDaGFyLCBpc05leHRQdW5jdENoYXIsIGlzTGFzdFdoaXRlU3BhY2UsIGlzTmV4dFdoaXRlU3BhY2UsXG4gICAgICBjYW5PcGVuLCBjYW5DbG9zZSwgaiwgaXNTaW5nbGUsIHN0YWNrLCBvcGVuUXVvdGUsIGNsb3NlUXVvdGU7XG5cbiAgc3RhY2sgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICB0aGlzTGV2ZWwgPSB0b2tlbnNbaV0ubGV2ZWw7XG5cbiAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDw9IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgIH1cbiAgICBzdGFjay5sZW5ndGggPSBqICsgMTtcblxuICAgIGlmICh0b2tlbi50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgIHBvcyA9IDA7XG4gICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAvKmVzbGludCBuby1sYWJlbHM6MCxibG9jay1zY29wZWQtdmFyOjAqL1xuICAgIE9VVEVSOlxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIFFVT1RFX1JFLmxhc3RJbmRleCA9IHBvcztcbiAgICAgIHQgPSBRVU9URV9SRS5leGVjKHRleHQpO1xuICAgICAgaWYgKCF0KSB7IGJyZWFrOyB9XG5cbiAgICAgIGNhbk9wZW4gPSBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBwb3MgPSB0LmluZGV4ICsgMTtcbiAgICAgIGlzU2luZ2xlID0gKHRbMF0gPT09IFwiJ1wiKTtcblxuICAgICAgLy8gRmluZCBwcmV2aW91cyBjaGFyYWN0ZXIsXG4gICAgICAvLyBkZWZhdWx0IHRvIHNwYWNlIGlmIGl0J3MgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgLy9cbiAgICAgIGxhc3RDaGFyID0gMHgyMDtcblxuICAgICAgaWYgKHQuaW5kZXggLSAxID49IDApIHtcbiAgICAgICAgbGFzdENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQodC5pbmRleCAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBuZXh0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbmV4dENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIG5leHRDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICAgICAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gICAgICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcblxuICAgICAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gMHgyMiAvKiBcIiAqLyAmJiB0WzBdID09PSAnXCInKSB7XG4gICAgICAgIGlmIChsYXN0Q2hhciA+PSAweDMwIC8qIDAgKi8gJiYgbGFzdENoYXIgPD0gMHgzOSAvKiA5ICovKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiAxXCJcIiAtIGNvdW50IGZpcnN0IHF1b3RlIGFzIGFuIGluY2hcbiAgICAgICAgICBjYW5DbG9zZSA9IGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3BlbiAmJiBjYW5DbG9zZSkge1xuICAgICAgICAvLyB0cmVhdCB0aGlzIGFzIHRoZSBtaWRkbGUgb2YgdGhlIHdvcmRcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICBjYW5DbG9zZSA9IGlzTmV4dFB1bmN0Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xuICAgICAgICAvLyBtaWRkbGUgb2Ygd29yZFxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNsb3NpbmcgcXVvdGUsIHJld2luZCB0aGUgc3RhY2sgdG8gZ2V0IGEgbWF0Y2hcbiAgICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG4gICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDwgdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgICAgICAgaWYgKGl0ZW0uc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG5cbiAgICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1syXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMF07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0b2tlbi5jb250ZW50ICpiZWZvcmUqIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LFxuICAgICAgICAgICAgLy8gYmVjYXVzZSwgaWYgdGhleSBhcmUgcG9pbnRpbmcgYXQgdGhlIHNhbWUgdG9rZW4sIHJlcGxhY2VBdFxuICAgICAgICAgICAgLy8gY291bGQgbWVzcyB1cCBpbmRpY2VzIHdoZW4gcXVvdGUgbGVuZ3RoICE9IDFcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgY2xvc2VRdW90ZSk7XG4gICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdChcbiAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsIGl0ZW0ucG9zLCBvcGVuUXVvdGUpO1xuXG4gICAgICAgICAgICBwb3MgKz0gY2xvc2VRdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW4gPT09IGkpIHsgcG9zICs9IG9wZW5RdW90ZS5sZW5ndGggLSAxOyB9XG5cbiAgICAgICAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICAgICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGo7XG4gICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXG4gICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQ2xvc2UgJiYgaXNTaW5nbGUpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNtYXJ0cXVvdGVzKHN0YXRlKSB7XG4gIC8qZXNsaW50IG1heC1kZXB0aDowKi9cbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIVFVT1RFX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvY2Vzc19pbmxpbmVzKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuLCBzdGF0ZSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qcyIsIi8vIENvcmUgc3RhdGUgb2JqZWN0XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xuXG5cbmZ1bmN0aW9uIFN0YXRlQ29yZShzcmMsIG1kLCBlbnYpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLmlubGluZU1vZGUgPSBmYWxzZTtcbiAgdGhpcy5tZCA9IG1kOyAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxufVxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGNvcmUgcnVsZXNcblN0YXRlQ29yZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCIvLyBQcm9jZXNzIGF1dG9saW5rcyAnPHByb3RvY29sOi4uLj4nXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKmVzbGludCBtYXgtbGVuOjAqL1xudmFyIEVNQUlMX1JFICAgID0gL148KFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopPi87XG52YXIgQVVUT0xJTktfUkUgPSAvXjwoW2EtekEtWl1bYS16QS1aMC05Ky5cXC1dezEsMzF9KTooW148PlxceDAwLVxceDIwXSopPi87XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdXRvbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciB0YWlsLCBsaW5rTWF0Y2gsIGVtYWlsTWF0Y2gsIHVybCwgZnVsbFVybCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHRhaWwgPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTtcblxuICBpZiAodGFpbC5pbmRleE9mKCc+JykgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChBVVRPTElOS19SRS50ZXN0KHRhaWwpKSB7XG4gICAgbGlua01hdGNoID0gdGFpbC5tYXRjaChBVVRPTElOS19SRSk7XG5cbiAgICB1cmwgPSBsaW5rTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGxpbmtNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRU1BSUxfUkUudGVzdCh0YWlsKSkge1xuICAgIGVtYWlsTWF0Y2ggPSB0YWlsLm1hdGNoKEVNQUlMX1JFKTtcblxuICAgIHVybCA9IGVtYWlsTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKCdtYWlsdG86JyArIHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGVtYWlsTWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanMiLCIvLyBQYXJzZSBiYWNrdGlja3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhY2t0aWNrKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHN0YXJ0LCBtYXgsIG1hcmtlciwgbWF0Y2hTdGFydCwgbWF0Y2hFbmQsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zLFxuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHg2MC8qIGAgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc3RhcnQgPSBwb3M7XG4gIHBvcysrO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDYwLyogYCAqLykgeyBwb3MrKzsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKTtcblxuICBtYXRjaFN0YXJ0ID0gbWF0Y2hFbmQgPSBwb3M7XG5cbiAgd2hpbGUgKChtYXRjaFN0YXJ0ID0gc3RhdGUuc3JjLmluZGV4T2YoJ2AnLCBtYXRjaEVuZCkpICE9PSAtMSkge1xuICAgIG1hdGNoRW5kID0gbWF0Y2hTdGFydCArIDE7XG5cbiAgICB3aGlsZSAobWF0Y2hFbmQgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQobWF0Y2hFbmQpID09PSAweDYwLyogYCAqLykgeyBtYXRjaEVuZCsrOyB9XG5cbiAgICBpZiAobWF0Y2hFbmQgLSBtYXRjaFN0YXJ0ID09PSBtYXJrZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnY29kZV9pbmxpbmUnLCAnY29kZScsIDApO1xuICAgICAgICB0b2tlbi5tYXJrdXAgID0gbWFya2VyO1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF0Y2hTdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bIFxcbl0rL2csICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBtYXRjaEVuZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gbWFya2VyOyB9XG4gIHN0YXRlLnBvcyArPSBtYXJrZXIubGVuZ3RoO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIi8vIEZvciBlYWNoIG9wZW5pbmcgZW1waGFzaXMtbGlrZSBtYXJrZXIgZmluZCBhIG1hdGNoaW5nIGNsb3Npbmcgb25lXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua19wYWlycyhzdGF0ZSkge1xuICB2YXIgaSwgaiwgbGFzdERlbGltLCBjdXJyRGVsaW0sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGxhc3REZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoIWxhc3REZWxpbS5jbG9zZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaiA9IGkgLSBsYXN0RGVsaW0uanVtcCAtIDE7XG5cbiAgICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgICBjdXJyRGVsaW0gPSBkZWxpbWl0ZXJzW2pdO1xuXG4gICAgICBpZiAoY3VyckRlbGltLm9wZW4gJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubWFya2VyID09PSBsYXN0RGVsaW0ubWFya2VyICYmXG4gICAgICAgICAgY3VyckRlbGltLmVuZCA8IDAgJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubGV2ZWwgPT09IGxhc3REZWxpbS5sZXZlbCkge1xuXG4gICAgICAgIC8vIHR5cGVvZnMgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggcGx1Z2luc1xuICAgICAgICB2YXIgb2RkX21hdGNoID0gKGN1cnJEZWxpbS5jbG9zZSB8fCBsYXN0RGVsaW0ub3BlbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyRGVsaW0ubGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxhc3REZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VyckRlbGltLmxlbmd0aCArIGxhc3REZWxpbS5sZW5ndGgpICUgMyA9PT0gMDtcblxuICAgICAgICBpZiAoIW9kZF9tYXRjaCkge1xuICAgICAgICAgIGxhc3REZWxpbS5qdW1wID0gaSAtIGo7XG4gICAgICAgICAgbGFzdERlbGltLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kICA9IGk7XG4gICAgICAgICAgY3VyckRlbGltLmp1bXAgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGogLT0gY3VyckRlbGltLmp1bXAgKyAxO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qcyIsIi8vIFByb2Nlc3MgaHRtbCBlbnRpdHkgLSAmIzEyMzssICYjeEFGOywgJnF1b3Q7LCAuLi5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW50aXRpZXMgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vZW50aXRpZXMnKTtcbnZhciBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmhhcztcbnZhciBpc1ZhbGlkRW50aXR5Q29kZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzVmFsaWRFbnRpdHlDb2RlO1xudmFyIGZyb21Db2RlUG9pbnQgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuZnJvbUNvZGVQb2ludDtcblxuXG52YXIgRElHSVRBTF9SRSA9IC9eJiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpOy9pO1xudmFyIE5BTUVEX1JFICAgPSAvXiYoW2Etel1bYS16MC05XXsxLDMxfSk7L2k7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbnRpdHkoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIGNvZGUsIG1hdGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyNi8qICYgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDEgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuXG4gICAgaWYgKGNoID09PSAweDIzIC8qICMgKi8pIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goRElHSVRBTF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICBjb2RlID0gbWF0Y2hbMV1bMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID8gcGFyc2VJbnQobWF0Y2hbMV0uc2xpY2UoMSksIDE2KSA6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgc3RhdGUucGVuZGluZyArPSBpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSA/IGZyb21Db2RlUG9pbnQoY29kZSkgOiBmcm9tQ29kZVBvaW50KDB4RkZGRCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goTkFNRURfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChoYXMoZW50aXRpZXMsIG1hdGNoWzFdKSkge1xuICAgICAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gZW50aXRpZXNbbWF0Y2hbMV1dOyB9XG4gICAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJyYnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VudGl0eS5qcyIsIi8vIFByb2NlZXNzIGVzY2FwZWQgY2hhcnMgYW5kIGhhcmRicmVha3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cbnZhciBFU0NBUEVEID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHsgRVNDQVBFRC5wdXNoKDApOyB9XG5cbidcXFxcIVwiIyQlJlxcJygpKissLi86Ozw9Pj9AW11eX2B7fH1+LSdcbiAgLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaCkgeyBFU0NBUEVEW2NoLmNoYXJDb2RlQXQoMCldID0gMTsgfSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVDLyogXFwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zKys7XG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCA8IDI1NiAmJiBFU0NBUEVEW2NoXSAhPT0gMCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbcG9zXTsgfVxuICAgICAgc3RhdGUucG9zICs9IDI7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICAgIC8vIHNraXAgbGVhZGluZyB3aGl0ZXNwYWNlcyBmcm9tIG5leHQgbGluZVxuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvcyA9IHBvcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJ1xcXFwnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5qcyIsIi8vIFByb2Nlc3MgaHRtbCB0YWdzXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgSFRNTF9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfVEFHX1JFO1xuXG5cbmZ1bmN0aW9uIGlzTGV0dGVyKGNoKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIHZhciBsYyA9IGNoIHwgMHgyMDsgLy8gdG8gbG93ZXIgY2FzZVxuICByZXR1cm4gKGxjID49IDB4NjEvKiBhICovKSAmJiAobGMgPD0gMHg3YS8qIHogKi8pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9pbmxpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIG1hdGNoLCBtYXgsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIENoZWNrIHN0YXJ0XG4gIG1heCA9IHN0YXRlLnBvc01heDtcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovIHx8XG4gICAgICBwb3MgKyAyID49IG1heCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFF1aWNrIGZhaWwgb24gc2Vjb25kIGNoYXJcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgaWYgKGNoICE9PSAweDIxLyogISAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YvKiA/ICovICYmXG4gICAgICBjaCAhPT0gMHgyRi8qIC8gKi8gJiZcbiAgICAgICFpc0xldHRlcihjaCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKEhUTUxfVEFHX1JFKTtcbiAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzIiwiLy8gUHJvY2VzcyAhW2ltYWdlXSg8c3JjPiBcInRpdGxlXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltYWdlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlZixcbiAgICAgIHJlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICB0b2tlbnMsXG4gICAgICBzdGFydCxcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHgyMS8qICEgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDI7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuXG4gICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKFxuICAgICAgY29udGVudCxcbiAgICAgIHN0YXRlLm1kLFxuICAgICAgc3RhdGUuZW52LFxuICAgICAgdG9rZW5zID0gW11cbiAgICApO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbWFnZScsICdpbWcnLCAwKTtcbiAgICB0b2tlbi5hdHRycyAgICA9IGF0dHJzID0gWyBbICdzcmMnLCBocmVmIF0sIFsgJ2FsdCcsICcnIF0gXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qcyIsIi8vIFByb2Nlc3MgW2xpbmtdKDx0bz4gXCJzdHVmZlwiKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVzLFxuICAgICAgcmVmLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMTtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MsIHRydWUpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gbWlnaHQgaGF2ZSBmb3VuZCBhIHZhbGlkIHNob3J0Y3V0IGxpbmssIGRpc2FibGUgcmVmZXJlbmNlIHBhcnNpbmdcbiAgICBwYXJzZVJlZmVyZW5jZSA9IGZhbHNlO1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICAvLyBwYXJzaW5nIGEgdmFsaWQgc2hvcnRjdXQgbGluayBmYWlsZWQsIGZhbGxiYWNrIHRvIHJlZmVyZW5jZVxuICAgICAgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwYXJzZVJlZmVyZW5jZSkge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnBvcyA9IGxhYmVsU3RhcnQ7XG4gICAgc3RhdGUucG9zTWF4ID0gbGFiZWxFbmQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgIHRva2VuLmF0dHJzICA9IGF0dHJzID0gWyBbICdocmVmJywgaHJlZiBdIF07XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBhdHRycy5wdXNoKFsgJ3RpdGxlJywgdGl0bGUgXSk7XG4gICAgfVxuXG4gICAgc3RhdGUubWQuaW5saW5lLnRva2VuaXplKHN0YXRlKTtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanMiLCIvLyBQcm9jZWVzcyAnXFxuJ1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5ld2xpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG1heCwgbWF4LCBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEvKiBcXG4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG1heCA9IHN0YXRlLnBlbmRpbmcubGVuZ3RoIC0gMTtcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vICcgIFxcbicgLT4gaGFyZGJyZWFrXG4gIC8vIExvb2t1cCBpbiBwZW5kaW5nIGNoYXJzIGlzIGJhZCBwcmFjdGljZSEgRG9uJ3QgY29weSB0byBvdGhlciBydWxlcyFcbiAgLy8gUGVuZGluZyBzdHJpbmcgaXMgc3RvcmVkIGluIGNvbmNhdCBtb2RlLCBpbmRleGVkIGxvb2t1cHMgd2lsbCBjYXVzZVxuICAvLyBjb252ZXJ0aW9uIHRvIGZsYXQgbW9kZS5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAocG1heCA+PSAwICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4KSA9PT0gMHgyMCkge1xuICAgICAgaWYgKHBtYXggPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCAtIDEpID09PSAweDIwKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnJlcGxhY2UoLyArJC8sICcnKTtcbiAgICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApO1xuICAgIH1cbiAgfVxuXG4gIHBvcysrO1xuXG4gIC8vIHNraXAgaGVhZGluZyBzcGFjZXMgZm9yIG5leHQgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4ICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHsgcG9zKys7IH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qcyIsIi8vIElubGluZSBwYXJzZXIgc3RhdGVcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUb2tlbiAgICAgICAgICA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xuXG5cbmZ1bmN0aW9uIFN0YXRlSW5saW5lKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy5tZCA9IG1kO1xuICB0aGlzLnRva2VucyA9IG91dFRva2VucztcblxuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMucG9zTWF4ID0gdGhpcy5zcmMubGVuZ3RoO1xuICB0aGlzLmxldmVsID0gMDtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHRoaXMucGVuZGluZ0xldmVsID0gMDtcblxuICB0aGlzLmNhY2hlID0ge307ICAgICAgICAvLyBTdG9yZXMgeyBzdGFydDogZW5kIH0gcGFpcnMuIFVzZWZ1bCBmb3IgYmFja3RyYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGltaXphdGlvbiBvZiBwYWlycyBwYXJzZSAoZW1waGFzaXMsIHN0cmlrZXMpLlxuXG4gIHRoaXMuZGVsaW1pdGVycyA9IFtdOyAgIC8vIEVtcGhhc2lzLWxpa2UgZGVsaW1pdGVyc1xufVxuXG5cbi8vIEZsdXNoIHBlbmRpbmcgdGV4dFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKCd0ZXh0JywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ID0gdGhpcy5wZW5kaW5nO1xuICB0b2tlbi5sZXZlbCA9IHRoaXMucGVuZGluZ0xldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vIElmIHBlbmRpbmcgdGV4dCBleGlzdHMgLSBmbHVzaCBpdCBhcyB0ZXh0IHRva2VuXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICB0aGlzLnB1c2hQZW5kaW5nKCk7XG4gIH1cblxuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcblxuICBpZiAobmVzdGluZyA8IDApIHsgdGhpcy5sZXZlbC0tOyB9XG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxuXG4gIHRoaXMucGVuZGluZ0xldmVsID0gdGhpcy5sZXZlbDtcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gU2NhbiBhIHNlcXVlbmNlIG9mIGVtcGhhc2lzLWxpa2UgbWFya2VycywgYW5kIGRldGVybWluZSB3aGV0aGVyXG4vLyBpdCBjYW4gc3RhcnQgYW4gZW1waGFzaXMgc2VxdWVuY2Ugb3IgZW5kIGFuIGVtcGhhc2lzIHNlcXVlbmNlLlxuLy9cbi8vICAtIHN0YXJ0IC0gcG9zaXRpb24gdG8gc2NhbiBmcm9tIChpdCBzaG91bGQgcG9pbnQgYXQgYSB2YWxpZCBtYXJrZXIpO1xuLy8gIC0gY2FuU3BsaXRXb3JkIC0gZGV0ZXJtaW5lIGlmIHRoZXNlIG1hcmtlcnMgY2FuIGJlIGZvdW5kIGluc2lkZSBhIHdvcmRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuc2NhbkRlbGltcyA9IGZ1bmN0aW9uIChzdGFydCwgY2FuU3BsaXRXb3JkKSB7XG4gIHZhciBwb3MgPSBzdGFydCwgbGFzdENoYXIsIG5leHRDaGFyLCBjb3VudCwgY2FuX29wZW4sIGNhbl9jbG9zZSxcbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UsIGlzTGFzdFB1bmN0Q2hhcixcbiAgICAgIGlzTmV4dFdoaXRlU3BhY2UsIGlzTmV4dFB1bmN0Q2hhcixcbiAgICAgIGxlZnRfZmxhbmtpbmcgPSB0cnVlLFxuICAgICAgcmlnaHRfZmxhbmtpbmcgPSB0cnVlLFxuICAgICAgbWF4ID0gdGhpcy5wb3NNYXgsXG4gICAgICBtYXJrZXIgPSB0aGlzLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICAvLyB0cmVhdCBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXG4gIGxhc3RDaGFyID0gc3RhcnQgPiAwID8gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCAtIDEpIDogMHgyMDtcblxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gbWFya2VyKSB7IHBvcysrOyB9XG5cbiAgY291bnQgPSBwb3MgLSBzdGFydDtcblxuICAvLyB0cmVhdCBlbmQgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXG4gIG5leHRDaGFyID0gcG9zIDwgbWF4ID8gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpIDogMHgyMDtcblxuICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xuXG4gIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcblxuICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgIGxlZnRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcbiAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgIGxlZnRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY2FuU3BsaXRXb3JkKSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZyAgJiYgKCFyaWdodF9mbGFua2luZyB8fCBpc0xhc3RQdW5jdENoYXIpO1xuICAgIGNhbl9jbG9zZSA9IHJpZ2h0X2ZsYW5raW5nICYmICghbGVmdF9mbGFua2luZyAgfHwgaXNOZXh0UHVuY3RDaGFyKTtcbiAgfSBlbHNlIHtcbiAgICBjYW5fb3BlbiAgPSBsZWZ0X2ZsYW5raW5nO1xuICAgIGNhbl9jbG9zZSA9IHJpZ2h0X2ZsYW5raW5nO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjYW5fb3BlbjogIGNhbl9vcGVuLFxuICAgIGNhbl9jbG9zZTogY2FuX2Nsb3NlLFxuICAgIGxlbmd0aDogICAgY291bnRcbiAgfTtcbn07XG5cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUlubGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLmpzIiwiLy8gU2tpcCB0ZXh0IGNoYXJhY3RlcnMgZm9yIHRleHQgdG9rZW4sIHBsYWNlIHRob3NlIHRvIHBlbmRpbmcgYnVmZmVyXG4vLyBhbmQgaW5jcmVtZW50IGN1cnJlbnQgcG9zXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBSdWxlIHRvIHNraXAgcHVyZSB0ZXh0XG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xuXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cblxuLy8gISEhISBEb24ndCBjb25mdXNlIHdpdGggXCJNYXJrZG93biBBU0NJSSBQdW5jdHVhdGlvblwiIGNoYXJzXG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgwQS8qIFxcbiAqLzpcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcblxuICB3aGlsZSAocG9zIDwgc3RhdGUucG9zTWF4ICYmICFpc1Rlcm1pbmF0b3JDaGFyKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zLCBwb3MpOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24sIGZvciBtZW1vcnkuXG4vL1xuLy8gSXQgY29zdHMgMTAlIG9mIHBlcmZvcm1hbmNlLCBidXQgYWxsb3dzIGV4dGVuZCB0ZXJtaW5hdG9ycyBsaXN0LCBpZiBwbGFjZSBpdFxuLy8gdG8gYFBhcmNlcklubGluZWAgcHJvcGVydHkuIFByb2JhYmx5LCB3aWxsIHN3aXRjaCB0byBpdCBzb21ldGltZSwgc3VjaFxuLy8gZmxleGliaWxpdHkgcmVxdWlyZWQuXG5cbi8qXG52YXIgVEVSTUlOQVRPUl9SRSA9IC9bXFxuISMkJSYqK1xcLTo8PT5AW1xcXFxcXF1eX2B7fX5dLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGlkeCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLnNlYXJjaChURVJNSU5BVE9SX1JFKTtcblxuICAvLyBmaXJzdCBjaGFyIGlzIHRlcm1pbmF0b3IgLT4gZW1wdHkgdGV4dFxuICBpZiAoaWR4ID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vIHRlcm1pbmF0b3IgLT4gdGV4dCB0aWxsIGVuZCBvZiBzdHJpbmdcbiAgaWYgKGlkeCA8IDApIHtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MpOyB9XG4gICAgc3RhdGUucG9zID0gc3RhdGUuc3JjLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgaWR4KTsgfVxuXG4gIHN0YXRlLnBvcyArPSBpZHg7XG5cbiAgcmV0dXJuIHRydWU7XG59OyovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCIvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGludG8gb25lLCBhbmQgcmUtY2FsY3VsYXRlIGFsbCB0b2tlbiBsZXZlbHNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0X2NvbGxhcHNlKHN0YXRlKSB7XG4gIHZhciBjdXJyLCBsYXN0LFxuICAgICAgbGV2ZWwgPSAwLFxuICAgICAgdG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbWF4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBmb3IgKGN1cnIgPSBsYXN0ID0gMDsgY3VyciA8IG1heDsgY3VycisrKSB7XG4gICAgLy8gcmUtY2FsY3VsYXRlIGxldmVsc1xuICAgIGxldmVsICs9IHRva2Vuc1tjdXJyXS5uZXN0aW5nO1xuICAgIHRva2Vuc1tjdXJyXS5sZXZlbCA9IGxldmVsO1xuXG4gICAgaWYgKHRva2Vuc1tjdXJyXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgY3VyciArIDEgPCBtYXggJiZcbiAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS50eXBlID09PSAndGV4dCcpIHtcblxuICAgICAgLy8gY29sbGFwc2UgdHdvIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgIHRva2Vuc1tjdXJyICsgMV0uY29udGVudCA9IHRva2Vuc1tjdXJyXS5jb250ZW50ICsgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkgeyB0b2tlbnNbbGFzdF0gPSB0b2tlbnNbY3Vycl07IH1cblxuICAgICAgbGFzdCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyICE9PSBsYXN0KSB7XG4gICAgdG9rZW5zLmxlbmd0aCA9IGxhc3Q7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbnZhciBkZWNvZGVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgY2FjaGUucHVzaChjaCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gZXhjbHVkZS5jaGFyQ29kZUF0KGkpO1xuICAgIGNhY2hlW2NoXSA9ICclJyArICgnMCcgKyBjaC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIERlY29kZSBwZXJjZW50LWVuY29kZWQgc3RyaW5nLlxuLy9cbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGV4Y2x1ZGUpIHtcbiAgdmFyIGNhY2hlO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICBleGNsdWRlID0gZGVjb2RlLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oJVthLWYwLTldezJ9KSsvZ2ksIGZ1bmN0aW9uKHNlcSkge1xuICAgIHZhciBpLCBsLCBiMSwgYjIsIGIzLCBiNCwgY2hyLFxuICAgICAgICByZXN1bHQgPSAnJztcblxuICAgIGZvciAoaSA9IDAsIGwgPSBzZXEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICBiMSA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMSwgaSArIDMpLCAxNik7XG5cbiAgICAgIGlmIChiMSA8IDB4ODApIHtcbiAgICAgICAgcmVzdWx0ICs9IGNhY2hlW2IxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEUwKSA9PT0gMHhDMCAmJiAoaSArIDMgPCBsKSkge1xuICAgICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCA2KSAmIDB4N0MwKSB8IChiMiAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGMCkgPT09IDB4RTAgJiYgKGkgKyA2IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxMikgJiAweEYwMDApIHwgKChiMiA8PCA2KSAmIDB4RkMwKSB8IChiMyAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODAwIHx8IChjaHIgPj0gMHhEODAwICYmIGNociA8PSAweERGRkYpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEY4KSA9PT0gMHhGMCAmJiAoaSArIDkgPCBsKSkge1xuICAgICAgICAvLyAxMTExMTB4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcbiAgICAgICAgYjQgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEwLCBpICsgMTIpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwICYmIChiNCAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxOCkgJiAweDFDMDAwMCkgfCAoKGIyIDw8IDEyKSAmIDB4M0YwMDApIHwgKChiMyA8PCA2KSAmIDB4RkMwKSB8IChiNCAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4MTAwMDAgfHwgY2hyID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociAtPSAweDEwMDAwO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKGNociA+PiAxMCksIDB4REMwMCArIChjaHIgJiAweDNGRikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gJ1xcdWZmZmQnO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG5cbmRlY29kZS5kZWZhdWx0Q2hhcnMgICA9ICc7Lz86QCY9KyQsIyc7XG5kZWNvZGUuY29tcG9uZW50Q2hhcnMgPSAnJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2RlY29kZS5qcyIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBlbmNvZGVDYWNoZSA9IHt9O1xuXG5cbi8vIENyZWF0ZSBhIGxvb2t1cCBhcnJheSB3aGVyZSBhbnl0aGluZyBidXQgY2hhcmFjdGVycyBpbiBgY2hhcnNgIHN0cmluZ1xuLy8gYW5kIGFscGhhbnVtZXJpYyBjaGFycyBpcyBwZXJjZW50LWVuY29kZWQuXG4vL1xuZnVuY3Rpb24gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuXG4gICAgaWYgKC9eWzAtOWEtel0kL2kudGVzdChjaCkpIHtcbiAgICAgIC8vIGFsd2F5cyBhbGxvdyB1bmVuY29kZWQgYWxwaGFudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgIGNhY2hlLnB1c2goY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5wdXNoKCclJyArICgnMCcgKyBpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMikpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGVbZXhjbHVkZS5jaGFyQ29kZUF0KGkpXSA9IGV4Y2x1ZGVbaV07XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59XG5cblxuLy8gRW5jb2RlIHVuc2FmZSBjaGFyYWN0ZXJzIHdpdGggcGVyY2VudC1lbmNvZGluZywgc2tpcHBpbmcgYWxyZWFkeVxuLy8gZW5jb2RlZCBzZXF1ZW5jZXMuXG4vL1xuLy8gIC0gc3RyaW5nICAgICAgIC0gc3RyaW5nIHRvIGVuY29kZVxuLy8gIC0gZXhjbHVkZSAgICAgIC0gbGlzdCBvZiBjaGFyYWN0ZXJzIHRvIGlnbm9yZSAoaW4gYWRkaXRpb24gdG8gYS16QS1aMC05KVxuLy8gIC0ga2VlcEVzY2FwZWQgIC0gZG9uJ3QgZW5jb2RlICclJyBpbiBhIGNvcnJlY3QgZXNjYXBlIHNlcXVlbmNlIChkZWZhdWx0OiB0cnVlKVxuLy9cbmZ1bmN0aW9uIGVuY29kZShzdHJpbmcsIGV4Y2x1ZGUsIGtlZXBFc2NhcGVkKSB7XG4gIHZhciBpLCBsLCBjb2RlLCBuZXh0Q29kZSwgY2FjaGUsXG4gICAgICByZXN1bHQgPSAnJztcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZW5jb2RlKHN0cmluZywga2VlcEVzY2FwZWQpXG4gICAga2VlcEVzY2FwZWQgID0gZXhjbHVkZTtcbiAgICBleGNsdWRlID0gZW5jb2RlLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2VlcEVzY2FwZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAga2VlcEVzY2FwZWQgPSB0cnVlO1xuICB9XG5cbiAgY2FjaGUgPSBnZXRFbmNvZGVDYWNoZShleGNsdWRlKTtcblxuICBmb3IgKGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChrZWVwRXNjYXBlZCAmJiBjb2RlID09PSAweDI1IC8qICUgKi8gJiYgaSArIDIgPCBsKSB7XG4gICAgICBpZiAoL15bMC05YS1mXXsyfSQvaS50ZXN0KHN0cmluZy5zbGljZShpICsgMSwgaSArIDMpKSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5nLnNsaWNlKGksIGkgKyAzKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA8IDEyOCkge1xuICAgICAgcmVzdWx0ICs9IGNhY2hlW2NvZGVdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhERkZGKSB7XG4gICAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERCRkYgJiYgaSArIDEgPCBsKSB7XG4gICAgICAgIG5leHRDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICBpZiAobmV4dENvZGUgPj0gMHhEQzAwICYmIG5leHRDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldICsgc3RyaW5nW2kgKyAxXSk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJyVFRiVCRiVCRCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5lbmNvZGUuZGVmYXVsdENoYXJzICAgPSBcIjsvPzpAJj0rJCwtXy4hfionKCkjXCI7XG5lbmNvZGUuY29tcG9uZW50Q2hhcnMgPSBcIi1fLiF+KicoKVwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZW5jb2RlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXQodXJsKSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICByZXN1bHQgKz0gdXJsLnByb3RvY29sIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNsYXNoZXMgPyAnLy8nIDogJyc7XG4gIHJlc3VsdCArPSB1cmwuYXV0aCA/IHVybC5hdXRoICsgJ0AnIDogJyc7XG5cbiAgaWYgKHVybC5ob3N0bmFtZSAmJiB1cmwuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIC8vIGlwdjYgYWRkcmVzc1xuICAgIHJlc3VsdCArPSAnWycgKyB1cmwuaG9zdG5hbWUgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IHVybC5ob3N0bmFtZSB8fCAnJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwucG9ydCA/ICc6JyArIHVybC5wb3J0IDogJyc7XG4gIHJlc3VsdCArPSB1cmwucGF0aG5hbWUgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2VhcmNoIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLmhhc2ggfHwgJyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9mb3JtYXQuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQ2hhbmdlcyBmcm9tIGpveWVudC9ub2RlOlxuLy9cbi8vIDEuIE5vIGxlYWRpbmcgc2xhc2ggaW4gcGF0aHMsXG4vLyAgICBlLmcuIGluIGB1cmwucGFyc2UoJ2h0dHA6Ly9mb28/YmFyJylgIHBhdGhuYW1lIGlzIGBgLCBub3QgYC9gXG4vL1xuLy8gMi4gQmFja3NsYXNoZXMgYXJlIG5vdCByZXBsYWNlZCB3aXRoIHNsYXNoZXMsXG4vLyAgICBzbyBgaHR0cDpcXFxcZXhhbXBsZS5vcmdcXGAgaXMgdHJlYXRlZCBsaWtlIGEgcmVsYXRpdmUgcGF0aFxuLy9cbi8vIDMuIFRyYWlsaW5nIGNvbG9uIGlzIHRyZWF0ZWQgbGlrZSBhIHBhcnQgb2YgdGhlIHBhdGgsXG4vLyAgICBpLmUuIGluIGBodHRwOi8vZXhhbXBsZS5vcmc6Zm9vYCBwYXRobmFtZSBpcyBgOmZvb2Bcbi8vXG4vLyA0LiBOb3RoaW5nIGlzIFVSTC1lbmNvZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LFxuLy8gICAgKGluIGpveWVudC9ub2RlIHNvbWUgY2hhcnMgaW4gYXV0aCBhbmQgcGF0aHMgYXJlIGVuY29kZWQpXG4vL1xuLy8gNS4gYHVybC5wYXJzZSgpYCBkb2VzIG5vdCBoYXZlIGBwYXJzZVF1ZXJ5U3RyaW5nYCBhcmd1bWVudFxuLy9cbi8vIDYuIFJlbW92ZWQgZXh0cmFuZW91cyByZXN1bHQgcHJvcGVydGllczogYGhvc3RgLCBgcGF0aGAsIGBxdWVyeWAsIGV0Yy4sXG4vLyAgICB3aGljaCBjYW4gYmUgY29uc3RydWN0ZWQgdXNpbmcgb3RoZXIgcGFydHMgb2YgdGhlIHVybC5cbi8vXG5cblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsgJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnIF0sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsgJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJyBdLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbICdcXCcnIF0uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbICclJywgJy8nLCAnPycsICc7JywgJyMnIF0uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsgJy8nLCAnPycsICcjJyBdLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2NyaXB0LXVybCAqL1xuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNjcmlwdC11cmwgKi9cblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICB2YXIgaSwgbCwgbG93ZXJQcm90bywgaGVjLCBzbGFzaGVzLFxuICAgICAgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAocmVzdFtob3N0RW5kIC0gMV0gPT09ICc6JykgeyBob3N0RW5kLS07IH1cbiAgICB2YXIgaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KGhvc3QpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oaG9zdCkge1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxQYXJzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL3BhcnNlLmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9wdW55Y29kZS9wdW55Y29kZS5qcyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3N0eWxlLWxvYWRlci9maXhVcmxzLmpzIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXHhBRFxcdTA2MDAtXFx1MDYwNVxcdTA2MUNcXHUwNkREXFx1MDcwRlxcdTA4RTJcXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDY0XFx1MjA2Ni1cXHUyMDZGXFx1RkVGRlxcdUZGRjktXFx1RkZGQl18XFx1RDgwNFxcdURDQkR8XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQW55ID0gcmVxdWlyZSgnLi9wcm9wZXJ0aWVzL0FueS9yZWdleCcpO1xuZXhwb3J0cy5DYyAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKTtcbmV4cG9ydHMuQ2YgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NmL3JlZ2V4Jyk7XG5leHBvcnRzLlAgICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5leHBvcnRzLlogICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9aL3JlZ2V4Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuXzJZcktFbXJ1U1hxLUxZOEhUOWdqY0F7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtoZWlnaHQ6Y2FsYygxMDAlIC0gMjMwcHgpfS5fM0w1TkVCODRLeFBmbHhCWnZleXNkZHt0ZXh0LWFsaWduOnJpZ2h0O21hcmdpbi10b3A6MTVweH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJlZGl0b3JXcmFwXCI6IFwiXzJZcktFbXJ1U1hxLUxZOEhUOWdqY0FcIixcblx0XCJzYXZlQnV0dG9uXCI6IFwiXzNMNU5FQjg0S3hQZmx4Qlp2ZXlzZGRcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2Nzcy1sb2FkZXI/e1wibW9kdWxlc1wiOnRydWUsXCJtaW5pbWl6ZVwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlfSEuL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5aZVczSEl3YV9CV0lHVzB5WkppNUd7d2lkdGg6MTAwJTtmb250LXNpemU6MjRwdDtwYWRkaW5nLWxlZnQ6MTBweH0uWmNzYVp2Y29mMHR4V2RlcWlrQ0dae3dpZHRoOjEwMCU7Zm9udC1zaXplOjE4cHQ7cGFkZGluZy1sZWZ0OjEwcHh9Ll8xb3Vhc2o2NDZNN2k5b0t3LTBRXzU1e3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7aGVpZ2h0OmNhbGMoMTAwJSAtIDIzMHB4KX0uXzJNTFdSOFdfcEhmTkJrQm1wMG5pMDh7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7YmFja2dyb3VuZDojZmNmY2ZjO3BhZGRpbmc6MTBweDtvdmVyZmxvdzphdXRvO2hlaWdodDoxMDAlfS5HSllvblNITE9YWkpoUFNVd1pkdmJ7bGVmdDowfS51X1JTeXZCTEQ3YjBaMTJocEs4RDR7bGVmdDo1MCU7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5fMmdBdGdtOW9BRE9yWll0MXVkbWNKUnt0ZXh0LWFsaWduOnJpZ2h0O21hcmdpbi10b3A6MTVweH0uXzNOQmJJcjRXbEh5VVFjMjlZVzZiU1h7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtyZXNpemU6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiNmY2ZjZmM7Ym9yZGVyOm5vbmU7Zm9udC1zaXplOjEwcHR9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwidGl0bGVcIjogXCJaZVczSEl3YV9CV0lHVzB5WkppNUdcIixcblx0XCJ0YWdzXCI6IFwiWmNzYVp2Y29mMHR4V2RlcWlrQ0daXCIsXG5cdFwiZWRpdG9yV3JhcFwiOiBcIl8xb3Vhc2o2NDZNN2k5b0t3LTBRXzU1XCIsXG5cdFwiZWRpdG9yXCI6IFwiXzJNTFdSOFdfcEhmTkJrQm1wMG5pMDhcIixcblx0XCJlZGl0b3JMZWZ0U2lkZVwiOiBcIkdKWW9uU0hMT1haSmhQU1V3WmR2YlwiLFxuXHRcImVkaXRvclJpZ2h0U2lkZVwiOiBcInVfUlN5dkJMRDdiMFoxMmhwSzhENFwiLFxuXHRcInNhdmVCdXR0b25cIjogXCJfMmdBdGdtOW9BRE9yWll0MXVkbWNKUlwiLFxuXHRcInRleHRhcmVhXCI6IFwiXzNOQmJJcjRXbEh5VVFjMjlZVzZiU1hcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2Nzcy1sb2FkZXI/e1wibW9kdWxlc1wiOnRydWUsXCJtaW5pbWl6ZVwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlfSEuLi9saWJzL2NvbXBvbmVudHMvc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiQWFjdXRlXCI6IFwiw4FcIixcblx0XCJhYWN1dGVcIjogXCLDoVwiLFxuXHRcIkFicmV2ZVwiOiBcIsSCXCIsXG5cdFwiYWJyZXZlXCI6IFwixINcIixcblx0XCJhY1wiOiBcIuKIvlwiLFxuXHRcImFjZFwiOiBcIuKIv1wiLFxuXHRcImFjRVwiOiBcIuKIvsyzXCIsXG5cdFwiQWNpcmNcIjogXCLDglwiLFxuXHRcImFjaXJjXCI6IFwiw6JcIixcblx0XCJhY3V0ZVwiOiBcIsK0XCIsXG5cdFwiQWN5XCI6IFwi0JBcIixcblx0XCJhY3lcIjogXCLQsFwiLFxuXHRcIkFFbGlnXCI6IFwiw4ZcIixcblx0XCJhZWxpZ1wiOiBcIsOmXCIsXG5cdFwiYWZcIjogXCLigaFcIixcblx0XCJBZnJcIjogXCLwnZSEXCIsXG5cdFwiYWZyXCI6IFwi8J2UnlwiLFxuXHRcIkFncmF2ZVwiOiBcIsOAXCIsXG5cdFwiYWdyYXZlXCI6IFwiw6BcIixcblx0XCJhbGVmc3ltXCI6IFwi4oS1XCIsXG5cdFwiYWxlcGhcIjogXCLihLVcIixcblx0XCJBbHBoYVwiOiBcIs6RXCIsXG5cdFwiYWxwaGFcIjogXCLOsVwiLFxuXHRcIkFtYWNyXCI6IFwixIBcIixcblx0XCJhbWFjclwiOiBcIsSBXCIsXG5cdFwiYW1hbGdcIjogXCLiqL9cIixcblx0XCJhbXBcIjogXCImXCIsXG5cdFwiQU1QXCI6IFwiJlwiLFxuXHRcImFuZGFuZFwiOiBcIuKplVwiLFxuXHRcIkFuZFwiOiBcIuKpk1wiLFxuXHRcImFuZFwiOiBcIuKIp1wiLFxuXHRcImFuZGRcIjogXCLiqZxcIixcblx0XCJhbmRzbG9wZVwiOiBcIuKpmFwiLFxuXHRcImFuZHZcIjogXCLiqZpcIixcblx0XCJhbmdcIjogXCLiiKBcIixcblx0XCJhbmdlXCI6IFwi4qakXCIsXG5cdFwiYW5nbGVcIjogXCLiiKBcIixcblx0XCJhbmdtc2RhYVwiOiBcIuKmqFwiLFxuXHRcImFuZ21zZGFiXCI6IFwi4qapXCIsXG5cdFwiYW5nbXNkYWNcIjogXCLipqpcIixcblx0XCJhbmdtc2RhZFwiOiBcIuKmq1wiLFxuXHRcImFuZ21zZGFlXCI6IFwi4qasXCIsXG5cdFwiYW5nbXNkYWZcIjogXCLipq1cIixcblx0XCJhbmdtc2RhZ1wiOiBcIuKmrlwiLFxuXHRcImFuZ21zZGFoXCI6IFwi4qavXCIsXG5cdFwiYW5nbXNkXCI6IFwi4oihXCIsXG5cdFwiYW5ncnRcIjogXCLiiJ9cIixcblx0XCJhbmdydHZiXCI6IFwi4oq+XCIsXG5cdFwiYW5ncnR2YmRcIjogXCLipp1cIixcblx0XCJhbmdzcGhcIjogXCLiiKJcIixcblx0XCJhbmdzdFwiOiBcIsOFXCIsXG5cdFwiYW5nemFyclwiOiBcIuKNvFwiLFxuXHRcIkFvZ29uXCI6IFwixIRcIixcblx0XCJhb2dvblwiOiBcIsSFXCIsXG5cdFwiQW9wZlwiOiBcIvCdlLhcIixcblx0XCJhb3BmXCI6IFwi8J2VklwiLFxuXHRcImFwYWNpclwiOiBcIuKpr1wiLFxuXHRcImFwXCI6IFwi4omIXCIsXG5cdFwiYXBFXCI6IFwi4qmwXCIsXG5cdFwiYXBlXCI6IFwi4omKXCIsXG5cdFwiYXBpZFwiOiBcIuKJi1wiLFxuXHRcImFwb3NcIjogXCInXCIsXG5cdFwiQXBwbHlGdW5jdGlvblwiOiBcIuKBoVwiLFxuXHRcImFwcHJveFwiOiBcIuKJiFwiLFxuXHRcImFwcHJveGVxXCI6IFwi4omKXCIsXG5cdFwiQXJpbmdcIjogXCLDhVwiLFxuXHRcImFyaW5nXCI6IFwiw6VcIixcblx0XCJBc2NyXCI6IFwi8J2SnFwiLFxuXHRcImFzY3JcIjogXCLwnZK2XCIsXG5cdFwiQXNzaWduXCI6IFwi4omUXCIsXG5cdFwiYXN0XCI6IFwiKlwiLFxuXHRcImFzeW1wXCI6IFwi4omIXCIsXG5cdFwiYXN5bXBlcVwiOiBcIuKJjVwiLFxuXHRcIkF0aWxkZVwiOiBcIsODXCIsXG5cdFwiYXRpbGRlXCI6IFwiw6NcIixcblx0XCJBdW1sXCI6IFwiw4RcIixcblx0XCJhdW1sXCI6IFwiw6RcIixcblx0XCJhd2NvbmludFwiOiBcIuKIs1wiLFxuXHRcImF3aW50XCI6IFwi4qiRXCIsXG5cdFwiYmFja2NvbmdcIjogXCLiiYxcIixcblx0XCJiYWNrZXBzaWxvblwiOiBcIs+2XCIsXG5cdFwiYmFja3ByaW1lXCI6IFwi4oC1XCIsXG5cdFwiYmFja3NpbVwiOiBcIuKIvVwiLFxuXHRcImJhY2tzaW1lcVwiOiBcIuKLjVwiLFxuXHRcIkJhY2tzbGFzaFwiOiBcIuKIllwiLFxuXHRcIkJhcnZcIjogXCLiq6dcIixcblx0XCJiYXJ2ZWVcIjogXCLiir1cIixcblx0XCJiYXJ3ZWRcIjogXCLijIVcIixcblx0XCJCYXJ3ZWRcIjogXCLijIZcIixcblx0XCJiYXJ3ZWRnZVwiOiBcIuKMhVwiLFxuXHRcImJicmtcIjogXCLijrVcIixcblx0XCJiYnJrdGJya1wiOiBcIuKOtlwiLFxuXHRcImJjb25nXCI6IFwi4omMXCIsXG5cdFwiQmN5XCI6IFwi0JFcIixcblx0XCJiY3lcIjogXCLQsVwiLFxuXHRcImJkcXVvXCI6IFwi4oCeXCIsXG5cdFwiYmVjYXVzXCI6IFwi4oi1XCIsXG5cdFwiYmVjYXVzZVwiOiBcIuKItVwiLFxuXHRcIkJlY2F1c2VcIjogXCLiiLVcIixcblx0XCJiZW1wdHl2XCI6IFwi4qawXCIsXG5cdFwiYmVwc2lcIjogXCLPtlwiLFxuXHRcImJlcm5vdVwiOiBcIuKErFwiLFxuXHRcIkJlcm5vdWxsaXNcIjogXCLihKxcIixcblx0XCJCZXRhXCI6IFwizpJcIixcblx0XCJiZXRhXCI6IFwizrJcIixcblx0XCJiZXRoXCI6IFwi4oS2XCIsXG5cdFwiYmV0d2VlblwiOiBcIuKJrFwiLFxuXHRcIkJmclwiOiBcIvCdlIVcIixcblx0XCJiZnJcIjogXCLwnZSfXCIsXG5cdFwiYmlnY2FwXCI6IFwi4ouCXCIsXG5cdFwiYmlnY2lyY1wiOiBcIuKXr1wiLFxuXHRcImJpZ2N1cFwiOiBcIuKLg1wiLFxuXHRcImJpZ29kb3RcIjogXCLiqIBcIixcblx0XCJiaWdvcGx1c1wiOiBcIuKogVwiLFxuXHRcImJpZ290aW1lc1wiOiBcIuKoglwiLFxuXHRcImJpZ3NxY3VwXCI6IFwi4qiGXCIsXG5cdFwiYmlnc3RhclwiOiBcIuKYhVwiLFxuXHRcImJpZ3RyaWFuZ2xlZG93blwiOiBcIuKWvVwiLFxuXHRcImJpZ3RyaWFuZ2xldXBcIjogXCLilrNcIixcblx0XCJiaWd1cGx1c1wiOiBcIuKohFwiLFxuXHRcImJpZ3ZlZVwiOiBcIuKLgVwiLFxuXHRcImJpZ3dlZGdlXCI6IFwi4ouAXCIsXG5cdFwiYmthcm93XCI6IFwi4qSNXCIsXG5cdFwiYmxhY2tsb3plbmdlXCI6IFwi4qerXCIsXG5cdFwiYmxhY2tzcXVhcmVcIjogXCLilqpcIixcblx0XCJibGFja3RyaWFuZ2xlXCI6IFwi4pa0XCIsXG5cdFwiYmxhY2t0cmlhbmdsZWRvd25cIjogXCLilr5cIixcblx0XCJibGFja3RyaWFuZ2xlbGVmdFwiOiBcIuKXglwiLFxuXHRcImJsYWNrdHJpYW5nbGVyaWdodFwiOiBcIuKWuFwiLFxuXHRcImJsYW5rXCI6IFwi4pCjXCIsXG5cdFwiYmxrMTJcIjogXCLilpJcIixcblx0XCJibGsxNFwiOiBcIuKWkVwiLFxuXHRcImJsazM0XCI6IFwi4paTXCIsXG5cdFwiYmxvY2tcIjogXCLilohcIixcblx0XCJibmVcIjogXCI94oOlXCIsXG5cdFwiYm5lcXVpdlwiOiBcIuKJoeKDpVwiLFxuXHRcImJOb3RcIjogXCLiq61cIixcblx0XCJibm90XCI6IFwi4oyQXCIsXG5cdFwiQm9wZlwiOiBcIvCdlLlcIixcblx0XCJib3BmXCI6IFwi8J2Vk1wiLFxuXHRcImJvdFwiOiBcIuKKpVwiLFxuXHRcImJvdHRvbVwiOiBcIuKKpVwiLFxuXHRcImJvd3RpZVwiOiBcIuKLiFwiLFxuXHRcImJveGJveFwiOiBcIuKniVwiLFxuXHRcImJveGRsXCI6IFwi4pSQXCIsXG5cdFwiYm94ZExcIjogXCLilZVcIixcblx0XCJib3hEbFwiOiBcIuKVllwiLFxuXHRcImJveERMXCI6IFwi4pWXXCIsXG5cdFwiYm94ZHJcIjogXCLilIxcIixcblx0XCJib3hkUlwiOiBcIuKVklwiLFxuXHRcImJveERyXCI6IFwi4pWTXCIsXG5cdFwiYm94RFJcIjogXCLilZRcIixcblx0XCJib3hoXCI6IFwi4pSAXCIsXG5cdFwiYm94SFwiOiBcIuKVkFwiLFxuXHRcImJveGhkXCI6IFwi4pSsXCIsXG5cdFwiYm94SGRcIjogXCLilaRcIixcblx0XCJib3hoRFwiOiBcIuKVpVwiLFxuXHRcImJveEhEXCI6IFwi4pWmXCIsXG5cdFwiYm94aHVcIjogXCLilLRcIixcblx0XCJib3hIdVwiOiBcIuKVp1wiLFxuXHRcImJveGhVXCI6IFwi4pWoXCIsXG5cdFwiYm94SFVcIjogXCLilalcIixcblx0XCJib3htaW51c1wiOiBcIuKKn1wiLFxuXHRcImJveHBsdXNcIjogXCLiip5cIixcblx0XCJib3h0aW1lc1wiOiBcIuKKoFwiLFxuXHRcImJveHVsXCI6IFwi4pSYXCIsXG5cdFwiYm94dUxcIjogXCLilZtcIixcblx0XCJib3hVbFwiOiBcIuKVnFwiLFxuXHRcImJveFVMXCI6IFwi4pWdXCIsXG5cdFwiYm94dXJcIjogXCLilJRcIixcblx0XCJib3h1UlwiOiBcIuKVmFwiLFxuXHRcImJveFVyXCI6IFwi4pWZXCIsXG5cdFwiYm94VVJcIjogXCLilZpcIixcblx0XCJib3h2XCI6IFwi4pSCXCIsXG5cdFwiYm94VlwiOiBcIuKVkVwiLFxuXHRcImJveHZoXCI6IFwi4pS8XCIsXG5cdFwiYm94dkhcIjogXCLilapcIixcblx0XCJib3hWaFwiOiBcIuKVq1wiLFxuXHRcImJveFZIXCI6IFwi4pWsXCIsXG5cdFwiYm94dmxcIjogXCLilKRcIixcblx0XCJib3h2TFwiOiBcIuKVoVwiLFxuXHRcImJveFZsXCI6IFwi4pWiXCIsXG5cdFwiYm94VkxcIjogXCLilaNcIixcblx0XCJib3h2clwiOiBcIuKUnFwiLFxuXHRcImJveHZSXCI6IFwi4pWeXCIsXG5cdFwiYm94VnJcIjogXCLilZ9cIixcblx0XCJib3hWUlwiOiBcIuKVoFwiLFxuXHRcImJwcmltZVwiOiBcIuKAtVwiLFxuXHRcImJyZXZlXCI6IFwiy5hcIixcblx0XCJCcmV2ZVwiOiBcIsuYXCIsXG5cdFwiYnJ2YmFyXCI6IFwiwqZcIixcblx0XCJic2NyXCI6IFwi8J2St1wiLFxuXHRcIkJzY3JcIjogXCLihKxcIixcblx0XCJic2VtaVwiOiBcIuKBj1wiLFxuXHRcImJzaW1cIjogXCLiiL1cIixcblx0XCJic2ltZVwiOiBcIuKLjVwiLFxuXHRcImJzb2xiXCI6IFwi4qeFXCIsXG5cdFwiYnNvbFwiOiBcIlxcXFxcIixcblx0XCJic29saHN1YlwiOiBcIuKfiFwiLFxuXHRcImJ1bGxcIjogXCLigKJcIixcblx0XCJidWxsZXRcIjogXCLigKJcIixcblx0XCJidW1wXCI6IFwi4omOXCIsXG5cdFwiYnVtcEVcIjogXCLiqq5cIixcblx0XCJidW1wZVwiOiBcIuKJj1wiLFxuXHRcIkJ1bXBlcVwiOiBcIuKJjlwiLFxuXHRcImJ1bXBlcVwiOiBcIuKJj1wiLFxuXHRcIkNhY3V0ZVwiOiBcIsSGXCIsXG5cdFwiY2FjdXRlXCI6IFwixIdcIixcblx0XCJjYXBhbmRcIjogXCLiqYRcIixcblx0XCJjYXBicmN1cFwiOiBcIuKpiVwiLFxuXHRcImNhcGNhcFwiOiBcIuKpi1wiLFxuXHRcImNhcFwiOiBcIuKIqVwiLFxuXHRcIkNhcFwiOiBcIuKLklwiLFxuXHRcImNhcGN1cFwiOiBcIuKph1wiLFxuXHRcImNhcGRvdFwiOiBcIuKpgFwiLFxuXHRcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6IFwi4oWFXCIsXG5cdFwiY2Fwc1wiOiBcIuKIqe+4gFwiLFxuXHRcImNhcmV0XCI6IFwi4oGBXCIsXG5cdFwiY2Fyb25cIjogXCLLh1wiLFxuXHRcIkNheWxleXNcIjogXCLihK1cIixcblx0XCJjY2Fwc1wiOiBcIuKpjVwiLFxuXHRcIkNjYXJvblwiOiBcIsSMXCIsXG5cdFwiY2Nhcm9uXCI6IFwixI1cIixcblx0XCJDY2VkaWxcIjogXCLDh1wiLFxuXHRcImNjZWRpbFwiOiBcIsOnXCIsXG5cdFwiQ2NpcmNcIjogXCLEiFwiLFxuXHRcImNjaXJjXCI6IFwixIlcIixcblx0XCJDY29uaW50XCI6IFwi4oiwXCIsXG5cdFwiY2N1cHNcIjogXCLiqYxcIixcblx0XCJjY3Vwc3NtXCI6IFwi4qmQXCIsXG5cdFwiQ2RvdFwiOiBcIsSKXCIsXG5cdFwiY2RvdFwiOiBcIsSLXCIsXG5cdFwiY2VkaWxcIjogXCLCuFwiLFxuXHRcIkNlZGlsbGFcIjogXCLCuFwiLFxuXHRcImNlbXB0eXZcIjogXCLiprJcIixcblx0XCJjZW50XCI6IFwiwqJcIixcblx0XCJjZW50ZXJkb3RcIjogXCLCt1wiLFxuXHRcIkNlbnRlckRvdFwiOiBcIsK3XCIsXG5cdFwiY2ZyXCI6IFwi8J2UoFwiLFxuXHRcIkNmclwiOiBcIuKErVwiLFxuXHRcIkNIY3lcIjogXCLQp1wiLFxuXHRcImNoY3lcIjogXCLRh1wiLFxuXHRcImNoZWNrXCI6IFwi4pyTXCIsXG5cdFwiY2hlY2ttYXJrXCI6IFwi4pyTXCIsXG5cdFwiQ2hpXCI6IFwizqdcIixcblx0XCJjaGlcIjogXCLPh1wiLFxuXHRcImNpcmNcIjogXCLLhlwiLFxuXHRcImNpcmNlcVwiOiBcIuKJl1wiLFxuXHRcImNpcmNsZWFycm93bGVmdFwiOiBcIuKGulwiLFxuXHRcImNpcmNsZWFycm93cmlnaHRcIjogXCLihrtcIixcblx0XCJjaXJjbGVkYXN0XCI6IFwi4oqbXCIsXG5cdFwiY2lyY2xlZGNpcmNcIjogXCLiippcIixcblx0XCJjaXJjbGVkZGFzaFwiOiBcIuKKnVwiLFxuXHRcIkNpcmNsZURvdFwiOiBcIuKKmVwiLFxuXHRcImNpcmNsZWRSXCI6IFwiwq5cIixcblx0XCJjaXJjbGVkU1wiOiBcIuKTiFwiLFxuXHRcIkNpcmNsZU1pbnVzXCI6IFwi4oqWXCIsXG5cdFwiQ2lyY2xlUGx1c1wiOiBcIuKKlVwiLFxuXHRcIkNpcmNsZVRpbWVzXCI6IFwi4oqXXCIsXG5cdFwiY2lyXCI6IFwi4peLXCIsXG5cdFwiY2lyRVwiOiBcIuKng1wiLFxuXHRcImNpcmVcIjogXCLiiZdcIixcblx0XCJjaXJmbmludFwiOiBcIuKokFwiLFxuXHRcImNpcm1pZFwiOiBcIuKrr1wiLFxuXHRcImNpcnNjaXJcIjogXCLip4JcIixcblx0XCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjogXCLiiLJcIixcblx0XCJDbG9zZUN1cmx5RG91YmxlUXVvdGVcIjogXCLigJ1cIixcblx0XCJDbG9zZUN1cmx5UXVvdGVcIjogXCLigJlcIixcblx0XCJjbHVic1wiOiBcIuKZo1wiLFxuXHRcImNsdWJzdWl0XCI6IFwi4pmjXCIsXG5cdFwiY29sb25cIjogXCI6XCIsXG5cdFwiQ29sb25cIjogXCLiiLdcIixcblx0XCJDb2xvbmVcIjogXCLiqbRcIixcblx0XCJjb2xvbmVcIjogXCLiiZRcIixcblx0XCJjb2xvbmVxXCI6IFwi4omUXCIsXG5cdFwiY29tbWFcIjogXCIsXCIsXG5cdFwiY29tbWF0XCI6IFwiQFwiLFxuXHRcImNvbXBcIjogXCLiiIFcIixcblx0XCJjb21wZm5cIjogXCLiiJhcIixcblx0XCJjb21wbGVtZW50XCI6IFwi4oiBXCIsXG5cdFwiY29tcGxleGVzXCI6IFwi4oSCXCIsXG5cdFwiY29uZ1wiOiBcIuKJhVwiLFxuXHRcImNvbmdkb3RcIjogXCLiqa1cIixcblx0XCJDb25ncnVlbnRcIjogXCLiiaFcIixcblx0XCJjb25pbnRcIjogXCLiiK5cIixcblx0XCJDb25pbnRcIjogXCLiiK9cIixcblx0XCJDb250b3VySW50ZWdyYWxcIjogXCLiiK5cIixcblx0XCJjb3BmXCI6IFwi8J2VlFwiLFxuXHRcIkNvcGZcIjogXCLihIJcIixcblx0XCJjb3Byb2RcIjogXCLiiJBcIixcblx0XCJDb3Byb2R1Y3RcIjogXCLiiJBcIixcblx0XCJjb3B5XCI6IFwiwqlcIixcblx0XCJDT1BZXCI6IFwiwqlcIixcblx0XCJjb3B5c3JcIjogXCLihJdcIixcblx0XCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6IFwi4oizXCIsXG5cdFwiY3JhcnJcIjogXCLihrVcIixcblx0XCJjcm9zc1wiOiBcIuKcl1wiLFxuXHRcIkNyb3NzXCI6IFwi4qivXCIsXG5cdFwiQ3NjclwiOiBcIvCdkp5cIixcblx0XCJjc2NyXCI6IFwi8J2SuFwiLFxuXHRcImNzdWJcIjogXCLiq49cIixcblx0XCJjc3ViZVwiOiBcIuKrkVwiLFxuXHRcImNzdXBcIjogXCLiq5BcIixcblx0XCJjc3VwZVwiOiBcIuKrklwiLFxuXHRcImN0ZG90XCI6IFwi4ouvXCIsXG5cdFwiY3VkYXJybFwiOiBcIuKkuFwiLFxuXHRcImN1ZGFycnJcIjogXCLipLVcIixcblx0XCJjdWVwclwiOiBcIuKLnlwiLFxuXHRcImN1ZXNjXCI6IFwi4oufXCIsXG5cdFwiY3VsYXJyXCI6IFwi4oa2XCIsXG5cdFwiY3VsYXJycFwiOiBcIuKkvVwiLFxuXHRcImN1cGJyY2FwXCI6IFwi4qmIXCIsXG5cdFwiY3VwY2FwXCI6IFwi4qmGXCIsXG5cdFwiQ3VwQ2FwXCI6IFwi4omNXCIsXG5cdFwiY3VwXCI6IFwi4oiqXCIsXG5cdFwiQ3VwXCI6IFwi4ouTXCIsXG5cdFwiY3VwY3VwXCI6IFwi4qmKXCIsXG5cdFwiY3VwZG90XCI6IFwi4oqNXCIsXG5cdFwiY3Vwb3JcIjogXCLiqYVcIixcblx0XCJjdXBzXCI6IFwi4oiq77iAXCIsXG5cdFwiY3VyYXJyXCI6IFwi4oa3XCIsXG5cdFwiY3VyYXJybVwiOiBcIuKkvFwiLFxuXHRcImN1cmx5ZXFwcmVjXCI6IFwi4oueXCIsXG5cdFwiY3VybHllcXN1Y2NcIjogXCLii59cIixcblx0XCJjdXJseXZlZVwiOiBcIuKLjlwiLFxuXHRcImN1cmx5d2VkZ2VcIjogXCLii49cIixcblx0XCJjdXJyZW5cIjogXCLCpFwiLFxuXHRcImN1cnZlYXJyb3dsZWZ0XCI6IFwi4oa2XCIsXG5cdFwiY3VydmVhcnJvd3JpZ2h0XCI6IFwi4oa3XCIsXG5cdFwiY3V2ZWVcIjogXCLii45cIixcblx0XCJjdXdlZFwiOiBcIuKLj1wiLFxuXHRcImN3Y29uaW50XCI6IFwi4oiyXCIsXG5cdFwiY3dpbnRcIjogXCLiiLFcIixcblx0XCJjeWxjdHlcIjogXCLijK1cIixcblx0XCJkYWdnZXJcIjogXCLigKBcIixcblx0XCJEYWdnZXJcIjogXCLigKFcIixcblx0XCJkYWxldGhcIjogXCLihLhcIixcblx0XCJkYXJyXCI6IFwi4oaTXCIsXG5cdFwiRGFyclwiOiBcIuKGoVwiLFxuXHRcImRBcnJcIjogXCLih5NcIixcblx0XCJkYXNoXCI6IFwi4oCQXCIsXG5cdFwiRGFzaHZcIjogXCLiq6RcIixcblx0XCJkYXNodlwiOiBcIuKKo1wiLFxuXHRcImRia2Fyb3dcIjogXCLipI9cIixcblx0XCJkYmxhY1wiOiBcIsudXCIsXG5cdFwiRGNhcm9uXCI6IFwixI5cIixcblx0XCJkY2Fyb25cIjogXCLEj1wiLFxuXHRcIkRjeVwiOiBcItCUXCIsXG5cdFwiZGN5XCI6IFwi0LRcIixcblx0XCJkZGFnZ2VyXCI6IFwi4oChXCIsXG5cdFwiZGRhcnJcIjogXCLih4pcIixcblx0XCJERFwiOiBcIuKFhVwiLFxuXHRcImRkXCI6IFwi4oWGXCIsXG5cdFwiRERvdHJhaGRcIjogXCLipJFcIixcblx0XCJkZG90c2VxXCI6IFwi4qm3XCIsXG5cdFwiZGVnXCI6IFwiwrBcIixcblx0XCJEZWxcIjogXCLiiIdcIixcblx0XCJEZWx0YVwiOiBcIs6UXCIsXG5cdFwiZGVsdGFcIjogXCLOtFwiLFxuXHRcImRlbXB0eXZcIjogXCLiprFcIixcblx0XCJkZmlzaHRcIjogXCLipb9cIixcblx0XCJEZnJcIjogXCLwnZSHXCIsXG5cdFwiZGZyXCI6IFwi8J2UoVwiLFxuXHRcImRIYXJcIjogXCLipaVcIixcblx0XCJkaGFybFwiOiBcIuKHg1wiLFxuXHRcImRoYXJyXCI6IFwi4oeCXCIsXG5cdFwiRGlhY3JpdGljYWxBY3V0ZVwiOiBcIsK0XCIsXG5cdFwiRGlhY3JpdGljYWxEb3RcIjogXCLLmVwiLFxuXHRcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjogXCLLnVwiLFxuXHRcIkRpYWNyaXRpY2FsR3JhdmVcIjogXCJgXCIsXG5cdFwiRGlhY3JpdGljYWxUaWxkZVwiOiBcIsucXCIsXG5cdFwiZGlhbVwiOiBcIuKLhFwiLFxuXHRcImRpYW1vbmRcIjogXCLii4RcIixcblx0XCJEaWFtb25kXCI6IFwi4ouEXCIsXG5cdFwiZGlhbW9uZHN1aXRcIjogXCLimaZcIixcblx0XCJkaWFtc1wiOiBcIuKZplwiLFxuXHRcImRpZVwiOiBcIsKoXCIsXG5cdFwiRGlmZmVyZW50aWFsRFwiOiBcIuKFhlwiLFxuXHRcImRpZ2FtbWFcIjogXCLPnVwiLFxuXHRcImRpc2luXCI6IFwi4ouyXCIsXG5cdFwiZGl2XCI6IFwiw7dcIixcblx0XCJkaXZpZGVcIjogXCLDt1wiLFxuXHRcImRpdmlkZW9udGltZXNcIjogXCLii4dcIixcblx0XCJkaXZvbnhcIjogXCLii4dcIixcblx0XCJESmN5XCI6IFwi0IJcIixcblx0XCJkamN5XCI6IFwi0ZJcIixcblx0XCJkbGNvcm5cIjogXCLijJ5cIixcblx0XCJkbGNyb3BcIjogXCLijI1cIixcblx0XCJkb2xsYXJcIjogXCIkXCIsXG5cdFwiRG9wZlwiOiBcIvCdlLtcIixcblx0XCJkb3BmXCI6IFwi8J2VlVwiLFxuXHRcIkRvdFwiOiBcIsKoXCIsXG5cdFwiZG90XCI6IFwiy5lcIixcblx0XCJEb3REb3RcIjogXCLig5xcIixcblx0XCJkb3RlcVwiOiBcIuKJkFwiLFxuXHRcImRvdGVxZG90XCI6IFwi4omRXCIsXG5cdFwiRG90RXF1YWxcIjogXCLiiZBcIixcblx0XCJkb3RtaW51c1wiOiBcIuKIuFwiLFxuXHRcImRvdHBsdXNcIjogXCLiiJRcIixcblx0XCJkb3RzcXVhcmVcIjogXCLiiqFcIixcblx0XCJkb3VibGViYXJ3ZWRnZVwiOiBcIuKMhlwiLFxuXHRcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbFwiOiBcIuKIr1wiLFxuXHRcIkRvdWJsZURvdFwiOiBcIsKoXCIsXG5cdFwiRG91YmxlRG93bkFycm93XCI6IFwi4oeTXCIsXG5cdFwiRG91YmxlTGVmdEFycm93XCI6IFwi4oeQXCIsXG5cdFwiRG91YmxlTGVmdFJpZ2h0QXJyb3dcIjogXCLih5RcIixcblx0XCJEb3VibGVMZWZ0VGVlXCI6IFwi4qukXCIsXG5cdFwiRG91YmxlTG9uZ0xlZnRBcnJvd1wiOiBcIuKfuFwiLFxuXHRcIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvd1wiOiBcIuKfulwiLFxuXHRcIkRvdWJsZUxvbmdSaWdodEFycm93XCI6IFwi4p+5XCIsXG5cdFwiRG91YmxlUmlnaHRBcnJvd1wiOiBcIuKHklwiLFxuXHRcIkRvdWJsZVJpZ2h0VGVlXCI6IFwi4oqoXCIsXG5cdFwiRG91YmxlVXBBcnJvd1wiOiBcIuKHkVwiLFxuXHRcIkRvdWJsZVVwRG93bkFycm93XCI6IFwi4oeVXCIsXG5cdFwiRG91YmxlVmVydGljYWxCYXJcIjogXCLiiKVcIixcblx0XCJEb3duQXJyb3dCYXJcIjogXCLipJNcIixcblx0XCJkb3duYXJyb3dcIjogXCLihpNcIixcblx0XCJEb3duQXJyb3dcIjogXCLihpNcIixcblx0XCJEb3duYXJyb3dcIjogXCLih5NcIixcblx0XCJEb3duQXJyb3dVcEFycm93XCI6IFwi4oe1XCIsXG5cdFwiRG93bkJyZXZlXCI6IFwizJFcIixcblx0XCJkb3duZG93bmFycm93c1wiOiBcIuKHilwiLFxuXHRcImRvd25oYXJwb29ubGVmdFwiOiBcIuKHg1wiLFxuXHRcImRvd25oYXJwb29ucmlnaHRcIjogXCLih4JcIixcblx0XCJEb3duTGVmdFJpZ2h0VmVjdG9yXCI6IFwi4qWQXCIsXG5cdFwiRG93bkxlZnRUZWVWZWN0b3JcIjogXCLipZ5cIixcblx0XCJEb3duTGVmdFZlY3RvckJhclwiOiBcIuKlllwiLFxuXHRcIkRvd25MZWZ0VmVjdG9yXCI6IFwi4oa9XCIsXG5cdFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6IFwi4qWfXCIsXG5cdFwiRG93blJpZ2h0VmVjdG9yQmFyXCI6IFwi4qWXXCIsXG5cdFwiRG93blJpZ2h0VmVjdG9yXCI6IFwi4oeBXCIsXG5cdFwiRG93blRlZUFycm93XCI6IFwi4oanXCIsXG5cdFwiRG93blRlZVwiOiBcIuKKpFwiLFxuXHRcImRyYmthcm93XCI6IFwi4qSQXCIsXG5cdFwiZHJjb3JuXCI6IFwi4oyfXCIsXG5cdFwiZHJjcm9wXCI6IFwi4oyMXCIsXG5cdFwiRHNjclwiOiBcIvCdkp9cIixcblx0XCJkc2NyXCI6IFwi8J2SuVwiLFxuXHRcIkRTY3lcIjogXCLQhVwiLFxuXHRcImRzY3lcIjogXCLRlVwiLFxuXHRcImRzb2xcIjogXCLip7ZcIixcblx0XCJEc3Ryb2tcIjogXCLEkFwiLFxuXHRcImRzdHJva1wiOiBcIsSRXCIsXG5cdFwiZHRkb3RcIjogXCLii7FcIixcblx0XCJkdHJpXCI6IFwi4pa/XCIsXG5cdFwiZHRyaWZcIjogXCLilr5cIixcblx0XCJkdWFyclwiOiBcIuKHtVwiLFxuXHRcImR1aGFyXCI6IFwi4qWvXCIsXG5cdFwiZHdhbmdsZVwiOiBcIuKmplwiLFxuXHRcIkRaY3lcIjogXCLQj1wiLFxuXHRcImR6Y3lcIjogXCLRn1wiLFxuXHRcImR6aWdyYXJyXCI6IFwi4p+/XCIsXG5cdFwiRWFjdXRlXCI6IFwiw4lcIixcblx0XCJlYWN1dGVcIjogXCLDqVwiLFxuXHRcImVhc3RlclwiOiBcIuKprlwiLFxuXHRcIkVjYXJvblwiOiBcIsSaXCIsXG5cdFwiZWNhcm9uXCI6IFwixJtcIixcblx0XCJFY2lyY1wiOiBcIsOKXCIsXG5cdFwiZWNpcmNcIjogXCLDqlwiLFxuXHRcImVjaXJcIjogXCLiiZZcIixcblx0XCJlY29sb25cIjogXCLiiZVcIixcblx0XCJFY3lcIjogXCLQrVwiLFxuXHRcImVjeVwiOiBcItGNXCIsXG5cdFwiZUREb3RcIjogXCLiqbdcIixcblx0XCJFZG90XCI6IFwixJZcIixcblx0XCJlZG90XCI6IFwixJdcIixcblx0XCJlRG90XCI6IFwi4omRXCIsXG5cdFwiZWVcIjogXCLihYdcIixcblx0XCJlZkRvdFwiOiBcIuKJklwiLFxuXHRcIkVmclwiOiBcIvCdlIhcIixcblx0XCJlZnJcIjogXCLwnZSiXCIsXG5cdFwiZWdcIjogXCLiqppcIixcblx0XCJFZ3JhdmVcIjogXCLDiFwiLFxuXHRcImVncmF2ZVwiOiBcIsOoXCIsXG5cdFwiZWdzXCI6IFwi4qqWXCIsXG5cdFwiZWdzZG90XCI6IFwi4qqYXCIsXG5cdFwiZWxcIjogXCLiqplcIixcblx0XCJFbGVtZW50XCI6IFwi4oiIXCIsXG5cdFwiZWxpbnRlcnNcIjogXCLij6dcIixcblx0XCJlbGxcIjogXCLihJNcIixcblx0XCJlbHNcIjogXCLiqpVcIixcblx0XCJlbHNkb3RcIjogXCLiqpdcIixcblx0XCJFbWFjclwiOiBcIsSSXCIsXG5cdFwiZW1hY3JcIjogXCLEk1wiLFxuXHRcImVtcHR5XCI6IFwi4oiFXCIsXG5cdFwiZW1wdHlzZXRcIjogXCLiiIVcIixcblx0XCJFbXB0eVNtYWxsU3F1YXJlXCI6IFwi4pe7XCIsXG5cdFwiZW1wdHl2XCI6IFwi4oiFXCIsXG5cdFwiRW1wdHlWZXJ5U21hbGxTcXVhcmVcIjogXCLilqtcIixcblx0XCJlbXNwMTNcIjogXCLigIRcIixcblx0XCJlbXNwMTRcIjogXCLigIVcIixcblx0XCJlbXNwXCI6IFwi4oCDXCIsXG5cdFwiRU5HXCI6IFwixYpcIixcblx0XCJlbmdcIjogXCLFi1wiLFxuXHRcImVuc3BcIjogXCLigIJcIixcblx0XCJFb2dvblwiOiBcIsSYXCIsXG5cdFwiZW9nb25cIjogXCLEmVwiLFxuXHRcIkVvcGZcIjogXCLwnZS8XCIsXG5cdFwiZW9wZlwiOiBcIvCdlZZcIixcblx0XCJlcGFyXCI6IFwi4ouVXCIsXG5cdFwiZXBhcnNsXCI6IFwi4qejXCIsXG5cdFwiZXBsdXNcIjogXCLiqbFcIixcblx0XCJlcHNpXCI6IFwizrVcIixcblx0XCJFcHNpbG9uXCI6IFwizpVcIixcblx0XCJlcHNpbG9uXCI6IFwizrVcIixcblx0XCJlcHNpdlwiOiBcIs+1XCIsXG5cdFwiZXFjaXJjXCI6IFwi4omWXCIsXG5cdFwiZXFjb2xvblwiOiBcIuKJlVwiLFxuXHRcImVxc2ltXCI6IFwi4omCXCIsXG5cdFwiZXFzbGFudGd0clwiOiBcIuKqllwiLFxuXHRcImVxc2xhbnRsZXNzXCI6IFwi4qqVXCIsXG5cdFwiRXF1YWxcIjogXCLiqbVcIixcblx0XCJlcXVhbHNcIjogXCI9XCIsXG5cdFwiRXF1YWxUaWxkZVwiOiBcIuKJglwiLFxuXHRcImVxdWVzdFwiOiBcIuKJn1wiLFxuXHRcIkVxdWlsaWJyaXVtXCI6IFwi4oeMXCIsXG5cdFwiZXF1aXZcIjogXCLiiaFcIixcblx0XCJlcXVpdkREXCI6IFwi4qm4XCIsXG5cdFwiZXF2cGFyc2xcIjogXCLip6VcIixcblx0XCJlcmFyclwiOiBcIuKlsVwiLFxuXHRcImVyRG90XCI6IFwi4omTXCIsXG5cdFwiZXNjclwiOiBcIuKEr1wiLFxuXHRcIkVzY3JcIjogXCLihLBcIixcblx0XCJlc2RvdFwiOiBcIuKJkFwiLFxuXHRcIkVzaW1cIjogXCLiqbNcIixcblx0XCJlc2ltXCI6IFwi4omCXCIsXG5cdFwiRXRhXCI6IFwizpdcIixcblx0XCJldGFcIjogXCLOt1wiLFxuXHRcIkVUSFwiOiBcIsOQXCIsXG5cdFwiZXRoXCI6IFwiw7BcIixcblx0XCJFdW1sXCI6IFwiw4tcIixcblx0XCJldW1sXCI6IFwiw6tcIixcblx0XCJldXJvXCI6IFwi4oKsXCIsXG5cdFwiZXhjbFwiOiBcIiFcIixcblx0XCJleGlzdFwiOiBcIuKIg1wiLFxuXHRcIkV4aXN0c1wiOiBcIuKIg1wiLFxuXHRcImV4cGVjdGF0aW9uXCI6IFwi4oSwXCIsXG5cdFwiZXhwb25lbnRpYWxlXCI6IFwi4oWHXCIsXG5cdFwiRXhwb25lbnRpYWxFXCI6IFwi4oWHXCIsXG5cdFwiZmFsbGluZ2RvdHNlcVwiOiBcIuKJklwiLFxuXHRcIkZjeVwiOiBcItCkXCIsXG5cdFwiZmN5XCI6IFwi0YRcIixcblx0XCJmZW1hbGVcIjogXCLimYBcIixcblx0XCJmZmlsaWdcIjogXCLvrINcIixcblx0XCJmZmxpZ1wiOiBcIu+sgFwiLFxuXHRcImZmbGxpZ1wiOiBcIu+shFwiLFxuXHRcIkZmclwiOiBcIvCdlIlcIixcblx0XCJmZnJcIjogXCLwnZSjXCIsXG5cdFwiZmlsaWdcIjogXCLvrIFcIixcblx0XCJGaWxsZWRTbWFsbFNxdWFyZVwiOiBcIuKXvFwiLFxuXHRcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZVwiOiBcIuKWqlwiLFxuXHRcImZqbGlnXCI6IFwiZmpcIixcblx0XCJmbGF0XCI6IFwi4pmtXCIsXG5cdFwiZmxsaWdcIjogXCLvrIJcIixcblx0XCJmbHRuc1wiOiBcIuKWsVwiLFxuXHRcImZub2ZcIjogXCLGklwiLFxuXHRcIkZvcGZcIjogXCLwnZS9XCIsXG5cdFwiZm9wZlwiOiBcIvCdlZdcIixcblx0XCJmb3JhbGxcIjogXCLiiIBcIixcblx0XCJGb3JBbGxcIjogXCLiiIBcIixcblx0XCJmb3JrXCI6IFwi4ouUXCIsXG5cdFwiZm9ya3ZcIjogXCLiq5lcIixcblx0XCJGb3VyaWVydHJmXCI6IFwi4oSxXCIsXG5cdFwiZnBhcnRpbnRcIjogXCLiqI1cIixcblx0XCJmcmFjMTJcIjogXCLCvVwiLFxuXHRcImZyYWMxM1wiOiBcIuKFk1wiLFxuXHRcImZyYWMxNFwiOiBcIsK8XCIsXG5cdFwiZnJhYzE1XCI6IFwi4oWVXCIsXG5cdFwiZnJhYzE2XCI6IFwi4oWZXCIsXG5cdFwiZnJhYzE4XCI6IFwi4oWbXCIsXG5cdFwiZnJhYzIzXCI6IFwi4oWUXCIsXG5cdFwiZnJhYzI1XCI6IFwi4oWWXCIsXG5cdFwiZnJhYzM0XCI6IFwiwr5cIixcblx0XCJmcmFjMzVcIjogXCLihZdcIixcblx0XCJmcmFjMzhcIjogXCLihZxcIixcblx0XCJmcmFjNDVcIjogXCLihZhcIixcblx0XCJmcmFjNTZcIjogXCLihZpcIixcblx0XCJmcmFjNThcIjogXCLihZ1cIixcblx0XCJmcmFjNzhcIjogXCLihZ5cIixcblx0XCJmcmFzbFwiOiBcIuKBhFwiLFxuXHRcImZyb3duXCI6IFwi4oyiXCIsXG5cdFwiZnNjclwiOiBcIvCdkrtcIixcblx0XCJGc2NyXCI6IFwi4oSxXCIsXG5cdFwiZ2FjdXRlXCI6IFwix7VcIixcblx0XCJHYW1tYVwiOiBcIs6TXCIsXG5cdFwiZ2FtbWFcIjogXCLOs1wiLFxuXHRcIkdhbW1hZFwiOiBcIs+cXCIsXG5cdFwiZ2FtbWFkXCI6IFwiz51cIixcblx0XCJnYXBcIjogXCLiqoZcIixcblx0XCJHYnJldmVcIjogXCLEnlwiLFxuXHRcImdicmV2ZVwiOiBcIsSfXCIsXG5cdFwiR2NlZGlsXCI6IFwixKJcIixcblx0XCJHY2lyY1wiOiBcIsScXCIsXG5cdFwiZ2NpcmNcIjogXCLEnVwiLFxuXHRcIkdjeVwiOiBcItCTXCIsXG5cdFwiZ2N5XCI6IFwi0LNcIixcblx0XCJHZG90XCI6IFwixKBcIixcblx0XCJnZG90XCI6IFwixKFcIixcblx0XCJnZVwiOiBcIuKJpVwiLFxuXHRcImdFXCI6IFwi4omnXCIsXG5cdFwiZ0VsXCI6IFwi4qqMXCIsXG5cdFwiZ2VsXCI6IFwi4oubXCIsXG5cdFwiZ2VxXCI6IFwi4omlXCIsXG5cdFwiZ2VxcVwiOiBcIuKJp1wiLFxuXHRcImdlcXNsYW50XCI6IFwi4qm+XCIsXG5cdFwiZ2VzY2NcIjogXCLiqqlcIixcblx0XCJnZXNcIjogXCLiqb5cIixcblx0XCJnZXNkb3RcIjogXCLiqoBcIixcblx0XCJnZXNkb3RvXCI6IFwi4qqCXCIsXG5cdFwiZ2VzZG90b2xcIjogXCLiqoRcIixcblx0XCJnZXNsXCI6IFwi4oub77iAXCIsXG5cdFwiZ2VzbGVzXCI6IFwi4qqUXCIsXG5cdFwiR2ZyXCI6IFwi8J2UilwiLFxuXHRcImdmclwiOiBcIvCdlKRcIixcblx0XCJnZ1wiOiBcIuKJq1wiLFxuXHRcIkdnXCI6IFwi4ouZXCIsXG5cdFwiZ2dnXCI6IFwi4ouZXCIsXG5cdFwiZ2ltZWxcIjogXCLihLdcIixcblx0XCJHSmN5XCI6IFwi0INcIixcblx0XCJnamN5XCI6IFwi0ZNcIixcblx0XCJnbGFcIjogXCLiqqVcIixcblx0XCJnbFwiOiBcIuKJt1wiLFxuXHRcImdsRVwiOiBcIuKqklwiLFxuXHRcImdsalwiOiBcIuKqpFwiLFxuXHRcImduYXBcIjogXCLiqopcIixcblx0XCJnbmFwcHJveFwiOiBcIuKqilwiLFxuXHRcImduZVwiOiBcIuKqiFwiLFxuXHRcImduRVwiOiBcIuKJqVwiLFxuXHRcImduZXFcIjogXCLiqohcIixcblx0XCJnbmVxcVwiOiBcIuKJqVwiLFxuXHRcImduc2ltXCI6IFwi4ounXCIsXG5cdFwiR29wZlwiOiBcIvCdlL5cIixcblx0XCJnb3BmXCI6IFwi8J2VmFwiLFxuXHRcImdyYXZlXCI6IFwiYFwiLFxuXHRcIkdyZWF0ZXJFcXVhbFwiOiBcIuKJpVwiLFxuXHRcIkdyZWF0ZXJFcXVhbExlc3NcIjogXCLii5tcIixcblx0XCJHcmVhdGVyRnVsbEVxdWFsXCI6IFwi4omnXCIsXG5cdFwiR3JlYXRlckdyZWF0ZXJcIjogXCLiqqJcIixcblx0XCJHcmVhdGVyTGVzc1wiOiBcIuKJt1wiLFxuXHRcIkdyZWF0ZXJTbGFudEVxdWFsXCI6IFwi4qm+XCIsXG5cdFwiR3JlYXRlclRpbGRlXCI6IFwi4omzXCIsXG5cdFwiR3NjclwiOiBcIvCdkqJcIixcblx0XCJnc2NyXCI6IFwi4oSKXCIsXG5cdFwiZ3NpbVwiOiBcIuKJs1wiLFxuXHRcImdzaW1lXCI6IFwi4qqOXCIsXG5cdFwiZ3NpbWxcIjogXCLiqpBcIixcblx0XCJndGNjXCI6IFwi4qqnXCIsXG5cdFwiZ3RjaXJcIjogXCLiqbpcIixcblx0XCJndFwiOiBcIj5cIixcblx0XCJHVFwiOiBcIj5cIixcblx0XCJHdFwiOiBcIuKJq1wiLFxuXHRcImd0ZG90XCI6IFwi4ouXXCIsXG5cdFwiZ3RsUGFyXCI6IFwi4qaVXCIsXG5cdFwiZ3RxdWVzdFwiOiBcIuKpvFwiLFxuXHRcImd0cmFwcHJveFwiOiBcIuKqhlwiLFxuXHRcImd0cmFyclwiOiBcIuKluFwiLFxuXHRcImd0cmRvdFwiOiBcIuKLl1wiLFxuXHRcImd0cmVxbGVzc1wiOiBcIuKLm1wiLFxuXHRcImd0cmVxcWxlc3NcIjogXCLiqoxcIixcblx0XCJndHJsZXNzXCI6IFwi4om3XCIsXG5cdFwiZ3Ryc2ltXCI6IFwi4omzXCIsXG5cdFwiZ3ZlcnRuZXFxXCI6IFwi4omp77iAXCIsXG5cdFwiZ3ZuRVwiOiBcIuKJqe+4gFwiLFxuXHRcIkhhY2VrXCI6IFwiy4dcIixcblx0XCJoYWlyc3BcIjogXCLigIpcIixcblx0XCJoYWxmXCI6IFwiwr1cIixcblx0XCJoYW1pbHRcIjogXCLihItcIixcblx0XCJIQVJEY3lcIjogXCLQqlwiLFxuXHRcImhhcmRjeVwiOiBcItGKXCIsXG5cdFwiaGFycmNpclwiOiBcIuKliFwiLFxuXHRcImhhcnJcIjogXCLihpRcIixcblx0XCJoQXJyXCI6IFwi4oeUXCIsXG5cdFwiaGFycndcIjogXCLihq1cIixcblx0XCJIYXRcIjogXCJeXCIsXG5cdFwiaGJhclwiOiBcIuKEj1wiLFxuXHRcIkhjaXJjXCI6IFwixKRcIixcblx0XCJoY2lyY1wiOiBcIsSlXCIsXG5cdFwiaGVhcnRzXCI6IFwi4pmlXCIsXG5cdFwiaGVhcnRzdWl0XCI6IFwi4pmlXCIsXG5cdFwiaGVsbGlwXCI6IFwi4oCmXCIsXG5cdFwiaGVyY29uXCI6IFwi4oq5XCIsXG5cdFwiaGZyXCI6IFwi8J2UpVwiLFxuXHRcIkhmclwiOiBcIuKEjFwiLFxuXHRcIkhpbGJlcnRTcGFjZVwiOiBcIuKEi1wiLFxuXHRcImhrc2Vhcm93XCI6IFwi4qSlXCIsXG5cdFwiaGtzd2Fyb3dcIjogXCLipKZcIixcblx0XCJob2FyclwiOiBcIuKHv1wiLFxuXHRcImhvbXRodFwiOiBcIuKIu1wiLFxuXHRcImhvb2tsZWZ0YXJyb3dcIjogXCLihqlcIixcblx0XCJob29rcmlnaHRhcnJvd1wiOiBcIuKGqlwiLFxuXHRcImhvcGZcIjogXCLwnZWZXCIsXG5cdFwiSG9wZlwiOiBcIuKEjVwiLFxuXHRcImhvcmJhclwiOiBcIuKAlVwiLFxuXHRcIkhvcml6b250YWxMaW5lXCI6IFwi4pSAXCIsXG5cdFwiaHNjclwiOiBcIvCdkr1cIixcblx0XCJIc2NyXCI6IFwi4oSLXCIsXG5cdFwiaHNsYXNoXCI6IFwi4oSPXCIsXG5cdFwiSHN0cm9rXCI6IFwixKZcIixcblx0XCJoc3Ryb2tcIjogXCLEp1wiLFxuXHRcIkh1bXBEb3duSHVtcFwiOiBcIuKJjlwiLFxuXHRcIkh1bXBFcXVhbFwiOiBcIuKJj1wiLFxuXHRcImh5YnVsbFwiOiBcIuKBg1wiLFxuXHRcImh5cGhlblwiOiBcIuKAkFwiLFxuXHRcIklhY3V0ZVwiOiBcIsONXCIsXG5cdFwiaWFjdXRlXCI6IFwiw61cIixcblx0XCJpY1wiOiBcIuKBo1wiLFxuXHRcIkljaXJjXCI6IFwiw45cIixcblx0XCJpY2lyY1wiOiBcIsOuXCIsXG5cdFwiSWN5XCI6IFwi0JhcIixcblx0XCJpY3lcIjogXCLQuFwiLFxuXHRcIklkb3RcIjogXCLEsFwiLFxuXHRcIklFY3lcIjogXCLQlVwiLFxuXHRcImllY3lcIjogXCLQtVwiLFxuXHRcImlleGNsXCI6IFwiwqFcIixcblx0XCJpZmZcIjogXCLih5RcIixcblx0XCJpZnJcIjogXCLwnZSmXCIsXG5cdFwiSWZyXCI6IFwi4oSRXCIsXG5cdFwiSWdyYXZlXCI6IFwiw4xcIixcblx0XCJpZ3JhdmVcIjogXCLDrFwiLFxuXHRcImlpXCI6IFwi4oWIXCIsXG5cdFwiaWlpaW50XCI6IFwi4qiMXCIsXG5cdFwiaWlpbnRcIjogXCLiiK1cIixcblx0XCJpaW5maW5cIjogXCLip5xcIixcblx0XCJpaW90YVwiOiBcIuKEqVwiLFxuXHRcIklKbGlnXCI6IFwixLJcIixcblx0XCJpamxpZ1wiOiBcIsSzXCIsXG5cdFwiSW1hY3JcIjogXCLEqlwiLFxuXHRcImltYWNyXCI6IFwixKtcIixcblx0XCJpbWFnZVwiOiBcIuKEkVwiLFxuXHRcIkltYWdpbmFyeUlcIjogXCLihYhcIixcblx0XCJpbWFnbGluZVwiOiBcIuKEkFwiLFxuXHRcImltYWdwYXJ0XCI6IFwi4oSRXCIsXG5cdFwiaW1hdGhcIjogXCLEsVwiLFxuXHRcIkltXCI6IFwi4oSRXCIsXG5cdFwiaW1vZlwiOiBcIuKKt1wiLFxuXHRcImltcGVkXCI6IFwixrVcIixcblx0XCJJbXBsaWVzXCI6IFwi4oeSXCIsXG5cdFwiaW5jYXJlXCI6IFwi4oSFXCIsXG5cdFwiaW5cIjogXCLiiIhcIixcblx0XCJpbmZpblwiOiBcIuKInlwiLFxuXHRcImluZmludGllXCI6IFwi4qedXCIsXG5cdFwiaW5vZG90XCI6IFwixLFcIixcblx0XCJpbnRjYWxcIjogXCLiirpcIixcblx0XCJpbnRcIjogXCLiiKtcIixcblx0XCJJbnRcIjogXCLiiKxcIixcblx0XCJpbnRlZ2Vyc1wiOiBcIuKEpFwiLFxuXHRcIkludGVncmFsXCI6IFwi4oirXCIsXG5cdFwiaW50ZXJjYWxcIjogXCLiirpcIixcblx0XCJJbnRlcnNlY3Rpb25cIjogXCLii4JcIixcblx0XCJpbnRsYXJoa1wiOiBcIuKol1wiLFxuXHRcImludHByb2RcIjogXCLiqLxcIixcblx0XCJJbnZpc2libGVDb21tYVwiOiBcIuKBo1wiLFxuXHRcIkludmlzaWJsZVRpbWVzXCI6IFwi4oGiXCIsXG5cdFwiSU9jeVwiOiBcItCBXCIsXG5cdFwiaW9jeVwiOiBcItGRXCIsXG5cdFwiSW9nb25cIjogXCLErlwiLFxuXHRcImlvZ29uXCI6IFwixK9cIixcblx0XCJJb3BmXCI6IFwi8J2VgFwiLFxuXHRcImlvcGZcIjogXCLwnZWaXCIsXG5cdFwiSW90YVwiOiBcIs6ZXCIsXG5cdFwiaW90YVwiOiBcIs65XCIsXG5cdFwiaXByb2RcIjogXCLiqLxcIixcblx0XCJpcXVlc3RcIjogXCLCv1wiLFxuXHRcImlzY3JcIjogXCLwnZK+XCIsXG5cdFwiSXNjclwiOiBcIuKEkFwiLFxuXHRcImlzaW5cIjogXCLiiIhcIixcblx0XCJpc2luZG90XCI6IFwi4ou1XCIsXG5cdFwiaXNpbkVcIjogXCLii7lcIixcblx0XCJpc2luc1wiOiBcIuKLtFwiLFxuXHRcImlzaW5zdlwiOiBcIuKLs1wiLFxuXHRcImlzaW52XCI6IFwi4oiIXCIsXG5cdFwiaXRcIjogXCLigaJcIixcblx0XCJJdGlsZGVcIjogXCLEqFwiLFxuXHRcIml0aWxkZVwiOiBcIsSpXCIsXG5cdFwiSXVrY3lcIjogXCLQhlwiLFxuXHRcIml1a2N5XCI6IFwi0ZZcIixcblx0XCJJdW1sXCI6IFwiw49cIixcblx0XCJpdW1sXCI6IFwiw69cIixcblx0XCJKY2lyY1wiOiBcIsS0XCIsXG5cdFwiamNpcmNcIjogXCLEtVwiLFxuXHRcIkpjeVwiOiBcItCZXCIsXG5cdFwiamN5XCI6IFwi0LlcIixcblx0XCJKZnJcIjogXCLwnZSNXCIsXG5cdFwiamZyXCI6IFwi8J2Up1wiLFxuXHRcImptYXRoXCI6IFwiyLdcIixcblx0XCJKb3BmXCI6IFwi8J2VgVwiLFxuXHRcImpvcGZcIjogXCLwnZWbXCIsXG5cdFwiSnNjclwiOiBcIvCdkqVcIixcblx0XCJqc2NyXCI6IFwi8J2Sv1wiLFxuXHRcIkpzZXJjeVwiOiBcItCIXCIsXG5cdFwianNlcmN5XCI6IFwi0ZhcIixcblx0XCJKdWtjeVwiOiBcItCEXCIsXG5cdFwianVrY3lcIjogXCLRlFwiLFxuXHRcIkthcHBhXCI6IFwizppcIixcblx0XCJrYXBwYVwiOiBcIs66XCIsXG5cdFwia2FwcGF2XCI6IFwiz7BcIixcblx0XCJLY2VkaWxcIjogXCLEtlwiLFxuXHRcImtjZWRpbFwiOiBcIsS3XCIsXG5cdFwiS2N5XCI6IFwi0JpcIixcblx0XCJrY3lcIjogXCLQulwiLFxuXHRcIktmclwiOiBcIvCdlI5cIixcblx0XCJrZnJcIjogXCLwnZSoXCIsXG5cdFwia2dyZWVuXCI6IFwixLhcIixcblx0XCJLSGN5XCI6IFwi0KVcIixcblx0XCJraGN5XCI6IFwi0YVcIixcblx0XCJLSmN5XCI6IFwi0IxcIixcblx0XCJramN5XCI6IFwi0ZxcIixcblx0XCJLb3BmXCI6IFwi8J2VglwiLFxuXHRcImtvcGZcIjogXCLwnZWcXCIsXG5cdFwiS3NjclwiOiBcIvCdkqZcIixcblx0XCJrc2NyXCI6IFwi8J2TgFwiLFxuXHRcImxBYXJyXCI6IFwi4oeaXCIsXG5cdFwiTGFjdXRlXCI6IFwixLlcIixcblx0XCJsYWN1dGVcIjogXCLEulwiLFxuXHRcImxhZW1wdHl2XCI6IFwi4qa0XCIsXG5cdFwibGFncmFuXCI6IFwi4oSSXCIsXG5cdFwiTGFtYmRhXCI6IFwizptcIixcblx0XCJsYW1iZGFcIjogXCLOu1wiLFxuXHRcImxhbmdcIjogXCLin6hcIixcblx0XCJMYW5nXCI6IFwi4p+qXCIsXG5cdFwibGFuZ2RcIjogXCLippFcIixcblx0XCJsYW5nbGVcIjogXCLin6hcIixcblx0XCJsYXBcIjogXCLiqoVcIixcblx0XCJMYXBsYWNldHJmXCI6IFwi4oSSXCIsXG5cdFwibGFxdW9cIjogXCLCq1wiLFxuXHRcImxhcnJiXCI6IFwi4oekXCIsXG5cdFwibGFycmJmc1wiOiBcIuKkn1wiLFxuXHRcImxhcnJcIjogXCLihpBcIixcblx0XCJMYXJyXCI6IFwi4oaeXCIsXG5cdFwibEFyclwiOiBcIuKHkFwiLFxuXHRcImxhcnJmc1wiOiBcIuKknVwiLFxuXHRcImxhcnJoa1wiOiBcIuKGqVwiLFxuXHRcImxhcnJscFwiOiBcIuKGq1wiLFxuXHRcImxhcnJwbFwiOiBcIuKkuVwiLFxuXHRcImxhcnJzaW1cIjogXCLipbNcIixcblx0XCJsYXJydGxcIjogXCLihqJcIixcblx0XCJsYXRhaWxcIjogXCLipJlcIixcblx0XCJsQXRhaWxcIjogXCLipJtcIixcblx0XCJsYXRcIjogXCLiqqtcIixcblx0XCJsYXRlXCI6IFwi4qqtXCIsXG5cdFwibGF0ZXNcIjogXCLiqq3vuIBcIixcblx0XCJsYmFyclwiOiBcIuKkjFwiLFxuXHRcImxCYXJyXCI6IFwi4qSOXCIsXG5cdFwibGJicmtcIjogXCLinbJcIixcblx0XCJsYnJhY2VcIjogXCJ7XCIsXG5cdFwibGJyYWNrXCI6IFwiW1wiLFxuXHRcImxicmtlXCI6IFwi4qaLXCIsXG5cdFwibGJya3NsZFwiOiBcIuKmj1wiLFxuXHRcImxicmtzbHVcIjogXCLipo1cIixcblx0XCJMY2Fyb25cIjogXCLEvVwiLFxuXHRcImxjYXJvblwiOiBcIsS+XCIsXG5cdFwiTGNlZGlsXCI6IFwixLtcIixcblx0XCJsY2VkaWxcIjogXCLEvFwiLFxuXHRcImxjZWlsXCI6IFwi4oyIXCIsXG5cdFwibGN1YlwiOiBcIntcIixcblx0XCJMY3lcIjogXCLQm1wiLFxuXHRcImxjeVwiOiBcItC7XCIsXG5cdFwibGRjYVwiOiBcIuKktlwiLFxuXHRcImxkcXVvXCI6IFwi4oCcXCIsXG5cdFwibGRxdW9yXCI6IFwi4oCeXCIsXG5cdFwibGRyZGhhclwiOiBcIuKlp1wiLFxuXHRcImxkcnVzaGFyXCI6IFwi4qWLXCIsXG5cdFwibGRzaFwiOiBcIuKGslwiLFxuXHRcImxlXCI6IFwi4omkXCIsXG5cdFwibEVcIjogXCLiiaZcIixcblx0XCJMZWZ0QW5nbGVCcmFja2V0XCI6IFwi4p+oXCIsXG5cdFwiTGVmdEFycm93QmFyXCI6IFwi4oekXCIsXG5cdFwibGVmdGFycm93XCI6IFwi4oaQXCIsXG5cdFwiTGVmdEFycm93XCI6IFwi4oaQXCIsXG5cdFwiTGVmdGFycm93XCI6IFwi4oeQXCIsXG5cdFwiTGVmdEFycm93UmlnaHRBcnJvd1wiOiBcIuKHhlwiLFxuXHRcImxlZnRhcnJvd3RhaWxcIjogXCLihqJcIixcblx0XCJMZWZ0Q2VpbGluZ1wiOiBcIuKMiFwiLFxuXHRcIkxlZnREb3VibGVCcmFja2V0XCI6IFwi4p+mXCIsXG5cdFwiTGVmdERvd25UZWVWZWN0b3JcIjogXCLipaFcIixcblx0XCJMZWZ0RG93blZlY3RvckJhclwiOiBcIuKlmVwiLFxuXHRcIkxlZnREb3duVmVjdG9yXCI6IFwi4oeDXCIsXG5cdFwiTGVmdEZsb29yXCI6IFwi4oyKXCIsXG5cdFwibGVmdGhhcnBvb25kb3duXCI6IFwi4oa9XCIsXG5cdFwibGVmdGhhcnBvb251cFwiOiBcIuKGvFwiLFxuXHRcImxlZnRsZWZ0YXJyb3dzXCI6IFwi4oeHXCIsXG5cdFwibGVmdHJpZ2h0YXJyb3dcIjogXCLihpRcIixcblx0XCJMZWZ0UmlnaHRBcnJvd1wiOiBcIuKGlFwiLFxuXHRcIkxlZnRyaWdodGFycm93XCI6IFwi4oeUXCIsXG5cdFwibGVmdHJpZ2h0YXJyb3dzXCI6IFwi4oeGXCIsXG5cdFwibGVmdHJpZ2h0aGFycG9vbnNcIjogXCLih4tcIixcblx0XCJsZWZ0cmlnaHRzcXVpZ2Fycm93XCI6IFwi4oatXCIsXG5cdFwiTGVmdFJpZ2h0VmVjdG9yXCI6IFwi4qWOXCIsXG5cdFwiTGVmdFRlZUFycm93XCI6IFwi4oakXCIsXG5cdFwiTGVmdFRlZVwiOiBcIuKKo1wiLFxuXHRcIkxlZnRUZWVWZWN0b3JcIjogXCLipZpcIixcblx0XCJsZWZ0dGhyZWV0aW1lc1wiOiBcIuKLi1wiLFxuXHRcIkxlZnRUcmlhbmdsZUJhclwiOiBcIuKnj1wiLFxuXHRcIkxlZnRUcmlhbmdsZVwiOiBcIuKKslwiLFxuXHRcIkxlZnRUcmlhbmdsZUVxdWFsXCI6IFwi4oq0XCIsXG5cdFwiTGVmdFVwRG93blZlY3RvclwiOiBcIuKlkVwiLFxuXHRcIkxlZnRVcFRlZVZlY3RvclwiOiBcIuKloFwiLFxuXHRcIkxlZnRVcFZlY3RvckJhclwiOiBcIuKlmFwiLFxuXHRcIkxlZnRVcFZlY3RvclwiOiBcIuKGv1wiLFxuXHRcIkxlZnRWZWN0b3JCYXJcIjogXCLipZJcIixcblx0XCJMZWZ0VmVjdG9yXCI6IFwi4oa8XCIsXG5cdFwibEVnXCI6IFwi4qqLXCIsXG5cdFwibGVnXCI6IFwi4ouaXCIsXG5cdFwibGVxXCI6IFwi4omkXCIsXG5cdFwibGVxcVwiOiBcIuKJplwiLFxuXHRcImxlcXNsYW50XCI6IFwi4qm9XCIsXG5cdFwibGVzY2NcIjogXCLiqqhcIixcblx0XCJsZXNcIjogXCLiqb1cIixcblx0XCJsZXNkb3RcIjogXCLiqb9cIixcblx0XCJsZXNkb3RvXCI6IFwi4qqBXCIsXG5cdFwibGVzZG90b3JcIjogXCLiqoNcIixcblx0XCJsZXNnXCI6IFwi4oua77iAXCIsXG5cdFwibGVzZ2VzXCI6IFwi4qqTXCIsXG5cdFwibGVzc2FwcHJveFwiOiBcIuKqhVwiLFxuXHRcImxlc3Nkb3RcIjogXCLii5ZcIixcblx0XCJsZXNzZXFndHJcIjogXCLii5pcIixcblx0XCJsZXNzZXFxZ3RyXCI6IFwi4qqLXCIsXG5cdFwiTGVzc0VxdWFsR3JlYXRlclwiOiBcIuKLmlwiLFxuXHRcIkxlc3NGdWxsRXF1YWxcIjogXCLiiaZcIixcblx0XCJMZXNzR3JlYXRlclwiOiBcIuKJtlwiLFxuXHRcImxlc3NndHJcIjogXCLiibZcIixcblx0XCJMZXNzTGVzc1wiOiBcIuKqoVwiLFxuXHRcImxlc3NzaW1cIjogXCLiibJcIixcblx0XCJMZXNzU2xhbnRFcXVhbFwiOiBcIuKpvVwiLFxuXHRcIkxlc3NUaWxkZVwiOiBcIuKJslwiLFxuXHRcImxmaXNodFwiOiBcIuKlvFwiLFxuXHRcImxmbG9vclwiOiBcIuKMilwiLFxuXHRcIkxmclwiOiBcIvCdlI9cIixcblx0XCJsZnJcIjogXCLwnZSpXCIsXG5cdFwibGdcIjogXCLiibZcIixcblx0XCJsZ0VcIjogXCLiqpFcIixcblx0XCJsSGFyXCI6IFwi4qWiXCIsXG5cdFwibGhhcmRcIjogXCLihr1cIixcblx0XCJsaGFydVwiOiBcIuKGvFwiLFxuXHRcImxoYXJ1bFwiOiBcIuKlqlwiLFxuXHRcImxoYmxrXCI6IFwi4paEXCIsXG5cdFwiTEpjeVwiOiBcItCJXCIsXG5cdFwibGpjeVwiOiBcItGZXCIsXG5cdFwibGxhcnJcIjogXCLih4dcIixcblx0XCJsbFwiOiBcIuKJqlwiLFxuXHRcIkxsXCI6IFwi4ouYXCIsXG5cdFwibGxjb3JuZXJcIjogXCLijJ5cIixcblx0XCJMbGVmdGFycm93XCI6IFwi4oeaXCIsXG5cdFwibGxoYXJkXCI6IFwi4qWrXCIsXG5cdFwibGx0cmlcIjogXCLil7pcIixcblx0XCJMbWlkb3RcIjogXCLEv1wiLFxuXHRcImxtaWRvdFwiOiBcIsWAXCIsXG5cdFwibG1vdXN0YWNoZVwiOiBcIuKOsFwiLFxuXHRcImxtb3VzdFwiOiBcIuKOsFwiLFxuXHRcImxuYXBcIjogXCLiqolcIixcblx0XCJsbmFwcHJveFwiOiBcIuKqiVwiLFxuXHRcImxuZVwiOiBcIuKqh1wiLFxuXHRcImxuRVwiOiBcIuKJqFwiLFxuXHRcImxuZXFcIjogXCLiqodcIixcblx0XCJsbmVxcVwiOiBcIuKJqFwiLFxuXHRcImxuc2ltXCI6IFwi4oumXCIsXG5cdFwibG9hbmdcIjogXCLin6xcIixcblx0XCJsb2FyclwiOiBcIuKHvVwiLFxuXHRcImxvYnJrXCI6IFwi4p+mXCIsXG5cdFwibG9uZ2xlZnRhcnJvd1wiOiBcIuKftVwiLFxuXHRcIkxvbmdMZWZ0QXJyb3dcIjogXCLin7VcIixcblx0XCJMb25nbGVmdGFycm93XCI6IFwi4p+4XCIsXG5cdFwibG9uZ2xlZnRyaWdodGFycm93XCI6IFwi4p+3XCIsXG5cdFwiTG9uZ0xlZnRSaWdodEFycm93XCI6IFwi4p+3XCIsXG5cdFwiTG9uZ2xlZnRyaWdodGFycm93XCI6IFwi4p+6XCIsXG5cdFwibG9uZ21hcHN0b1wiOiBcIuKfvFwiLFxuXHRcImxvbmdyaWdodGFycm93XCI6IFwi4p+2XCIsXG5cdFwiTG9uZ1JpZ2h0QXJyb3dcIjogXCLin7ZcIixcblx0XCJMb25ncmlnaHRhcnJvd1wiOiBcIuKfuVwiLFxuXHRcImxvb3BhcnJvd2xlZnRcIjogXCLihqtcIixcblx0XCJsb29wYXJyb3dyaWdodFwiOiBcIuKGrFwiLFxuXHRcImxvcGFyXCI6IFwi4qaFXCIsXG5cdFwiTG9wZlwiOiBcIvCdlYNcIixcblx0XCJsb3BmXCI6IFwi8J2VnVwiLFxuXHRcImxvcGx1c1wiOiBcIuKorVwiLFxuXHRcImxvdGltZXNcIjogXCLiqLRcIixcblx0XCJsb3dhc3RcIjogXCLiiJdcIixcblx0XCJsb3diYXJcIjogXCJfXCIsXG5cdFwiTG93ZXJMZWZ0QXJyb3dcIjogXCLihplcIixcblx0XCJMb3dlclJpZ2h0QXJyb3dcIjogXCLihphcIixcblx0XCJsb3pcIjogXCLil4pcIixcblx0XCJsb3plbmdlXCI6IFwi4peKXCIsXG5cdFwibG96ZlwiOiBcIuKnq1wiLFxuXHRcImxwYXJcIjogXCIoXCIsXG5cdFwibHBhcmx0XCI6IFwi4qaTXCIsXG5cdFwibHJhcnJcIjogXCLih4ZcIixcblx0XCJscmNvcm5lclwiOiBcIuKMn1wiLFxuXHRcImxyaGFyXCI6IFwi4oeLXCIsXG5cdFwibHJoYXJkXCI6IFwi4qWtXCIsXG5cdFwibHJtXCI6IFwi4oCOXCIsXG5cdFwibHJ0cmlcIjogXCLiir9cIixcblx0XCJsc2FxdW9cIjogXCLigLlcIixcblx0XCJsc2NyXCI6IFwi8J2TgVwiLFxuXHRcIkxzY3JcIjogXCLihJJcIixcblx0XCJsc2hcIjogXCLihrBcIixcblx0XCJMc2hcIjogXCLihrBcIixcblx0XCJsc2ltXCI6IFwi4omyXCIsXG5cdFwibHNpbWVcIjogXCLiqo1cIixcblx0XCJsc2ltZ1wiOiBcIuKqj1wiLFxuXHRcImxzcWJcIjogXCJbXCIsXG5cdFwibHNxdW9cIjogXCLigJhcIixcblx0XCJsc3F1b3JcIjogXCLigJpcIixcblx0XCJMc3Ryb2tcIjogXCLFgVwiLFxuXHRcImxzdHJva1wiOiBcIsWCXCIsXG5cdFwibHRjY1wiOiBcIuKqplwiLFxuXHRcImx0Y2lyXCI6IFwi4qm5XCIsXG5cdFwibHRcIjogXCI8XCIsXG5cdFwiTFRcIjogXCI8XCIsXG5cdFwiTHRcIjogXCLiiapcIixcblx0XCJsdGRvdFwiOiBcIuKLllwiLFxuXHRcImx0aHJlZVwiOiBcIuKLi1wiLFxuXHRcImx0aW1lc1wiOiBcIuKLiVwiLFxuXHRcImx0bGFyclwiOiBcIuKltlwiLFxuXHRcImx0cXVlc3RcIjogXCLiqbtcIixcblx0XCJsdHJpXCI6IFwi4peDXCIsXG5cdFwibHRyaWVcIjogXCLiirRcIixcblx0XCJsdHJpZlwiOiBcIuKXglwiLFxuXHRcImx0clBhclwiOiBcIuKmllwiLFxuXHRcImx1cmRzaGFyXCI6IFwi4qWKXCIsXG5cdFwibHVydWhhclwiOiBcIuKlplwiLFxuXHRcImx2ZXJ0bmVxcVwiOiBcIuKJqO+4gFwiLFxuXHRcImx2bkVcIjogXCLiiajvuIBcIixcblx0XCJtYWNyXCI6IFwiwq9cIixcblx0XCJtYWxlXCI6IFwi4pmCXCIsXG5cdFwibWFsdFwiOiBcIuKcoFwiLFxuXHRcIm1hbHRlc2VcIjogXCLinKBcIixcblx0XCJNYXBcIjogXCLipIVcIixcblx0XCJtYXBcIjogXCLihqZcIixcblx0XCJtYXBzdG9cIjogXCLihqZcIixcblx0XCJtYXBzdG9kb3duXCI6IFwi4oanXCIsXG5cdFwibWFwc3RvbGVmdFwiOiBcIuKGpFwiLFxuXHRcIm1hcHN0b3VwXCI6IFwi4oalXCIsXG5cdFwibWFya2VyXCI6IFwi4pauXCIsXG5cdFwibWNvbW1hXCI6IFwi4qipXCIsXG5cdFwiTWN5XCI6IFwi0JxcIixcblx0XCJtY3lcIjogXCLQvFwiLFxuXHRcIm1kYXNoXCI6IFwi4oCUXCIsXG5cdFwibUREb3RcIjogXCLiiLpcIixcblx0XCJtZWFzdXJlZGFuZ2xlXCI6IFwi4oihXCIsXG5cdFwiTWVkaXVtU3BhY2VcIjogXCLigZ9cIixcblx0XCJNZWxsaW50cmZcIjogXCLihLNcIixcblx0XCJNZnJcIjogXCLwnZSQXCIsXG5cdFwibWZyXCI6IFwi8J2UqlwiLFxuXHRcIm1ob1wiOiBcIuKEp1wiLFxuXHRcIm1pY3JvXCI6IFwiwrVcIixcblx0XCJtaWRhc3RcIjogXCIqXCIsXG5cdFwibWlkY2lyXCI6IFwi4quwXCIsXG5cdFwibWlkXCI6IFwi4oijXCIsXG5cdFwibWlkZG90XCI6IFwiwrdcIixcblx0XCJtaW51c2JcIjogXCLiip9cIixcblx0XCJtaW51c1wiOiBcIuKIklwiLFxuXHRcIm1pbnVzZFwiOiBcIuKIuFwiLFxuXHRcIm1pbnVzZHVcIjogXCLiqKpcIixcblx0XCJNaW51c1BsdXNcIjogXCLiiJNcIixcblx0XCJtbGNwXCI6IFwi4qubXCIsXG5cdFwibWxkclwiOiBcIuKAplwiLFxuXHRcIm1ucGx1c1wiOiBcIuKIk1wiLFxuXHRcIm1vZGVsc1wiOiBcIuKKp1wiLFxuXHRcIk1vcGZcIjogXCLwnZWEXCIsXG5cdFwibW9wZlwiOiBcIvCdlZ5cIixcblx0XCJtcFwiOiBcIuKIk1wiLFxuXHRcIm1zY3JcIjogXCLwnZOCXCIsXG5cdFwiTXNjclwiOiBcIuKEs1wiLFxuXHRcIm1zdHBvc1wiOiBcIuKIvlwiLFxuXHRcIk11XCI6IFwizpxcIixcblx0XCJtdVwiOiBcIs68XCIsXG5cdFwibXVsdGltYXBcIjogXCLiirhcIixcblx0XCJtdW1hcFwiOiBcIuKKuFwiLFxuXHRcIm5hYmxhXCI6IFwi4oiHXCIsXG5cdFwiTmFjdXRlXCI6IFwixYNcIixcblx0XCJuYWN1dGVcIjogXCLFhFwiLFxuXHRcIm5hbmdcIjogXCLiiKDig5JcIixcblx0XCJuYXBcIjogXCLiiYlcIixcblx0XCJuYXBFXCI6IFwi4qmwzLhcIixcblx0XCJuYXBpZFwiOiBcIuKJi8y4XCIsXG5cdFwibmFwb3NcIjogXCLFiVwiLFxuXHRcIm5hcHByb3hcIjogXCLiiYlcIixcblx0XCJuYXR1cmFsXCI6IFwi4pmuXCIsXG5cdFwibmF0dXJhbHNcIjogXCLihJVcIixcblx0XCJuYXR1clwiOiBcIuKZrlwiLFxuXHRcIm5ic3BcIjogXCLCoFwiLFxuXHRcIm5idW1wXCI6IFwi4omOzLhcIixcblx0XCJuYnVtcGVcIjogXCLiiY/MuFwiLFxuXHRcIm5jYXBcIjogXCLiqYNcIixcblx0XCJOY2Fyb25cIjogXCLFh1wiLFxuXHRcIm5jYXJvblwiOiBcIsWIXCIsXG5cdFwiTmNlZGlsXCI6IFwixYVcIixcblx0XCJuY2VkaWxcIjogXCLFhlwiLFxuXHRcIm5jb25nXCI6IFwi4omHXCIsXG5cdFwibmNvbmdkb3RcIjogXCLiqa3MuFwiLFxuXHRcIm5jdXBcIjogXCLiqYJcIixcblx0XCJOY3lcIjogXCLQnVwiLFxuXHRcIm5jeVwiOiBcItC9XCIsXG5cdFwibmRhc2hcIjogXCLigJNcIixcblx0XCJuZWFyaGtcIjogXCLipKRcIixcblx0XCJuZWFyclwiOiBcIuKGl1wiLFxuXHRcIm5lQXJyXCI6IFwi4oeXXCIsXG5cdFwibmVhcnJvd1wiOiBcIuKGl1wiLFxuXHRcIm5lXCI6IFwi4omgXCIsXG5cdFwibmVkb3RcIjogXCLiiZDMuFwiLFxuXHRcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjogXCLigItcIixcblx0XCJOZWdhdGl2ZVRoaWNrU3BhY2VcIjogXCLigItcIixcblx0XCJOZWdhdGl2ZVRoaW5TcGFjZVwiOiBcIuKAi1wiLFxuXHRcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOiBcIuKAi1wiLFxuXHRcIm5lcXVpdlwiOiBcIuKJolwiLFxuXHRcIm5lc2VhclwiOiBcIuKkqFwiLFxuXHRcIm5lc2ltXCI6IFwi4omCzLhcIixcblx0XCJOZXN0ZWRHcmVhdGVyR3JlYXRlclwiOiBcIuKJq1wiLFxuXHRcIk5lc3RlZExlc3NMZXNzXCI6IFwi4omqXCIsXG5cdFwiTmV3TGluZVwiOiBcIlxcblwiLFxuXHRcIm5leGlzdFwiOiBcIuKIhFwiLFxuXHRcIm5leGlzdHNcIjogXCLiiIRcIixcblx0XCJOZnJcIjogXCLwnZSRXCIsXG5cdFwibmZyXCI6IFwi8J2Uq1wiLFxuXHRcIm5nRVwiOiBcIuKJp8y4XCIsXG5cdFwibmdlXCI6IFwi4omxXCIsXG5cdFwibmdlcVwiOiBcIuKJsVwiLFxuXHRcIm5nZXFxXCI6IFwi4omnzLhcIixcblx0XCJuZ2Vxc2xhbnRcIjogXCLiqb7MuFwiLFxuXHRcIm5nZXNcIjogXCLiqb7MuFwiLFxuXHRcIm5HZ1wiOiBcIuKLmcy4XCIsXG5cdFwibmdzaW1cIjogXCLiibVcIixcblx0XCJuR3RcIjogXCLiiavig5JcIixcblx0XCJuZ3RcIjogXCLiia9cIixcblx0XCJuZ3RyXCI6IFwi4omvXCIsXG5cdFwibkd0dlwiOiBcIuKJq8y4XCIsXG5cdFwibmhhcnJcIjogXCLihq5cIixcblx0XCJuaEFyclwiOiBcIuKHjlwiLFxuXHRcIm5ocGFyXCI6IFwi4quyXCIsXG5cdFwibmlcIjogXCLiiItcIixcblx0XCJuaXNcIjogXCLii7xcIixcblx0XCJuaXNkXCI6IFwi4ou6XCIsXG5cdFwibml2XCI6IFwi4oiLXCIsXG5cdFwiTkpjeVwiOiBcItCKXCIsXG5cdFwibmpjeVwiOiBcItGaXCIsXG5cdFwibmxhcnJcIjogXCLihppcIixcblx0XCJubEFyclwiOiBcIuKHjVwiLFxuXHRcIm5sZHJcIjogXCLigKVcIixcblx0XCJubEVcIjogXCLiiabMuFwiLFxuXHRcIm5sZVwiOiBcIuKJsFwiLFxuXHRcIm5sZWZ0YXJyb3dcIjogXCLihppcIixcblx0XCJuTGVmdGFycm93XCI6IFwi4oeNXCIsXG5cdFwibmxlZnRyaWdodGFycm93XCI6IFwi4oauXCIsXG5cdFwibkxlZnRyaWdodGFycm93XCI6IFwi4oeOXCIsXG5cdFwibmxlcVwiOiBcIuKJsFwiLFxuXHRcIm5sZXFxXCI6IFwi4ommzLhcIixcblx0XCJubGVxc2xhbnRcIjogXCLiqb3MuFwiLFxuXHRcIm5sZXNcIjogXCLiqb3MuFwiLFxuXHRcIm5sZXNzXCI6IFwi4omuXCIsXG5cdFwibkxsXCI6IFwi4ouYzLhcIixcblx0XCJubHNpbVwiOiBcIuKJtFwiLFxuXHRcIm5MdFwiOiBcIuKJquKDklwiLFxuXHRcIm5sdFwiOiBcIuKJrlwiLFxuXHRcIm5sdHJpXCI6IFwi4ouqXCIsXG5cdFwibmx0cmllXCI6IFwi4ousXCIsXG5cdFwibkx0dlwiOiBcIuKJqsy4XCIsXG5cdFwibm1pZFwiOiBcIuKIpFwiLFxuXHRcIk5vQnJlYWtcIjogXCLigaBcIixcblx0XCJOb25CcmVha2luZ1NwYWNlXCI6IFwiwqBcIixcblx0XCJub3BmXCI6IFwi8J2Vn1wiLFxuXHRcIk5vcGZcIjogXCLihJVcIixcblx0XCJOb3RcIjogXCLiq6xcIixcblx0XCJub3RcIjogXCLCrFwiLFxuXHRcIk5vdENvbmdydWVudFwiOiBcIuKJolwiLFxuXHRcIk5vdEN1cENhcFwiOiBcIuKJrVwiLFxuXHRcIk5vdERvdWJsZVZlcnRpY2FsQmFyXCI6IFwi4oimXCIsXG5cdFwiTm90RWxlbWVudFwiOiBcIuKIiVwiLFxuXHRcIk5vdEVxdWFsXCI6IFwi4omgXCIsXG5cdFwiTm90RXF1YWxUaWxkZVwiOiBcIuKJgsy4XCIsXG5cdFwiTm90RXhpc3RzXCI6IFwi4oiEXCIsXG5cdFwiTm90R3JlYXRlclwiOiBcIuKJr1wiLFxuXHRcIk5vdEdyZWF0ZXJFcXVhbFwiOiBcIuKJsVwiLFxuXHRcIk5vdEdyZWF0ZXJGdWxsRXF1YWxcIjogXCLiiafMuFwiLFxuXHRcIk5vdEdyZWF0ZXJHcmVhdGVyXCI6IFwi4omrzLhcIixcblx0XCJOb3RHcmVhdGVyTGVzc1wiOiBcIuKJuVwiLFxuXHRcIk5vdEdyZWF0ZXJTbGFudEVxdWFsXCI6IFwi4qm+zLhcIixcblx0XCJOb3RHcmVhdGVyVGlsZGVcIjogXCLiibVcIixcblx0XCJOb3RIdW1wRG93bkh1bXBcIjogXCLiiY7MuFwiLFxuXHRcIk5vdEh1bXBFcXVhbFwiOiBcIuKJj8y4XCIsXG5cdFwibm90aW5cIjogXCLiiIlcIixcblx0XCJub3RpbmRvdFwiOiBcIuKLtcy4XCIsXG5cdFwibm90aW5FXCI6IFwi4ou5zLhcIixcblx0XCJub3RpbnZhXCI6IFwi4oiJXCIsXG5cdFwibm90aW52YlwiOiBcIuKLt1wiLFxuXHRcIm5vdGludmNcIjogXCLii7ZcIixcblx0XCJOb3RMZWZ0VHJpYW5nbGVCYXJcIjogXCLip4/MuFwiLFxuXHRcIk5vdExlZnRUcmlhbmdsZVwiOiBcIuKLqlwiLFxuXHRcIk5vdExlZnRUcmlhbmdsZUVxdWFsXCI6IFwi4ousXCIsXG5cdFwiTm90TGVzc1wiOiBcIuKJrlwiLFxuXHRcIk5vdExlc3NFcXVhbFwiOiBcIuKJsFwiLFxuXHRcIk5vdExlc3NHcmVhdGVyXCI6IFwi4om4XCIsXG5cdFwiTm90TGVzc0xlc3NcIjogXCLiiarMuFwiLFxuXHRcIk5vdExlc3NTbGFudEVxdWFsXCI6IFwi4qm9zLhcIixcblx0XCJOb3RMZXNzVGlsZGVcIjogXCLiibRcIixcblx0XCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlclwiOiBcIuKqosy4XCIsXG5cdFwiTm90TmVzdGVkTGVzc0xlc3NcIjogXCLiqqHMuFwiLFxuXHRcIm5vdG5pXCI6IFwi4oiMXCIsXG5cdFwibm90bml2YVwiOiBcIuKIjFwiLFxuXHRcIm5vdG5pdmJcIjogXCLii75cIixcblx0XCJub3RuaXZjXCI6IFwi4ou9XCIsXG5cdFwiTm90UHJlY2VkZXNcIjogXCLiioBcIixcblx0XCJOb3RQcmVjZWRlc0VxdWFsXCI6IFwi4qqvzLhcIixcblx0XCJOb3RQcmVjZWRlc1NsYW50RXF1YWxcIjogXCLii6BcIixcblx0XCJOb3RSZXZlcnNlRWxlbWVudFwiOiBcIuKIjFwiLFxuXHRcIk5vdFJpZ2h0VHJpYW5nbGVCYXJcIjogXCLip5DMuFwiLFxuXHRcIk5vdFJpZ2h0VHJpYW5nbGVcIjogXCLii6tcIixcblx0XCJOb3RSaWdodFRyaWFuZ2xlRXF1YWxcIjogXCLii61cIixcblx0XCJOb3RTcXVhcmVTdWJzZXRcIjogXCLiio/MuFwiLFxuXHRcIk5vdFNxdWFyZVN1YnNldEVxdWFsXCI6IFwi4ouiXCIsXG5cdFwiTm90U3F1YXJlU3VwZXJzZXRcIjogXCLiipDMuFwiLFxuXHRcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWxcIjogXCLii6NcIixcblx0XCJOb3RTdWJzZXRcIjogXCLiioLig5JcIixcblx0XCJOb3RTdWJzZXRFcXVhbFwiOiBcIuKKiFwiLFxuXHRcIk5vdFN1Y2NlZWRzXCI6IFwi4oqBXCIsXG5cdFwiTm90U3VjY2VlZHNFcXVhbFwiOiBcIuKqsMy4XCIsXG5cdFwiTm90U3VjY2VlZHNTbGFudEVxdWFsXCI6IFwi4ouhXCIsXG5cdFwiTm90U3VjY2VlZHNUaWxkZVwiOiBcIuKJv8y4XCIsXG5cdFwiTm90U3VwZXJzZXRcIjogXCLiioPig5JcIixcblx0XCJOb3RTdXBlcnNldEVxdWFsXCI6IFwi4oqJXCIsXG5cdFwiTm90VGlsZGVcIjogXCLiiYFcIixcblx0XCJOb3RUaWxkZUVxdWFsXCI6IFwi4omEXCIsXG5cdFwiTm90VGlsZGVGdWxsRXF1YWxcIjogXCLiiYdcIixcblx0XCJOb3RUaWxkZVRpbGRlXCI6IFwi4omJXCIsXG5cdFwiTm90VmVydGljYWxCYXJcIjogXCLiiKRcIixcblx0XCJucGFyYWxsZWxcIjogXCLiiKZcIixcblx0XCJucGFyXCI6IFwi4oimXCIsXG5cdFwibnBhcnNsXCI6IFwi4qu94oOlXCIsXG5cdFwibnBhcnRcIjogXCLiiILMuFwiLFxuXHRcIm5wb2xpbnRcIjogXCLiqJRcIixcblx0XCJucHJcIjogXCLiioBcIixcblx0XCJucHJjdWVcIjogXCLii6BcIixcblx0XCJucHJlY1wiOiBcIuKKgFwiLFxuXHRcIm5wcmVjZXFcIjogXCLiqq/MuFwiLFxuXHRcIm5wcmVcIjogXCLiqq/MuFwiLFxuXHRcIm5yYXJyY1wiOiBcIuKks8y4XCIsXG5cdFwibnJhcnJcIjogXCLihptcIixcblx0XCJuckFyclwiOiBcIuKHj1wiLFxuXHRcIm5yYXJyd1wiOiBcIuKGncy4XCIsXG5cdFwibnJpZ2h0YXJyb3dcIjogXCLihptcIixcblx0XCJuUmlnaHRhcnJvd1wiOiBcIuKHj1wiLFxuXHRcIm5ydHJpXCI6IFwi4ourXCIsXG5cdFwibnJ0cmllXCI6IFwi4outXCIsXG5cdFwibnNjXCI6IFwi4oqBXCIsXG5cdFwibnNjY3VlXCI6IFwi4ouhXCIsXG5cdFwibnNjZVwiOiBcIuKqsMy4XCIsXG5cdFwiTnNjclwiOiBcIvCdkqlcIixcblx0XCJuc2NyXCI6IFwi8J2Tg1wiLFxuXHRcIm5zaG9ydG1pZFwiOiBcIuKIpFwiLFxuXHRcIm5zaG9ydHBhcmFsbGVsXCI6IFwi4oimXCIsXG5cdFwibnNpbVwiOiBcIuKJgVwiLFxuXHRcIm5zaW1lXCI6IFwi4omEXCIsXG5cdFwibnNpbWVxXCI6IFwi4omEXCIsXG5cdFwibnNtaWRcIjogXCLiiKRcIixcblx0XCJuc3BhclwiOiBcIuKIplwiLFxuXHRcIm5zcXN1YmVcIjogXCLii6JcIixcblx0XCJuc3FzdXBlXCI6IFwi4oujXCIsXG5cdFwibnN1YlwiOiBcIuKKhFwiLFxuXHRcIm5zdWJFXCI6IFwi4quFzLhcIixcblx0XCJuc3ViZVwiOiBcIuKKiFwiLFxuXHRcIm5zdWJzZXRcIjogXCLiioLig5JcIixcblx0XCJuc3Vic2V0ZXFcIjogXCLiiohcIixcblx0XCJuc3Vic2V0ZXFxXCI6IFwi4quFzLhcIixcblx0XCJuc3VjY1wiOiBcIuKKgVwiLFxuXHRcIm5zdWNjZXFcIjogXCLiqrDMuFwiLFxuXHRcIm5zdXBcIjogXCLiioVcIixcblx0XCJuc3VwRVwiOiBcIuKrhsy4XCIsXG5cdFwibnN1cGVcIjogXCLiiolcIixcblx0XCJuc3Vwc2V0XCI6IFwi4oqD4oOSXCIsXG5cdFwibnN1cHNldGVxXCI6IFwi4oqJXCIsXG5cdFwibnN1cHNldGVxcVwiOiBcIuKrhsy4XCIsXG5cdFwibnRnbFwiOiBcIuKJuVwiLFxuXHRcIk50aWxkZVwiOiBcIsORXCIsXG5cdFwibnRpbGRlXCI6IFwiw7FcIixcblx0XCJudGxnXCI6IFwi4om4XCIsXG5cdFwibnRyaWFuZ2xlbGVmdFwiOiBcIuKLqlwiLFxuXHRcIm50cmlhbmdsZWxlZnRlcVwiOiBcIuKLrFwiLFxuXHRcIm50cmlhbmdsZXJpZ2h0XCI6IFwi4ourXCIsXG5cdFwibnRyaWFuZ2xlcmlnaHRlcVwiOiBcIuKLrVwiLFxuXHRcIk51XCI6IFwizp1cIixcblx0XCJudVwiOiBcIs69XCIsXG5cdFwibnVtXCI6IFwiI1wiLFxuXHRcIm51bWVyb1wiOiBcIuKEllwiLFxuXHRcIm51bXNwXCI6IFwi4oCHXCIsXG5cdFwibnZhcFwiOiBcIuKJjeKDklwiLFxuXHRcIm52ZGFzaFwiOiBcIuKKrFwiLFxuXHRcIm52RGFzaFwiOiBcIuKKrVwiLFxuXHRcIm5WZGFzaFwiOiBcIuKKrlwiLFxuXHRcIm5WRGFzaFwiOiBcIuKKr1wiLFxuXHRcIm52Z2VcIjogXCLiiaXig5JcIixcblx0XCJudmd0XCI6IFwiPuKDklwiLFxuXHRcIm52SGFyclwiOiBcIuKkhFwiLFxuXHRcIm52aW5maW5cIjogXCLip55cIixcblx0XCJudmxBcnJcIjogXCLipIJcIixcblx0XCJudmxlXCI6IFwi4omk4oOSXCIsXG5cdFwibnZsdFwiOiBcIjzig5JcIixcblx0XCJudmx0cmllXCI6IFwi4oq04oOSXCIsXG5cdFwibnZyQXJyXCI6IFwi4qSDXCIsXG5cdFwibnZydHJpZVwiOiBcIuKKteKDklwiLFxuXHRcIm52c2ltXCI6IFwi4oi84oOSXCIsXG5cdFwibndhcmhrXCI6IFwi4qSjXCIsXG5cdFwibndhcnJcIjogXCLihpZcIixcblx0XCJud0FyclwiOiBcIuKHllwiLFxuXHRcIm53YXJyb3dcIjogXCLihpZcIixcblx0XCJud25lYXJcIjogXCLipKdcIixcblx0XCJPYWN1dGVcIjogXCLDk1wiLFxuXHRcIm9hY3V0ZVwiOiBcIsOzXCIsXG5cdFwib2FzdFwiOiBcIuKKm1wiLFxuXHRcIk9jaXJjXCI6IFwiw5RcIixcblx0XCJvY2lyY1wiOiBcIsO0XCIsXG5cdFwib2NpclwiOiBcIuKKmlwiLFxuXHRcIk9jeVwiOiBcItCeXCIsXG5cdFwib2N5XCI6IFwi0L5cIixcblx0XCJvZGFzaFwiOiBcIuKKnVwiLFxuXHRcIk9kYmxhY1wiOiBcIsWQXCIsXG5cdFwib2RibGFjXCI6IFwixZFcIixcblx0XCJvZGl2XCI6IFwi4qi4XCIsXG5cdFwib2RvdFwiOiBcIuKKmVwiLFxuXHRcIm9kc29sZFwiOiBcIuKmvFwiLFxuXHRcIk9FbGlnXCI6IFwixZJcIixcblx0XCJvZWxpZ1wiOiBcIsWTXCIsXG5cdFwib2ZjaXJcIjogXCLipr9cIixcblx0XCJPZnJcIjogXCLwnZSSXCIsXG5cdFwib2ZyXCI6IFwi8J2UrFwiLFxuXHRcIm9nb25cIjogXCLLm1wiLFxuXHRcIk9ncmF2ZVwiOiBcIsOSXCIsXG5cdFwib2dyYXZlXCI6IFwiw7JcIixcblx0XCJvZ3RcIjogXCLip4FcIixcblx0XCJvaGJhclwiOiBcIuKmtVwiLFxuXHRcIm9obVwiOiBcIs6pXCIsXG5cdFwib2ludFwiOiBcIuKIrlwiLFxuXHRcIm9sYXJyXCI6IFwi4oa6XCIsXG5cdFwib2xjaXJcIjogXCLipr5cIixcblx0XCJvbGNyb3NzXCI6IFwi4qa7XCIsXG5cdFwib2xpbmVcIjogXCLigL5cIixcblx0XCJvbHRcIjogXCLip4BcIixcblx0XCJPbWFjclwiOiBcIsWMXCIsXG5cdFwib21hY3JcIjogXCLFjVwiLFxuXHRcIk9tZWdhXCI6IFwizqlcIixcblx0XCJvbWVnYVwiOiBcIs+JXCIsXG5cdFwiT21pY3JvblwiOiBcIs6fXCIsXG5cdFwib21pY3JvblwiOiBcIs6/XCIsXG5cdFwib21pZFwiOiBcIuKmtlwiLFxuXHRcIm9taW51c1wiOiBcIuKKllwiLFxuXHRcIk9vcGZcIjogXCLwnZWGXCIsXG5cdFwib29wZlwiOiBcIvCdlaBcIixcblx0XCJvcGFyXCI6IFwi4qa3XCIsXG5cdFwiT3BlbkN1cmx5RG91YmxlUXVvdGVcIjogXCLigJxcIixcblx0XCJPcGVuQ3VybHlRdW90ZVwiOiBcIuKAmFwiLFxuXHRcIm9wZXJwXCI6IFwi4qa5XCIsXG5cdFwib3BsdXNcIjogXCLiipVcIixcblx0XCJvcmFyclwiOiBcIuKGu1wiLFxuXHRcIk9yXCI6IFwi4qmUXCIsXG5cdFwib3JcIjogXCLiiKhcIixcblx0XCJvcmRcIjogXCLiqZ1cIixcblx0XCJvcmRlclwiOiBcIuKEtFwiLFxuXHRcIm9yZGVyb2ZcIjogXCLihLRcIixcblx0XCJvcmRmXCI6IFwiwqpcIixcblx0XCJvcmRtXCI6IFwiwrpcIixcblx0XCJvcmlnb2ZcIjogXCLiirZcIixcblx0XCJvcm9yXCI6IFwi4qmWXCIsXG5cdFwib3JzbG9wZVwiOiBcIuKpl1wiLFxuXHRcIm9ydlwiOiBcIuKpm1wiLFxuXHRcIm9TXCI6IFwi4pOIXCIsXG5cdFwiT3NjclwiOiBcIvCdkqpcIixcblx0XCJvc2NyXCI6IFwi4oS0XCIsXG5cdFwiT3NsYXNoXCI6IFwiw5hcIixcblx0XCJvc2xhc2hcIjogXCLDuFwiLFxuXHRcIm9zb2xcIjogXCLiiphcIixcblx0XCJPdGlsZGVcIjogXCLDlVwiLFxuXHRcIm90aWxkZVwiOiBcIsO1XCIsXG5cdFwib3RpbWVzYXNcIjogXCLiqLZcIixcblx0XCJPdGltZXNcIjogXCLiqLdcIixcblx0XCJvdGltZXNcIjogXCLiipdcIixcblx0XCJPdW1sXCI6IFwiw5ZcIixcblx0XCJvdW1sXCI6IFwiw7ZcIixcblx0XCJvdmJhclwiOiBcIuKMvVwiLFxuXHRcIk92ZXJCYXJcIjogXCLigL5cIixcblx0XCJPdmVyQnJhY2VcIjogXCLij55cIixcblx0XCJPdmVyQnJhY2tldFwiOiBcIuKOtFwiLFxuXHRcIk92ZXJQYXJlbnRoZXNpc1wiOiBcIuKPnFwiLFxuXHRcInBhcmFcIjogXCLCtlwiLFxuXHRcInBhcmFsbGVsXCI6IFwi4oilXCIsXG5cdFwicGFyXCI6IFwi4oilXCIsXG5cdFwicGFyc2ltXCI6IFwi4quzXCIsXG5cdFwicGFyc2xcIjogXCLiq71cIixcblx0XCJwYXJ0XCI6IFwi4oiCXCIsXG5cdFwiUGFydGlhbERcIjogXCLiiIJcIixcblx0XCJQY3lcIjogXCLQn1wiLFxuXHRcInBjeVwiOiBcItC/XCIsXG5cdFwicGVyY250XCI6IFwiJVwiLFxuXHRcInBlcmlvZFwiOiBcIi5cIixcblx0XCJwZXJtaWxcIjogXCLigLBcIixcblx0XCJwZXJwXCI6IFwi4oqlXCIsXG5cdFwicGVydGVua1wiOiBcIuKAsVwiLFxuXHRcIlBmclwiOiBcIvCdlJNcIixcblx0XCJwZnJcIjogXCLwnZStXCIsXG5cdFwiUGhpXCI6IFwizqZcIixcblx0XCJwaGlcIjogXCLPhlwiLFxuXHRcInBoaXZcIjogXCLPlVwiLFxuXHRcInBobW1hdFwiOiBcIuKEs1wiLFxuXHRcInBob25lXCI6IFwi4piOXCIsXG5cdFwiUGlcIjogXCLOoFwiLFxuXHRcInBpXCI6IFwiz4BcIixcblx0XCJwaXRjaGZvcmtcIjogXCLii5RcIixcblx0XCJwaXZcIjogXCLPllwiLFxuXHRcInBsYW5ja1wiOiBcIuKEj1wiLFxuXHRcInBsYW5ja2hcIjogXCLihI5cIixcblx0XCJwbGFua3ZcIjogXCLihI9cIixcblx0XCJwbHVzYWNpclwiOiBcIuKoo1wiLFxuXHRcInBsdXNiXCI6IFwi4oqeXCIsXG5cdFwicGx1c2NpclwiOiBcIuKoolwiLFxuXHRcInBsdXNcIjogXCIrXCIsXG5cdFwicGx1c2RvXCI6IFwi4oiUXCIsXG5cdFwicGx1c2R1XCI6IFwi4qilXCIsXG5cdFwicGx1c2VcIjogXCLiqbJcIixcblx0XCJQbHVzTWludXNcIjogXCLCsVwiLFxuXHRcInBsdXNtblwiOiBcIsKxXCIsXG5cdFwicGx1c3NpbVwiOiBcIuKoplwiLFxuXHRcInBsdXN0d29cIjogXCLiqKdcIixcblx0XCJwbVwiOiBcIsKxXCIsXG5cdFwiUG9pbmNhcmVwbGFuZVwiOiBcIuKEjFwiLFxuXHRcInBvaW50aW50XCI6IFwi4qiVXCIsXG5cdFwicG9wZlwiOiBcIvCdlaFcIixcblx0XCJQb3BmXCI6IFwi4oSZXCIsXG5cdFwicG91bmRcIjogXCLCo1wiLFxuXHRcInByYXBcIjogXCLiqrdcIixcblx0XCJQclwiOiBcIuKqu1wiLFxuXHRcInByXCI6IFwi4om6XCIsXG5cdFwicHJjdWVcIjogXCLiibxcIixcblx0XCJwcmVjYXBwcm94XCI6IFwi4qq3XCIsXG5cdFwicHJlY1wiOiBcIuKJulwiLFxuXHRcInByZWNjdXJseWVxXCI6IFwi4om8XCIsXG5cdFwiUHJlY2VkZXNcIjogXCLiibpcIixcblx0XCJQcmVjZWRlc0VxdWFsXCI6IFwi4qqvXCIsXG5cdFwiUHJlY2VkZXNTbGFudEVxdWFsXCI6IFwi4om8XCIsXG5cdFwiUHJlY2VkZXNUaWxkZVwiOiBcIuKJvlwiLFxuXHRcInByZWNlcVwiOiBcIuKqr1wiLFxuXHRcInByZWNuYXBwcm94XCI6IFwi4qq5XCIsXG5cdFwicHJlY25lcXFcIjogXCLiqrVcIixcblx0XCJwcmVjbnNpbVwiOiBcIuKLqFwiLFxuXHRcInByZVwiOiBcIuKqr1wiLFxuXHRcInByRVwiOiBcIuKqs1wiLFxuXHRcInByZWNzaW1cIjogXCLiib5cIixcblx0XCJwcmltZVwiOiBcIuKAslwiLFxuXHRcIlByaW1lXCI6IFwi4oCzXCIsXG5cdFwicHJpbWVzXCI6IFwi4oSZXCIsXG5cdFwicHJuYXBcIjogXCLiqrlcIixcblx0XCJwcm5FXCI6IFwi4qq1XCIsXG5cdFwicHJuc2ltXCI6IFwi4ouoXCIsXG5cdFwicHJvZFwiOiBcIuKIj1wiLFxuXHRcIlByb2R1Y3RcIjogXCLiiI9cIixcblx0XCJwcm9mYWxhclwiOiBcIuKMrlwiLFxuXHRcInByb2ZsaW5lXCI6IFwi4oySXCIsXG5cdFwicHJvZnN1cmZcIjogXCLijJNcIixcblx0XCJwcm9wXCI6IFwi4oidXCIsXG5cdFwiUHJvcG9ydGlvbmFsXCI6IFwi4oidXCIsXG5cdFwiUHJvcG9ydGlvblwiOiBcIuKIt1wiLFxuXHRcInByb3B0b1wiOiBcIuKInVwiLFxuXHRcInByc2ltXCI6IFwi4om+XCIsXG5cdFwicHJ1cmVsXCI6IFwi4oqwXCIsXG5cdFwiUHNjclwiOiBcIvCdkqtcIixcblx0XCJwc2NyXCI6IFwi8J2ThVwiLFxuXHRcIlBzaVwiOiBcIs6oXCIsXG5cdFwicHNpXCI6IFwiz4hcIixcblx0XCJwdW5jc3BcIjogXCLigIhcIixcblx0XCJRZnJcIjogXCLwnZSUXCIsXG5cdFwicWZyXCI6IFwi8J2UrlwiLFxuXHRcInFpbnRcIjogXCLiqIxcIixcblx0XCJxb3BmXCI6IFwi8J2VolwiLFxuXHRcIlFvcGZcIjogXCLihJpcIixcblx0XCJxcHJpbWVcIjogXCLigZdcIixcblx0XCJRc2NyXCI6IFwi8J2SrFwiLFxuXHRcInFzY3JcIjogXCLwnZOGXCIsXG5cdFwicXVhdGVybmlvbnNcIjogXCLihI1cIixcblx0XCJxdWF0aW50XCI6IFwi4qiWXCIsXG5cdFwicXVlc3RcIjogXCI/XCIsXG5cdFwicXVlc3RlcVwiOiBcIuKJn1wiLFxuXHRcInF1b3RcIjogXCJcXFwiXCIsXG5cdFwiUVVPVFwiOiBcIlxcXCJcIixcblx0XCJyQWFyclwiOiBcIuKHm1wiLFxuXHRcInJhY2VcIjogXCLiiL3MsVwiLFxuXHRcIlJhY3V0ZVwiOiBcIsWUXCIsXG5cdFwicmFjdXRlXCI6IFwixZVcIixcblx0XCJyYWRpY1wiOiBcIuKImlwiLFxuXHRcInJhZW1wdHl2XCI6IFwi4qazXCIsXG5cdFwicmFuZ1wiOiBcIuKfqVwiLFxuXHRcIlJhbmdcIjogXCLin6tcIixcblx0XCJyYW5nZFwiOiBcIuKmklwiLFxuXHRcInJhbmdlXCI6IFwi4qalXCIsXG5cdFwicmFuZ2xlXCI6IFwi4p+pXCIsXG5cdFwicmFxdW9cIjogXCLCu1wiLFxuXHRcInJhcnJhcFwiOiBcIuKltVwiLFxuXHRcInJhcnJiXCI6IFwi4oelXCIsXG5cdFwicmFycmJmc1wiOiBcIuKkoFwiLFxuXHRcInJhcnJjXCI6IFwi4qSzXCIsXG5cdFwicmFyclwiOiBcIuKGklwiLFxuXHRcIlJhcnJcIjogXCLihqBcIixcblx0XCJyQXJyXCI6IFwi4oeSXCIsXG5cdFwicmFycmZzXCI6IFwi4qSeXCIsXG5cdFwicmFycmhrXCI6IFwi4oaqXCIsXG5cdFwicmFycmxwXCI6IFwi4oasXCIsXG5cdFwicmFycnBsXCI6IFwi4qWFXCIsXG5cdFwicmFycnNpbVwiOiBcIuKltFwiLFxuXHRcIlJhcnJ0bFwiOiBcIuKkllwiLFxuXHRcInJhcnJ0bFwiOiBcIuKGo1wiLFxuXHRcInJhcnJ3XCI6IFwi4oadXCIsXG5cdFwicmF0YWlsXCI6IFwi4qSaXCIsXG5cdFwickF0YWlsXCI6IFwi4qScXCIsXG5cdFwicmF0aW9cIjogXCLiiLZcIixcblx0XCJyYXRpb25hbHNcIjogXCLihJpcIixcblx0XCJyYmFyclwiOiBcIuKkjVwiLFxuXHRcInJCYXJyXCI6IFwi4qSPXCIsXG5cdFwiUkJhcnJcIjogXCLipJBcIixcblx0XCJyYmJya1wiOiBcIuKds1wiLFxuXHRcInJicmFjZVwiOiBcIn1cIixcblx0XCJyYnJhY2tcIjogXCJdXCIsXG5cdFwicmJya2VcIjogXCLipoxcIixcblx0XCJyYnJrc2xkXCI6IFwi4qaOXCIsXG5cdFwicmJya3NsdVwiOiBcIuKmkFwiLFxuXHRcIlJjYXJvblwiOiBcIsWYXCIsXG5cdFwicmNhcm9uXCI6IFwixZlcIixcblx0XCJSY2VkaWxcIjogXCLFllwiLFxuXHRcInJjZWRpbFwiOiBcIsWXXCIsXG5cdFwicmNlaWxcIjogXCLijIlcIixcblx0XCJyY3ViXCI6IFwifVwiLFxuXHRcIlJjeVwiOiBcItCgXCIsXG5cdFwicmN5XCI6IFwi0YBcIixcblx0XCJyZGNhXCI6IFwi4qS3XCIsXG5cdFwicmRsZGhhclwiOiBcIuKlqVwiLFxuXHRcInJkcXVvXCI6IFwi4oCdXCIsXG5cdFwicmRxdW9yXCI6IFwi4oCdXCIsXG5cdFwicmRzaFwiOiBcIuKGs1wiLFxuXHRcInJlYWxcIjogXCLihJxcIixcblx0XCJyZWFsaW5lXCI6IFwi4oSbXCIsXG5cdFwicmVhbHBhcnRcIjogXCLihJxcIixcblx0XCJyZWFsc1wiOiBcIuKEnVwiLFxuXHRcIlJlXCI6IFwi4oScXCIsXG5cdFwicmVjdFwiOiBcIuKWrVwiLFxuXHRcInJlZ1wiOiBcIsKuXCIsXG5cdFwiUkVHXCI6IFwiwq5cIixcblx0XCJSZXZlcnNlRWxlbWVudFwiOiBcIuKIi1wiLFxuXHRcIlJldmVyc2VFcXVpbGlicml1bVwiOiBcIuKHi1wiLFxuXHRcIlJldmVyc2VVcEVxdWlsaWJyaXVtXCI6IFwi4qWvXCIsXG5cdFwicmZpc2h0XCI6IFwi4qW9XCIsXG5cdFwicmZsb29yXCI6IFwi4oyLXCIsXG5cdFwicmZyXCI6IFwi8J2Ur1wiLFxuXHRcIlJmclwiOiBcIuKEnFwiLFxuXHRcInJIYXJcIjogXCLipaRcIixcblx0XCJyaGFyZFwiOiBcIuKHgVwiLFxuXHRcInJoYXJ1XCI6IFwi4oeAXCIsXG5cdFwicmhhcnVsXCI6IFwi4qWsXCIsXG5cdFwiUmhvXCI6IFwizqFcIixcblx0XCJyaG9cIjogXCLPgVwiLFxuXHRcInJob3ZcIjogXCLPsVwiLFxuXHRcIlJpZ2h0QW5nbGVCcmFja2V0XCI6IFwi4p+pXCIsXG5cdFwiUmlnaHRBcnJvd0JhclwiOiBcIuKHpVwiLFxuXHRcInJpZ2h0YXJyb3dcIjogXCLihpJcIixcblx0XCJSaWdodEFycm93XCI6IFwi4oaSXCIsXG5cdFwiUmlnaHRhcnJvd1wiOiBcIuKHklwiLFxuXHRcIlJpZ2h0QXJyb3dMZWZ0QXJyb3dcIjogXCLih4RcIixcblx0XCJyaWdodGFycm93dGFpbFwiOiBcIuKGo1wiLFxuXHRcIlJpZ2h0Q2VpbGluZ1wiOiBcIuKMiVwiLFxuXHRcIlJpZ2h0RG91YmxlQnJhY2tldFwiOiBcIuKfp1wiLFxuXHRcIlJpZ2h0RG93blRlZVZlY3RvclwiOiBcIuKlnVwiLFxuXHRcIlJpZ2h0RG93blZlY3RvckJhclwiOiBcIuKllVwiLFxuXHRcIlJpZ2h0RG93blZlY3RvclwiOiBcIuKHglwiLFxuXHRcIlJpZ2h0Rmxvb3JcIjogXCLijItcIixcblx0XCJyaWdodGhhcnBvb25kb3duXCI6IFwi4oeBXCIsXG5cdFwicmlnaHRoYXJwb29udXBcIjogXCLih4BcIixcblx0XCJyaWdodGxlZnRhcnJvd3NcIjogXCLih4RcIixcblx0XCJyaWdodGxlZnRoYXJwb29uc1wiOiBcIuKHjFwiLFxuXHRcInJpZ2h0cmlnaHRhcnJvd3NcIjogXCLih4lcIixcblx0XCJyaWdodHNxdWlnYXJyb3dcIjogXCLihp1cIixcblx0XCJSaWdodFRlZUFycm93XCI6IFwi4oamXCIsXG5cdFwiUmlnaHRUZWVcIjogXCLiiqJcIixcblx0XCJSaWdodFRlZVZlY3RvclwiOiBcIuKlm1wiLFxuXHRcInJpZ2h0dGhyZWV0aW1lc1wiOiBcIuKLjFwiLFxuXHRcIlJpZ2h0VHJpYW5nbGVCYXJcIjogXCLip5BcIixcblx0XCJSaWdodFRyaWFuZ2xlXCI6IFwi4oqzXCIsXG5cdFwiUmlnaHRUcmlhbmdsZUVxdWFsXCI6IFwi4oq1XCIsXG5cdFwiUmlnaHRVcERvd25WZWN0b3JcIjogXCLipY9cIixcblx0XCJSaWdodFVwVGVlVmVjdG9yXCI6IFwi4qWcXCIsXG5cdFwiUmlnaHRVcFZlY3RvckJhclwiOiBcIuKllFwiLFxuXHRcIlJpZ2h0VXBWZWN0b3JcIjogXCLihr5cIixcblx0XCJSaWdodFZlY3RvckJhclwiOiBcIuKlk1wiLFxuXHRcIlJpZ2h0VmVjdG9yXCI6IFwi4oeAXCIsXG5cdFwicmluZ1wiOiBcIsuaXCIsXG5cdFwicmlzaW5nZG90c2VxXCI6IFwi4omTXCIsXG5cdFwicmxhcnJcIjogXCLih4RcIixcblx0XCJybGhhclwiOiBcIuKHjFwiLFxuXHRcInJsbVwiOiBcIuKAj1wiLFxuXHRcInJtb3VzdGFjaGVcIjogXCLijrFcIixcblx0XCJybW91c3RcIjogXCLijrFcIixcblx0XCJybm1pZFwiOiBcIuKrrlwiLFxuXHRcInJvYW5nXCI6IFwi4p+tXCIsXG5cdFwicm9hcnJcIjogXCLih75cIixcblx0XCJyb2Jya1wiOiBcIuKfp1wiLFxuXHRcInJvcGFyXCI6IFwi4qaGXCIsXG5cdFwicm9wZlwiOiBcIvCdlaNcIixcblx0XCJSb3BmXCI6IFwi4oSdXCIsXG5cdFwicm9wbHVzXCI6IFwi4qiuXCIsXG5cdFwicm90aW1lc1wiOiBcIuKotVwiLFxuXHRcIlJvdW5kSW1wbGllc1wiOiBcIuKlsFwiLFxuXHRcInJwYXJcIjogXCIpXCIsXG5cdFwicnBhcmd0XCI6IFwi4qaUXCIsXG5cdFwicnBwb2xpbnRcIjogXCLiqJJcIixcblx0XCJycmFyclwiOiBcIuKHiVwiLFxuXHRcIlJyaWdodGFycm93XCI6IFwi4oebXCIsXG5cdFwicnNhcXVvXCI6IFwi4oC6XCIsXG5cdFwicnNjclwiOiBcIvCdk4dcIixcblx0XCJSc2NyXCI6IFwi4oSbXCIsXG5cdFwicnNoXCI6IFwi4oaxXCIsXG5cdFwiUnNoXCI6IFwi4oaxXCIsXG5cdFwicnNxYlwiOiBcIl1cIixcblx0XCJyc3F1b1wiOiBcIuKAmVwiLFxuXHRcInJzcXVvclwiOiBcIuKAmVwiLFxuXHRcInJ0aHJlZVwiOiBcIuKLjFwiLFxuXHRcInJ0aW1lc1wiOiBcIuKLilwiLFxuXHRcInJ0cmlcIjogXCLilrlcIixcblx0XCJydHJpZVwiOiBcIuKKtVwiLFxuXHRcInJ0cmlmXCI6IFwi4pa4XCIsXG5cdFwicnRyaWx0cmlcIjogXCLip45cIixcblx0XCJSdWxlRGVsYXllZFwiOiBcIuKntFwiLFxuXHRcInJ1bHVoYXJcIjogXCLipahcIixcblx0XCJyeFwiOiBcIuKEnlwiLFxuXHRcIlNhY3V0ZVwiOiBcIsWaXCIsXG5cdFwic2FjdXRlXCI6IFwixZtcIixcblx0XCJzYnF1b1wiOiBcIuKAmlwiLFxuXHRcInNjYXBcIjogXCLiqrhcIixcblx0XCJTY2Fyb25cIjogXCLFoFwiLFxuXHRcInNjYXJvblwiOiBcIsWhXCIsXG5cdFwiU2NcIjogXCLiqrxcIixcblx0XCJzY1wiOiBcIuKJu1wiLFxuXHRcInNjY3VlXCI6IFwi4om9XCIsXG5cdFwic2NlXCI6IFwi4qqwXCIsXG5cdFwic2NFXCI6IFwi4qq0XCIsXG5cdFwiU2NlZGlsXCI6IFwixZ5cIixcblx0XCJzY2VkaWxcIjogXCLFn1wiLFxuXHRcIlNjaXJjXCI6IFwixZxcIixcblx0XCJzY2lyY1wiOiBcIsWdXCIsXG5cdFwic2NuYXBcIjogXCLiqrpcIixcblx0XCJzY25FXCI6IFwi4qq2XCIsXG5cdFwic2Nuc2ltXCI6IFwi4oupXCIsXG5cdFwic2Nwb2xpbnRcIjogXCLiqJNcIixcblx0XCJzY3NpbVwiOiBcIuKJv1wiLFxuXHRcIlNjeVwiOiBcItChXCIsXG5cdFwic2N5XCI6IFwi0YFcIixcblx0XCJzZG90YlwiOiBcIuKKoVwiLFxuXHRcInNkb3RcIjogXCLii4VcIixcblx0XCJzZG90ZVwiOiBcIuKpplwiLFxuXHRcInNlYXJoa1wiOiBcIuKkpVwiLFxuXHRcInNlYXJyXCI6IFwi4oaYXCIsXG5cdFwic2VBcnJcIjogXCLih5hcIixcblx0XCJzZWFycm93XCI6IFwi4oaYXCIsXG5cdFwic2VjdFwiOiBcIsKnXCIsXG5cdFwic2VtaVwiOiBcIjtcIixcblx0XCJzZXN3YXJcIjogXCLipKlcIixcblx0XCJzZXRtaW51c1wiOiBcIuKIllwiLFxuXHRcInNldG1uXCI6IFwi4oiWXCIsXG5cdFwic2V4dFwiOiBcIuKctlwiLFxuXHRcIlNmclwiOiBcIvCdlJZcIixcblx0XCJzZnJcIjogXCLwnZSwXCIsXG5cdFwic2Zyb3duXCI6IFwi4oyiXCIsXG5cdFwic2hhcnBcIjogXCLima9cIixcblx0XCJTSENIY3lcIjogXCLQqVwiLFxuXHRcInNoY2hjeVwiOiBcItGJXCIsXG5cdFwiU0hjeVwiOiBcItCoXCIsXG5cdFwic2hjeVwiOiBcItGIXCIsXG5cdFwiU2hvcnREb3duQXJyb3dcIjogXCLihpNcIixcblx0XCJTaG9ydExlZnRBcnJvd1wiOiBcIuKGkFwiLFxuXHRcInNob3J0bWlkXCI6IFwi4oijXCIsXG5cdFwic2hvcnRwYXJhbGxlbFwiOiBcIuKIpVwiLFxuXHRcIlNob3J0UmlnaHRBcnJvd1wiOiBcIuKGklwiLFxuXHRcIlNob3J0VXBBcnJvd1wiOiBcIuKGkVwiLFxuXHRcInNoeVwiOiBcIsKtXCIsXG5cdFwiU2lnbWFcIjogXCLOo1wiLFxuXHRcInNpZ21hXCI6IFwiz4NcIixcblx0XCJzaWdtYWZcIjogXCLPglwiLFxuXHRcInNpZ21hdlwiOiBcIs+CXCIsXG5cdFwic2ltXCI6IFwi4oi8XCIsXG5cdFwic2ltZG90XCI6IFwi4qmqXCIsXG5cdFwic2ltZVwiOiBcIuKJg1wiLFxuXHRcInNpbWVxXCI6IFwi4omDXCIsXG5cdFwic2ltZ1wiOiBcIuKqnlwiLFxuXHRcInNpbWdFXCI6IFwi4qqgXCIsXG5cdFwic2ltbFwiOiBcIuKqnVwiLFxuXHRcInNpbWxFXCI6IFwi4qqfXCIsXG5cdFwic2ltbmVcIjogXCLiiYZcIixcblx0XCJzaW1wbHVzXCI6IFwi4qikXCIsXG5cdFwic2ltcmFyclwiOiBcIuKlslwiLFxuXHRcInNsYXJyXCI6IFwi4oaQXCIsXG5cdFwiU21hbGxDaXJjbGVcIjogXCLiiJhcIixcblx0XCJzbWFsbHNldG1pbnVzXCI6IFwi4oiWXCIsXG5cdFwic21hc2hwXCI6IFwi4qizXCIsXG5cdFwic21lcGFyc2xcIjogXCLip6RcIixcblx0XCJzbWlkXCI6IFwi4oijXCIsXG5cdFwic21pbGVcIjogXCLijKNcIixcblx0XCJzbXRcIjogXCLiqqpcIixcblx0XCJzbXRlXCI6IFwi4qqsXCIsXG5cdFwic210ZXNcIjogXCLiqqzvuIBcIixcblx0XCJTT0ZUY3lcIjogXCLQrFwiLFxuXHRcInNvZnRjeVwiOiBcItGMXCIsXG5cdFwic29sYmFyXCI6IFwi4oy/XCIsXG5cdFwic29sYlwiOiBcIuKnhFwiLFxuXHRcInNvbFwiOiBcIi9cIixcblx0XCJTb3BmXCI6IFwi8J2VilwiLFxuXHRcInNvcGZcIjogXCLwnZWkXCIsXG5cdFwic3BhZGVzXCI6IFwi4pmgXCIsXG5cdFwic3BhZGVzdWl0XCI6IFwi4pmgXCIsXG5cdFwic3BhclwiOiBcIuKIpVwiLFxuXHRcInNxY2FwXCI6IFwi4oqTXCIsXG5cdFwic3FjYXBzXCI6IFwi4oqT77iAXCIsXG5cdFwic3FjdXBcIjogXCLiipRcIixcblx0XCJzcWN1cHNcIjogXCLiipTvuIBcIixcblx0XCJTcXJ0XCI6IFwi4oiaXCIsXG5cdFwic3FzdWJcIjogXCLiio9cIixcblx0XCJzcXN1YmVcIjogXCLiipFcIixcblx0XCJzcXN1YnNldFwiOiBcIuKKj1wiLFxuXHRcInNxc3Vic2V0ZXFcIjogXCLiipFcIixcblx0XCJzcXN1cFwiOiBcIuKKkFwiLFxuXHRcInNxc3VwZVwiOiBcIuKKklwiLFxuXHRcInNxc3Vwc2V0XCI6IFwi4oqQXCIsXG5cdFwic3FzdXBzZXRlcVwiOiBcIuKKklwiLFxuXHRcInNxdWFyZVwiOiBcIuKWoVwiLFxuXHRcIlNxdWFyZVwiOiBcIuKWoVwiLFxuXHRcIlNxdWFyZUludGVyc2VjdGlvblwiOiBcIuKKk1wiLFxuXHRcIlNxdWFyZVN1YnNldFwiOiBcIuKKj1wiLFxuXHRcIlNxdWFyZVN1YnNldEVxdWFsXCI6IFwi4oqRXCIsXG5cdFwiU3F1YXJlU3VwZXJzZXRcIjogXCLiipBcIixcblx0XCJTcXVhcmVTdXBlcnNldEVxdWFsXCI6IFwi4oqSXCIsXG5cdFwiU3F1YXJlVW5pb25cIjogXCLiipRcIixcblx0XCJzcXVhcmZcIjogXCLilqpcIixcblx0XCJzcXVcIjogXCLilqFcIixcblx0XCJzcXVmXCI6IFwi4paqXCIsXG5cdFwic3JhcnJcIjogXCLihpJcIixcblx0XCJTc2NyXCI6IFwi8J2SrlwiLFxuXHRcInNzY3JcIjogXCLwnZOIXCIsXG5cdFwic3NldG1uXCI6IFwi4oiWXCIsXG5cdFwic3NtaWxlXCI6IFwi4oyjXCIsXG5cdFwic3N0YXJmXCI6IFwi4ouGXCIsXG5cdFwiU3RhclwiOiBcIuKLhlwiLFxuXHRcInN0YXJcIjogXCLimIZcIixcblx0XCJzdGFyZlwiOiBcIuKYhVwiLFxuXHRcInN0cmFpZ2h0ZXBzaWxvblwiOiBcIs+1XCIsXG5cdFwic3RyYWlnaHRwaGlcIjogXCLPlVwiLFxuXHRcInN0cm5zXCI6IFwiwq9cIixcblx0XCJzdWJcIjogXCLiioJcIixcblx0XCJTdWJcIjogXCLii5BcIixcblx0XCJzdWJkb3RcIjogXCLiqr1cIixcblx0XCJzdWJFXCI6IFwi4quFXCIsXG5cdFwic3ViZVwiOiBcIuKKhlwiLFxuXHRcInN1YmVkb3RcIjogXCLiq4NcIixcblx0XCJzdWJtdWx0XCI6IFwi4quBXCIsXG5cdFwic3VibkVcIjogXCLiq4tcIixcblx0XCJzdWJuZVwiOiBcIuKKilwiLFxuXHRcInN1YnBsdXNcIjogXCLiqr9cIixcblx0XCJzdWJyYXJyXCI6IFwi4qW5XCIsXG5cdFwic3Vic2V0XCI6IFwi4oqCXCIsXG5cdFwiU3Vic2V0XCI6IFwi4ouQXCIsXG5cdFwic3Vic2V0ZXFcIjogXCLiioZcIixcblx0XCJzdWJzZXRlcXFcIjogXCLiq4VcIixcblx0XCJTdWJzZXRFcXVhbFwiOiBcIuKKhlwiLFxuXHRcInN1YnNldG5lcVwiOiBcIuKKilwiLFxuXHRcInN1YnNldG5lcXFcIjogXCLiq4tcIixcblx0XCJzdWJzaW1cIjogXCLiq4dcIixcblx0XCJzdWJzdWJcIjogXCLiq5VcIixcblx0XCJzdWJzdXBcIjogXCLiq5NcIixcblx0XCJzdWNjYXBwcm94XCI6IFwi4qq4XCIsXG5cdFwic3VjY1wiOiBcIuKJu1wiLFxuXHRcInN1Y2NjdXJseWVxXCI6IFwi4om9XCIsXG5cdFwiU3VjY2VlZHNcIjogXCLiibtcIixcblx0XCJTdWNjZWVkc0VxdWFsXCI6IFwi4qqwXCIsXG5cdFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6IFwi4om9XCIsXG5cdFwiU3VjY2VlZHNUaWxkZVwiOiBcIuKJv1wiLFxuXHRcInN1Y2NlcVwiOiBcIuKqsFwiLFxuXHRcInN1Y2NuYXBwcm94XCI6IFwi4qq6XCIsXG5cdFwic3VjY25lcXFcIjogXCLiqrZcIixcblx0XCJzdWNjbnNpbVwiOiBcIuKLqVwiLFxuXHRcInN1Y2NzaW1cIjogXCLiib9cIixcblx0XCJTdWNoVGhhdFwiOiBcIuKIi1wiLFxuXHRcInN1bVwiOiBcIuKIkVwiLFxuXHRcIlN1bVwiOiBcIuKIkVwiLFxuXHRcInN1bmdcIjogXCLimapcIixcblx0XCJzdXAxXCI6IFwiwrlcIixcblx0XCJzdXAyXCI6IFwiwrJcIixcblx0XCJzdXAzXCI6IFwiwrNcIixcblx0XCJzdXBcIjogXCLiioNcIixcblx0XCJTdXBcIjogXCLii5FcIixcblx0XCJzdXBkb3RcIjogXCLiqr5cIixcblx0XCJzdXBkc3ViXCI6IFwi4quYXCIsXG5cdFwic3VwRVwiOiBcIuKrhlwiLFxuXHRcInN1cGVcIjogXCLiiodcIixcblx0XCJzdXBlZG90XCI6IFwi4quEXCIsXG5cdFwiU3VwZXJzZXRcIjogXCLiioNcIixcblx0XCJTdXBlcnNldEVxdWFsXCI6IFwi4oqHXCIsXG5cdFwic3VwaHNvbFwiOiBcIuKfiVwiLFxuXHRcInN1cGhzdWJcIjogXCLiq5dcIixcblx0XCJzdXBsYXJyXCI6IFwi4qW7XCIsXG5cdFwic3VwbXVsdFwiOiBcIuKrglwiLFxuXHRcInN1cG5FXCI6IFwi4quMXCIsXG5cdFwic3VwbmVcIjogXCLiiotcIixcblx0XCJzdXBwbHVzXCI6IFwi4quAXCIsXG5cdFwic3Vwc2V0XCI6IFwi4oqDXCIsXG5cdFwiU3Vwc2V0XCI6IFwi4ouRXCIsXG5cdFwic3Vwc2V0ZXFcIjogXCLiiodcIixcblx0XCJzdXBzZXRlcXFcIjogXCLiq4ZcIixcblx0XCJzdXBzZXRuZXFcIjogXCLiiotcIixcblx0XCJzdXBzZXRuZXFxXCI6IFwi4quMXCIsXG5cdFwic3Vwc2ltXCI6IFwi4quIXCIsXG5cdFwic3Vwc3ViXCI6IFwi4quUXCIsXG5cdFwic3Vwc3VwXCI6IFwi4quWXCIsXG5cdFwic3dhcmhrXCI6IFwi4qSmXCIsXG5cdFwic3dhcnJcIjogXCLihplcIixcblx0XCJzd0FyclwiOiBcIuKHmVwiLFxuXHRcInN3YXJyb3dcIjogXCLihplcIixcblx0XCJzd253YXJcIjogXCLipKpcIixcblx0XCJzemxpZ1wiOiBcIsOfXCIsXG5cdFwiVGFiXCI6IFwiXFx0XCIsXG5cdFwidGFyZ2V0XCI6IFwi4oyWXCIsXG5cdFwiVGF1XCI6IFwizqRcIixcblx0XCJ0YXVcIjogXCLPhFwiLFxuXHRcInRicmtcIjogXCLijrRcIixcblx0XCJUY2Fyb25cIjogXCLFpFwiLFxuXHRcInRjYXJvblwiOiBcIsWlXCIsXG5cdFwiVGNlZGlsXCI6IFwixaJcIixcblx0XCJ0Y2VkaWxcIjogXCLFo1wiLFxuXHRcIlRjeVwiOiBcItCiXCIsXG5cdFwidGN5XCI6IFwi0YJcIixcblx0XCJ0ZG90XCI6IFwi4oObXCIsXG5cdFwidGVscmVjXCI6IFwi4oyVXCIsXG5cdFwiVGZyXCI6IFwi8J2Ul1wiLFxuXHRcInRmclwiOiBcIvCdlLFcIixcblx0XCJ0aGVyZTRcIjogXCLiiLRcIixcblx0XCJ0aGVyZWZvcmVcIjogXCLiiLRcIixcblx0XCJUaGVyZWZvcmVcIjogXCLiiLRcIixcblx0XCJUaGV0YVwiOiBcIs6YXCIsXG5cdFwidGhldGFcIjogXCLOuFwiLFxuXHRcInRoZXRhc3ltXCI6IFwiz5FcIixcblx0XCJ0aGV0YXZcIjogXCLPkVwiLFxuXHRcInRoaWNrYXBwcm94XCI6IFwi4omIXCIsXG5cdFwidGhpY2tzaW1cIjogXCLiiLxcIixcblx0XCJUaGlja1NwYWNlXCI6IFwi4oGf4oCKXCIsXG5cdFwiVGhpblNwYWNlXCI6IFwi4oCJXCIsXG5cdFwidGhpbnNwXCI6IFwi4oCJXCIsXG5cdFwidGhrYXBcIjogXCLiiYhcIixcblx0XCJ0aGtzaW1cIjogXCLiiLxcIixcblx0XCJUSE9STlwiOiBcIsOeXCIsXG5cdFwidGhvcm5cIjogXCLDvlwiLFxuXHRcInRpbGRlXCI6IFwiy5xcIixcblx0XCJUaWxkZVwiOiBcIuKIvFwiLFxuXHRcIlRpbGRlRXF1YWxcIjogXCLiiYNcIixcblx0XCJUaWxkZUZ1bGxFcXVhbFwiOiBcIuKJhVwiLFxuXHRcIlRpbGRlVGlsZGVcIjogXCLiiYhcIixcblx0XCJ0aW1lc2JhclwiOiBcIuKosVwiLFxuXHRcInRpbWVzYlwiOiBcIuKKoFwiLFxuXHRcInRpbWVzXCI6IFwiw5dcIixcblx0XCJ0aW1lc2RcIjogXCLiqLBcIixcblx0XCJ0aW50XCI6IFwi4oitXCIsXG5cdFwidG9lYVwiOiBcIuKkqFwiLFxuXHRcInRvcGJvdFwiOiBcIuKMtlwiLFxuXHRcInRvcGNpclwiOiBcIuKrsVwiLFxuXHRcInRvcFwiOiBcIuKKpFwiLFxuXHRcIlRvcGZcIjogXCLwnZWLXCIsXG5cdFwidG9wZlwiOiBcIvCdlaVcIixcblx0XCJ0b3Bmb3JrXCI6IFwi4quaXCIsXG5cdFwidG9zYVwiOiBcIuKkqVwiLFxuXHRcInRwcmltZVwiOiBcIuKAtFwiLFxuXHRcInRyYWRlXCI6IFwi4oSiXCIsXG5cdFwiVFJBREVcIjogXCLihKJcIixcblx0XCJ0cmlhbmdsZVwiOiBcIuKWtVwiLFxuXHRcInRyaWFuZ2xlZG93blwiOiBcIuKWv1wiLFxuXHRcInRyaWFuZ2xlbGVmdFwiOiBcIuKXg1wiLFxuXHRcInRyaWFuZ2xlbGVmdGVxXCI6IFwi4oq0XCIsXG5cdFwidHJpYW5nbGVxXCI6IFwi4omcXCIsXG5cdFwidHJpYW5nbGVyaWdodFwiOiBcIuKWuVwiLFxuXHRcInRyaWFuZ2xlcmlnaHRlcVwiOiBcIuKKtVwiLFxuXHRcInRyaWRvdFwiOiBcIuKXrFwiLFxuXHRcInRyaWVcIjogXCLiiZxcIixcblx0XCJ0cmltaW51c1wiOiBcIuKoulwiLFxuXHRcIlRyaXBsZURvdFwiOiBcIuKDm1wiLFxuXHRcInRyaXBsdXNcIjogXCLiqLlcIixcblx0XCJ0cmlzYlwiOiBcIuKnjVwiLFxuXHRcInRyaXRpbWVcIjogXCLiqLtcIixcblx0XCJ0cnBleml1bVwiOiBcIuKPolwiLFxuXHRcIlRzY3JcIjogXCLwnZKvXCIsXG5cdFwidHNjclwiOiBcIvCdk4lcIixcblx0XCJUU2N5XCI6IFwi0KZcIixcblx0XCJ0c2N5XCI6IFwi0YZcIixcblx0XCJUU0hjeVwiOiBcItCLXCIsXG5cdFwidHNoY3lcIjogXCLRm1wiLFxuXHRcIlRzdHJva1wiOiBcIsWmXCIsXG5cdFwidHN0cm9rXCI6IFwixadcIixcblx0XCJ0d2l4dFwiOiBcIuKJrFwiLFxuXHRcInR3b2hlYWRsZWZ0YXJyb3dcIjogXCLihp5cIixcblx0XCJ0d29oZWFkcmlnaHRhcnJvd1wiOiBcIuKGoFwiLFxuXHRcIlVhY3V0ZVwiOiBcIsOaXCIsXG5cdFwidWFjdXRlXCI6IFwiw7pcIixcblx0XCJ1YXJyXCI6IFwi4oaRXCIsXG5cdFwiVWFyclwiOiBcIuKGn1wiLFxuXHRcInVBcnJcIjogXCLih5FcIixcblx0XCJVYXJyb2NpclwiOiBcIuKliVwiLFxuXHRcIlVicmN5XCI6IFwi0I5cIixcblx0XCJ1YnJjeVwiOiBcItGeXCIsXG5cdFwiVWJyZXZlXCI6IFwixaxcIixcblx0XCJ1YnJldmVcIjogXCLFrVwiLFxuXHRcIlVjaXJjXCI6IFwiw5tcIixcblx0XCJ1Y2lyY1wiOiBcIsO7XCIsXG5cdFwiVWN5XCI6IFwi0KNcIixcblx0XCJ1Y3lcIjogXCLRg1wiLFxuXHRcInVkYXJyXCI6IFwi4oeFXCIsXG5cdFwiVWRibGFjXCI6IFwixbBcIixcblx0XCJ1ZGJsYWNcIjogXCLFsVwiLFxuXHRcInVkaGFyXCI6IFwi4qWuXCIsXG5cdFwidWZpc2h0XCI6IFwi4qW+XCIsXG5cdFwiVWZyXCI6IFwi8J2UmFwiLFxuXHRcInVmclwiOiBcIvCdlLJcIixcblx0XCJVZ3JhdmVcIjogXCLDmVwiLFxuXHRcInVncmF2ZVwiOiBcIsO5XCIsXG5cdFwidUhhclwiOiBcIuKlo1wiLFxuXHRcInVoYXJsXCI6IFwi4oa/XCIsXG5cdFwidWhhcnJcIjogXCLihr5cIixcblx0XCJ1aGJsa1wiOiBcIuKWgFwiLFxuXHRcInVsY29yblwiOiBcIuKMnFwiLFxuXHRcInVsY29ybmVyXCI6IFwi4oycXCIsXG5cdFwidWxjcm9wXCI6IFwi4oyPXCIsXG5cdFwidWx0cmlcIjogXCLil7hcIixcblx0XCJVbWFjclwiOiBcIsWqXCIsXG5cdFwidW1hY3JcIjogXCLFq1wiLFxuXHRcInVtbFwiOiBcIsKoXCIsXG5cdFwiVW5kZXJCYXJcIjogXCJfXCIsXG5cdFwiVW5kZXJCcmFjZVwiOiBcIuKPn1wiLFxuXHRcIlVuZGVyQnJhY2tldFwiOiBcIuKOtVwiLFxuXHRcIlVuZGVyUGFyZW50aGVzaXNcIjogXCLij51cIixcblx0XCJVbmlvblwiOiBcIuKLg1wiLFxuXHRcIlVuaW9uUGx1c1wiOiBcIuKKjlwiLFxuXHRcIlVvZ29uXCI6IFwixbJcIixcblx0XCJ1b2dvblwiOiBcIsWzXCIsXG5cdFwiVW9wZlwiOiBcIvCdlYxcIixcblx0XCJ1b3BmXCI6IFwi8J2VplwiLFxuXHRcIlVwQXJyb3dCYXJcIjogXCLipJJcIixcblx0XCJ1cGFycm93XCI6IFwi4oaRXCIsXG5cdFwiVXBBcnJvd1wiOiBcIuKGkVwiLFxuXHRcIlVwYXJyb3dcIjogXCLih5FcIixcblx0XCJVcEFycm93RG93bkFycm93XCI6IFwi4oeFXCIsXG5cdFwidXBkb3duYXJyb3dcIjogXCLihpVcIixcblx0XCJVcERvd25BcnJvd1wiOiBcIuKGlVwiLFxuXHRcIlVwZG93bmFycm93XCI6IFwi4oeVXCIsXG5cdFwiVXBFcXVpbGlicml1bVwiOiBcIuKlrlwiLFxuXHRcInVwaGFycG9vbmxlZnRcIjogXCLihr9cIixcblx0XCJ1cGhhcnBvb25yaWdodFwiOiBcIuKGvlwiLFxuXHRcInVwbHVzXCI6IFwi4oqOXCIsXG5cdFwiVXBwZXJMZWZ0QXJyb3dcIjogXCLihpZcIixcblx0XCJVcHBlclJpZ2h0QXJyb3dcIjogXCLihpdcIixcblx0XCJ1cHNpXCI6IFwiz4VcIixcblx0XCJVcHNpXCI6IFwiz5JcIixcblx0XCJ1cHNpaFwiOiBcIs+SXCIsXG5cdFwiVXBzaWxvblwiOiBcIs6lXCIsXG5cdFwidXBzaWxvblwiOiBcIs+FXCIsXG5cdFwiVXBUZWVBcnJvd1wiOiBcIuKGpVwiLFxuXHRcIlVwVGVlXCI6IFwi4oqlXCIsXG5cdFwidXB1cGFycm93c1wiOiBcIuKHiFwiLFxuXHRcInVyY29yblwiOiBcIuKMnVwiLFxuXHRcInVyY29ybmVyXCI6IFwi4oydXCIsXG5cdFwidXJjcm9wXCI6IFwi4oyOXCIsXG5cdFwiVXJpbmdcIjogXCLFrlwiLFxuXHRcInVyaW5nXCI6IFwixa9cIixcblx0XCJ1cnRyaVwiOiBcIuKXuVwiLFxuXHRcIlVzY3JcIjogXCLwnZKwXCIsXG5cdFwidXNjclwiOiBcIvCdk4pcIixcblx0XCJ1dGRvdFwiOiBcIuKLsFwiLFxuXHRcIlV0aWxkZVwiOiBcIsWoXCIsXG5cdFwidXRpbGRlXCI6IFwixalcIixcblx0XCJ1dHJpXCI6IFwi4pa1XCIsXG5cdFwidXRyaWZcIjogXCLilrRcIixcblx0XCJ1dWFyclwiOiBcIuKHiFwiLFxuXHRcIlV1bWxcIjogXCLDnFwiLFxuXHRcInV1bWxcIjogXCLDvFwiLFxuXHRcInV3YW5nbGVcIjogXCLipqdcIixcblx0XCJ2YW5ncnRcIjogXCLippxcIixcblx0XCJ2YXJlcHNpbG9uXCI6IFwiz7VcIixcblx0XCJ2YXJrYXBwYVwiOiBcIs+wXCIsXG5cdFwidmFybm90aGluZ1wiOiBcIuKIhVwiLFxuXHRcInZhcnBoaVwiOiBcIs+VXCIsXG5cdFwidmFycGlcIjogXCLPllwiLFxuXHRcInZhcnByb3B0b1wiOiBcIuKInVwiLFxuXHRcInZhcnJcIjogXCLihpVcIixcblx0XCJ2QXJyXCI6IFwi4oeVXCIsXG5cdFwidmFycmhvXCI6IFwiz7FcIixcblx0XCJ2YXJzaWdtYVwiOiBcIs+CXCIsXG5cdFwidmFyc3Vic2V0bmVxXCI6IFwi4oqK77iAXCIsXG5cdFwidmFyc3Vic2V0bmVxcVwiOiBcIuKri++4gFwiLFxuXHRcInZhcnN1cHNldG5lcVwiOiBcIuKKi++4gFwiLFxuXHRcInZhcnN1cHNldG5lcXFcIjogXCLiq4zvuIBcIixcblx0XCJ2YXJ0aGV0YVwiOiBcIs+RXCIsXG5cdFwidmFydHJpYW5nbGVsZWZ0XCI6IFwi4oqyXCIsXG5cdFwidmFydHJpYW5nbGVyaWdodFwiOiBcIuKKs1wiLFxuXHRcInZCYXJcIjogXCLiq6hcIixcblx0XCJWYmFyXCI6IFwi4qurXCIsXG5cdFwidkJhcnZcIjogXCLiq6lcIixcblx0XCJWY3lcIjogXCLQklwiLFxuXHRcInZjeVwiOiBcItCyXCIsXG5cdFwidmRhc2hcIjogXCLiiqJcIixcblx0XCJ2RGFzaFwiOiBcIuKKqFwiLFxuXHRcIlZkYXNoXCI6IFwi4oqpXCIsXG5cdFwiVkRhc2hcIjogXCLiiqtcIixcblx0XCJWZGFzaGxcIjogXCLiq6ZcIixcblx0XCJ2ZWViYXJcIjogXCLiirtcIixcblx0XCJ2ZWVcIjogXCLiiKhcIixcblx0XCJWZWVcIjogXCLii4FcIixcblx0XCJ2ZWVlcVwiOiBcIuKJmlwiLFxuXHRcInZlbGxpcFwiOiBcIuKLrlwiLFxuXHRcInZlcmJhclwiOiBcInxcIixcblx0XCJWZXJiYXJcIjogXCLigJZcIixcblx0XCJ2ZXJ0XCI6IFwifFwiLFxuXHRcIlZlcnRcIjogXCLigJZcIixcblx0XCJWZXJ0aWNhbEJhclwiOiBcIuKIo1wiLFxuXHRcIlZlcnRpY2FsTGluZVwiOiBcInxcIixcblx0XCJWZXJ0aWNhbFNlcGFyYXRvclwiOiBcIuKdmFwiLFxuXHRcIlZlcnRpY2FsVGlsZGVcIjogXCLiiYBcIixcblx0XCJWZXJ5VGhpblNwYWNlXCI6IFwi4oCKXCIsXG5cdFwiVmZyXCI6IFwi8J2UmVwiLFxuXHRcInZmclwiOiBcIvCdlLNcIixcblx0XCJ2bHRyaVwiOiBcIuKKslwiLFxuXHRcInZuc3ViXCI6IFwi4oqC4oOSXCIsXG5cdFwidm5zdXBcIjogXCLiioPig5JcIixcblx0XCJWb3BmXCI6IFwi8J2VjVwiLFxuXHRcInZvcGZcIjogXCLwnZWnXCIsXG5cdFwidnByb3BcIjogXCLiiJ1cIixcblx0XCJ2cnRyaVwiOiBcIuKKs1wiLFxuXHRcIlZzY3JcIjogXCLwnZKxXCIsXG5cdFwidnNjclwiOiBcIvCdk4tcIixcblx0XCJ2c3VibkVcIjogXCLiq4vvuIBcIixcblx0XCJ2c3VibmVcIjogXCLiiorvuIBcIixcblx0XCJ2c3VwbkVcIjogXCLiq4zvuIBcIixcblx0XCJ2c3VwbmVcIjogXCLiiovvuIBcIixcblx0XCJWdmRhc2hcIjogXCLiiqpcIixcblx0XCJ2emlnemFnXCI6IFwi4qaaXCIsXG5cdFwiV2NpcmNcIjogXCLFtFwiLFxuXHRcIndjaXJjXCI6IFwixbVcIixcblx0XCJ3ZWRiYXJcIjogXCLiqZ9cIixcblx0XCJ3ZWRnZVwiOiBcIuKIp1wiLFxuXHRcIldlZGdlXCI6IFwi4ouAXCIsXG5cdFwid2VkZ2VxXCI6IFwi4omZXCIsXG5cdFwid2VpZXJwXCI6IFwi4oSYXCIsXG5cdFwiV2ZyXCI6IFwi8J2UmlwiLFxuXHRcIndmclwiOiBcIvCdlLRcIixcblx0XCJXb3BmXCI6IFwi8J2VjlwiLFxuXHRcIndvcGZcIjogXCLwnZWoXCIsXG5cdFwid3BcIjogXCLihJhcIixcblx0XCJ3clwiOiBcIuKJgFwiLFxuXHRcIndyZWF0aFwiOiBcIuKJgFwiLFxuXHRcIldzY3JcIjogXCLwnZKyXCIsXG5cdFwid3NjclwiOiBcIvCdk4xcIixcblx0XCJ4Y2FwXCI6IFwi4ouCXCIsXG5cdFwieGNpcmNcIjogXCLil69cIixcblx0XCJ4Y3VwXCI6IFwi4ouDXCIsXG5cdFwieGR0cmlcIjogXCLilr1cIixcblx0XCJYZnJcIjogXCLwnZSbXCIsXG5cdFwieGZyXCI6IFwi8J2UtVwiLFxuXHRcInhoYXJyXCI6IFwi4p+3XCIsXG5cdFwieGhBcnJcIjogXCLin7pcIixcblx0XCJYaVwiOiBcIs6eXCIsXG5cdFwieGlcIjogXCLOvlwiLFxuXHRcInhsYXJyXCI6IFwi4p+1XCIsXG5cdFwieGxBcnJcIjogXCLin7hcIixcblx0XCJ4bWFwXCI6IFwi4p+8XCIsXG5cdFwieG5pc1wiOiBcIuKLu1wiLFxuXHRcInhvZG90XCI6IFwi4qiAXCIsXG5cdFwiWG9wZlwiOiBcIvCdlY9cIixcblx0XCJ4b3BmXCI6IFwi8J2VqVwiLFxuXHRcInhvcGx1c1wiOiBcIuKogVwiLFxuXHRcInhvdGltZVwiOiBcIuKoglwiLFxuXHRcInhyYXJyXCI6IFwi4p+2XCIsXG5cdFwieHJBcnJcIjogXCLin7lcIixcblx0XCJYc2NyXCI6IFwi8J2Ss1wiLFxuXHRcInhzY3JcIjogXCLwnZONXCIsXG5cdFwieHNxY3VwXCI6IFwi4qiGXCIsXG5cdFwieHVwbHVzXCI6IFwi4qiEXCIsXG5cdFwieHV0cmlcIjogXCLilrNcIixcblx0XCJ4dmVlXCI6IFwi4ouBXCIsXG5cdFwieHdlZGdlXCI6IFwi4ouAXCIsXG5cdFwiWWFjdXRlXCI6IFwiw51cIixcblx0XCJ5YWN1dGVcIjogXCLDvVwiLFxuXHRcIllBY3lcIjogXCLQr1wiLFxuXHRcInlhY3lcIjogXCLRj1wiLFxuXHRcIlljaXJjXCI6IFwixbZcIixcblx0XCJ5Y2lyY1wiOiBcIsW3XCIsXG5cdFwiWWN5XCI6IFwi0KtcIixcblx0XCJ5Y3lcIjogXCLRi1wiLFxuXHRcInllblwiOiBcIsKlXCIsXG5cdFwiWWZyXCI6IFwi8J2UnFwiLFxuXHRcInlmclwiOiBcIvCdlLZcIixcblx0XCJZSWN5XCI6IFwi0IdcIixcblx0XCJ5aWN5XCI6IFwi0ZdcIixcblx0XCJZb3BmXCI6IFwi8J2VkFwiLFxuXHRcInlvcGZcIjogXCLwnZWqXCIsXG5cdFwiWXNjclwiOiBcIvCdkrRcIixcblx0XCJ5c2NyXCI6IFwi8J2TjlwiLFxuXHRcIllVY3lcIjogXCLQrlwiLFxuXHRcInl1Y3lcIjogXCLRjlwiLFxuXHRcInl1bWxcIjogXCLDv1wiLFxuXHRcIll1bWxcIjogXCLFuFwiLFxuXHRcIlphY3V0ZVwiOiBcIsW5XCIsXG5cdFwiemFjdXRlXCI6IFwixbpcIixcblx0XCJaY2Fyb25cIjogXCLFvVwiLFxuXHRcInpjYXJvblwiOiBcIsW+XCIsXG5cdFwiWmN5XCI6IFwi0JdcIixcblx0XCJ6Y3lcIjogXCLQt1wiLFxuXHRcIlpkb3RcIjogXCLFu1wiLFxuXHRcInpkb3RcIjogXCLFvFwiLFxuXHRcInplZXRyZlwiOiBcIuKEqFwiLFxuXHRcIlplcm9XaWR0aFNwYWNlXCI6IFwi4oCLXCIsXG5cdFwiWmV0YVwiOiBcIs6WXCIsXG5cdFwiemV0YVwiOiBcIs62XCIsXG5cdFwiemZyXCI6IFwi8J2Ut1wiLFxuXHRcIlpmclwiOiBcIuKEqFwiLFxuXHRcIlpIY3lcIjogXCLQllwiLFxuXHRcInpoY3lcIjogXCLQtlwiLFxuXHRcInppZ3JhcnJcIjogXCLih51cIixcblx0XCJ6b3BmXCI6IFwi8J2Vq1wiLFxuXHRcIlpvcGZcIjogXCLihKRcIixcblx0XCJac2NyXCI6IFwi8J2StVwiLFxuXHRcInpzY3JcIjogXCLwnZOPXCIsXG5cdFwiendqXCI6IFwi4oCNXCIsXG5cdFwiendualwiOiBcIuKAjFwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=