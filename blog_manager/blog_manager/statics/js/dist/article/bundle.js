/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

;(function () {
	"use strict";

	function Vnode(tag, key, attrs0, children, text, dom) {
		return { tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false };
	}
	Vnode.normalize = function (node) {
		if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined);
		if (node != null && (typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined);
		return node;
	};
	Vnode.normalizeChildren = function normalizeChildren(children) {
		for (var i = 0; i < children.length; i++) {
			children[i] = Vnode.normalize(children[i]);
		}
		return children;
	};
	var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
	var selectorCache = {};
	var hasOwn = {}.hasOwnProperty;
	function compileSelector(selector) {
		var match,
		    tag = "div",
		    classes = [],
		    attrs = {};
		while (match = selectorParser.exec(selector)) {
			var type = match[1],
			    value = match[2];
			if (type === "" && value !== "") tag = value;else if (type === "#") attrs.id = value;else if (type === ".") classes.push(value);else if (match[3][0] === "[") {
				var attrValue = match[6];
				if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
				if (match[4] === "class") classes.push(attrValue);else attrs[match[4]] = attrValue || true;
			}
		}
		if (classes.length > 0) attrs.className = classes.join(" ");
		return selectorCache[selector] = { tag: tag, attrs: attrs };
	}
	function execSelector(state, attrs, children) {
		var hasAttrs = false,
		    childList,
		    text;
		var className = attrs.className || attrs.class;
		for (var key in state.attrs) {
			if (hasOwn.call(state.attrs, key)) {
				attrs[key] = state.attrs[key];
			}
		}
		if (className !== undefined) {
			if (attrs.class !== undefined) {
				attrs.class = undefined;
				attrs.className = className;
			}
			if (state.attrs.className != null) {
				attrs.className = state.attrs.className + " " + className;
			}
		}
		for (var key in attrs) {
			if (hasOwn.call(attrs, key) && key !== "key") {
				hasAttrs = true;
				break;
			}
		}
		if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
			text = children[0].children;
		} else {
			childList = children;
		}
		return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text);
	}
	function hyperscript(selector) {
		// Because sloppy mode sucks
		var attrs = arguments[1],
		    start = 2,
		    children;
		if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
			throw Error("The selector must be either a string or a component.");
		}
		if (typeof selector === "string") {
			var cached = selectorCache[selector] || compileSelector(selector);
		}
		if (attrs == null) {
			attrs = {};
		} else if ((typeof attrs === "undefined" ? "undefined" : _typeof(attrs)) !== "object" || attrs.tag != null || Array.isArray(attrs)) {
			attrs = {};
			start = 1;
		}
		if (arguments.length === start + 1) {
			children = arguments[start];
			if (!Array.isArray(children)) children = [children];
		} else {
			children = [];
			while (start < arguments.length) {
				children.push(arguments[start++]);
			}
		}
		var normalized = Vnode.normalizeChildren(children);
		if (typeof selector === "string") {
			return execSelector(cached, attrs, normalized);
		} else {
			return Vnode(selector, attrs.key, attrs, normalized);
		}
	}
	hyperscript.trust = function (html) {
		if (html == null) html = "";
		return Vnode("<", undefined, undefined, html, undefined, undefined);
	};
	hyperscript.fragment = function (attrs1, children) {
		return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined);
	};
	var m = hyperscript;
	/** @constructor */
	var PromisePolyfill = function PromisePolyfill(executor) {
		if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`");
		if (typeof executor !== "function") throw new TypeError("executor must be a function");
		var self = this,
		    resolvers = [],
		    rejectors = [],
		    resolveCurrent = handler(resolvers, true),
		    rejectCurrent = handler(rejectors, false);
		var instance = self._instance = { resolvers: resolvers, rejectors: rejectors };
		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function handler(list, shouldAbsorb) {
			return function execute(value) {
				var then;
				try {
					if (shouldAbsorb && value != null && ((typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
						if (value === self) throw new TypeError("Promise can't be resolved w/ itself");
						executeOnce(then.bind(value));
					} else {
						callAsync(function () {
							if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value);
							for (var i = 0; i < list.length; i++) {
								list[i](value);
							}resolvers.length = 0, rejectors.length = 0;
							instance.state = shouldAbsorb;
							instance.retry = function () {
								execute(value);
							};
						});
					}
				} catch (e) {
					rejectCurrent(e);
				}
			};
		}
		function executeOnce(then) {
			var runs = 0;
			function run(fn) {
				return function (value) {
					if (runs++ > 0) return;
					fn(value);
				};
			}
			var onerror = run(rejectCurrent);
			try {
				then(run(resolveCurrent), onerror);
			} catch (e) {
				onerror(e);
			}
		}
		executeOnce(executor);
	};
	PromisePolyfill.prototype.then = function (onFulfilled, onRejection) {
		var self = this,
		    instance = self._instance;
		function handle(callback, list, next, state) {
			list.push(function (value) {
				if (typeof callback !== "function") next(value);else try {
					resolveNext(callback(value));
				} catch (e) {
					if (rejectNext) rejectNext(e);
				}
			});
			if (typeof instance.retry === "function" && state === instance.state) instance.retry();
		}
		var resolveNext, rejectNext;
		var promise = new PromisePolyfill(function (resolve, reject) {
			resolveNext = resolve, rejectNext = reject;
		});
		handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
		return promise;
	};
	PromisePolyfill.prototype.catch = function (onRejection) {
		return this.then(null, onRejection);
	};
	PromisePolyfill.resolve = function (value) {
		if (value instanceof PromisePolyfill) return value;
		return new PromisePolyfill(function (resolve) {
			resolve(value);
		});
	};
	PromisePolyfill.reject = function (value) {
		return new PromisePolyfill(function (resolve, reject) {
			reject(value);
		});
	};
	PromisePolyfill.all = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			var total = list.length,
			    count = 0,
			    values = [];
			if (list.length === 0) resolve([]);else for (var i = 0; i < list.length; i++) {
				(function (i) {
					function consume(value) {
						count++;
						values[i] = value;
						if (count === total) resolve(values);
					}
					if (list[i] != null && (_typeof(list[i]) === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
						list[i].then(consume, reject);
					} else consume(list[i]);
				})(i);
			}
		});
	};
	PromisePolyfill.race = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			for (var i = 0; i < list.length; i++) {
				list[i].then(resolve, reject);
			}
		});
	};
	if (typeof window !== "undefined") {
		if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill;
		var PromisePolyfill = window.Promise;
	} else if (typeof global !== "undefined") {
		if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill;
		var PromisePolyfill = global.Promise;
	} else {}
	var buildQueryString = function buildQueryString(object) {
		if (Object.prototype.toString.call(object) !== "[object Object]") return "";
		var args = [];
		for (var key0 in object) {
			destructure(key0, object[key0]);
		}
		return args.join("&");
		function destructure(key0, value) {
			if (Array.isArray(value)) {
				for (var i = 0; i < value.length; i++) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else if (Object.prototype.toString.call(value) === "[object Object]") {
				for (var i in value) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
		}
	};
	var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i");
	var _8 = function _8($window, Promise) {
		var callbackCount = 0;
		var oncompletion;
		function setCompletionCallback(callback) {
			oncompletion = callback;
		}
		function finalizer() {
			var count = 0;
			function complete() {
				if (--count === 0 && typeof oncompletion === "function") oncompletion();
			}
			return function finalize(promise0) {
				var then0 = promise0.then;
				promise0.then = function () {
					count++;
					var next = then0.apply(promise0, arguments);
					next.then(complete, function (e) {
						complete();
						if (count === 0) throw e;
					});
					return finalize(next);
				};
				return promise0;
			};
		}
		function normalize(args, extra) {
			if (typeof args === "string") {
				var url = args;
				args = extra || {};
				if (args.url == null) args.url = url;
			}
			return args;
		}
		function request(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				if (args.method == null) args.method = "GET";
				args.method = args.method.toUpperCase();
				var useBody = args.method === "GET" || args.method === "TRACE" ? false : typeof args.useBody === "boolean" ? args.useBody : true;
				if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function (value) {
					return value;
				} : JSON.stringify;
				if (typeof args.deserialize !== "function") args.deserialize = deserialize;
				if (typeof args.extract !== "function") args.extract = extract;
				args.url = interpolate(args.url, args.data);
				if (useBody) args.data = args.serialize(args.data);else args.url = assemble(args.url, args.data);
				var xhr = new $window.XMLHttpRequest(),
				    aborted = false,
				    _abort = xhr.abort;
				xhr.abort = function abort() {
					aborted = true;
					_abort.call(xhr);
				};
				xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);
				if (args.serialize === JSON.stringify && useBody) {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
				}
				if (args.deserialize === deserialize) {
					xhr.setRequestHeader("Accept", "application/json, text/*");
				}
				if (args.withCredentials) xhr.withCredentials = args.withCredentials;
				for (var key in args.headers) {
					if ({}.hasOwnProperty.call(args.headers, key)) {
						xhr.setRequestHeader(key, args.headers[key]);
					}
				}if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr;
				xhr.onreadystatechange = function () {
					// Don't throw errors on xhr.abort().
					if (aborted) return;
					if (xhr.readyState === 4) {
						try {
							var response = args.extract !== extract ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args));
							if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
								resolve(cast(args.type, response));
							} else {
								var error = new Error(xhr.responseText);
								for (var key in response) {
									error[key] = response[key];
								}reject(error);
							}
						} catch (e) {
							reject(e);
						}
					}
				};
				if (useBody && args.data != null) xhr.send(args.data);else xhr.send();
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function jsonp(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
				var script = $window.document.createElement("script");
				$window[callbackName] = function (data) {
					script.parentNode.removeChild(script);
					resolve(cast(args.type, data));
					delete $window[callbackName];
				};
				script.onerror = function () {
					script.parentNode.removeChild(script);
					reject(new Error("JSONP request failed"));
					delete $window[callbackName];
				};
				if (args.data == null) args.data = {};
				args.url = interpolate(args.url, args.data);
				args.data[args.callbackKey || "callback"] = callbackName;
				script.src = assemble(args.url, args.data);
				$window.document.documentElement.appendChild(script);
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function interpolate(url, data) {
			if (data == null) return url;
			var tokens = url.match(/:[^\/]+/gi) || [];
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1);
				if (data[key] != null) {
					url = url.replace(tokens[i], data[key]);
				}
			}
			return url;
		}
		function assemble(url, data) {
			var querystring = buildQueryString(data);
			if (querystring !== "") {
				var prefix = url.indexOf("?") < 0 ? "?" : "&";
				url += prefix + querystring;
			}
			return url;
		}
		function deserialize(data) {
			try {
				return data !== "" ? JSON.parse(data) : null;
			} catch (e) {
				throw new Error(data);
			}
		}
		function extract(xhr) {
			return xhr.responseText;
		}
		function cast(type0, data) {
			if (typeof type0 === "function") {
				if (Array.isArray(data)) {
					for (var i = 0; i < data.length; i++) {
						data[i] = new type0(data[i]);
					}
				} else return new type0(data);
			}
			return data;
		}
		return { request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback };
	};
	var requestService = _8(window, PromisePolyfill);
	var coreRenderer = function coreRenderer($window) {
		var $doc = $window.document;
		var $emptyFragment = $doc.createDocumentFragment();
		var onevent;
		function setEventCallback(callback) {
			return onevent = callback;
		}
		//create
		function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					createNode(parent, vnode, hooks, ns, nextSibling);
				}
			}
		}
		function createNode(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			if (typeof tag === "string") {
				vnode.state = {};
				if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
				switch (tag) {
					case "#":
						return createText(parent, vnode, nextSibling);
					case "<":
						return createHTML(parent, vnode, nextSibling);
					case "[":
						return createFragment(parent, vnode, hooks, ns, nextSibling);
					default:
						return createElement(parent, vnode, hooks, ns, nextSibling);
				}
			} else return createComponent(parent, vnode, hooks, ns, nextSibling);
		}
		function createText(parent, vnode, nextSibling) {
			vnode.dom = $doc.createTextNode(vnode.children);
			insertNode(parent, vnode.dom, nextSibling);
			return vnode.dom;
		}
		function createHTML(parent, vnode, nextSibling) {
			var match1 = vnode.children.match(/^\s*?<(\w+)/im) || [];
			var parent1 = { caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup" }[match1[1]] || "div";
			var temp = $doc.createElement(parent1);
			temp.innerHTML = vnode.children;
			vnode.dom = temp.firstChild;
			vnode.domSize = temp.childNodes.length;
			var fragment = $doc.createDocumentFragment();
			var child;
			while (child = temp.firstChild) {
				fragment.appendChild(child);
			}
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createFragment(parent, vnode, hooks, ns, nextSibling) {
			var fragment = $doc.createDocumentFragment();
			if (vnode.children != null) {
				var children = vnode.children;
				createNodes(fragment, children, 0, children.length, hooks, null, ns);
			}
			vnode.dom = fragment.firstChild;
			vnode.domSize = fragment.childNodes.length;
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createElement(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			var attrs2 = vnode.attrs;
			var is = attrs2 && attrs2.is;
			var element = ns ? is ? $doc.createElementNS(ns, tag, { is: is }) : $doc.createElementNS(ns, tag) : is ? $doc.createElement(tag, { is: is }) : $doc.createElement(tag);
			vnode.dom = element;
			if (attrs2 != null) {
				setAttrs(vnode, attrs2, ns);
			}
			insertNode(parent, element, nextSibling);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else {
				if (vnode.text != null) {
					if (vnode.text !== "") element.textContent = vnode.text;else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				}
				if (vnode.children != null) {
					var children = vnode.children;
					createNodes(element, children, 0, children.length, hooks, null, ns);
					setLateAttrs(vnode);
				}
			}
			return element;
		}
		function initComponent(vnode, hooks) {
			var sentinel;
			if (typeof vnode.tag.view === "function") {
				vnode.state = Object.create(vnode.tag);
				sentinel = vnode.state.view;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
			} else {
				vnode.state = void 0;
				sentinel = vnode.tag;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
				vnode.state = vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function" ? new vnode.tag(vnode) : vnode.tag(vnode);
			}
			vnode._state = vnode.state;
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
			initLifecycle(vnode._state, vnode, hooks);
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
			sentinel.$$reentrantLock$$ = null;
		}
		function createComponent(parent, vnode, hooks, ns, nextSibling) {
			initComponent(vnode, hooks);
			if (vnode.instance != null) {
				var element = createNode(parent, vnode.instance, hooks, ns, nextSibling);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
				insertNode(parent, element, nextSibling);
				return element;
			} else {
				vnode.domSize = 0;
				return $emptyFragment;
			}
		}
		//update
		function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
			if (old === vnodes || old == null && vnodes == null) return;else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined);else if (vnodes == null) removeNodes(old, 0, old.length, vnodes);else {
				if (old.length === vnodes.length) {
					var isUnkeyed = false;
					for (var i = 0; i < vnodes.length; i++) {
						if (vnodes[i] != null && old[i] != null) {
							isUnkeyed = vnodes[i].key == null && old[i].key == null;
							break;
						}
					}
					if (isUnkeyed) {
						for (var i = 0; i < old.length; i++) {
							if (old[i] === vnodes[i]) continue;else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling));else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes);else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns);
						}
						return;
					}
				}
				recycling = recycling || isRecyclable(old, vnodes);
				if (recycling) {
					var pool = old.pool;
					old = old.concat(old.pool);
				}
				var oldStart = 0,
				    start = 0,
				    oldEnd = old.length - 1,
				    end = vnodes.length - 1,
				    map;
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldStart],
					    v = vnodes[start];
					if (o === v && !recycling) oldStart++, start++;else if (o == null) oldStart++;else if (v == null) start++;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldStart >= old.length - pool.length || pool == null && recycling;
						oldStart++, start++;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
					} else {
						var o = old[oldEnd];
						if (o === v && !recycling) oldEnd--, start++;else if (o == null) oldEnd--;else if (v == null) start++;else if (o.key === v.key) {
							var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
							updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
							if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling));
							oldEnd--, start++;
						} else break;
					}
				}
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldEnd],
					    v = vnodes[end];
					if (o === v && !recycling) oldEnd--, end--;else if (o == null) oldEnd--;else if (v == null) end--;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
						if (o.dom != null) nextSibling = o.dom;
						oldEnd--, end--;
					} else {
						if (!map) map = getKeyMap(old, oldEnd);
						if (v != null) {
							var oldIndex = map[v.key];
							if (oldIndex != null) {
								var movable = old[oldIndex];
								var shouldRecycle = pool != null && oldIndex >= old.length - pool.length || pool == null && recycling;
								updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns);
								insertNode(parent, toFragment(movable), nextSibling);
								old[oldIndex].skip = true;
								if (movable.dom != null) nextSibling = movable.dom;
							} else {
								var dom = createNode(parent, v, hooks, undefined, nextSibling);
								nextSibling = dom;
							}
						}
						end--;
					}
					if (end < start) break;
				}
				createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
				removeNodes(old, oldStart, oldEnd + 1, vnodes);
			}
		}
		function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			var oldTag = old.tag,
			    tag = vnode.tag;
			if (oldTag === tag) {
				vnode.state = old.state;
				vnode._state = old._state;
				vnode.events = old.events;
				if (!recycling && shouldNotUpdate(vnode, old)) return;
				if (typeof oldTag === "string") {
					if (vnode.attrs != null) {
						if (recycling) {
							vnode.state = {};
							initLifecycle(vnode.attrs, vnode, hooks);
						} else updateLifecycle(vnode.attrs, vnode, hooks);
					}
					switch (oldTag) {
						case "#":
							updateText(old, vnode);break;
						case "<":
							updateHTML(parent, old, vnode, nextSibling);break;
						case "[":
							updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns);break;
						default:
							updateElement(old, vnode, recycling, hooks, ns);
					}
				} else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns);
			} else {
				removeNode(old, null);
				createNode(parent, vnode, hooks, ns, nextSibling);
			}
		}
		function updateText(old, vnode) {
			if (old.children.toString() !== vnode.children.toString()) {
				old.dom.nodeValue = vnode.children;
			}
			vnode.dom = old.dom;
		}
		function updateHTML(parent, old, vnode, nextSibling) {
			if (old.children !== vnode.children) {
				toFragment(old);
				createHTML(parent, vnode, nextSibling);
			} else vnode.dom = old.dom, vnode.domSize = old.domSize;
		}
		function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
			updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns);
			var domSize = 0,
			    children = vnode.children;
			vnode.dom = null;
			if (children != null) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i];
					if (child != null && child.dom != null) {
						if (vnode.dom == null) vnode.dom = child.dom;
						domSize += child.domSize || 1;
					}
				}
				if (domSize !== 1) vnode.domSize = domSize;
			}
		}
		function updateElement(old, vnode, recycling, hooks, ns) {
			var element = vnode.dom = old.dom;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			if (vnode.tag === "textarea") {
				if (vnode.attrs == null) vnode.attrs = {};
				if (vnode.text != null) {
					vnode.attrs.value = vnode.text; //FIXME handle0 multiple children
					vnode.text = undefined;
				}
			}
			updateAttrs(vnode, old.attrs, vnode.attrs, ns);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else if (old.text != null && vnode.text != null && vnode.text !== "") {
				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text;
			} else {
				if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)];
				if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns);
			}
		}
		function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			if (recycling) {
				initComponent(vnode, hooks);
			} else {
				vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
				if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
				if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);
				updateLifecycle(vnode._state, vnode, hooks);
			}
			if (vnode.instance != null) {
				if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.instance.domSize;
			} else if (old.instance != null) {
				removeNode(old.instance, null);
				vnode.dom = undefined;
				vnode.domSize = 0;
			} else {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
			}
		}
		function isRecyclable(old, vnodes) {
			if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
				var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0;
				var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0;
				var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0;
				if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
					return true;
				}
			}
			return false;
		}
		function getKeyMap(vnodes, end) {
			var map = {},
			    i = 0;
			for (var i = 0; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					var key2 = vnode.key;
					if (key2 != null) map[key2] = i;
				}
			}
			return map;
		}
		function toFragment(vnode) {
			var count0 = vnode.domSize;
			if (count0 != null || vnode.dom == null) {
				var fragment = $doc.createDocumentFragment();
				if (count0 > 0) {
					var dom = vnode.dom;
					while (--count0) {
						fragment.appendChild(dom.nextSibling);
					}fragment.insertBefore(dom, fragment.firstChild);
				}
				return fragment;
			} else return vnode.dom;
		}
		function getNextSibling(vnodes, i, nextSibling) {
			for (; i < vnodes.length; i++) {
				if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom;
			}
			return nextSibling;
		}
		function insertNode(parent, dom, nextSibling) {
			if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling);else parent.appendChild(dom);
		}
		function setContentEditable(vnode) {
			var children = vnode.children;
			if (children != null && children.length === 1 && children[0].tag === "<") {
				var content = children[0].children;
				if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;
			} else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted");
		}
		//remove
		function removeNodes(vnodes, start, end, context) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					if (vnode.skip) vnode.skip = false;else removeNode(vnode, context);
				}
			}
		}
		function removeNode(vnode, context) {
			var expected = 1,
			    called = 0;
			if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
				var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
				var result = vnode._state.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			continuation();
			function continuation() {
				if (++called === expected) {
					onremove(vnode);
					if (vnode.dom) {
						var count0 = vnode.domSize || 1;
						if (count0 > 1) {
							var dom = vnode.dom;
							while (--count0) {
								removeNodeFromDOM(dom.nextSibling);
							}
						}
						removeNodeFromDOM(vnode.dom);
						if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") {
							//TODO test custom elements
							if (!context.pool) context.pool = [vnode];else context.pool.push(vnode);
						}
					}
				}
			}
		}
		function removeNodeFromDOM(node) {
			var parent = node.parentNode;
			if (parent != null) parent.removeChild(node);
		}
		function onremove(vnode) {
			if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode);
			if (vnode.instance != null) onremove(vnode.instance);else {
				var children = vnode.children;
				if (Array.isArray(children)) {
					for (var i = 0; i < children.length; i++) {
						var child = children[i];
						if (child != null) onremove(child);
					}
				}
			}
		}
		//attrs2
		function setAttrs(vnode, attrs2, ns) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, null, attrs2[key2], ns);
			}
		}
		function setAttr(vnode, key2, old, value, ns) {
			var element = vnode.dom;
			if (key2 === "key" || key2 === "is" || old === value && !isFormAttribute(vnode, key2) && (typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return;
			var nsLastIndex = key2.indexOf(":");
			if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
				element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value);
			} else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value);else if (key2 === "style") updateStyle(element, old, value);else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if (vnode.tag === "input" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && key2 === "value" && vnode.dom.value == value) return;
				// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
				if (vnode.tag === "input" && key2 === "type") {
					element.setAttribute(key2, value);
					return;
				}
				element[key2] = value;
			} else {
				if (typeof value === "boolean") {
					if (value) element.setAttribute(key2, "");else element.removeAttribute(key2);
				} else element.setAttribute(key2 === "className" ? "class" : key2, value);
			}
		}
		function setLateAttrs(vnode) {
			var attrs2 = vnode.attrs;
			if (vnode.tag === "select" && attrs2 != null) {
				if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined);
				if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined);
			}
		}
		function updateAttrs(vnode, old, attrs2, ns) {
			if (attrs2 != null) {
				for (var key2 in attrs2) {
					setAttr(vnode, key2, old && old[key2], attrs2[key2], ns);
				}
			}
			if (old != null) {
				for (var key2 in old) {
					if (attrs2 == null || !(key2 in attrs2)) {
						if (key2 === "className") key2 = "class";
						if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined);else if (key2 !== "key") vnode.dom.removeAttribute(key2);
					}
				}
			}
		}
		function isFormAttribute(vnode, attr) {
			return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement;
		}
		function isLifecycleMethod(attr) {
			return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate";
		}
		function isAttribute(attr) {
			return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"; // || attr === "type"
		}
		function isCustomElement(vnode) {
			return vnode.attrs.is || vnode.tag.indexOf("-") > -1;
		}
		function hasIntegrationMethods(source) {
			return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove);
		}
		//style
		function updateStyle(element, old, style) {
			if (old === style) element.style.cssText = "", old = null;
			if (style == null) element.style.cssText = "";else if (typeof style === "string") element.style.cssText = style;else {
				if (typeof old === "string") element.style.cssText = "";
				for (var key2 in style) {
					element.style[key2] = style[key2];
				}
				if (old != null && typeof old !== "string") {
					for (var key2 in old) {
						if (!(key2 in style)) element.style[key2] = "";
					}
				}
			}
		}
		//event
		function updateEvent(vnode, key2, value) {
			var element = vnode.dom;
			var callback = typeof onevent !== "function" ? value : function (e) {
				var result = value.call(element, e);
				onevent.call(element, e);
				return result;
			};
			if (key2 in element) element[key2] = typeof value === "function" ? callback : null;else {
				var eventName = key2.slice(2);
				if (vnode.events === undefined) vnode.events = {};
				if (vnode.events[key2] === callback) return;
				if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false);
				if (typeof value === "function") {
					vnode.events[key2] = callback;
					element.addEventListener(eventName, vnode.events[key2], false);
				}
			}
		}
		//lifecycle
		function initLifecycle(source, vnode, hooks) {
			if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode);
			if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode));
		}
		function updateLifecycle(source, vnode, hooks) {
			if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode));
		}
		function shouldNotUpdate(vnode, old) {
			var forceVnodeUpdate, forceComponentUpdate;
			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old);
			if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
				vnode.instance = old.instance;
				return true;
			}
			return false;
		}
		function render(dom, vnodes) {
			if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");
			var hooks = [];
			var active = $doc.activeElement;
			// First time0 rendering into a node clears it out
			if (dom.vnodes == null) dom.textContent = "";
			if (!Array.isArray(vnodes)) vnodes = [vnodes];
			updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined);
			dom.vnodes = vnodes;
			for (var i = 0; i < hooks.length; i++) {
				hooks[i]();
			}if ($doc.activeElement !== active) active.focus();
		}
		return { render: render, setEventCallback: setEventCallback };
	};
	function throttle(callback) {
		//60fps translates to 16.6ms, round it down since setTimeout requires int
		var time = 16;
		var last = 0,
		    pending = null;
		var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout;
		return function () {
			var now = Date.now();
			if (last === 0 || now - last >= time) {
				last = now;
				callback();
			} else if (pending === null) {
				pending = timeout(function () {
					pending = null;
					callback();
					last = Date.now();
				}, time - (now - last));
			}
		};
	}
	var _11 = function _11($window) {
		var renderService = coreRenderer($window);
		renderService.setEventCallback(function (e) {
			if (e.redraw !== false) redraw();
		});
		var callbacks = [];
		function subscribe(key1, callback) {
			unsubscribe(key1);
			callbacks.push(key1, throttle(callback));
		}
		function unsubscribe(key1) {
			var index = callbacks.indexOf(key1);
			if (index > -1) callbacks.splice(index, 2);
		}
		function redraw() {
			for (var i = 1; i < callbacks.length; i += 2) {
				callbacks[i]();
			}
		}
		return { subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render };
	};
	var redrawService = _11(window);
	requestService.setCompletionCallback(redrawService.redraw);
	var _16 = function _16(redrawService0) {
		return function (root, component) {
			if (component === null) {
				redrawService0.render(root, []);
				redrawService0.unsubscribe(root);
				return;
			}

			if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode");

			var run0 = function run0() {
				redrawService0.render(root, Vnode(component));
			};
			redrawService0.subscribe(root, run0);
			redrawService0.redraw();
		};
	};
	m.mount = _16(redrawService);
	var Promise = PromisePolyfill;
	var parseQueryString = function parseQueryString(string) {
		if (string === "" || string == null) return {};
		if (string.charAt(0) === "?") string = string.slice(1);
		var entries = string.split("&"),
		    data0 = {},
		    counters = {};
		for (var i = 0; i < entries.length; i++) {
			var entry = entries[i].split("=");
			var key5 = decodeURIComponent(entry[0]);
			var value = entry.length === 2 ? decodeURIComponent(entry[1]) : "";
			if (value === "true") value = true;else if (value === "false") value = false;
			var levels = key5.split(/\]\[?|\[/);
			var cursor = data0;
			if (key5.indexOf("[") > -1) levels.pop();
			for (var j = 0; j < levels.length; j++) {
				var level = levels[j],
				    nextLevel = levels[j + 1];
				var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
				var isValue = j === levels.length - 1;
				if (level === "") {
					var key5 = levels.slice(0, j).join();
					if (counters[key5] == null) counters[key5] = 0;
					level = counters[key5]++;
				}
				if (cursor[level] == null) {
					cursor[level] = isValue ? value : isNumber ? [] : {};
				}
				cursor = cursor[level];
			}
		}
		return data0;
	};
	var coreRouter = function coreRouter($window) {
		var supportsPushState = typeof $window.history.pushState === "function";
		var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function normalize1(fragment0) {
			var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent);
			if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data;
			return data;
		}
		var asyncId;
		function debounceAsync(callback0) {
			return function () {
				if (asyncId != null) return;
				asyncId = callAsync0(function () {
					asyncId = null;
					callback0();
				});
			};
		}
		function parsePath(path, queryData, hashData) {
			var queryIndex = path.indexOf("?");
			var hashIndex = path.indexOf("#");
			var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length;
			if (queryIndex > -1) {
				var queryEnd = hashIndex > -1 ? hashIndex : path.length;
				var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd));
				for (var key4 in queryParams) {
					queryData[key4] = queryParams[key4];
				}
			}
			if (hashIndex > -1) {
				var hashParams = parseQueryString(path.slice(hashIndex + 1));
				for (var key4 in hashParams) {
					hashData[key4] = hashParams[key4];
				}
			}
			return path.slice(0, pathEnd);
		}
		var router = { prefix: "#!" };
		router.getPath = function () {
			var type2 = router.prefix.charAt(0);
			switch (type2) {
				case "#":
					return normalize1("hash").slice(router.prefix.length);
				case "?":
					return normalize1("search").slice(router.prefix.length) + normalize1("hash");
				default:
					return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash");
			}
		};
		router.setPath = function (path, data, options) {
			var queryData = {},
			    hashData = {};
			path = parsePath(path, queryData, hashData);
			if (data != null) {
				for (var key4 in data) {
					queryData[key4] = data[key4];
				}path = path.replace(/:([^\/]+)/g, function (match2, token) {
					delete queryData[token];
					return data[token];
				});
			}
			var query = buildQueryString(queryData);
			if (query) path += "?" + query;
			var hash = buildQueryString(hashData);
			if (hash) path += "#" + hash;
			if (supportsPushState) {
				var state = options ? options.state : null;
				var title = options ? options.title : null;
				$window.onpopstate();
				if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path);else $window.history.pushState(state, title, router.prefix + path);
			} else $window.location.href = router.prefix + path;
		};
		router.defineRoutes = function (routes, resolve, reject) {
			function resolveRoute() {
				var path = router.getPath();
				var params = {};
				var pathname = parsePath(path, params, params);
				var state = $window.history.state;
				if (state != null) {
					for (var k in state) {
						params[k] = state[k];
					}
				}
				for (var route0 in routes) {
					var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");
					if (matcher.test(pathname)) {
						pathname.replace(matcher, function () {
							var keys = route0.match(/:[^\/]+/g) || [];
							var values = [].slice.call(arguments, 1, -2);
							for (var i = 0; i < keys.length; i++) {
								params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i]);
							}
							resolve(routes[route0], params, path, route0);
						});
						return;
					}
				}
				reject(path, params);
			}
			if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute);else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute;
			resolveRoute();
		};
		return router;
	};
	var _20 = function _20($window, redrawService0) {
		var routeService = coreRouter($window);
		var identity = function identity(v) {
			return v;
		};
		var render1, component, attrs3, currentPath, _lastUpdate;
		var route = function route(root, defaultRoute, routes) {
			if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined");
			var run1 = function run1() {
				if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)));
			};
			var bail = function bail(path) {
				if (path !== defaultRoute) routeService.setPath(defaultRoute, null, { replace: true });else throw new Error("Could not resolve default route " + defaultRoute);
			};
			routeService.defineRoutes(routes, function (payload, params, path) {
				var update = _lastUpdate = function lastUpdate(routeResolver, comp) {
					if (update !== _lastUpdate) return;
					component = comp != null && (typeof comp.view === "function" || typeof comp === "function") ? comp : "div";
					attrs3 = params, currentPath = path, _lastUpdate = null;
					render1 = (routeResolver.render || identity).bind(routeResolver);
					run1();
				};
				if (payload.view || typeof payload === "function") update({}, payload);else {
					if (payload.onmatch) {
						Promise.resolve(payload.onmatch(params, path)).then(function (resolved) {
							update(payload, resolved);
						}, bail);
					} else update(payload, "div");
				}
			}, bail);
			redrawService0.subscribe(root, run1);
		};
		route.set = function (path, data, options) {
			if (_lastUpdate != null) options = { replace: true };
			_lastUpdate = null;
			routeService.setPath(path, data, options);
		};
		route.get = function () {
			return currentPath;
		};
		route.prefix = function (prefix0) {
			routeService.prefix = prefix0;
		};
		route.link = function (vnode1) {
			vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href);
			vnode1.dom.onclick = function (e) {
				if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return;
				e.preventDefault();
				e.redraw = false;
				var href = this.getAttribute("href");
				if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length);
				route.set(href, undefined, undefined);
			};
		};
		route.param = function (key3) {
			if (typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3];
			return attrs3;
		};
		return route;
	};
	m.route = _20(window, redrawService);
	m.withAttr = function (attrName, callback1, context) {
		return function (e) {
			callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName));
		};
	};
	var _28 = coreRenderer(window);
	m.render = _28.render;
	m.redraw = redrawService.redraw;
	m.request = requestService.request;
	m.jsonp = requestService.jsonp;
	m.parseQueryString = parseQueryString;
	m.buildQueryString = buildQueryString;
	m.version = "1.1.1";
	m.vnode = Vnode;
	if (true) module["exports"] = m;else window.m = m;
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _component = __webpack_require__(6);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_mithril2.default.mount(document.getElementById('main'), _component2.default);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(3)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(4);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _markdownIt = __webpack_require__(23);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

var _model = __webpack_require__(7);

var _model2 = _interopRequireDefault(_model);

var _styles = __webpack_require__(85);

var _styles2 = _interopRequireDefault(_styles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md = new _markdownIt2.default();

var Cell = {
  view: function view(vnode) {
    return (0, _mithril2.default)(
      'div',
      { className: 'mdl-cell mdl-cell--' + vnode.attrs.span + '-col ' + (vnode.attrs.cls || '') },
      vnode.attrs.inner
    );
  }
};

var Title = {
  view: function view(vnode) {
    var model = vnode.attrs.model;
    var inner = (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.title,
      onchange: _mithril2.default.withAttr('value', function (v) {
        return model.data.title = v;
      }),
      value: model.data.title
    });
    return (0, _mithril2.default)(Cell, { span: 12, inner: inner });
  }
};

var Tags = {
  view: function view(vnode) {
    var model = vnode.attrs.model;
    var inner = (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.tags,
      onchange: _mithril2.default.withAttr('value', function (v) {
        return model.data.tags = v.split(',');
      }),
      value: model.data.tags.join(',')
    });
    return (0, _mithril2.default)(Cell, { span: 12, inner: inner });
  }
};

var Editor = {
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'div',
      { contentEditable: true, oninput: function oninput() {
          return console.log('input');
        } },
      vnode.attrs.model.data.body
    );
    return (0, _mithril2.default)(Cell, { span: 6, cls: _styles2.default.editor, inner: inner });
  }
};

var Preview = {
  view: function view(vnode) {
    return (0, _mithril2.default)(Cell, { span: 6, cls: _styles2.default.preview, inner: _mithril2.default.trust(md.render(vnode.attrs.model.data.body)) });
  }
};

var Save = {
  view: function view(vnode) {
    var model = vnode.model;
    var inner = (0, _mithril2.default)(
      'button',
      {
        className: 'mdl-button mdl-js-button mdl-button--raised mdl-button--colored',
        onclick: model.save },
      'save'
    );
    return (0, _mithril2.default)(Cell, { span: 12, inner: inner });
  }
};

exports.default = {
  oninit: function oninit(vnode) {
    _model2.default.fetch();
  },
  view: function view(vnode) {
    if (_model2.default.fetched) {
      return (0, _mithril2.default)(
        'div',
        { className: 'mdl-grid' },
        (0, _mithril2.default)(Title, { model: _model2.default }),
        (0, _mithril2.default)(Tags, { model: _model2.default }),
        (0, _mithril2.default)(Editor, { model: _model2.default }),
        (0, _mithril2.default)(Preview, { model: _model2.default }),
        (0, _mithril2.default)(Save, { model: _model2.default })
      );
    }
    return (0, _mithril2.default)(
      'div',
      null,
      '\u30C7\u30FC\u30BF\u53D6\u5F97\u4E2D...'
    );
  }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var url = '/api/articles/' + location.href.split('/').slice(4).join('/');

var Model = {
  data: {},
  fetched: false,

  fetch: function fetch() {
    return _mithril2.default.request({
      method: 'GET',
      url: url
    }).then(function (response) {
      Model.fetched = true;
      Model.data = response;
    });
  },
  save: function save() {
    return _mithril2.default.request({
      method: 'POST',
      url: url
    }).then(function (response) {
      Model.data = response;
    });
  }
};

exports.default = Model;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Utilities
//


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(12);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(11);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(16);
exports.lib.ucmicro = __webpack_require__(74);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/


/**
 * new Ruler()
 **/

function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typorgapher replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Token class



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/

function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML5 entities map: { name -> utf16string }
//


/*eslint quotes:0*/

module.exports = __webpack_require__(76);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = '';
      state.tokens[delimiters[startDelim.end - 1].token].content = '';
      i++;
    }
  }
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ~~strike through~~
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports.encode = __webpack_require__(69);
module.exports.decode = __webpack_require__(68);
module.exports.format = __webpack_require__(70);
module.exports.parse = __webpack_require__(71);

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//

function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(22)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(19).source;
  re.src_Cc = __webpack_require__(17).source;
  re.src_Z = __webpack_require__(18).source;
  re.src_P = __webpack_require__(11).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(29);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Just a shortcut for bulk export


exports.parseLinkLabel = __webpack_require__(27);
exports.parseLinkDestination = __webpack_require__(26);
exports.parseLinkTitle = __webpack_require__(28);

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link destination
//


var isSpace = __webpack_require__(8).isSpace;
var unescapeAll = __webpack_require__(8).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
        if (level > 1) {
          break;
        }
      }

    if (code === 0x29 /* ) */) {
        level--;
        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//


module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link title
//


var unescapeAll = __webpack_require__(8).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Main parser class



var utils = __webpack_require__(8);
var helpers = __webpack_require__(25);
var Renderer = __webpack_require__(36);
var ParserCore = __webpack_require__(31);
var ParserBlock = __webpack_require__(30);
var ParserInline = __webpack_require__(32);
var LinkifyIt = __webpack_require__(21);
var mdurl = __webpack_require__(16);
var punycode = __webpack_require__(72);

var config = {
  'default': __webpack_require__(34),
  zero: __webpack_require__(35),
  commonmark: __webpack_require__(33)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - ``, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `''` for Russian, `''` for German, and
 *   `['\xA0', '\xA0', '\xA0', '\xA0']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/


var Ruler = __webpack_require__(9);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(48), ['paragraph', 'reference']], ['code', __webpack_require__(38)], ['fence', __webpack_require__(39), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(37), ['paragraph', 'reference', 'list']], ['hr', __webpack_require__(41), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(44), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(46)], ['heading', __webpack_require__(40), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(43)], ['html_block', __webpack_require__(42), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(45)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(47);

module.exports = ParserBlock;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/


var Ruler = __webpack_require__(9);

var _rules = [['normalize', __webpack_require__(52)], ['block', __webpack_require__(49)], ['inline', __webpack_require__(50)], ['linkify', __webpack_require__(51)], ['replacements', __webpack_require__(53)], ['smartquotes', __webpack_require__(54)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(55);

module.exports = Core;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/


var Ruler = __webpack_require__(9);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(66)], ['newline', __webpack_require__(64)], ['escape', __webpack_require__(60)], ['backticks', __webpack_require__(57)], ['strikethrough', __webpack_require__(15).tokenize], ['emphasis', __webpack_require__(14).tokenize], ['link', __webpack_require__(63)], ['image', __webpack_require__(62)], ['autolink', __webpack_require__(56)], ['html_inline', __webpack_require__(61)], ['entity', __webpack_require__(59)]];

var _rules2 = [['balance_pairs', __webpack_require__(58)], ['strikethrough', __webpack_require__(15).postProcess], ['emphasis', __webpack_require__(14).postProcess], ['text_collapse', __webpack_require__(67)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(65);

module.exports = ParserInline;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /*  */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// markdown-it default options



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /*  */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /*  */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign = __webpack_require__(8).assign;
var unescapeAll = __webpack_require__(8).unescapeAll;
var escapeHtml = __webpack_require__(8).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without mudofying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes



var isSpace = __webpack_require__(8).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      isOutdented,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    if (isOutdented) break;

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)



var isSpace = __webpack_require__(8).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule



var isSpace = __webpack_require__(8).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block



var block_names = __webpack_require__(24);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(13).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists



var isSpace = __webpack_require__(8).isSpace;

// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finilize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var normalizeReference = __webpack_require__(8).normalizeReference;
var isSpace = __webpack_require__(8).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class



var Token = __webpack_require__(10);
var isSpace = __webpack_require__(8).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard



var isSpace = __webpack_require__(8).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//


var arrayReplaceAt = __webpack_require__(8).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Normalize input string



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographyc replacements
//
// (c) (C)  
// (tm) (TM)  
// (r) (R)  
// +-  
// (p) (P) -> 
// ...   (also ?....  ?.., !....  !..)
// ????????  ???, !!!!!  !!!, `,,`  `,`
// --  &ndash;, ---  &mdash;
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> , , 
// - miltiplication 2 x 4 -> 2  4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '',
  r: '',
  p: '',
  tm: ''
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '')
        // .., ..., ....... -> 
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '').replace(/([?!])/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//


var isWhiteSpace = __webpack_require__(8).isWhiteSpace;
var isPunctChar = __webpack_require__(8).isPunctChar;
var isMdAsciiPunct = __webpack_require__(8).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /*  */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Core state object
//


var Token = __webpack_require__(10);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'



/*eslint max-len:0*/

var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// For each opening emphasis-like marker find a matching closing one
//


module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities = __webpack_require__(12);
var has = __webpack_require__(8).has;
var isValidEntityCode = __webpack_require__(8).isValidEntityCode;
var fromCodePoint = __webpack_require__(8).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess escaped chars and hardbreaks



var isSpace = __webpack_require__(8).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags



var HTML_TAG_RE = __webpack_require__(13).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ![image](<src> "title")



var normalizeReference = __webpack_require__(8).normalizeReference;
var isSpace = __webpack_require__(8).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [link](<to> "stuff")



var normalizeReference = __webpack_require__(8).normalizeReference;
var isSpace = __webpack_require__(8).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'



var isSpace = __webpack_require__(8).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state



var Token = __webpack_require__(10);
var isWhiteSpace = __webpack_require__(8).isWhiteSpace;
var isPunctChar = __webpack_require__(8).isPunctChar;
var isMdAsciiPunct = __webpack_require__(8).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Merge adjacent text nodes into one, and re-calculate all token levels
//


module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(20)) == 'object' && __webpack_require__(20)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(75)(module), __webpack_require__(0)))

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Any = __webpack_require__(19);
exports.Cc = __webpack_require__(17);
exports.Cf = __webpack_require__(73);
exports.P = __webpack_require__(11);
exports.Z = __webpack_require__(18);

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = {
	"Aacute": "",
	"aacute": "",
	"Abreve": "",
	"abreve": "",
	"ac": "",
	"acd": "",
	"acE": "",
	"Acirc": "",
	"acirc": "",
	"acute": "",
	"Acy": "",
	"acy": "",
	"AElig": "",
	"aelig": "",
	"af": "",
	"Afr": "",
	"afr": "",
	"Agrave": "",
	"agrave": "",
	"alefsym": "",
	"aleph": "",
	"Alpha": "",
	"alpha": "",
	"Amacr": "",
	"amacr": "",
	"amalg": "",
	"amp": "&",
	"AMP": "&",
	"andand": "",
	"And": "",
	"and": "",
	"andd": "",
	"andslope": "",
	"andv": "",
	"ang": "",
	"ange": "",
	"angle": "",
	"angmsdaa": "",
	"angmsdab": "",
	"angmsdac": "",
	"angmsdad": "",
	"angmsdae": "",
	"angmsdaf": "",
	"angmsdag": "",
	"angmsdah": "",
	"angmsd": "",
	"angrt": "",
	"angrtvb": "",
	"angrtvbd": "",
	"angsph": "",
	"angst": "",
	"angzarr": "",
	"Aogon": "",
	"aogon": "",
	"Aopf": "",
	"aopf": "",
	"apacir": "",
	"ap": "",
	"apE": "",
	"ape": "",
	"apid": "",
	"apos": "'",
	"ApplyFunction": "",
	"approx": "",
	"approxeq": "",
	"Aring": "",
	"aring": "",
	"Ascr": "",
	"ascr": "",
	"Assign": "",
	"ast": "*",
	"asymp": "",
	"asympeq": "",
	"Atilde": "",
	"atilde": "",
	"Auml": "",
	"auml": "",
	"awconint": "",
	"awint": "",
	"backcong": "",
	"backepsilon": "",
	"backprime": "",
	"backsim": "",
	"backsimeq": "",
	"Backslash": "",
	"Barv": "",
	"barvee": "",
	"barwed": "",
	"Barwed": "",
	"barwedge": "",
	"bbrk": "",
	"bbrktbrk": "",
	"bcong": "",
	"Bcy": "",
	"bcy": "",
	"bdquo": "",
	"becaus": "",
	"because": "",
	"Because": "",
	"bemptyv": "",
	"bepsi": "",
	"bernou": "",
	"Bernoullis": "",
	"Beta": "",
	"beta": "",
	"beth": "",
	"between": "",
	"Bfr": "",
	"bfr": "",
	"bigcap": "",
	"bigcirc": "",
	"bigcup": "",
	"bigodot": "",
	"bigoplus": "",
	"bigotimes": "",
	"bigsqcup": "",
	"bigstar": "",
	"bigtriangledown": "",
	"bigtriangleup": "",
	"biguplus": "",
	"bigvee": "",
	"bigwedge": "",
	"bkarow": "",
	"blacklozenge": "",
	"blacksquare": "",
	"blacktriangle": "",
	"blacktriangledown": "",
	"blacktriangleleft": "",
	"blacktriangleright": "",
	"blank": "",
	"blk12": "",
	"blk14": "",
	"blk34": "",
	"block": "",
	"bne": "=",
	"bnequiv": "",
	"bNot": "",
	"bnot": "",
	"Bopf": "",
	"bopf": "",
	"bot": "",
	"bottom": "",
	"bowtie": "",
	"boxbox": "",
	"boxdl": "",
	"boxdL": "",
	"boxDl": "",
	"boxDL": "",
	"boxdr": "",
	"boxdR": "",
	"boxDr": "",
	"boxDR": "",
	"boxh": "",
	"boxH": "",
	"boxhd": "",
	"boxHd": "",
	"boxhD": "",
	"boxHD": "",
	"boxhu": "",
	"boxHu": "",
	"boxhU": "",
	"boxHU": "",
	"boxminus": "",
	"boxplus": "",
	"boxtimes": "",
	"boxul": "",
	"boxuL": "",
	"boxUl": "",
	"boxUL": "",
	"boxur": "",
	"boxuR": "",
	"boxUr": "",
	"boxUR": "",
	"boxv": "",
	"boxV": "",
	"boxvh": "",
	"boxvH": "",
	"boxVh": "",
	"boxVH": "",
	"boxvl": "",
	"boxvL": "",
	"boxVl": "",
	"boxVL": "",
	"boxvr": "",
	"boxvR": "",
	"boxVr": "",
	"boxVR": "",
	"bprime": "",
	"breve": "",
	"Breve": "",
	"brvbar": "",
	"bscr": "",
	"Bscr": "",
	"bsemi": "",
	"bsim": "",
	"bsime": "",
	"bsolb": "",
	"bsol": "\\",
	"bsolhsub": "",
	"bull": "",
	"bullet": "",
	"bump": "",
	"bumpE": "",
	"bumpe": "",
	"Bumpeq": "",
	"bumpeq": "",
	"Cacute": "",
	"cacute": "",
	"capand": "",
	"capbrcup": "",
	"capcap": "",
	"cap": "",
	"Cap": "",
	"capcup": "",
	"capdot": "",
	"CapitalDifferentialD": "",
	"caps": "",
	"caret": "",
	"caron": "",
	"Cayleys": "",
	"ccaps": "",
	"Ccaron": "",
	"ccaron": "",
	"Ccedil": "",
	"ccedil": "",
	"Ccirc": "",
	"ccirc": "",
	"Cconint": "",
	"ccups": "",
	"ccupssm": "",
	"Cdot": "",
	"cdot": "",
	"cedil": "",
	"Cedilla": "",
	"cemptyv": "",
	"cent": "",
	"centerdot": "",
	"CenterDot": "",
	"cfr": "",
	"Cfr": "",
	"CHcy": "",
	"chcy": "",
	"check": "",
	"checkmark": "",
	"Chi": "",
	"chi": "",
	"circ": "",
	"circeq": "",
	"circlearrowleft": "",
	"circlearrowright": "",
	"circledast": "",
	"circledcirc": "",
	"circleddash": "",
	"CircleDot": "",
	"circledR": "",
	"circledS": "",
	"CircleMinus": "",
	"CirclePlus": "",
	"CircleTimes": "",
	"cir": "",
	"cirE": "",
	"cire": "",
	"cirfnint": "",
	"cirmid": "",
	"cirscir": "",
	"ClockwiseContourIntegral": "",
	"CloseCurlyDoubleQuote": "",
	"CloseCurlyQuote": "",
	"clubs": "",
	"clubsuit": "",
	"colon": ":",
	"Colon": "",
	"Colone": "",
	"colone": "",
	"coloneq": "",
	"comma": ",",
	"commat": "@",
	"comp": "",
	"compfn": "",
	"complement": "",
	"complexes": "",
	"cong": "",
	"congdot": "",
	"Congruent": "",
	"conint": "",
	"Conint": "",
	"ContourIntegral": "",
	"copf": "",
	"Copf": "",
	"coprod": "",
	"Coproduct": "",
	"copy": "",
	"COPY": "",
	"copysr": "",
	"CounterClockwiseContourIntegral": "",
	"crarr": "",
	"cross": "",
	"Cross": "",
	"Cscr": "",
	"cscr": "",
	"csub": "",
	"csube": "",
	"csup": "",
	"csupe": "",
	"ctdot": "",
	"cudarrl": "",
	"cudarrr": "",
	"cuepr": "",
	"cuesc": "",
	"cularr": "",
	"cularrp": "",
	"cupbrcap": "",
	"cupcap": "",
	"CupCap": "",
	"cup": "",
	"Cup": "",
	"cupcup": "",
	"cupdot": "",
	"cupor": "",
	"cups": "",
	"curarr": "",
	"curarrm": "",
	"curlyeqprec": "",
	"curlyeqsucc": "",
	"curlyvee": "",
	"curlywedge": "",
	"curren": "",
	"curvearrowleft": "",
	"curvearrowright": "",
	"cuvee": "",
	"cuwed": "",
	"cwconint": "",
	"cwint": "",
	"cylcty": "",
	"dagger": "",
	"Dagger": "",
	"daleth": "",
	"darr": "",
	"Darr": "",
	"dArr": "",
	"dash": "",
	"Dashv": "",
	"dashv": "",
	"dbkarow": "",
	"dblac": "",
	"Dcaron": "",
	"dcaron": "",
	"Dcy": "",
	"dcy": "",
	"ddagger": "",
	"ddarr": "",
	"DD": "",
	"dd": "",
	"DDotrahd": "",
	"ddotseq": "",
	"deg": "",
	"Del": "",
	"Delta": "",
	"delta": "",
	"demptyv": "",
	"dfisht": "",
	"Dfr": "",
	"dfr": "",
	"dHar": "",
	"dharl": "",
	"dharr": "",
	"DiacriticalAcute": "",
	"DiacriticalDot": "",
	"DiacriticalDoubleAcute": "",
	"DiacriticalGrave": "`",
	"DiacriticalTilde": "",
	"diam": "",
	"diamond": "",
	"Diamond": "",
	"diamondsuit": "",
	"diams": "",
	"die": "",
	"DifferentialD": "",
	"digamma": "",
	"disin": "",
	"div": "",
	"divide": "",
	"divideontimes": "",
	"divonx": "",
	"DJcy": "",
	"djcy": "",
	"dlcorn": "",
	"dlcrop": "",
	"dollar": "$",
	"Dopf": "",
	"dopf": "",
	"Dot": "",
	"dot": "",
	"DotDot": "",
	"doteq": "",
	"doteqdot": "",
	"DotEqual": "",
	"dotminus": "",
	"dotplus": "",
	"dotsquare": "",
	"doublebarwedge": "",
	"DoubleContourIntegral": "",
	"DoubleDot": "",
	"DoubleDownArrow": "",
	"DoubleLeftArrow": "",
	"DoubleLeftRightArrow": "",
	"DoubleLeftTee": "",
	"DoubleLongLeftArrow": "",
	"DoubleLongLeftRightArrow": "",
	"DoubleLongRightArrow": "",
	"DoubleRightArrow": "",
	"DoubleRightTee": "",
	"DoubleUpArrow": "",
	"DoubleUpDownArrow": "",
	"DoubleVerticalBar": "",
	"DownArrowBar": "",
	"downarrow": "",
	"DownArrow": "",
	"Downarrow": "",
	"DownArrowUpArrow": "",
	"DownBreve": "",
	"downdownarrows": "",
	"downharpoonleft": "",
	"downharpoonright": "",
	"DownLeftRightVector": "",
	"DownLeftTeeVector": "",
	"DownLeftVectorBar": "",
	"DownLeftVector": "",
	"DownRightTeeVector": "",
	"DownRightVectorBar": "",
	"DownRightVector": "",
	"DownTeeArrow": "",
	"DownTee": "",
	"drbkarow": "",
	"drcorn": "",
	"drcrop": "",
	"Dscr": "",
	"dscr": "",
	"DScy": "",
	"dscy": "",
	"dsol": "",
	"Dstrok": "",
	"dstrok": "",
	"dtdot": "",
	"dtri": "",
	"dtrif": "",
	"duarr": "",
	"duhar": "",
	"dwangle": "",
	"DZcy": "",
	"dzcy": "",
	"dzigrarr": "",
	"Eacute": "",
	"eacute": "",
	"easter": "",
	"Ecaron": "",
	"ecaron": "",
	"Ecirc": "",
	"ecirc": "",
	"ecir": "",
	"ecolon": "",
	"Ecy": "",
	"ecy": "",
	"eDDot": "",
	"Edot": "",
	"edot": "",
	"eDot": "",
	"ee": "",
	"efDot": "",
	"Efr": "",
	"efr": "",
	"eg": "",
	"Egrave": "",
	"egrave": "",
	"egs": "",
	"egsdot": "",
	"el": "",
	"Element": "",
	"elinters": "",
	"ell": "",
	"els": "",
	"elsdot": "",
	"Emacr": "",
	"emacr": "",
	"empty": "",
	"emptyset": "",
	"EmptySmallSquare": "",
	"emptyv": "",
	"EmptyVerySmallSquare": "",
	"emsp13": "",
	"emsp14": "",
	"emsp": "",
	"ENG": "",
	"eng": "",
	"ensp": "",
	"Eogon": "",
	"eogon": "",
	"Eopf": "",
	"eopf": "",
	"epar": "",
	"eparsl": "",
	"eplus": "",
	"epsi": "",
	"Epsilon": "",
	"epsilon": "",
	"epsiv": "",
	"eqcirc": "",
	"eqcolon": "",
	"eqsim": "",
	"eqslantgtr": "",
	"eqslantless": "",
	"Equal": "",
	"equals": "=",
	"EqualTilde": "",
	"equest": "",
	"Equilibrium": "",
	"equiv": "",
	"equivDD": "",
	"eqvparsl": "",
	"erarr": "",
	"erDot": "",
	"escr": "",
	"Escr": "",
	"esdot": "",
	"Esim": "",
	"esim": "",
	"Eta": "",
	"eta": "",
	"ETH": "",
	"eth": "",
	"Euml": "",
	"euml": "",
	"euro": "",
	"excl": "!",
	"exist": "",
	"Exists": "",
	"expectation": "",
	"exponentiale": "",
	"ExponentialE": "",
	"fallingdotseq": "",
	"Fcy": "",
	"fcy": "",
	"female": "",
	"ffilig": "",
	"fflig": "",
	"ffllig": "",
	"Ffr": "",
	"ffr": "",
	"filig": "",
	"FilledSmallSquare": "",
	"FilledVerySmallSquare": "",
	"fjlig": "fj",
	"flat": "",
	"fllig": "",
	"fltns": "",
	"fnof": "",
	"Fopf": "",
	"fopf": "",
	"forall": "",
	"ForAll": "",
	"fork": "",
	"forkv": "",
	"Fouriertrf": "",
	"fpartint": "",
	"frac12": "",
	"frac13": "",
	"frac14": "",
	"frac15": "",
	"frac16": "",
	"frac18": "",
	"frac23": "",
	"frac25": "",
	"frac34": "",
	"frac35": "",
	"frac38": "",
	"frac45": "",
	"frac56": "",
	"frac58": "",
	"frac78": "",
	"frasl": "",
	"frown": "",
	"fscr": "",
	"Fscr": "",
	"gacute": "",
	"Gamma": "",
	"gamma": "",
	"Gammad": "",
	"gammad": "",
	"gap": "",
	"Gbreve": "",
	"gbreve": "",
	"Gcedil": "",
	"Gcirc": "",
	"gcirc": "",
	"Gcy": "",
	"gcy": "",
	"Gdot": "",
	"gdot": "",
	"ge": "",
	"gE": "",
	"gEl": "",
	"gel": "",
	"geq": "",
	"geqq": "",
	"geqslant": "",
	"gescc": "",
	"ges": "",
	"gesdot": "",
	"gesdoto": "",
	"gesdotol": "",
	"gesl": "",
	"gesles": "",
	"Gfr": "",
	"gfr": "",
	"gg": "",
	"Gg": "",
	"ggg": "",
	"gimel": "",
	"GJcy": "",
	"gjcy": "",
	"gla": "",
	"gl": "",
	"glE": "",
	"glj": "",
	"gnap": "",
	"gnapprox": "",
	"gne": "",
	"gnE": "",
	"gneq": "",
	"gneqq": "",
	"gnsim": "",
	"Gopf": "",
	"gopf": "",
	"grave": "`",
	"GreaterEqual": "",
	"GreaterEqualLess": "",
	"GreaterFullEqual": "",
	"GreaterGreater": "",
	"GreaterLess": "",
	"GreaterSlantEqual": "",
	"GreaterTilde": "",
	"Gscr": "",
	"gscr": "",
	"gsim": "",
	"gsime": "",
	"gsiml": "",
	"gtcc": "",
	"gtcir": "",
	"gt": ">",
	"GT": ">",
	"Gt": "",
	"gtdot": "",
	"gtlPar": "",
	"gtquest": "",
	"gtrapprox": "",
	"gtrarr": "",
	"gtrdot": "",
	"gtreqless": "",
	"gtreqqless": "",
	"gtrless": "",
	"gtrsim": "",
	"gvertneqq": "",
	"gvnE": "",
	"Hacek": "",
	"hairsp": "",
	"half": "",
	"hamilt": "",
	"HARDcy": "",
	"hardcy": "",
	"harrcir": "",
	"harr": "",
	"hArr": "",
	"harrw": "",
	"Hat": "^",
	"hbar": "",
	"Hcirc": "",
	"hcirc": "",
	"hearts": "",
	"heartsuit": "",
	"hellip": "",
	"hercon": "",
	"hfr": "",
	"Hfr": "",
	"HilbertSpace": "",
	"hksearow": "",
	"hkswarow": "",
	"hoarr": "",
	"homtht": "",
	"hookleftarrow": "",
	"hookrightarrow": "",
	"hopf": "",
	"Hopf": "",
	"horbar": "",
	"HorizontalLine": "",
	"hscr": "",
	"Hscr": "",
	"hslash": "",
	"Hstrok": "",
	"hstrok": "",
	"HumpDownHump": "",
	"HumpEqual": "",
	"hybull": "",
	"hyphen": "",
	"Iacute": "",
	"iacute": "",
	"ic": "",
	"Icirc": "",
	"icirc": "",
	"Icy": "",
	"icy": "",
	"Idot": "",
	"IEcy": "",
	"iecy": "",
	"iexcl": "",
	"iff": "",
	"ifr": "",
	"Ifr": "",
	"Igrave": "",
	"igrave": "",
	"ii": "",
	"iiiint": "",
	"iiint": "",
	"iinfin": "",
	"iiota": "",
	"IJlig": "",
	"ijlig": "",
	"Imacr": "",
	"imacr": "",
	"image": "",
	"ImaginaryI": "",
	"imagline": "",
	"imagpart": "",
	"imath": "",
	"Im": "",
	"imof": "",
	"imped": "",
	"Implies": "",
	"incare": "",
	"in": "",
	"infin": "",
	"infintie": "",
	"inodot": "",
	"intcal": "",
	"int": "",
	"Int": "",
	"integers": "",
	"Integral": "",
	"intercal": "",
	"Intersection": "",
	"intlarhk": "",
	"intprod": "",
	"InvisibleComma": "",
	"InvisibleTimes": "",
	"IOcy": "",
	"iocy": "",
	"Iogon": "",
	"iogon": "",
	"Iopf": "",
	"iopf": "",
	"Iota": "",
	"iota": "",
	"iprod": "",
	"iquest": "",
	"iscr": "",
	"Iscr": "",
	"isin": "",
	"isindot": "",
	"isinE": "",
	"isins": "",
	"isinsv": "",
	"isinv": "",
	"it": "",
	"Itilde": "",
	"itilde": "",
	"Iukcy": "",
	"iukcy": "",
	"Iuml": "",
	"iuml": "",
	"Jcirc": "",
	"jcirc": "",
	"Jcy": "",
	"jcy": "",
	"Jfr": "",
	"jfr": "",
	"jmath": "",
	"Jopf": "",
	"jopf": "",
	"Jscr": "",
	"jscr": "",
	"Jsercy": "",
	"jsercy": "",
	"Jukcy": "",
	"jukcy": "",
	"Kappa": "",
	"kappa": "",
	"kappav": "",
	"Kcedil": "",
	"kcedil": "",
	"Kcy": "",
	"kcy": "",
	"Kfr": "",
	"kfr": "",
	"kgreen": "",
	"KHcy": "",
	"khcy": "",
	"KJcy": "",
	"kjcy": "",
	"Kopf": "",
	"kopf": "",
	"Kscr": "",
	"kscr": "",
	"lAarr": "",
	"Lacute": "",
	"lacute": "",
	"laemptyv": "",
	"lagran": "",
	"Lambda": "",
	"lambda": "",
	"lang": "",
	"Lang": "",
	"langd": "",
	"langle": "",
	"lap": "",
	"Laplacetrf": "",
	"laquo": "",
	"larrb": "",
	"larrbfs": "",
	"larr": "",
	"Larr": "",
	"lArr": "",
	"larrfs": "",
	"larrhk": "",
	"larrlp": "",
	"larrpl": "",
	"larrsim": "",
	"larrtl": "",
	"latail": "",
	"lAtail": "",
	"lat": "",
	"late": "",
	"lates": "",
	"lbarr": "",
	"lBarr": "",
	"lbbrk": "",
	"lbrace": "{",
	"lbrack": "[",
	"lbrke": "",
	"lbrksld": "",
	"lbrkslu": "",
	"Lcaron": "",
	"lcaron": "",
	"Lcedil": "",
	"lcedil": "",
	"lceil": "",
	"lcub": "{",
	"Lcy": "",
	"lcy": "",
	"ldca": "",
	"ldquo": "",
	"ldquor": "",
	"ldrdhar": "",
	"ldrushar": "",
	"ldsh": "",
	"le": "",
	"lE": "",
	"LeftAngleBracket": "",
	"LeftArrowBar": "",
	"leftarrow": "",
	"LeftArrow": "",
	"Leftarrow": "",
	"LeftArrowRightArrow": "",
	"leftarrowtail": "",
	"LeftCeiling": "",
	"LeftDoubleBracket": "",
	"LeftDownTeeVector": "",
	"LeftDownVectorBar": "",
	"LeftDownVector": "",
	"LeftFloor": "",
	"leftharpoondown": "",
	"leftharpoonup": "",
	"leftleftarrows": "",
	"leftrightarrow": "",
	"LeftRightArrow": "",
	"Leftrightarrow": "",
	"leftrightarrows": "",
	"leftrightharpoons": "",
	"leftrightsquigarrow": "",
	"LeftRightVector": "",
	"LeftTeeArrow": "",
	"LeftTee": "",
	"LeftTeeVector": "",
	"leftthreetimes": "",
	"LeftTriangleBar": "",
	"LeftTriangle": "",
	"LeftTriangleEqual": "",
	"LeftUpDownVector": "",
	"LeftUpTeeVector": "",
	"LeftUpVectorBar": "",
	"LeftUpVector": "",
	"LeftVectorBar": "",
	"LeftVector": "",
	"lEg": "",
	"leg": "",
	"leq": "",
	"leqq": "",
	"leqslant": "",
	"lescc": "",
	"les": "",
	"lesdot": "",
	"lesdoto": "",
	"lesdotor": "",
	"lesg": "",
	"lesges": "",
	"lessapprox": "",
	"lessdot": "",
	"lesseqgtr": "",
	"lesseqqgtr": "",
	"LessEqualGreater": "",
	"LessFullEqual": "",
	"LessGreater": "",
	"lessgtr": "",
	"LessLess": "",
	"lesssim": "",
	"LessSlantEqual": "",
	"LessTilde": "",
	"lfisht": "",
	"lfloor": "",
	"Lfr": "",
	"lfr": "",
	"lg": "",
	"lgE": "",
	"lHar": "",
	"lhard": "",
	"lharu": "",
	"lharul": "",
	"lhblk": "",
	"LJcy": "",
	"ljcy": "",
	"llarr": "",
	"ll": "",
	"Ll": "",
	"llcorner": "",
	"Lleftarrow": "",
	"llhard": "",
	"lltri": "",
	"Lmidot": "",
	"lmidot": "",
	"lmoustache": "",
	"lmoust": "",
	"lnap": "",
	"lnapprox": "",
	"lne": "",
	"lnE": "",
	"lneq": "",
	"lneqq": "",
	"lnsim": "",
	"loang": "",
	"loarr": "",
	"lobrk": "",
	"longleftarrow": "",
	"LongLeftArrow": "",
	"Longleftarrow": "",
	"longleftrightarrow": "",
	"LongLeftRightArrow": "",
	"Longleftrightarrow": "",
	"longmapsto": "",
	"longrightarrow": "",
	"LongRightArrow": "",
	"Longrightarrow": "",
	"looparrowleft": "",
	"looparrowright": "",
	"lopar": "",
	"Lopf": "",
	"lopf": "",
	"loplus": "",
	"lotimes": "",
	"lowast": "",
	"lowbar": "_",
	"LowerLeftArrow": "",
	"LowerRightArrow": "",
	"loz": "",
	"lozenge": "",
	"lozf": "",
	"lpar": "(",
	"lparlt": "",
	"lrarr": "",
	"lrcorner": "",
	"lrhar": "",
	"lrhard": "",
	"lrm": "",
	"lrtri": "",
	"lsaquo": "",
	"lscr": "",
	"Lscr": "",
	"lsh": "",
	"Lsh": "",
	"lsim": "",
	"lsime": "",
	"lsimg": "",
	"lsqb": "[",
	"lsquo": "",
	"lsquor": "",
	"Lstrok": "",
	"lstrok": "",
	"ltcc": "",
	"ltcir": "",
	"lt": "<",
	"LT": "<",
	"Lt": "",
	"ltdot": "",
	"lthree": "",
	"ltimes": "",
	"ltlarr": "",
	"ltquest": "",
	"ltri": "",
	"ltrie": "",
	"ltrif": "",
	"ltrPar": "",
	"lurdshar": "",
	"luruhar": "",
	"lvertneqq": "",
	"lvnE": "",
	"macr": "",
	"male": "",
	"malt": "",
	"maltese": "",
	"Map": "",
	"map": "",
	"mapsto": "",
	"mapstodown": "",
	"mapstoleft": "",
	"mapstoup": "",
	"marker": "",
	"mcomma": "",
	"Mcy": "",
	"mcy": "",
	"mdash": "",
	"mDDot": "",
	"measuredangle": "",
	"MediumSpace": "",
	"Mellintrf": "",
	"Mfr": "",
	"mfr": "",
	"mho": "",
	"micro": "",
	"midast": "*",
	"midcir": "",
	"mid": "",
	"middot": "",
	"minusb": "",
	"minus": "",
	"minusd": "",
	"minusdu": "",
	"MinusPlus": "",
	"mlcp": "",
	"mldr": "",
	"mnplus": "",
	"models": "",
	"Mopf": "",
	"mopf": "",
	"mp": "",
	"mscr": "",
	"Mscr": "",
	"mstpos": "",
	"Mu": "",
	"mu": "",
	"multimap": "",
	"mumap": "",
	"nabla": "",
	"Nacute": "",
	"nacute": "",
	"nang": "",
	"nap": "",
	"napE": "",
	"napid": "",
	"napos": "",
	"napprox": "",
	"natural": "",
	"naturals": "",
	"natur": "",
	"nbsp": "",
	"nbump": "",
	"nbumpe": "",
	"ncap": "",
	"Ncaron": "",
	"ncaron": "",
	"Ncedil": "",
	"ncedil": "",
	"ncong": "",
	"ncongdot": "",
	"ncup": "",
	"Ncy": "",
	"ncy": "",
	"ndash": "",
	"nearhk": "",
	"nearr": "",
	"neArr": "",
	"nearrow": "",
	"ne": "",
	"nedot": "",
	"NegativeMediumSpace": "",
	"NegativeThickSpace": "",
	"NegativeThinSpace": "",
	"NegativeVeryThinSpace": "",
	"nequiv": "",
	"nesear": "",
	"nesim": "",
	"NestedGreaterGreater": "",
	"NestedLessLess": "",
	"NewLine": "\n",
	"nexist": "",
	"nexists": "",
	"Nfr": "",
	"nfr": "",
	"ngE": "",
	"nge": "",
	"ngeq": "",
	"ngeqq": "",
	"ngeqslant": "",
	"nges": "",
	"nGg": "",
	"ngsim": "",
	"nGt": "",
	"ngt": "",
	"ngtr": "",
	"nGtv": "",
	"nharr": "",
	"nhArr": "",
	"nhpar": "",
	"ni": "",
	"nis": "",
	"nisd": "",
	"niv": "",
	"NJcy": "",
	"njcy": "",
	"nlarr": "",
	"nlArr": "",
	"nldr": "",
	"nlE": "",
	"nle": "",
	"nleftarrow": "",
	"nLeftarrow": "",
	"nleftrightarrow": "",
	"nLeftrightarrow": "",
	"nleq": "",
	"nleqq": "",
	"nleqslant": "",
	"nles": "",
	"nless": "",
	"nLl": "",
	"nlsim": "",
	"nLt": "",
	"nlt": "",
	"nltri": "",
	"nltrie": "",
	"nLtv": "",
	"nmid": "",
	"NoBreak": "",
	"NonBreakingSpace": "",
	"nopf": "",
	"Nopf": "",
	"Not": "",
	"not": "",
	"NotCongruent": "",
	"NotCupCap": "",
	"NotDoubleVerticalBar": "",
	"NotElement": "",
	"NotEqual": "",
	"NotEqualTilde": "",
	"NotExists": "",
	"NotGreater": "",
	"NotGreaterEqual": "",
	"NotGreaterFullEqual": "",
	"NotGreaterGreater": "",
	"NotGreaterLess": "",
	"NotGreaterSlantEqual": "",
	"NotGreaterTilde": "",
	"NotHumpDownHump": "",
	"NotHumpEqual": "",
	"notin": "",
	"notindot": "",
	"notinE": "",
	"notinva": "",
	"notinvb": "",
	"notinvc": "",
	"NotLeftTriangleBar": "",
	"NotLeftTriangle": "",
	"NotLeftTriangleEqual": "",
	"NotLess": "",
	"NotLessEqual": "",
	"NotLessGreater": "",
	"NotLessLess": "",
	"NotLessSlantEqual": "",
	"NotLessTilde": "",
	"NotNestedGreaterGreater": "",
	"NotNestedLessLess": "",
	"notni": "",
	"notniva": "",
	"notnivb": "",
	"notnivc": "",
	"NotPrecedes": "",
	"NotPrecedesEqual": "",
	"NotPrecedesSlantEqual": "",
	"NotReverseElement": "",
	"NotRightTriangleBar": "",
	"NotRightTriangle": "",
	"NotRightTriangleEqual": "",
	"NotSquareSubset": "",
	"NotSquareSubsetEqual": "",
	"NotSquareSuperset": "",
	"NotSquareSupersetEqual": "",
	"NotSubset": "",
	"NotSubsetEqual": "",
	"NotSucceeds": "",
	"NotSucceedsEqual": "",
	"NotSucceedsSlantEqual": "",
	"NotSucceedsTilde": "",
	"NotSuperset": "",
	"NotSupersetEqual": "",
	"NotTilde": "",
	"NotTildeEqual": "",
	"NotTildeFullEqual": "",
	"NotTildeTilde": "",
	"NotVerticalBar": "",
	"nparallel": "",
	"npar": "",
	"nparsl": "",
	"npart": "",
	"npolint": "",
	"npr": "",
	"nprcue": "",
	"nprec": "",
	"npreceq": "",
	"npre": "",
	"nrarrc": "",
	"nrarr": "",
	"nrArr": "",
	"nrarrw": "",
	"nrightarrow": "",
	"nRightarrow": "",
	"nrtri": "",
	"nrtrie": "",
	"nsc": "",
	"nsccue": "",
	"nsce": "",
	"Nscr": "",
	"nscr": "",
	"nshortmid": "",
	"nshortparallel": "",
	"nsim": "",
	"nsime": "",
	"nsimeq": "",
	"nsmid": "",
	"nspar": "",
	"nsqsube": "",
	"nsqsupe": "",
	"nsub": "",
	"nsubE": "",
	"nsube": "",
	"nsubset": "",
	"nsubseteq": "",
	"nsubseteqq": "",
	"nsucc": "",
	"nsucceq": "",
	"nsup": "",
	"nsupE": "",
	"nsupe": "",
	"nsupset": "",
	"nsupseteq": "",
	"nsupseteqq": "",
	"ntgl": "",
	"Ntilde": "",
	"ntilde": "",
	"ntlg": "",
	"ntriangleleft": "",
	"ntrianglelefteq": "",
	"ntriangleright": "",
	"ntrianglerighteq": "",
	"Nu": "",
	"nu": "",
	"num": "#",
	"numero": "",
	"numsp": "",
	"nvap": "",
	"nvdash": "",
	"nvDash": "",
	"nVdash": "",
	"nVDash": "",
	"nvge": "",
	"nvgt": ">",
	"nvHarr": "",
	"nvinfin": "",
	"nvlArr": "",
	"nvle": "",
	"nvlt": "<",
	"nvltrie": "",
	"nvrArr": "",
	"nvrtrie": "",
	"nvsim": "",
	"nwarhk": "",
	"nwarr": "",
	"nwArr": "",
	"nwarrow": "",
	"nwnear": "",
	"Oacute": "",
	"oacute": "",
	"oast": "",
	"Ocirc": "",
	"ocirc": "",
	"ocir": "",
	"Ocy": "",
	"ocy": "",
	"odash": "",
	"Odblac": "",
	"odblac": "",
	"odiv": "",
	"odot": "",
	"odsold": "",
	"OElig": "",
	"oelig": "",
	"ofcir": "",
	"Ofr": "",
	"ofr": "",
	"ogon": "",
	"Ograve": "",
	"ograve": "",
	"ogt": "",
	"ohbar": "",
	"ohm": "",
	"oint": "",
	"olarr": "",
	"olcir": "",
	"olcross": "",
	"oline": "",
	"olt": "",
	"Omacr": "",
	"omacr": "",
	"Omega": "",
	"omega": "",
	"Omicron": "",
	"omicron": "",
	"omid": "",
	"ominus": "",
	"Oopf": "",
	"oopf": "",
	"opar": "",
	"OpenCurlyDoubleQuote": "",
	"OpenCurlyQuote": "",
	"operp": "",
	"oplus": "",
	"orarr": "",
	"Or": "",
	"or": "",
	"ord": "",
	"order": "",
	"orderof": "",
	"ordf": "",
	"ordm": "",
	"origof": "",
	"oror": "",
	"orslope": "",
	"orv": "",
	"oS": "",
	"Oscr": "",
	"oscr": "",
	"Oslash": "",
	"oslash": "",
	"osol": "",
	"Otilde": "",
	"otilde": "",
	"otimesas": "",
	"Otimes": "",
	"otimes": "",
	"Ouml": "",
	"ouml": "",
	"ovbar": "",
	"OverBar": "",
	"OverBrace": "",
	"OverBracket": "",
	"OverParenthesis": "",
	"para": "",
	"parallel": "",
	"par": "",
	"parsim": "",
	"parsl": "",
	"part": "",
	"PartialD": "",
	"Pcy": "",
	"pcy": "",
	"percnt": "%",
	"period": ".",
	"permil": "",
	"perp": "",
	"pertenk": "",
	"Pfr": "",
	"pfr": "",
	"Phi": "",
	"phi": "",
	"phiv": "",
	"phmmat": "",
	"phone": "",
	"Pi": "",
	"pi": "",
	"pitchfork": "",
	"piv": "",
	"planck": "",
	"planckh": "",
	"plankv": "",
	"plusacir": "",
	"plusb": "",
	"pluscir": "",
	"plus": "+",
	"plusdo": "",
	"plusdu": "",
	"pluse": "",
	"PlusMinus": "",
	"plusmn": "",
	"plussim": "",
	"plustwo": "",
	"pm": "",
	"Poincareplane": "",
	"pointint": "",
	"popf": "",
	"Popf": "",
	"pound": "",
	"prap": "",
	"Pr": "",
	"pr": "",
	"prcue": "",
	"precapprox": "",
	"prec": "",
	"preccurlyeq": "",
	"Precedes": "",
	"PrecedesEqual": "",
	"PrecedesSlantEqual": "",
	"PrecedesTilde": "",
	"preceq": "",
	"precnapprox": "",
	"precneqq": "",
	"precnsim": "",
	"pre": "",
	"prE": "",
	"precsim": "",
	"prime": "",
	"Prime": "",
	"primes": "",
	"prnap": "",
	"prnE": "",
	"prnsim": "",
	"prod": "",
	"Product": "",
	"profalar": "",
	"profline": "",
	"profsurf": "",
	"prop": "",
	"Proportional": "",
	"Proportion": "",
	"propto": "",
	"prsim": "",
	"prurel": "",
	"Pscr": "",
	"pscr": "",
	"Psi": "",
	"psi": "",
	"puncsp": "",
	"Qfr": "",
	"qfr": "",
	"qint": "",
	"qopf": "",
	"Qopf": "",
	"qprime": "",
	"Qscr": "",
	"qscr": "",
	"quaternions": "",
	"quatint": "",
	"quest": "?",
	"questeq": "",
	"quot": "\"",
	"QUOT": "\"",
	"rAarr": "",
	"race": "",
	"Racute": "",
	"racute": "",
	"radic": "",
	"raemptyv": "",
	"rang": "",
	"Rang": "",
	"rangd": "",
	"range": "",
	"rangle": "",
	"raquo": "",
	"rarrap": "",
	"rarrb": "",
	"rarrbfs": "",
	"rarrc": "",
	"rarr": "",
	"Rarr": "",
	"rArr": "",
	"rarrfs": "",
	"rarrhk": "",
	"rarrlp": "",
	"rarrpl": "",
	"rarrsim": "",
	"Rarrtl": "",
	"rarrtl": "",
	"rarrw": "",
	"ratail": "",
	"rAtail": "",
	"ratio": "",
	"rationals": "",
	"rbarr": "",
	"rBarr": "",
	"RBarr": "",
	"rbbrk": "",
	"rbrace": "}",
	"rbrack": "]",
	"rbrke": "",
	"rbrksld": "",
	"rbrkslu": "",
	"Rcaron": "",
	"rcaron": "",
	"Rcedil": "",
	"rcedil": "",
	"rceil": "",
	"rcub": "}",
	"Rcy": "",
	"rcy": "",
	"rdca": "",
	"rdldhar": "",
	"rdquo": "",
	"rdquor": "",
	"rdsh": "",
	"real": "",
	"realine": "",
	"realpart": "",
	"reals": "",
	"Re": "",
	"rect": "",
	"reg": "",
	"REG": "",
	"ReverseElement": "",
	"ReverseEquilibrium": "",
	"ReverseUpEquilibrium": "",
	"rfisht": "",
	"rfloor": "",
	"rfr": "",
	"Rfr": "",
	"rHar": "",
	"rhard": "",
	"rharu": "",
	"rharul": "",
	"Rho": "",
	"rho": "",
	"rhov": "",
	"RightAngleBracket": "",
	"RightArrowBar": "",
	"rightarrow": "",
	"RightArrow": "",
	"Rightarrow": "",
	"RightArrowLeftArrow": "",
	"rightarrowtail": "",
	"RightCeiling": "",
	"RightDoubleBracket": "",
	"RightDownTeeVector": "",
	"RightDownVectorBar": "",
	"RightDownVector": "",
	"RightFloor": "",
	"rightharpoondown": "",
	"rightharpoonup": "",
	"rightleftarrows": "",
	"rightleftharpoons": "",
	"rightrightarrows": "",
	"rightsquigarrow": "",
	"RightTeeArrow": "",
	"RightTee": "",
	"RightTeeVector": "",
	"rightthreetimes": "",
	"RightTriangleBar": "",
	"RightTriangle": "",
	"RightTriangleEqual": "",
	"RightUpDownVector": "",
	"RightUpTeeVector": "",
	"RightUpVectorBar": "",
	"RightUpVector": "",
	"RightVectorBar": "",
	"RightVector": "",
	"ring": "",
	"risingdotseq": "",
	"rlarr": "",
	"rlhar": "",
	"rlm": "",
	"rmoustache": "",
	"rmoust": "",
	"rnmid": "",
	"roang": "",
	"roarr": "",
	"robrk": "",
	"ropar": "",
	"ropf": "",
	"Ropf": "",
	"roplus": "",
	"rotimes": "",
	"RoundImplies": "",
	"rpar": ")",
	"rpargt": "",
	"rppolint": "",
	"rrarr": "",
	"Rrightarrow": "",
	"rsaquo": "",
	"rscr": "",
	"Rscr": "",
	"rsh": "",
	"Rsh": "",
	"rsqb": "]",
	"rsquo": "",
	"rsquor": "",
	"rthree": "",
	"rtimes": "",
	"rtri": "",
	"rtrie": "",
	"rtrif": "",
	"rtriltri": "",
	"RuleDelayed": "",
	"ruluhar": "",
	"rx": "",
	"Sacute": "",
	"sacute": "",
	"sbquo": "",
	"scap": "",
	"Scaron": "",
	"scaron": "",
	"Sc": "",
	"sc": "",
	"sccue": "",
	"sce": "",
	"scE": "",
	"Scedil": "",
	"scedil": "",
	"Scirc": "",
	"scirc": "",
	"scnap": "",
	"scnE": "",
	"scnsim": "",
	"scpolint": "",
	"scsim": "",
	"Scy": "",
	"scy": "",
	"sdotb": "",
	"sdot": "",
	"sdote": "",
	"searhk": "",
	"searr": "",
	"seArr": "",
	"searrow": "",
	"sect": "",
	"semi": ";",
	"seswar": "",
	"setminus": "",
	"setmn": "",
	"sext": "",
	"Sfr": "",
	"sfr": "",
	"sfrown": "",
	"sharp": "",
	"SHCHcy": "",
	"shchcy": "",
	"SHcy": "",
	"shcy": "",
	"ShortDownArrow": "",
	"ShortLeftArrow": "",
	"shortmid": "",
	"shortparallel": "",
	"ShortRightArrow": "",
	"ShortUpArrow": "",
	"shy": "",
	"Sigma": "",
	"sigma": "",
	"sigmaf": "",
	"sigmav": "",
	"sim": "",
	"simdot": "",
	"sime": "",
	"simeq": "",
	"simg": "",
	"simgE": "",
	"siml": "",
	"simlE": "",
	"simne": "",
	"simplus": "",
	"simrarr": "",
	"slarr": "",
	"SmallCircle": "",
	"smallsetminus": "",
	"smashp": "",
	"smeparsl": "",
	"smid": "",
	"smile": "",
	"smt": "",
	"smte": "",
	"smtes": "",
	"SOFTcy": "",
	"softcy": "",
	"solbar": "",
	"solb": "",
	"sol": "/",
	"Sopf": "",
	"sopf": "",
	"spades": "",
	"spadesuit": "",
	"spar": "",
	"sqcap": "",
	"sqcaps": "",
	"sqcup": "",
	"sqcups": "",
	"Sqrt": "",
	"sqsub": "",
	"sqsube": "",
	"sqsubset": "",
	"sqsubseteq": "",
	"sqsup": "",
	"sqsupe": "",
	"sqsupset": "",
	"sqsupseteq": "",
	"square": "",
	"Square": "",
	"SquareIntersection": "",
	"SquareSubset": "",
	"SquareSubsetEqual": "",
	"SquareSuperset": "",
	"SquareSupersetEqual": "",
	"SquareUnion": "",
	"squarf": "",
	"squ": "",
	"squf": "",
	"srarr": "",
	"Sscr": "",
	"sscr": "",
	"ssetmn": "",
	"ssmile": "",
	"sstarf": "",
	"Star": "",
	"star": "",
	"starf": "",
	"straightepsilon": "",
	"straightphi": "",
	"strns": "",
	"sub": "",
	"Sub": "",
	"subdot": "",
	"subE": "",
	"sube": "",
	"subedot": "",
	"submult": "",
	"subnE": "",
	"subne": "",
	"subplus": "",
	"subrarr": "",
	"subset": "",
	"Subset": "",
	"subseteq": "",
	"subseteqq": "",
	"SubsetEqual": "",
	"subsetneq": "",
	"subsetneqq": "",
	"subsim": "",
	"subsub": "",
	"subsup": "",
	"succapprox": "",
	"succ": "",
	"succcurlyeq": "",
	"Succeeds": "",
	"SucceedsEqual": "",
	"SucceedsSlantEqual": "",
	"SucceedsTilde": "",
	"succeq": "",
	"succnapprox": "",
	"succneqq": "",
	"succnsim": "",
	"succsim": "",
	"SuchThat": "",
	"sum": "",
	"Sum": "",
	"sung": "",
	"sup1": "",
	"sup2": "",
	"sup3": "",
	"sup": "",
	"Sup": "",
	"supdot": "",
	"supdsub": "",
	"supE": "",
	"supe": "",
	"supedot": "",
	"Superset": "",
	"SupersetEqual": "",
	"suphsol": "",
	"suphsub": "",
	"suplarr": "",
	"supmult": "",
	"supnE": "",
	"supne": "",
	"supplus": "",
	"supset": "",
	"Supset": "",
	"supseteq": "",
	"supseteqq": "",
	"supsetneq": "",
	"supsetneqq": "",
	"supsim": "",
	"supsub": "",
	"supsup": "",
	"swarhk": "",
	"swarr": "",
	"swArr": "",
	"swarrow": "",
	"swnwar": "",
	"szlig": "",
	"Tab": "\t",
	"target": "",
	"Tau": "",
	"tau": "",
	"tbrk": "",
	"Tcaron": "",
	"tcaron": "",
	"Tcedil": "",
	"tcedil": "",
	"Tcy": "",
	"tcy": "",
	"tdot": "",
	"telrec": "",
	"Tfr": "",
	"tfr": "",
	"there4": "",
	"therefore": "",
	"Therefore": "",
	"Theta": "",
	"theta": "",
	"thetasym": "",
	"thetav": "",
	"thickapprox": "",
	"thicksim": "",
	"ThickSpace": "",
	"ThinSpace": "",
	"thinsp": "",
	"thkap": "",
	"thksim": "",
	"THORN": "",
	"thorn": "",
	"tilde": "",
	"Tilde": "",
	"TildeEqual": "",
	"TildeFullEqual": "",
	"TildeTilde": "",
	"timesbar": "",
	"timesb": "",
	"times": "",
	"timesd": "",
	"tint": "",
	"toea": "",
	"topbot": "",
	"topcir": "",
	"top": "",
	"Topf": "",
	"topf": "",
	"topfork": "",
	"tosa": "",
	"tprime": "",
	"trade": "",
	"TRADE": "",
	"triangle": "",
	"triangledown": "",
	"triangleleft": "",
	"trianglelefteq": "",
	"triangleq": "",
	"triangleright": "",
	"trianglerighteq": "",
	"tridot": "",
	"trie": "",
	"triminus": "",
	"TripleDot": "",
	"triplus": "",
	"trisb": "",
	"tritime": "",
	"trpezium": "",
	"Tscr": "",
	"tscr": "",
	"TScy": "",
	"tscy": "",
	"TSHcy": "",
	"tshcy": "",
	"Tstrok": "",
	"tstrok": "",
	"twixt": "",
	"twoheadleftarrow": "",
	"twoheadrightarrow": "",
	"Uacute": "",
	"uacute": "",
	"uarr": "",
	"Uarr": "",
	"uArr": "",
	"Uarrocir": "",
	"Ubrcy": "",
	"ubrcy": "",
	"Ubreve": "",
	"ubreve": "",
	"Ucirc": "",
	"ucirc": "",
	"Ucy": "",
	"ucy": "",
	"udarr": "",
	"Udblac": "",
	"udblac": "",
	"udhar": "",
	"ufisht": "",
	"Ufr": "",
	"ufr": "",
	"Ugrave": "",
	"ugrave": "",
	"uHar": "",
	"uharl": "",
	"uharr": "",
	"uhblk": "",
	"ulcorn": "",
	"ulcorner": "",
	"ulcrop": "",
	"ultri": "",
	"Umacr": "",
	"umacr": "",
	"uml": "",
	"UnderBar": "_",
	"UnderBrace": "",
	"UnderBracket": "",
	"UnderParenthesis": "",
	"Union": "",
	"UnionPlus": "",
	"Uogon": "",
	"uogon": "",
	"Uopf": "",
	"uopf": "",
	"UpArrowBar": "",
	"uparrow": "",
	"UpArrow": "",
	"Uparrow": "",
	"UpArrowDownArrow": "",
	"updownarrow": "",
	"UpDownArrow": "",
	"Updownarrow": "",
	"UpEquilibrium": "",
	"upharpoonleft": "",
	"upharpoonright": "",
	"uplus": "",
	"UpperLeftArrow": "",
	"UpperRightArrow": "",
	"upsi": "",
	"Upsi": "",
	"upsih": "",
	"Upsilon": "",
	"upsilon": "",
	"UpTeeArrow": "",
	"UpTee": "",
	"upuparrows": "",
	"urcorn": "",
	"urcorner": "",
	"urcrop": "",
	"Uring": "",
	"uring": "",
	"urtri": "",
	"Uscr": "",
	"uscr": "",
	"utdot": "",
	"Utilde": "",
	"utilde": "",
	"utri": "",
	"utrif": "",
	"uuarr": "",
	"Uuml": "",
	"uuml": "",
	"uwangle": "",
	"vangrt": "",
	"varepsilon": "",
	"varkappa": "",
	"varnothing": "",
	"varphi": "",
	"varpi": "",
	"varpropto": "",
	"varr": "",
	"vArr": "",
	"varrho": "",
	"varsigma": "",
	"varsubsetneq": "",
	"varsubsetneqq": "",
	"varsupsetneq": "",
	"varsupsetneqq": "",
	"vartheta": "",
	"vartriangleleft": "",
	"vartriangleright": "",
	"vBar": "",
	"Vbar": "",
	"vBarv": "",
	"Vcy": "",
	"vcy": "",
	"vdash": "",
	"vDash": "",
	"Vdash": "",
	"VDash": "",
	"Vdashl": "",
	"veebar": "",
	"vee": "",
	"Vee": "",
	"veeeq": "",
	"vellip": "",
	"verbar": "|",
	"Verbar": "",
	"vert": "|",
	"Vert": "",
	"VerticalBar": "",
	"VerticalLine": "|",
	"VerticalSeparator": "",
	"VerticalTilde": "",
	"VeryThinSpace": "",
	"Vfr": "",
	"vfr": "",
	"vltri": "",
	"vnsub": "",
	"vnsup": "",
	"Vopf": "",
	"vopf": "",
	"vprop": "",
	"vrtri": "",
	"Vscr": "",
	"vscr": "",
	"vsubnE": "",
	"vsubne": "",
	"vsupnE": "",
	"vsupne": "",
	"Vvdash": "",
	"vzigzag": "",
	"Wcirc": "",
	"wcirc": "",
	"wedbar": "",
	"wedge": "",
	"Wedge": "",
	"wedgeq": "",
	"weierp": "",
	"Wfr": "",
	"wfr": "",
	"Wopf": "",
	"wopf": "",
	"wp": "",
	"wr": "",
	"wreath": "",
	"Wscr": "",
	"wscr": "",
	"xcap": "",
	"xcirc": "",
	"xcup": "",
	"xdtri": "",
	"Xfr": "",
	"xfr": "",
	"xharr": "",
	"xhArr": "",
	"Xi": "",
	"xi": "",
	"xlarr": "",
	"xlArr": "",
	"xmap": "",
	"xnis": "",
	"xodot": "",
	"Xopf": "",
	"xopf": "",
	"xoplus": "",
	"xotime": "",
	"xrarr": "",
	"xrArr": "",
	"Xscr": "",
	"xscr": "",
	"xsqcup": "",
	"xuplus": "",
	"xutri": "",
	"xvee": "",
	"xwedge": "",
	"Yacute": "",
	"yacute": "",
	"YAcy": "",
	"yacy": "",
	"Ycirc": "",
	"ycirc": "",
	"Ycy": "",
	"ycy": "",
	"yen": "",
	"Yfr": "",
	"yfr": "",
	"YIcy": "",
	"yicy": "",
	"Yopf": "",
	"yopf": "",
	"Yscr": "",
	"yscr": "",
	"YUcy": "",
	"yucy": "",
	"yuml": "",
	"Yuml": "",
	"Zacute": "",
	"zacute": "",
	"Zcaron": "",
	"zcaron": "",
	"Zcy": "",
	"zcy": "",
	"Zdot": "",
	"zdot": "",
	"zeetrf": "",
	"ZeroWidthSpace": "",
	"Zeta": "",
	"zeta": "",
	"zfr": "",
	"Zfr": "",
	"ZHcy": "",
	"zhcy": "",
	"zigrarr": "",
	"zopf": "",
	"Zopf": "",
	"Zscr": "",
	"zscr": "",
	"zwj": "",
	"zwnj": ""
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(77);
var ieee754 = __webpack_require__(80);
var isArray = __webpack_require__(81);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(78).Buffer))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(79)(undefined);
// imports


// module
exports.push([module.i, "._1KcE7rh1MKAyevd2eM_Atg{background:#fcfcfc}._1KcE7rh1MKAyevd2eM_Atg,._2JVrhqwwHo83LeHuZREeE1{padding:10px;overflow:auto;max-height:600px}._1uPz2lT9fVqVJNBexEHKSq{width:100%;font-size:24pt;padding-left:10px}._2nS6m57p7dJjy-WwNYxzve{width:100%;font-size:18pt;padding-left:10px}", ""]);

// exports
exports.locals = {
	"editor": "_1KcE7rh1MKAyevd2eM_Atg",
	"preview": "_2JVrhqwwHo83LeHuZREeE1",
	"title": "_1uPz2lT9fVqVJNBexEHKSq",
	"tags": "_2nS6m57p7dJjy-WwNYxzve"
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(82);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(83);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(84)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjcxZGUzNTcxNjViYWE4MTcwZjUiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21pdGhyaWwvbWl0aHJpbC5qcyIsIndlYnBhY2s6Ly8vLi9lbnRyeS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvdG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2xpbmtpZnktaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2xpYi9yZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9ibG9jay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9saW5rLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24iLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2ZpeFVybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzLmNzcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzLmNzcz9hODEzIl0sIm5hbWVzIjpbImciLCJGdW5jdGlvbiIsImV2YWwiLCJlIiwid2luZG93IiwibW9kdWxlIiwiZXhwb3J0cyIsIlZub2RlIiwidGFnIiwia2V5IiwiYXR0cnMwIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZG9tIiwiYXR0cnMiLCJkb21TaXplIiwidW5kZWZpbmVkIiwic3RhdGUiLCJfc3RhdGUiLCJldmVudHMiLCJpbnN0YW5jZSIsInNraXAiLCJub3JtYWxpemUiLCJub2RlIiwiQXJyYXkiLCJpc0FycmF5Iiwibm9ybWFsaXplQ2hpbGRyZW4iLCJpIiwibGVuZ3RoIiwic2VsZWN0b3JQYXJzZXIiLCJzZWxlY3RvckNhY2hlIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJjb21waWxlU2VsZWN0b3IiLCJzZWxlY3RvciIsIm1hdGNoIiwiY2xhc3NlcyIsImV4ZWMiLCJ0eXBlIiwidmFsdWUiLCJpZCIsInB1c2giLCJhdHRyVmFsdWUiLCJyZXBsYWNlIiwiY2xhc3NOYW1lIiwiam9pbiIsImV4ZWNTZWxlY3RvciIsImhhc0F0dHJzIiwiY2hpbGRMaXN0IiwiY2xhc3MiLCJjYWxsIiwiaHlwZXJzY3JpcHQiLCJhcmd1bWVudHMiLCJzdGFydCIsInZpZXciLCJFcnJvciIsImNhY2hlZCIsIm5vcm1hbGl6ZWQiLCJ0cnVzdCIsImh0bWwiLCJmcmFnbWVudCIsImF0dHJzMSIsIm0iLCJQcm9taXNlUG9seWZpbGwiLCJleGVjdXRvciIsIlR5cGVFcnJvciIsInNlbGYiLCJyZXNvbHZlcnMiLCJyZWplY3RvcnMiLCJyZXNvbHZlQ3VycmVudCIsImhhbmRsZXIiLCJyZWplY3RDdXJyZW50IiwiX2luc3RhbmNlIiwiY2FsbEFzeW5jIiwic2V0SW1tZWRpYXRlIiwic2V0VGltZW91dCIsImxpc3QiLCJzaG91bGRBYnNvcmIiLCJleGVjdXRlIiwidGhlbiIsImV4ZWN1dGVPbmNlIiwiYmluZCIsImNvbnNvbGUiLCJlcnJvciIsInJldHJ5IiwicnVucyIsInJ1biIsImZuIiwib25lcnJvciIsInByb3RvdHlwZSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3Rpb24iLCJoYW5kbGUiLCJjYWxsYmFjayIsIm5leHQiLCJyZXNvbHZlTmV4dCIsInJlamVjdE5leHQiLCJwcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhdGNoIiwiYWxsIiwidG90YWwiLCJjb3VudCIsInZhbHVlcyIsImNvbnN1bWUiLCJyYWNlIiwiUHJvbWlzZSIsImdsb2JhbCIsImJ1aWxkUXVlcnlTdHJpbmciLCJvYmplY3QiLCJPYmplY3QiLCJ0b1N0cmluZyIsImFyZ3MiLCJrZXkwIiwiZGVzdHJ1Y3R1cmUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJGSUxFX1BST1RPQ09MX1JFR0VYIiwiUmVnRXhwIiwiXzgiLCIkd2luZG93IiwiY2FsbGJhY2tDb3VudCIsIm9uY29tcGxldGlvbiIsInNldENvbXBsZXRpb25DYWxsYmFjayIsImZpbmFsaXplciIsImNvbXBsZXRlIiwiZmluYWxpemUiLCJwcm9taXNlMCIsInRoZW4wIiwiYXBwbHkiLCJleHRyYSIsInVybCIsInJlcXVlc3QiLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInVzZUJvZHkiLCJzZXJpYWxpemUiLCJGb3JtRGF0YSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzZXJpYWxpemUiLCJleHRyYWN0IiwiaW50ZXJwb2xhdGUiLCJhc3NlbWJsZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiYWJvcnRlZCIsIl9hYm9ydCIsImFib3J0Iiwib3BlbiIsImFzeW5jIiwidXNlciIsInBhc3N3b3JkIiwic2V0UmVxdWVzdEhlYWRlciIsIndpdGhDcmVkZW50aWFscyIsImhlYWRlcnMiLCJjb25maWciLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJ0ZXN0IiwiY2FzdCIsInJlc3BvbnNlVGV4dCIsInNlbmQiLCJiYWNrZ3JvdW5kIiwianNvbnAiLCJjYWxsYmFja05hbWUiLCJNYXRoIiwicm91bmQiLCJyYW5kb20iLCJzY3JpcHQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjYWxsYmFja0tleSIsInNyYyIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwidG9rZW5zIiwic2xpY2UiLCJxdWVyeXN0cmluZyIsInByZWZpeCIsImluZGV4T2YiLCJwYXJzZSIsInR5cGUwIiwicmVxdWVzdFNlcnZpY2UiLCJjb3JlUmVuZGVyZXIiLCIkZG9jIiwiJGVtcHR5RnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50Iiwib25ldmVudCIsInNldEV2ZW50Q2FsbGJhY2siLCJjcmVhdGVOb2RlcyIsInBhcmVudCIsInZub2RlcyIsImVuZCIsImhvb2tzIiwibmV4dFNpYmxpbmciLCJucyIsInZub2RlIiwiY3JlYXRlTm9kZSIsImluaXRMaWZlY3ljbGUiLCJjcmVhdGVUZXh0IiwiY3JlYXRlSFRNTCIsImNyZWF0ZUZyYWdtZW50IiwiY3JlYXRlQ29tcG9uZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJpbnNlcnROb2RlIiwibWF0Y2gxIiwicGFyZW50MSIsImNhcHRpb24iLCJ0aGVhZCIsInRib2R5IiwidGZvb3QiLCJ0ciIsInRoIiwidGQiLCJjb2xncm91cCIsImNvbCIsInRlbXAiLCJpbm5lckhUTUwiLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImNoaWxkIiwiYXR0cnMyIiwiaXMiLCJlbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwic2V0QXR0cnMiLCJjb250ZW50ZWRpdGFibGUiLCJzZXRDb250ZW50RWRpdGFibGUiLCJ0ZXh0Q29udGVudCIsInNldExhdGVBdHRycyIsImluaXRDb21wb25lbnQiLCJzZW50aW5lbCIsImNyZWF0ZSIsIiQkcmVlbnRyYW50TG9jayQkIiwidXBkYXRlTm9kZXMiLCJvbGQiLCJyZWN5Y2xpbmciLCJyZW1vdmVOb2RlcyIsImlzVW5rZXllZCIsImdldE5leHRTaWJsaW5nIiwidXBkYXRlTm9kZSIsImlzUmVjeWNsYWJsZSIsInBvb2wiLCJjb25jYXQiLCJvbGRTdGFydCIsIm9sZEVuZCIsIm1hcCIsIm8iLCJ2Iiwic2hvdWxkUmVjeWNsZSIsInRvRnJhZ21lbnQiLCJnZXRLZXlNYXAiLCJvbGRJbmRleCIsIm1vdmFibGUiLCJvbGRUYWciLCJzaG91bGROb3RVcGRhdGUiLCJ1cGRhdGVMaWZlY3ljbGUiLCJ1cGRhdGVUZXh0IiwidXBkYXRlSFRNTCIsInVwZGF0ZUZyYWdtZW50IiwidXBkYXRlRWxlbWVudCIsInVwZGF0ZUNvbXBvbmVudCIsInJlbW92ZU5vZGUiLCJub2RlVmFsdWUiLCJ1cGRhdGVBdHRycyIsImFicyIsIm9sZENoaWxkcmVuTGVuZ3RoIiwicG9vbENoaWxkcmVuTGVuZ3RoIiwidm5vZGVzQ2hpbGRyZW5MZW5ndGgiLCJrZXkyIiwiY291bnQwIiwiaW5zZXJ0QmVmb3JlIiwiY29udGVudCIsImNvbnRleHQiLCJleHBlY3RlZCIsImNhbGxlZCIsIm9uYmVmb3JlcmVtb3ZlIiwicmVzdWx0IiwiY29udGludWF0aW9uIiwib25yZW1vdmUiLCJyZW1vdmVOb2RlRnJvbURPTSIsImhhc0ludGVncmF0aW9uTWV0aG9kcyIsInNldEF0dHIiLCJpc0Zvcm1BdHRyaWJ1dGUiLCJpc0xpZmVjeWNsZU1ldGhvZCIsIm5zTGFzdEluZGV4Iiwic3Vic3RyIiwic2V0QXR0cmlidXRlTlMiLCJ1cGRhdGVFdmVudCIsInVwZGF0ZVN0eWxlIiwiaXNBdHRyaWJ1dGUiLCJpc0N1c3RvbUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwic2VsZWN0ZWRJbmRleCIsImF0dHIiLCJzb3VyY2UiLCJvbmNyZWF0ZSIsIm9udXBkYXRlIiwic3R5bGUiLCJjc3NUZXh0IiwiZXZlbnROYW1lIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmluaXQiLCJmb3JjZVZub2RlVXBkYXRlIiwiZm9yY2VDb21wb25lbnRVcGRhdGUiLCJvbmJlZm9yZXVwZGF0ZSIsInJlbmRlciIsImFjdGl2ZSIsImZvY3VzIiwidGhyb3R0bGUiLCJ0aW1lIiwibGFzdCIsInBlbmRpbmciLCJ0aW1lb3V0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibm93IiwiRGF0ZSIsIl8xMSIsInJlbmRlclNlcnZpY2UiLCJyZWRyYXciLCJjYWxsYmFja3MiLCJzdWJzY3JpYmUiLCJrZXkxIiwidW5zdWJzY3JpYmUiLCJpbmRleCIsInNwbGljZSIsInJlZHJhd1NlcnZpY2UiLCJfMTYiLCJyZWRyYXdTZXJ2aWNlMCIsInJvb3QiLCJjb21wb25lbnQiLCJydW4wIiwibW91bnQiLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic3RyaW5nIiwiY2hhckF0IiwiZW50cmllcyIsInNwbGl0IiwiZGF0YTAiLCJjb3VudGVycyIsImVudHJ5Iiwia2V5NSIsImRlY29kZVVSSUNvbXBvbmVudCIsImxldmVscyIsImN1cnNvciIsInBvcCIsImoiLCJsZXZlbCIsIm5leHRMZXZlbCIsImlzTnVtYmVyIiwiaXNOYU4iLCJwYXJzZUludCIsImlzVmFsdWUiLCJjb3JlUm91dGVyIiwic3VwcG9ydHNQdXNoU3RhdGUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiY2FsbEFzeW5jMCIsIm5vcm1hbGl6ZTEiLCJmcmFnbWVudDAiLCJsb2NhdGlvbiIsImFzeW5jSWQiLCJkZWJvdW5jZUFzeW5jIiwiY2FsbGJhY2swIiwicGFyc2VQYXRoIiwicGF0aCIsInF1ZXJ5RGF0YSIsImhhc2hEYXRhIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsInBhdGhFbmQiLCJxdWVyeUVuZCIsInF1ZXJ5UGFyYW1zIiwia2V5NCIsImhhc2hQYXJhbXMiLCJyb3V0ZXIiLCJnZXRQYXRoIiwidHlwZTIiLCJzZXRQYXRoIiwib3B0aW9ucyIsIm1hdGNoMiIsInRva2VuIiwicXVlcnkiLCJoYXNoIiwidGl0bGUiLCJvbnBvcHN0YXRlIiwicmVwbGFjZVN0YXRlIiwiaHJlZiIsImRlZmluZVJvdXRlcyIsInJvdXRlcyIsInJlc29sdmVSb3V0ZSIsInBhcmFtcyIsInBhdGhuYW1lIiwiayIsInJvdXRlMCIsIm1hdGNoZXIiLCJrZXlzIiwib25oYXNoY2hhbmdlIiwiXzIwIiwicm91dGVTZXJ2aWNlIiwiaWRlbnRpdHkiLCJyZW5kZXIxIiwiYXR0cnMzIiwiY3VycmVudFBhdGgiLCJsYXN0VXBkYXRlIiwicm91dGUiLCJkZWZhdWx0Um91dGUiLCJydW4xIiwiYmFpbCIsInBheWxvYWQiLCJ1cGRhdGUiLCJyb3V0ZVJlc29sdmVyIiwiY29tcCIsIm9ubWF0Y2giLCJyZXNvbHZlZCIsInNldCIsImdldCIsInByZWZpeDAiLCJsaW5rIiwidm5vZGUxIiwib25jbGljayIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ3aGljaCIsInByZXZlbnREZWZhdWx0IiwiZ2V0QXR0cmlidXRlIiwicGFyYW0iLCJrZXkzIiwid2l0aEF0dHIiLCJhdHRyTmFtZSIsImNhbGxiYWNrMSIsImN1cnJlbnRUYXJnZXQiLCJfMjgiLCJ2ZXJzaW9uIiwiZ2V0RWxlbWVudEJ5SWQiLCJwcm9jZXNzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsImxlbiIsIm5leHRUaWNrIiwiSXRlbSIsImFycmF5IiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJuYW1lIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJ0YXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJydW5JZlByZXNlbnQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsImNhblVzZVBvc3RNZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsIm9ubWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsIm9uR2xvYmFsTWVzc2FnZSIsImV2ZW50IiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwiZ2V0UHJvdG90eXBlT2YiLCJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2xvc2UiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIml0ZW0iLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwicmVxdWlyZSIsIm1kIiwiQ2VsbCIsInNwYW4iLCJjbHMiLCJpbm5lciIsIlRpdGxlIiwibW9kZWwiLCJUYWdzIiwidGFncyIsIkVkaXRvciIsImxvZyIsImJvZHkiLCJlZGl0b3IiLCJQcmV2aWV3IiwicHJldmlldyIsIlNhdmUiLCJzYXZlIiwiZmV0Y2giLCJmZXRjaGVkIiwiTW9kZWwiLCJfY2xhc3MiLCJvYmoiLCJpc1N0cmluZyIsIl9oYXNPd25Qcm9wZXJ0eSIsImhhcyIsImFzc2lnbiIsInNvdXJjZXMiLCJmb3JFYWNoIiwiYXJyYXlSZXBsYWNlQXQiLCJwb3MiLCJuZXdFbGVtZW50cyIsImlzVmFsaWRFbnRpdHlDb2RlIiwiYyIsImZyb21Db2RlUG9pbnQiLCJzdXJyb2dhdGUxIiwic3Vycm9nYXRlMiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIlVORVNDQVBFX01EX1JFIiwiRU5USVRZX1JFIiwiVU5FU0NBUEVfQUxMX1JFIiwiRElHSVRBTF9FTlRJVFlfVEVTVF9SRSIsImVudGl0aWVzIiwicmVwbGFjZUVudGl0eVBhdHRlcm4iLCJjb2RlIiwiY2hhckNvZGVBdCIsInRvTG93ZXJDYXNlIiwidW5lc2NhcGVNZCIsInN0ciIsInVuZXNjYXBlQWxsIiwiZXNjYXBlZCIsImVudGl0eSIsIkhUTUxfRVNDQVBFX1RFU1RfUkUiLCJIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFIiwiSFRNTF9SRVBMQUNFTUVOVFMiLCJyZXBsYWNlVW5zYWZlQ2hhciIsImNoIiwiZXNjYXBlSHRtbCIsIlJFR0VYUF9FU0NBUEVfUkUiLCJlc2NhcGVSRSIsImlzU3BhY2UiLCJpc1doaXRlU3BhY2UiLCJVTklDT0RFX1BVTkNUX1JFIiwiaXNQdW5jdENoYXIiLCJpc01kQXNjaWlQdW5jdCIsIm5vcm1hbGl6ZVJlZmVyZW5jZSIsInRyaW0iLCJsaWIiLCJtZHVybCIsInVjbWljcm8iLCJSdWxlciIsIl9fcnVsZXNfXyIsIl9fY2FjaGVfXyIsIl9fZmluZF9fIiwiX19jb21waWxlX18iLCJjaGFpbnMiLCJydWxlIiwiZW5hYmxlZCIsImFsdCIsImFsdE5hbWUiLCJjaGFpbiIsImF0Iiwib3B0IiwiYmVmb3JlIiwiYmVmb3JlTmFtZSIsInJ1bGVOYW1lIiwiYWZ0ZXIiLCJhZnRlck5hbWUiLCJlbmFibGUiLCJpZ25vcmVJbnZhbGlkIiwiaWR4IiwiZW5hYmxlT25seSIsImRpc2FibGUiLCJnZXRSdWxlcyIsImNoYWluTmFtZSIsIlRva2VuIiwibmVzdGluZyIsIm1hcmt1cCIsImluZm8iLCJtZXRhIiwiYmxvY2siLCJoaWRkZW4iLCJhdHRySW5kZXgiLCJhdHRyUHVzaCIsImF0dHJEYXRhIiwiYXR0clNldCIsImF0dHJHZXQiLCJhdHRySm9pbiIsImF0dHJfbmFtZSIsInVucXVvdGVkIiwic2luZ2xlX3F1b3RlZCIsImRvdWJsZV9xdW90ZWQiLCJhdHRyX3ZhbHVlIiwiYXR0cmlidXRlIiwib3Blbl90YWciLCJjbG9zZV90YWciLCJjb21tZW50IiwicHJvY2Vzc2luZyIsImRlY2xhcmF0aW9uIiwiY2RhdGEiLCJIVE1MX1RBR19SRSIsIkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUiLCJ0b2tlbml6ZSIsImVtcGhhc2lzIiwic2lsZW50Iiwic2Nhbm5lZCIsInNjYW5EZWxpbXMiLCJkZWxpbWl0ZXJzIiwianVtcCIsImNhbl9vcGVuIiwiY2FuX2Nsb3NlIiwicG9zdFByb2Nlc3MiLCJzdGFydERlbGltIiwiZW5kRGVsaW0iLCJpc1N0cm9uZyIsIm1heCIsInN0cmlrZXRocm91Z2giLCJsb25lTWFya2VycyIsImVuY29kZSIsImRlY29kZSIsImZvcm1hdCIsImlzT2JqZWN0IiwiaXNSZWdFeHAiLCJpc0Z1bmN0aW9uIiwiZGVmYXVsdE9wdGlvbnMiLCJmdXp6eUxpbmsiLCJmdXp6eUVtYWlsIiwiZnV6enlJUCIsImlzT3B0aW9uc09iaiIsInJlZHVjZSIsImFjYyIsImRlZmF1bHRTY2hlbWFzIiwidmFsaWRhdGUiLCJ0YWlsIiwicmUiLCJodHRwIiwic3JjX2F1dGgiLCJzcmNfaG9zdF9wb3J0X3N0cmljdCIsInNyY19wYXRoIiwibm9faHR0cCIsInNyY19kb21haW4iLCJzcmNfZG9tYWluX3Jvb3QiLCJzcmNfcG9ydCIsInNyY19ob3N0X3Rlcm1pbmF0b3IiLCJtYWlsdG8iLCJzcmNfZW1haWxfbmFtZSIsInNyY19ob3N0X3N0cmljdCIsInRsZHNfMmNoX3NyY19yZSIsInRsZHNfZGVmYXVsdCIsInJlc2V0U2NhbkNhY2hlIiwiX19pbmRleF9fIiwiX190ZXh0X2NhY2hlX18iLCJjcmVhdGVWYWxpZGF0b3IiLCJjcmVhdGVOb3JtYWxpemVyIiwiY29tcGlsZSIsIl9fb3B0c19fIiwidGxkcyIsIl9fdGxkc19fIiwib25Db21waWxlIiwiX190bGRzX3JlcGxhY2VkX18iLCJzcmNfeG4iLCJzcmNfdGxkcyIsInVudHBsIiwidHBsIiwiZW1haWxfZnV6enkiLCJ0cGxfZW1haWxfZnV6enkiLCJsaW5rX2Z1enp5IiwidHBsX2xpbmtfZnV6enkiLCJsaW5rX25vX2lwX2Z1enp5IiwidHBsX2xpbmtfbm9faXBfZnV6enkiLCJob3N0X2Z1enp5X3Rlc3QiLCJ0cGxfaG9zdF9mdXp6eV90ZXN0IiwiYWxpYXNlcyIsIl9fY29tcGlsZWRfXyIsInNjaGVtYUVycm9yIiwidmFsIiwiX19zY2hlbWFzX18iLCJjb21waWxlZCIsImFsaWFzIiwic2xpc3QiLCJmaWx0ZXIiLCJzY2hlbWFfdGVzdCIsInNyY19aUENjIiwic2NoZW1hX3NlYXJjaCIsInByZXRlc3QiLCJNYXRjaCIsInNoaWZ0IiwiX19sYXN0X2luZGV4X18iLCJzY2hlbWEiLCJfX3NjaGVtYV9fIiwibGFzdEluZGV4IiwicmF3IiwiY3JlYXRlTWF0Y2giLCJMaW5raWZ5SXQiLCJzY2hlbWFzIiwiYWRkIiwiZGVmaW5pdGlvbiIsIm1sIiwibWUiLCJ0bGRfcG9zIiwiYXRfcG9zIiwidGVzdFNjaGVtYUF0Iiwic2VhcmNoIiwia2VlcE9sZCIsInNvcnQiLCJlbCIsImFyciIsInJldmVyc2UiLCJvcHRzIiwic3JjX0FueSIsInNyY19DYyIsInNyY19aIiwic3JjX1AiLCJzcmNfWkNjIiwidGV4dF9zZXBhcmF0b3JzIiwic3JjX3BzZXVkb19sZXR0ZXIiLCJzcmNfaXA0Iiwic3JjX2hvc3QiLCJ0cGxfaG9zdF9mdXp6eSIsInRwbF9ob3N0X25vX2lwX2Z1enp5IiwidHBsX2hvc3RfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QiLCJ0cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCIsInBhcnNlTGlua0xhYmVsIiwicGFyc2VMaW5rRGVzdGluYXRpb24iLCJwYXJzZUxpbmtUaXRsZSIsImxpbmVzIiwib2siLCJkaXNhYmxlTmVzdGVkIiwiZm91bmQiLCJwcmV2UG9zIiwibGFiZWxFbmQiLCJwb3NNYXgiLCJvbGRQb3MiLCJpbmxpbmUiLCJza2lwVG9rZW4iLCJ1dGlscyIsImhlbHBlcnMiLCJSZW5kZXJlciIsIlBhcnNlckNvcmUiLCJQYXJzZXJCbG9jayIsIlBhcnNlcklubGluZSIsInB1bnljb2RlIiwiemVybyIsImNvbW1vbm1hcmsiLCJCQURfUFJPVE9fUkUiLCJHT09EX0RBVEFfUkUiLCJ2YWxpZGF0ZUxpbmsiLCJSRUNPREVfSE9TVE5BTUVfRk9SIiwibm9ybWFsaXplTGluayIsInBhcnNlZCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJ0b0FTQ0lJIiwiZXIiLCJub3JtYWxpemVMaW5rVGV4dCIsInRvVW5pY29kZSIsIk1hcmtkb3duSXQiLCJwcmVzZXROYW1lIiwiY29yZSIsInJlbmRlcmVyIiwibGlua2lmeSIsImNvbmZpZ3VyZSIsInByZXNldHMiLCJjb21wb25lbnRzIiwicnVsZXMiLCJydWxlciIsInJ1bGVzMiIsInJ1bGVyMiIsIm1pc3NlZCIsInVzZSIsInBsdWdpbiIsIlN0YXRlIiwicGFyc2VJbmxpbmUiLCJpbmxpbmVNb2RlIiwicmVuZGVySW5saW5lIiwiX3J1bGVzIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsImxpbmUiLCJoYXNFbXB0eUxpbmVzIiwibWF4TmVzdGluZyIsInNraXBFbXB0eUxpbmVzIiwic0NvdW50IiwiYmxrSW5kZW50IiwidGlnaHQiLCJpc0VtcHR5Iiwib3V0VG9rZW5zIiwibGluZU1heCIsIkNvcmUiLCJsIiwiX3J1bGVzMiIsImNhY2hlIiwicHVzaFBlbmRpbmciLCJ4aHRtbE91dCIsImJyZWFrcyIsImxhbmdQcmVmaXgiLCJ0eXBvZ3JhcGhlciIsInF1b3RlcyIsImhpZ2hsaWdodCIsImRlZmF1bHRfcnVsZXMiLCJjb2RlX2lubGluZSIsInNsZiIsInJlbmRlckF0dHJzIiwiY29kZV9ibG9jayIsImZlbmNlIiwibGFuZ05hbWUiLCJoaWdobGlnaHRlZCIsInRtcEF0dHJzIiwidG1wVG9rZW4iLCJpbWFnZSIsInJlbmRlcklubGluZUFzVGV4dCIsInJlbmRlclRva2VuIiwiaGFyZGJyZWFrIiwic29mdGJyZWFrIiwiaHRtbF9ibG9jayIsImh0bWxfaW5saW5lIiwibmV4dFRva2VuIiwibmVlZExmIiwiYmxvY2txdW90ZSIsImFkanVzdFRhYiIsImluaXRpYWwiLCJpc091dGRlbnRlZCIsImxhc3RMaW5lRW1wdHkiLCJuZXh0TGluZSIsIm9mZnNldCIsIm9sZEJNYXJrcyIsIm9sZEJTQ291bnQiLCJvbGRJbmRlbnQiLCJvbGRQYXJlbnRUeXBlIiwib2xkU0NvdW50Iiwib2xkVFNoaWZ0Iiwic3BhY2VBZnRlck1hcmtlciIsInRlcm1pbmF0ZSIsInRlcm1pbmF0b3JSdWxlcyIsIm9sZExpbmVNYXgiLCJiTWFya3MiLCJ0U2hpZnQiLCJlTWFya3MiLCJic0NvdW50IiwicGFyZW50VHlwZSIsImdldExpbmVzIiwibWVtIiwiaGF2ZUVuZE1hcmtlciIsInNraXBDaGFycyIsInNraXBTcGFjZXMiLCJoZWFkaW5nIiwidG1wIiwic2tpcFNwYWNlc0JhY2siLCJza2lwQ2hhcnNCYWNrIiwiaHIiLCJjbnQiLCJibG9ja19uYW1lcyIsIkhUTUxfU0VRVUVOQ0VTIiwibGluZVRleHQiLCJsaGVhZGluZyIsInNraXBCdWxsZXRMaXN0TWFya2VyIiwic2tpcE9yZGVyZWRMaXN0TWFya2VyIiwibWFya1RpZ2h0UGFyYWdyYXBocyIsImNvbnRlbnRTdGFydCIsImluZGVudCIsImluZGVudEFmdGVyTWFya2VyIiwiaXNPcmRlcmVkIiwiaXRlbUxpbmVzIiwibGlzdExpbmVzIiwibGlzdFRva0lkeCIsIm1hcmtlckNoYXJDb2RlIiwibWFya2VyVmFsdWUiLCJvbGRMSW5kZW50Iiwib2xkVGlnaHQiLCJwb3NBZnRlck1hcmtlciIsInByZXZFbXB0eUVuZCIsImlzVGVybWluYXRpbmdQYXJhZ3JhcGgiLCJOdW1iZXIiLCJtaW4iLCJwYXJhZ3JhcGgiLCJyZWZlcmVuY2UiLCJfZW5kTGluZSIsImRlc3RFbmRQb3MiLCJkZXN0RW5kTGluZU5vIiwibGFiZWwiLCJyZXMiLCJyZWZlcmVuY2VzIiwiU3RhdGVCbG9jayIsInMiLCJpbmRlbnRfZm91bmQiLCJkZEluZGVudCIsImZyb20iLCJiZWdpbiIsImtlZXBMYXN0TEYiLCJsaW5lSW5kZW50IiwiZmlyc3QiLCJsaW5lU3RhcnQiLCJnZXRMaW5lIiwiZXNjYXBlZFNwbGl0IiwiZXNjYXBlcyIsImxhc3RQb3MiLCJiYWNrVGlja2VkIiwibGFzdEJhY2tUaWNrIiwic3Vic3RyaW5nIiwidGFibGUiLCJjb2x1bW5zIiwiY29sdW1uQ291bnQiLCJhbGlnbnMiLCJ0IiwidGFibGVMaW5lcyIsInRib2R5TGluZXMiLCJ0b2siLCJpc0xpbmtPcGVuIiwiaXNMaW5rQ2xvc2UiLCJjdXJyZW50VG9rZW4iLCJub2RlcyIsImxuIiwiaHRtbExpbmtMZXZlbCIsImZ1bGxVcmwiLCJ1cmxUZXh0IiwiYmxvY2tUb2tlbnMiLCJsaW5rcyIsIk5FV0xJTkVTX1JFIiwiTlVMTF9SRSIsIlJBUkVfUkUiLCJTQ09QRURfQUJCUl9URVNUX1JFIiwiU0NPUEVEX0FCQlJfUkUiLCJTQ09QRURfQUJCUiIsInIiLCJwIiwidG0iLCJyZXBsYWNlRm4iLCJyZXBsYWNlX3Njb3BlZCIsImlubGluZVRva2VucyIsImluc2lkZV9hdXRvbGluayIsInJlcGxhY2VfcmFyZSIsImJsa0lkeCIsIlFVT1RFX1RFU1RfUkUiLCJRVU9URV9SRSIsIkFQT1NUUk9QSEUiLCJyZXBsYWNlQXQiLCJwcm9jZXNzX2lubGluZXMiLCJ0aGlzTGV2ZWwiLCJsYXN0Q2hhciIsIm5leHRDaGFyIiwiaXNMYXN0UHVuY3RDaGFyIiwiaXNOZXh0UHVuY3RDaGFyIiwiaXNMYXN0V2hpdGVTcGFjZSIsImlzTmV4dFdoaXRlU3BhY2UiLCJjYW5PcGVuIiwiY2FuQ2xvc2UiLCJpc1NpbmdsZSIsInN0YWNrIiwib3BlblF1b3RlIiwiY2xvc2VRdW90ZSIsIk9VVEVSIiwic2luZ2xlIiwic21hcnRxdW90ZXMiLCJTdGF0ZUNvcmUiLCJFTUFJTF9SRSIsIkFVVE9MSU5LX1JFIiwiYXV0b2xpbmsiLCJsaW5rTWF0Y2giLCJlbWFpbE1hdGNoIiwiYmFja3RpY2siLCJtYXRjaFN0YXJ0IiwibWF0Y2hFbmQiLCJsaW5rX3BhaXJzIiwibGFzdERlbGltIiwiY3VyckRlbGltIiwib2RkX21hdGNoIiwiRElHSVRBTF9SRSIsIk5BTUVEX1JFIiwiRVNDQVBFRCIsImVzY2FwZSIsImlzTGV0dGVyIiwibGMiLCJsYWJlbFN0YXJ0IiwicGFyc2VSZWZlcmVuY2UiLCJuZXdsaW5lIiwicG1heCIsIlN0YXRlSW5saW5lIiwicGVuZGluZ0xldmVsIiwiY2FuU3BsaXRXb3JkIiwibGVmdF9mbGFua2luZyIsInJpZ2h0X2ZsYW5raW5nIiwiaXNUZXJtaW5hdG9yQ2hhciIsInRleHRfY29sbGFwc2UiLCJjdXJyIiwiZGVjb2RlQ2FjaGUiLCJnZXREZWNvZGVDYWNoZSIsImV4Y2x1ZGUiLCJkZWZhdWx0Q2hhcnMiLCJzZXEiLCJiMSIsImIyIiwiYjMiLCJiNCIsImNociIsImNvbXBvbmVudENoYXJzIiwiZW5jb2RlQ2FjaGUiLCJnZXRFbmNvZGVDYWNoZSIsImtlZXBFc2NhcGVkIiwibmV4dENvZGUiLCJzbGFzaGVzIiwiYXV0aCIsInBvcnQiLCJVcmwiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInVybFBhcnNlIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJ1IiwibG93ZXJQcm90byIsImhlYyIsInJlc3QiLCJzaW1wbGVQYXRoIiwicHJvdG8iLCJob3N0RW5kIiwiYXRTaWduIiwibGFzdEluZGV4T2YiLCJob3N0IiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsInVuc2hpZnQiLCJxbSIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwiZnJlZUdsb2JhbCIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsImZsb29yIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwiUmFuZ2VFcnJvciIsIm1hcERvbWFpbiIsInBhcnRzIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwib3V0IiwibiIsImJpYXMiLCJiYXNpYyIsIm9sZGkiLCJ3IiwiYmFzZU1pbnVzVCIsImhhbmRsZWRDUENvdW50IiwiYmFzaWNMZW5ndGgiLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsImRlZmluZSIsIkFueSIsIkNjIiwiQ2YiLCJQIiwiWiIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiYnl0ZUxlbmd0aCIsInRvQnl0ZUFycmF5IiwiZnJvbUJ5dGVBcnJheSIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsIlVpbnQ4QXJyYXkiLCJwbGFjZUhvbGRlcnNDb3VudCIsImI2NCIsInBsYWNlSG9sZGVycyIsIkwiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4IiwiZXh0cmFCeXRlcyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsImJhc2U2NCIsImllZWU3NTQiLCJCdWZmZXIiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJrTWF4TGVuZ3RoIiwiX19wcm90b19fIiwiZm9vIiwic3ViYXJyYXkiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwicG9vbFNpemUiLCJfYXVnbWVudCIsIkFycmF5QnVmZmVyIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uZmlndXJhYmxlIiwiYXNzZXJ0U2l6ZSIsInNpemUiLCJhbGxvYyIsImZpbGwiLCJlbmNvZGluZyIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJpc0VuY29kaW5nIiwiYWN0dWFsIiwid3JpdGUiLCJmcm9tQXJyYXlMaWtlIiwiYnl0ZU9mZnNldCIsImlzQnVmZmVyIiwiY29weSIsImJ1ZmZlciIsImlzbmFuIiwiYiIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwieCIsInkiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInRhcmdldCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImFycmF5SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsInJlbWFpbmluZyIsInN0ckxlbiIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwiZmlyc3RCeXRlIiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsInJldCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwidW5pdHMiLCJJbmZpbml0eSIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJoaSIsImxvIiwiZHN0IiwidXNlU291cmNlTWFwIiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImNzc01hcHBpbmciLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsImQiLCJOYU4iLCJydCIsIkxOMiIsImNzcyIsImJhc2VVcmwiLCJjdXJyZW50RGlyIiwiZml4ZWRDc3MiLCJmdWxsTWF0Y2giLCJvcmlnVXJsIiwidW5xdW90ZWRPcmlnVXJsIiwiJDEiLCJuZXdVcmwiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoRUEsSUFBSUEsQ0FBSjs7QUFFQTtBQUNBQSxJQUFLLFlBQVc7QUFDZixRQUFPLElBQVA7QUFDQSxDQUZHLEVBQUo7O0FBSUEsSUFBSTtBQUNIO0FBQ0FBLEtBQUlBLEtBQUtDLFNBQVMsYUFBVCxHQUFMLElBQWtDLENBQUMsR0FBRUMsSUFBSCxF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQzlrRUE7O0FBRUFDLFFBQVE0bkMsVUFBUixHQUFxQkEsVUFBckI7QUFDQTVuQyxRQUFRNm5DLFdBQVIsR0FBc0JBLFdBQXRCO0FBQ0E3bkMsUUFBUThuQyxhQUFSLEdBQXdCQSxhQUF4Qjs7QUFFQSxJQUFJQyxTQUFTLEVBQWI7QUFDQSxJQUFJQyxZQUFZLEVBQWhCO0FBQ0EsSUFBSUMsTUFBTSxPQUFPQyxVQUFQLEtBQXNCLFdBQXRCLEdBQW9DQSxVQUFwQyxHQUFpRGhuQyxLQUEzRDs7QUFFQSxJQUFJdWlCLE9BQU8sa0VBQVg7QUFDQSxLQUFLLElBQUlwaUIsSUFBSSxDQUFSLEVBQVdrYixNQUFNa0gsS0FBS25pQixNQUEzQixFQUFtQ0QsSUFBSWtiLEdBQXZDLEVBQTRDLEVBQUVsYixDQUE5QyxFQUFpRDtBQUMvQzBtQyxTQUFPMW1DLENBQVAsSUFBWW9pQixLQUFLcGlCLENBQUwsQ0FBWjtBQUNBMm1DLFlBQVV2a0IsS0FBS0MsVUFBTCxDQUFnQnJpQixDQUFoQixDQUFWLElBQWdDQSxDQUFoQztBQUNEOztBQUVEMm1DLFVBQVUsSUFBSXRrQixVQUFKLENBQWUsQ0FBZixDQUFWLElBQStCLEVBQS9CO0FBQ0Fza0IsVUFBVSxJQUFJdGtCLFVBQUosQ0FBZSxDQUFmLENBQVYsSUFBK0IsRUFBL0I7O0FBRUEsU0FBU3lrQixpQkFBVCxDQUE0QkMsR0FBNUIsRUFBaUM7QUFDL0IsTUFBSTdyQixNQUFNNnJCLElBQUk5bUMsTUFBZDtBQUNBLE1BQUlpYixNQUFNLENBQU4sR0FBVSxDQUFkLEVBQWlCO0FBQ2YsVUFBTSxJQUFJdFosS0FBSixDQUFVLGdEQUFWLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT21sQyxJQUFJN3JCLE1BQU0sQ0FBVixNQUFpQixHQUFqQixHQUF1QixDQUF2QixHQUEyQjZyQixJQUFJN3JCLE1BQU0sQ0FBVixNQUFpQixHQUFqQixHQUF1QixDQUF2QixHQUEyQixDQUE3RDtBQUNEOztBQUVELFNBQVNxckIsVUFBVCxDQUFxQlEsR0FBckIsRUFBMEI7QUFDeEI7QUFDQSxTQUFPQSxJQUFJOW1DLE1BQUosR0FBYSxDQUFiLEdBQWlCLENBQWpCLEdBQXFCNm1DLGtCQUFrQkMsR0FBbEIsQ0FBNUI7QUFDRDs7QUFFRCxTQUFTUCxXQUFULENBQXNCTyxHQUF0QixFQUEyQjtBQUN6QixNQUFJL21DLENBQUosRUFBT3dVLENBQVAsRUFBVXNlLENBQVYsRUFBYXlELEdBQWIsRUFBa0J5USxZQUFsQixFQUFnQ3RaLEdBQWhDO0FBQ0EsTUFBSXhTLE1BQU02ckIsSUFBSTltQyxNQUFkO0FBQ0ErbUMsaUJBQWVGLGtCQUFrQkMsR0FBbEIsQ0FBZjs7QUFFQXJaLFFBQU0sSUFBSWtaLEdBQUosQ0FBUTFyQixNQUFNLENBQU4sR0FBVSxDQUFWLEdBQWM4ckIsWUFBdEIsQ0FBTjs7QUFFQTtBQUNBbFUsTUFBSWtVLGVBQWUsQ0FBZixHQUFtQjlyQixNQUFNLENBQXpCLEdBQTZCQSxHQUFqQzs7QUFFQSxNQUFJK3JCLElBQUksQ0FBUjs7QUFFQSxPQUFLam5DLElBQUksQ0FBSixFQUFPd1UsSUFBSSxDQUFoQixFQUFtQnhVLElBQUk4eUIsQ0FBdkIsRUFBMEI5eUIsS0FBSyxDQUFMLEVBQVF3VSxLQUFLLENBQXZDLEVBQTBDO0FBQ3hDK2hCLFVBQU9vUSxVQUFVSSxJQUFJMWtCLFVBQUosQ0FBZXJpQixDQUFmLENBQVYsS0FBZ0MsRUFBakMsR0FBd0MybUMsVUFBVUksSUFBSTFrQixVQUFKLENBQWVyaUIsSUFBSSxDQUFuQixDQUFWLEtBQW9DLEVBQTVFLEdBQW1GMm1DLFVBQVVJLElBQUkxa0IsVUFBSixDQUFlcmlCLElBQUksQ0FBbkIsQ0FBVixLQUFvQyxDQUF2SCxHQUE0SDJtQyxVQUFVSSxJQUFJMWtCLFVBQUosQ0FBZXJpQixJQUFJLENBQW5CLENBQVYsQ0FBbEk7QUFDQTB0QixRQUFJdVosR0FBSixJQUFZMVEsT0FBTyxFQUFSLEdBQWMsSUFBekI7QUFDQTdJLFFBQUl1WixHQUFKLElBQVkxUSxPQUFPLENBQVIsR0FBYSxJQUF4QjtBQUNBN0ksUUFBSXVaLEdBQUosSUFBVzFRLE1BQU0sSUFBakI7QUFDRDs7QUFFRCxNQUFJeVEsaUJBQWlCLENBQXJCLEVBQXdCO0FBQ3RCelEsVUFBT29RLFVBQVVJLElBQUkxa0IsVUFBSixDQUFlcmlCLENBQWYsQ0FBVixLQUFnQyxDQUFqQyxHQUF1QzJtQyxVQUFVSSxJQUFJMWtCLFVBQUosQ0FBZXJpQixJQUFJLENBQW5CLENBQVYsS0FBb0MsQ0FBakY7QUFDQTB0QixRQUFJdVosR0FBSixJQUFXMVEsTUFBTSxJQUFqQjtBQUNELEdBSEQsTUFHTyxJQUFJeVEsaUJBQWlCLENBQXJCLEVBQXdCO0FBQzdCelEsVUFBT29RLFVBQVVJLElBQUkxa0IsVUFBSixDQUFlcmlCLENBQWYsQ0FBVixLQUFnQyxFQUFqQyxHQUF3QzJtQyxVQUFVSSxJQUFJMWtCLFVBQUosQ0FBZXJpQixJQUFJLENBQW5CLENBQVYsS0FBb0MsQ0FBNUUsR0FBa0YybUMsVUFBVUksSUFBSTFrQixVQUFKLENBQWVyaUIsSUFBSSxDQUFuQixDQUFWLEtBQW9DLENBQTVIO0FBQ0EwdEIsUUFBSXVaLEdBQUosSUFBWTFRLE9BQU8sQ0FBUixHQUFhLElBQXhCO0FBQ0E3SSxRQUFJdVosR0FBSixJQUFXMVEsTUFBTSxJQUFqQjtBQUNEOztBQUVELFNBQU83SSxHQUFQO0FBQ0Q7O0FBRUQsU0FBU3daLGVBQVQsQ0FBMEJDLEdBQTFCLEVBQStCO0FBQzdCLFNBQU9ULE9BQU9TLE9BQU8sRUFBUCxHQUFZLElBQW5CLElBQTJCVCxPQUFPUyxPQUFPLEVBQVAsR0FBWSxJQUFuQixDQUEzQixHQUFzRFQsT0FBT1MsT0FBTyxDQUFQLEdBQVcsSUFBbEIsQ0FBdEQsR0FBZ0ZULE9BQU9TLE1BQU0sSUFBYixDQUF2RjtBQUNEOztBQUVELFNBQVNDLFdBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCM2xDLEtBQTdCLEVBQW9DaUosR0FBcEMsRUFBeUM7QUFDdkMsTUFBSTRyQixHQUFKO0FBQ0EsTUFBSTBOLFNBQVMsRUFBYjtBQUNBLE9BQUssSUFBSWprQyxJQUFJMEIsS0FBYixFQUFvQjFCLElBQUkySyxHQUF4QixFQUE2QjNLLEtBQUssQ0FBbEMsRUFBcUM7QUFDbkN1MkIsVUFBTSxDQUFDOFEsTUFBTXJuQyxDQUFOLEtBQVksRUFBYixLQUFvQnFuQyxNQUFNcm5DLElBQUksQ0FBVixLQUFnQixDQUFwQyxJQUEwQ3FuQyxNQUFNcm5DLElBQUksQ0FBVixDQUFoRDtBQUNBaWtDLFdBQU9uakMsSUFBUCxDQUFZb21DLGdCQUFnQjNRLEdBQWhCLENBQVo7QUFDRDtBQUNELFNBQU8wTixPQUFPL2lDLElBQVAsQ0FBWSxFQUFaLENBQVA7QUFDRDs7QUFFRCxTQUFTdWxDLGFBQVQsQ0FBd0JZLEtBQXhCLEVBQStCO0FBQzdCLE1BQUk5USxHQUFKO0FBQ0EsTUFBSXJiLE1BQU1tc0IsTUFBTXBuQyxNQUFoQjtBQUNBLE1BQUlxbkMsYUFBYXBzQixNQUFNLENBQXZCLENBSDZCLENBR0o7QUFDekIsTUFBSStvQixTQUFTLEVBQWI7QUFDQSxNQUFJSixRQUFRLEVBQVo7QUFDQSxNQUFJMEQsaUJBQWlCLEtBQXJCLENBTjZCLENBTUY7O0FBRTNCO0FBQ0EsT0FBSyxJQUFJdm5DLElBQUksQ0FBUixFQUFXd25DLE9BQU90c0IsTUFBTW9zQixVQUE3QixFQUF5Q3RuQyxJQUFJd25DLElBQTdDLEVBQW1EeG5DLEtBQUt1bkMsY0FBeEQsRUFBd0U7QUFDdEUxRCxVQUFNL2lDLElBQU4sQ0FBV3NtQyxZQUFZQyxLQUFaLEVBQW1Ccm5DLENBQW5CLEVBQXVCQSxJQUFJdW5DLGNBQUwsR0FBdUJDLElBQXZCLEdBQThCQSxJQUE5QixHQUFzQ3huQyxJQUFJdW5DLGNBQWhFLENBQVg7QUFDRDs7QUFFRDtBQUNBLE1BQUlELGVBQWUsQ0FBbkIsRUFBc0I7QUFDcEIvUSxVQUFNOFEsTUFBTW5zQixNQUFNLENBQVosQ0FBTjtBQUNBK29CLGNBQVV5QyxPQUFPblEsT0FBTyxDQUFkLENBQVY7QUFDQTBOLGNBQVV5QyxPQUFRblEsT0FBTyxDQUFSLEdBQWEsSUFBcEIsQ0FBVjtBQUNBME4sY0FBVSxJQUFWO0FBQ0QsR0FMRCxNQUtPLElBQUlxRCxlQUFlLENBQW5CLEVBQXNCO0FBQzNCL1EsVUFBTSxDQUFDOFEsTUFBTW5zQixNQUFNLENBQVosS0FBa0IsQ0FBbkIsSUFBeUJtc0IsTUFBTW5zQixNQUFNLENBQVosQ0FBL0I7QUFDQStvQixjQUFVeUMsT0FBT25RLE9BQU8sRUFBZCxDQUFWO0FBQ0EwTixjQUFVeUMsT0FBUW5RLE9BQU8sQ0FBUixHQUFhLElBQXBCLENBQVY7QUFDQTBOLGNBQVV5QyxPQUFRblEsT0FBTyxDQUFSLEdBQWEsSUFBcEIsQ0FBVjtBQUNBME4sY0FBVSxHQUFWO0FBQ0Q7O0FBRURKLFFBQU0vaUMsSUFBTixDQUFXbWpDLE1BQVg7O0FBRUEsU0FBT0osTUFBTTNpQyxJQUFOLENBQVcsRUFBWCxDQUFQO0FBQ0QsQzs7Ozs7OztBQ2pIRDs7Ozs7O0FBTUE7O0FBRUE7O0FBRUEsSUFBSXVtQyxTQUFTLG1CQUFBbG9CLENBQVEsRUFBUixDQUFiO0FBQ0EsSUFBSW1vQixVQUFVLG1CQUFBbm9CLENBQVEsRUFBUixDQUFkO0FBQ0EsSUFBSXpmLFVBQVUsbUJBQUF5ZixDQUFRLEVBQVIsQ0FBZDs7QUFFQTVnQixRQUFRZ3BDLE1BQVIsR0FBaUJBLE1BQWpCO0FBQ0FocEMsUUFBUWlwQyxVQUFSLEdBQXFCQSxVQUFyQjtBQUNBanBDLFFBQVFrcEMsaUJBQVIsR0FBNEIsRUFBNUI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQUYsT0FBT0csbUJBQVAsR0FBNkI3aUMsT0FBTzZpQyxtQkFBUCxLQUErQnpvQyxTQUEvQixHQUN6QjRGLE9BQU82aUMsbUJBRGtCLEdBRXpCQyxtQkFGSjs7QUFJQTs7O0FBR0FwcEMsUUFBUXFwQyxVQUFSLEdBQXFCQSxZQUFyQjs7QUFFQSxTQUFTRCxpQkFBVCxHQUE4QjtBQUM1QixNQUFJO0FBQ0YsUUFBSXJhLE1BQU0sSUFBSW1aLFVBQUosQ0FBZSxDQUFmLENBQVY7QUFDQW5aLFFBQUl1YSxTQUFKLEdBQWdCLEVBQUNBLFdBQVdwQixXQUFXL2lDLFNBQXZCLEVBQWtDb2tDLEtBQUssZUFBWTtBQUFFLGVBQU8sRUFBUDtBQUFXLE9BQWhFLEVBQWhCO0FBQ0EsV0FBT3hhLElBQUl3YSxHQUFKLE9BQWMsRUFBZCxJQUFvQjtBQUN2QixXQUFPeGEsSUFBSXlhLFFBQVgsS0FBd0IsVUFEckIsSUFDbUM7QUFDdEN6YSxRQUFJeWEsUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUI1QixVQUFuQixLQUFrQyxDQUZ0QyxDQUhFLENBS3NDO0FBQ3pDLEdBTkQsQ0FNRSxPQUFPL25DLENBQVAsRUFBVTtBQUNWLFdBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3dwQyxVQUFULEdBQXVCO0FBQ3JCLFNBQU9MLE9BQU9HLG1CQUFQLEdBQ0gsVUFERyxHQUVILFVBRko7QUFHRDs7QUFFRCxTQUFTTSxZQUFULENBQXVCQyxJQUF2QixFQUE2QnBvQyxNQUE3QixFQUFxQztBQUNuQyxNQUFJK25DLGVBQWUvbkMsTUFBbkIsRUFBMkI7QUFDekIsVUFBTSxJQUFJMGpDLFVBQUosQ0FBZSw0QkFBZixDQUFOO0FBQ0Q7QUFDRCxNQUFJZ0UsT0FBT0csbUJBQVgsRUFBZ0M7QUFDOUI7QUFDQU8sV0FBTyxJQUFJeEIsVUFBSixDQUFlNW1DLE1BQWYsQ0FBUDtBQUNBb29DLFNBQUtKLFNBQUwsR0FBaUJOLE9BQU83akMsU0FBeEI7QUFDRCxHQUpELE1BSU87QUFDTDtBQUNBLFFBQUl1a0MsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCQSxhQUFPLElBQUlWLE1BQUosQ0FBVzFuQyxNQUFYLENBQVA7QUFDRDtBQUNEb29DLFNBQUtwb0MsTUFBTCxHQUFjQSxNQUFkO0FBQ0Q7O0FBRUQsU0FBT29vQyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxTQUFTVixNQUFULENBQWlCVyxHQUFqQixFQUFzQkMsZ0JBQXRCLEVBQXdDdG9DLE1BQXhDLEVBQWdEO0FBQzlDLE1BQUksQ0FBQzBuQyxPQUFPRyxtQkFBUixJQUErQixFQUFFLGdCQUFnQkgsTUFBbEIsQ0FBbkMsRUFBOEQ7QUFDNUQsV0FBTyxJQUFJQSxNQUFKLENBQVdXLEdBQVgsRUFBZ0JDLGdCQUFoQixFQUFrQ3RvQyxNQUFsQyxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJLE9BQU9xb0MsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFFBQUksT0FBT0MsZ0JBQVAsS0FBNEIsUUFBaEMsRUFBMEM7QUFDeEMsWUFBTSxJQUFJM21DLEtBQUosQ0FDSixtRUFESSxDQUFOO0FBR0Q7QUFDRCxXQUFPNG1DLFlBQVksSUFBWixFQUFrQkYsR0FBbEIsQ0FBUDtBQUNEO0FBQ0QsU0FBT3ZQLEtBQUssSUFBTCxFQUFXdVAsR0FBWCxFQUFnQkMsZ0JBQWhCLEVBQWtDdG9DLE1BQWxDLENBQVA7QUFDRDs7QUFFRDBuQyxPQUFPYyxRQUFQLEdBQWtCLElBQWxCLEMsQ0FBdUI7O0FBRXZCO0FBQ0FkLE9BQU9lLFFBQVAsR0FBa0IsVUFBVWhiLEdBQVYsRUFBZTtBQUMvQkEsTUFBSXVhLFNBQUosR0FBZ0JOLE9BQU83akMsU0FBdkI7QUFDQSxTQUFPNHBCLEdBQVA7QUFDRCxDQUhEOztBQUtBLFNBQVNxTCxJQUFULENBQWVzUCxJQUFmLEVBQXFCem5DLEtBQXJCLEVBQTRCMm5DLGdCQUE1QixFQUE4Q3RvQyxNQUE5QyxFQUFzRDtBQUNwRCxNQUFJLE9BQU9XLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsVUFBTSxJQUFJMEIsU0FBSixDQUFjLHVDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJLE9BQU9xbUMsV0FBUCxLQUF1QixXQUF2QixJQUFzQy9uQyxpQkFBaUIrbkMsV0FBM0QsRUFBd0U7QUFDdEUsV0FBT0MsZ0JBQWdCUCxJQUFoQixFQUFzQnpuQyxLQUF0QixFQUE2QjJuQyxnQkFBN0IsRUFBK0N0b0MsTUFBL0MsQ0FBUDtBQUNEOztBQUVELE1BQUksT0FBT1csS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixXQUFPaW9DLFdBQVdSLElBQVgsRUFBaUJ6bkMsS0FBakIsRUFBd0IybkMsZ0JBQXhCLENBQVA7QUFDRDs7QUFFRCxTQUFPTyxXQUFXVCxJQUFYLEVBQWlCem5DLEtBQWpCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSttQyxPQUFPNU8sSUFBUCxHQUFjLFVBQVVuNEIsS0FBVixFQUFpQjJuQyxnQkFBakIsRUFBbUN0b0MsTUFBbkMsRUFBMkM7QUFDdkQsU0FBTzg0QixLQUFLLElBQUwsRUFBV240QixLQUFYLEVBQWtCMm5DLGdCQUFsQixFQUFvQ3RvQyxNQUFwQyxDQUFQO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJMG5DLE9BQU9HLG1CQUFYLEVBQWdDO0FBQzlCSCxTQUFPN2pDLFNBQVAsQ0FBaUJta0MsU0FBakIsR0FBNkJwQixXQUFXL2lDLFNBQXhDO0FBQ0E2akMsU0FBT00sU0FBUCxHQUFtQnBCLFVBQW5CO0FBQ0EsTUFBSSxPQUFPa0MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT0MsT0FBeEMsSUFDQXJCLE9BQU9vQixPQUFPQyxPQUFkLE1BQTJCckIsTUFEL0IsRUFDdUM7QUFDckM7QUFDQXZpQyxXQUFPaWhDLGNBQVAsQ0FBc0JzQixNQUF0QixFQUE4Qm9CLE9BQU9DLE9BQXJDLEVBQThDO0FBQzVDcG9DLGFBQU8sSUFEcUM7QUFFNUNxb0Msb0JBQWM7QUFGOEIsS0FBOUM7QUFJRDtBQUNGOztBQUVELFNBQVNDLFVBQVQsQ0FBcUJDLElBQXJCLEVBQTJCO0FBQ3pCLE1BQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixVQUFNLElBQUk3bUMsU0FBSixDQUFjLGtDQUFkLENBQU47QUFDRCxHQUZELE1BRU8sSUFBSTZtQyxPQUFPLENBQVgsRUFBYztBQUNuQixVQUFNLElBQUl4RixVQUFKLENBQWUsc0NBQWYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3lGLEtBQVQsQ0FBZ0JmLElBQWhCLEVBQXNCYyxJQUF0QixFQUE0QkUsSUFBNUIsRUFBa0NDLFFBQWxDLEVBQTRDO0FBQzFDSixhQUFXQyxJQUFYO0FBQ0EsTUFBSUEsUUFBUSxDQUFaLEVBQWU7QUFDYixXQUFPZixhQUFhQyxJQUFiLEVBQW1CYyxJQUFuQixDQUFQO0FBQ0Q7QUFDRCxNQUFJRSxTQUFTaHFDLFNBQWIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsV0FBTyxPQUFPaXFDLFFBQVAsS0FBb0IsUUFBcEIsR0FDSGxCLGFBQWFDLElBQWIsRUFBbUJjLElBQW5CLEVBQXlCRSxJQUF6QixDQUE4QkEsSUFBOUIsRUFBb0NDLFFBQXBDLENBREcsR0FFSGxCLGFBQWFDLElBQWIsRUFBbUJjLElBQW5CLEVBQXlCRSxJQUF6QixDQUE4QkEsSUFBOUIsQ0FGSjtBQUdEO0FBQ0QsU0FBT2pCLGFBQWFDLElBQWIsRUFBbUJjLElBQW5CLENBQVA7QUFDRDs7QUFFRDs7OztBQUlBeEIsT0FBT3lCLEtBQVAsR0FBZSxVQUFVRCxJQUFWLEVBQWdCRSxJQUFoQixFQUFzQkMsUUFBdEIsRUFBZ0M7QUFDN0MsU0FBT0YsTUFBTSxJQUFOLEVBQVlELElBQVosRUFBa0JFLElBQWxCLEVBQXdCQyxRQUF4QixDQUFQO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTZCxXQUFULENBQXNCSCxJQUF0QixFQUE0QmMsSUFBNUIsRUFBa0M7QUFDaENELGFBQVdDLElBQVg7QUFDQWQsU0FBT0QsYUFBYUMsSUFBYixFQUFtQmMsT0FBTyxDQUFQLEdBQVcsQ0FBWCxHQUFlSSxRQUFRSixJQUFSLElBQWdCLENBQWxELENBQVA7QUFDQSxNQUFJLENBQUN4QixPQUFPRyxtQkFBWixFQUFpQztBQUMvQixTQUFLLElBQUk5bkMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbXBDLElBQXBCLEVBQTBCLEVBQUVucEMsQ0FBNUIsRUFBK0I7QUFDN0Jxb0MsV0FBS3JvQyxDQUFMLElBQVUsQ0FBVjtBQUNEO0FBQ0Y7QUFDRCxTQUFPcW9DLElBQVA7QUFDRDs7QUFFRDs7O0FBR0FWLE9BQU9hLFdBQVAsR0FBcUIsVUFBVVcsSUFBVixFQUFnQjtBQUNuQyxTQUFPWCxZQUFZLElBQVosRUFBa0JXLElBQWxCLENBQVA7QUFDRCxDQUZEO0FBR0E7OztBQUdBeEIsT0FBTzZCLGVBQVAsR0FBeUIsVUFBVUwsSUFBVixFQUFnQjtBQUN2QyxTQUFPWCxZQUFZLElBQVosRUFBa0JXLElBQWxCLENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVNOLFVBQVQsQ0FBcUJSLElBQXJCLEVBQTJCejBCLE1BQTNCLEVBQW1DMDFCLFFBQW5DLEVBQTZDO0FBQzNDLE1BQUksT0FBT0EsUUFBUCxLQUFvQixRQUFwQixJQUFnQ0EsYUFBYSxFQUFqRCxFQUFxRDtBQUNuREEsZUFBVyxNQUFYO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDM0IsT0FBTzhCLFVBQVAsQ0FBa0JILFFBQWxCLENBQUwsRUFBa0M7QUFDaEMsVUFBTSxJQUFJaG5DLFNBQUosQ0FBYyw0Q0FBZCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSXJDLFNBQVNzbUMsV0FBVzN5QixNQUFYLEVBQW1CMDFCLFFBQW5CLElBQStCLENBQTVDO0FBQ0FqQixTQUFPRCxhQUFhQyxJQUFiLEVBQW1CcG9DLE1BQW5CLENBQVA7O0FBRUEsTUFBSXlwQyxTQUFTckIsS0FBS3NCLEtBQUwsQ0FBVy8xQixNQUFYLEVBQW1CMDFCLFFBQW5CLENBQWI7O0FBRUEsTUFBSUksV0FBV3pwQyxNQUFmLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBb29DLFdBQU9BLEtBQUsxK0IsS0FBTCxDQUFXLENBQVgsRUFBYysvQixNQUFkLENBQVA7QUFDRDs7QUFFRCxTQUFPckIsSUFBUDtBQUNEOztBQUVELFNBQVN1QixhQUFULENBQXdCdkIsSUFBeEIsRUFBOEJodEIsS0FBOUIsRUFBcUM7QUFDbkMsTUFBSXBiLFNBQVNvYixNQUFNcGIsTUFBTixHQUFlLENBQWYsR0FBbUIsQ0FBbkIsR0FBdUJzcEMsUUFBUWx1QixNQUFNcGIsTUFBZCxJQUF3QixDQUE1RDtBQUNBb29DLFNBQU9ELGFBQWFDLElBQWIsRUFBbUJwb0MsTUFBbkIsQ0FBUDtBQUNBLE9BQUssSUFBSUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJQyxNQUFwQixFQUE0QkQsS0FBSyxDQUFqQyxFQUFvQztBQUNsQ3FvQyxTQUFLcm9DLENBQUwsSUFBVXFiLE1BQU1yYixDQUFOLElBQVcsR0FBckI7QUFDRDtBQUNELFNBQU9xb0MsSUFBUDtBQUNEOztBQUVELFNBQVNPLGVBQVQsQ0FBMEJQLElBQTFCLEVBQWdDaHRCLEtBQWhDLEVBQXVDd3VCLFVBQXZDLEVBQW1ENXBDLE1BQW5ELEVBQTJEO0FBQ3pEb2IsUUFBTWtyQixVQUFOLENBRHlELENBQ3hDOztBQUVqQixNQUFJc0QsYUFBYSxDQUFiLElBQWtCeHVCLE1BQU1rckIsVUFBTixHQUFtQnNELFVBQXpDLEVBQXFEO0FBQ25ELFVBQU0sSUFBSWxHLFVBQUosQ0FBZSw2QkFBZixDQUFOO0FBQ0Q7O0FBRUQsTUFBSXRvQixNQUFNa3JCLFVBQU4sR0FBbUJzRCxjQUFjNXBDLFVBQVUsQ0FBeEIsQ0FBdkIsRUFBbUQ7QUFDakQsVUFBTSxJQUFJMGpDLFVBQUosQ0FBZSw2QkFBZixDQUFOO0FBQ0Q7O0FBRUQsTUFBSWtHLGVBQWV4cUMsU0FBZixJQUE0QlksV0FBV1osU0FBM0MsRUFBc0Q7QUFDcERnYyxZQUFRLElBQUl3ckIsVUFBSixDQUFleHJCLEtBQWYsQ0FBUjtBQUNELEdBRkQsTUFFTyxJQUFJcGIsV0FBV1osU0FBZixFQUEwQjtBQUMvQmdjLFlBQVEsSUFBSXdyQixVQUFKLENBQWV4ckIsS0FBZixFQUFzQnd1QixVQUF0QixDQUFSO0FBQ0QsR0FGTSxNQUVBO0FBQ0x4dUIsWUFBUSxJQUFJd3JCLFVBQUosQ0FBZXhyQixLQUFmLEVBQXNCd3VCLFVBQXRCLEVBQWtDNXBDLE1BQWxDLENBQVI7QUFDRDs7QUFFRCxNQUFJMG5DLE9BQU9HLG1CQUFYLEVBQWdDO0FBQzlCO0FBQ0FPLFdBQU9odEIsS0FBUDtBQUNBZ3RCLFNBQUtKLFNBQUwsR0FBaUJOLE9BQU83akMsU0FBeEI7QUFDRCxHQUpELE1BSU87QUFDTDtBQUNBdWtDLFdBQU91QixjQUFjdkIsSUFBZCxFQUFvQmh0QixLQUFwQixDQUFQO0FBQ0Q7QUFDRCxTQUFPZ3RCLElBQVA7QUFDRDs7QUFFRCxTQUFTUyxVQUFULENBQXFCVCxJQUFyQixFQUEyQnhuQixHQUEzQixFQUFnQztBQUM5QixNQUFJOG1CLE9BQU9tQyxRQUFQLENBQWdCanBCLEdBQWhCLENBQUosRUFBMEI7QUFDeEIsUUFBSTNGLE1BQU1xdUIsUUFBUTFvQixJQUFJNWdCLE1BQVosSUFBc0IsQ0FBaEM7QUFDQW9vQyxXQUFPRCxhQUFhQyxJQUFiLEVBQW1CbnRCLEdBQW5CLENBQVA7O0FBRUEsUUFBSW10QixLQUFLcG9DLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckIsYUFBT29vQyxJQUFQO0FBQ0Q7O0FBRUR4bkIsUUFBSWtwQixJQUFKLENBQVMxQixJQUFULEVBQWUsQ0FBZixFQUFrQixDQUFsQixFQUFxQm50QixHQUFyQjtBQUNBLFdBQU9tdEIsSUFBUDtBQUNEOztBQUVELE1BQUl4bkIsR0FBSixFQUFTO0FBQ1AsUUFBSyxPQUFPOG5CLFdBQVAsS0FBdUIsV0FBdkIsSUFDRDluQixJQUFJbXBCLE1BQUosWUFBc0JyQixXQUR0QixJQUNzQyxZQUFZOW5CLEdBRHRELEVBQzJEO0FBQ3pELFVBQUksT0FBT0EsSUFBSTVnQixNQUFYLEtBQXNCLFFBQXRCLElBQWtDZ3FDLE1BQU1wcEIsSUFBSTVnQixNQUFWLENBQXRDLEVBQXlEO0FBQ3ZELGVBQU9tb0MsYUFBYUMsSUFBYixFQUFtQixDQUFuQixDQUFQO0FBQ0Q7QUFDRCxhQUFPdUIsY0FBY3ZCLElBQWQsRUFBb0J4bkIsR0FBcEIsQ0FBUDtBQUNEOztBQUVELFFBQUlBLElBQUlsZ0IsSUFBSixLQUFhLFFBQWIsSUFBeUJiLFFBQVErZ0IsSUFBSTlaLElBQVosQ0FBN0IsRUFBZ0Q7QUFDOUMsYUFBTzZpQyxjQUFjdkIsSUFBZCxFQUFvQnhuQixJQUFJOVosSUFBeEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsUUFBTSxJQUFJekUsU0FBSixDQUFjLG9GQUFkLENBQU47QUFDRDs7QUFFRCxTQUFTaW5DLE9BQVQsQ0FBa0J0cEMsTUFBbEIsRUFBMEI7QUFDeEI7QUFDQTtBQUNBLE1BQUlBLFVBQVUrbkMsWUFBZCxFQUE0QjtBQUMxQixVQUFNLElBQUlyRSxVQUFKLENBQWUsb0RBQ0EsVUFEQSxHQUNhcUUsYUFBYTNpQyxRQUFiLENBQXNCLEVBQXRCLENBRGIsR0FDeUMsUUFEeEQsQ0FBTjtBQUVEO0FBQ0QsU0FBT3BGLFNBQVMsQ0FBaEI7QUFDRDs7QUFFRCxTQUFTMm5DLFVBQVQsQ0FBcUIzbkMsTUFBckIsRUFBNkI7QUFDM0IsTUFBSSxDQUFDQSxNQUFELElBQVdBLE1BQWYsRUFBdUI7QUFBRTtBQUN2QkEsYUFBUyxDQUFUO0FBQ0Q7QUFDRCxTQUFPMG5DLE9BQU95QixLQUFQLENBQWEsQ0FBQ25wQyxNQUFkLENBQVA7QUFDRDs7QUFFRDBuQyxPQUFPbUMsUUFBUCxHQUFrQixTQUFTQSxRQUFULENBQW1CSSxDQUFuQixFQUFzQjtBQUN0QyxTQUFPLENBQUMsRUFBRUEsS0FBSyxJQUFMLElBQWFBLEVBQUVDLFNBQWpCLENBQVI7QUFDRCxDQUZEOztBQUlBeEMsT0FBT3lDLE9BQVAsR0FBaUIsU0FBU0EsT0FBVCxDQUFrQkMsQ0FBbEIsRUFBcUJILENBQXJCLEVBQXdCO0FBQ3ZDLE1BQUksQ0FBQ3ZDLE9BQU9tQyxRQUFQLENBQWdCTyxDQUFoQixDQUFELElBQXVCLENBQUMxQyxPQUFPbUMsUUFBUCxDQUFnQkksQ0FBaEIsQ0FBNUIsRUFBZ0Q7QUFDOUMsVUFBTSxJQUFJNW5DLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSStuQyxNQUFNSCxDQUFWLEVBQWEsT0FBTyxDQUFQOztBQUViLE1BQUlJLElBQUlELEVBQUVwcUMsTUFBVjtBQUNBLE1BQUlzcUMsSUFBSUwsRUFBRWpxQyxNQUFWOztBQUVBLE9BQUssSUFBSUQsSUFBSSxDQUFSLEVBQVdrYixNQUFNcFMsS0FBS292QixHQUFMLENBQVNvUyxDQUFULEVBQVlDLENBQVosQ0FBdEIsRUFBc0N2cUMsSUFBSWtiLEdBQTFDLEVBQStDLEVBQUVsYixDQUFqRCxFQUFvRDtBQUNsRCxRQUFJcXFDLEVBQUVycUMsQ0FBRixNQUFTa3FDLEVBQUVscUMsQ0FBRixDQUFiLEVBQW1CO0FBQ2pCc3FDLFVBQUlELEVBQUVycUMsQ0FBRixDQUFKO0FBQ0F1cUMsVUFBSUwsRUFBRWxxQyxDQUFGLENBQUo7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSXNxQyxJQUFJQyxDQUFSLEVBQVcsT0FBTyxDQUFDLENBQVI7QUFDWCxNQUFJQSxJQUFJRCxDQUFSLEVBQVcsT0FBTyxDQUFQO0FBQ1gsU0FBTyxDQUFQO0FBQ0QsQ0FyQkQ7O0FBdUJBM0MsT0FBTzhCLFVBQVAsR0FBb0IsU0FBU0EsVUFBVCxDQUFxQkgsUUFBckIsRUFBK0I7QUFDakQsVUFBUTFuQixPQUFPMG5CLFFBQVAsRUFBaUJobkIsV0FBakIsRUFBUjtBQUNFLFNBQUssS0FBTDtBQUNBLFNBQUssTUFBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssTUFBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssU0FBTDtBQUNBLFNBQUssVUFBTDtBQUNFLGFBQU8sSUFBUDtBQUNGO0FBQ0UsYUFBTyxLQUFQO0FBZEo7QUFnQkQsQ0FqQkQ7O0FBbUJBcWxCLE9BQU83NUIsTUFBUCxHQUFnQixTQUFTQSxNQUFULENBQWlCN0ssSUFBakIsRUFBdUJoRCxNQUF2QixFQUErQjtBQUM3QyxNQUFJLENBQUNILFFBQVFtRCxJQUFSLENBQUwsRUFBb0I7QUFDbEIsVUFBTSxJQUFJWCxTQUFKLENBQWMsNkNBQWQsQ0FBTjtBQUNEOztBQUVELE1BQUlXLEtBQUtoRCxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLFdBQU8wbkMsT0FBT3lCLEtBQVAsQ0FBYSxDQUFiLENBQVA7QUFDRDs7QUFFRCxNQUFJcHBDLENBQUo7QUFDQSxNQUFJQyxXQUFXWixTQUFmLEVBQTBCO0FBQ3hCWSxhQUFTLENBQVQ7QUFDQSxTQUFLRCxJQUFJLENBQVQsRUFBWUEsSUFBSWlELEtBQUtoRCxNQUFyQixFQUE2QixFQUFFRCxDQUEvQixFQUFrQztBQUNoQ0MsZ0JBQVVnRCxLQUFLakQsQ0FBTCxFQUFRQyxNQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSStwQyxTQUFTckMsT0FBT2EsV0FBUCxDQUFtQnZvQyxNQUFuQixDQUFiO0FBQ0EsTUFBSW9oQixNQUFNLENBQVY7QUFDQSxPQUFLcmhCLElBQUksQ0FBVCxFQUFZQSxJQUFJaUQsS0FBS2hELE1BQXJCLEVBQTZCLEVBQUVELENBQS9CLEVBQWtDO0FBQ2hDLFFBQUl3cUMsTUFBTXZuQyxLQUFLakQsQ0FBTCxDQUFWO0FBQ0EsUUFBSSxDQUFDMm5DLE9BQU9tQyxRQUFQLENBQWdCVSxHQUFoQixDQUFMLEVBQTJCO0FBQ3pCLFlBQU0sSUFBSWxvQyxTQUFKLENBQWMsNkNBQWQsQ0FBTjtBQUNEO0FBQ0Rrb0MsUUFBSVQsSUFBSixDQUFTQyxNQUFULEVBQWlCM29CLEdBQWpCO0FBQ0FBLFdBQU9tcEIsSUFBSXZxQyxNQUFYO0FBQ0Q7QUFDRCxTQUFPK3BDLE1BQVA7QUFDRCxDQTVCRDs7QUE4QkEsU0FBU3pELFVBQVQsQ0FBcUIzeUIsTUFBckIsRUFBNkIwMUIsUUFBN0IsRUFBdUM7QUFDckMsTUFBSTNCLE9BQU9tQyxRQUFQLENBQWdCbDJCLE1BQWhCLENBQUosRUFBNkI7QUFDM0IsV0FBT0EsT0FBTzNULE1BQWQ7QUFDRDtBQUNELE1BQUksT0FBTzBvQyxXQUFQLEtBQXVCLFdBQXZCLElBQXNDLE9BQU9BLFlBQVk4QixNQUFuQixLQUE4QixVQUFwRSxLQUNDOUIsWUFBWThCLE1BQVosQ0FBbUI3MkIsTUFBbkIsS0FBOEJBLGtCQUFrQiswQixXQURqRCxDQUFKLEVBQ21FO0FBQ2pFLFdBQU8vMEIsT0FBTzJ5QixVQUFkO0FBQ0Q7QUFDRCxNQUFJLE9BQU8zeUIsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QkEsYUFBUyxLQUFLQSxNQUFkO0FBQ0Q7O0FBRUQsTUFBSXNILE1BQU10SCxPQUFPM1QsTUFBakI7QUFDQSxNQUFJaWIsUUFBUSxDQUFaLEVBQWUsT0FBTyxDQUFQOztBQUVmO0FBQ0EsTUFBSXd2QixjQUFjLEtBQWxCO0FBQ0EsV0FBUztBQUNQLFlBQVFwQixRQUFSO0FBQ0UsV0FBSyxPQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBT3B1QixHQUFQO0FBQ0YsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSzdiLFNBQUw7QUFDRSxlQUFPc3JDLFlBQVkvMkIsTUFBWixFQUFvQjNULE1BQTNCO0FBQ0YsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0UsZUFBT2liLE1BQU0sQ0FBYjtBQUNGLFdBQUssS0FBTDtBQUNFLGVBQU9BLFFBQVEsQ0FBZjtBQUNGLFdBQUssUUFBTDtBQUNFLGVBQU8wdkIsY0FBY2gzQixNQUFkLEVBQXNCM1QsTUFBN0I7QUFDRjtBQUNFLFlBQUl5cUMsV0FBSixFQUFpQixPQUFPQyxZQUFZLzJCLE1BQVosRUFBb0IzVCxNQUEzQixDQURuQixDQUNxRDtBQUNuRHFwQyxtQkFBVyxDQUFDLEtBQUtBLFFBQU4sRUFBZ0JobkIsV0FBaEIsRUFBWDtBQUNBb29CLHNCQUFjLElBQWQ7QUFyQko7QUF1QkQ7QUFDRjtBQUNEL0MsT0FBT3BCLFVBQVAsR0FBb0JBLFVBQXBCOztBQUVBLFNBQVNzRSxZQUFULENBQXVCdkIsUUFBdkIsRUFBaUM1bkMsS0FBakMsRUFBd0NpSixHQUF4QyxFQUE2QztBQUMzQyxNQUFJKy9CLGNBQWMsS0FBbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlocEMsVUFBVXJDLFNBQVYsSUFBdUJxQyxRQUFRLENBQW5DLEVBQXNDO0FBQ3BDQSxZQUFRLENBQVI7QUFDRDtBQUNEO0FBQ0E7QUFDQSxNQUFJQSxRQUFRLEtBQUt6QixNQUFqQixFQUF5QjtBQUN2QixXQUFPLEVBQVA7QUFDRDs7QUFFRCxNQUFJMEssUUFBUXRMLFNBQVIsSUFBcUJzTCxNQUFNLEtBQUsxSyxNQUFwQyxFQUE0QztBQUMxQzBLLFVBQU0sS0FBSzFLLE1BQVg7QUFDRDs7QUFFRCxNQUFJMEssT0FBTyxDQUFYLEVBQWM7QUFDWixXQUFPLEVBQVA7QUFDRDs7QUFFRDtBQUNBQSxXQUFTLENBQVQ7QUFDQWpKLGFBQVcsQ0FBWDs7QUFFQSxNQUFJaUosT0FBT2pKLEtBQVgsRUFBa0I7QUFDaEIsV0FBTyxFQUFQO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDNG5DLFFBQUwsRUFBZUEsV0FBVyxNQUFYOztBQUVmLFNBQU8sSUFBUCxFQUFhO0FBQ1gsWUFBUUEsUUFBUjtBQUNFLFdBQUssS0FBTDtBQUNFLGVBQU93QixTQUFTLElBQVQsRUFBZXBwQyxLQUFmLEVBQXNCaUosR0FBdEIsQ0FBUDs7QUFFRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDRSxlQUFPb2dDLFVBQVUsSUFBVixFQUFnQnJwQyxLQUFoQixFQUF1QmlKLEdBQXZCLENBQVA7O0FBRUYsV0FBSyxPQUFMO0FBQ0UsZUFBT3FnQyxXQUFXLElBQVgsRUFBaUJ0cEMsS0FBakIsRUFBd0JpSixHQUF4QixDQUFQOztBQUVGLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNFLGVBQU9zZ0MsWUFBWSxJQUFaLEVBQWtCdnBDLEtBQWxCLEVBQXlCaUosR0FBekIsQ0FBUDs7QUFFRixXQUFLLFFBQUw7QUFDRSxlQUFPdWdDLFlBQVksSUFBWixFQUFrQnhwQyxLQUFsQixFQUF5QmlKLEdBQXpCLENBQVA7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0UsZUFBT3dnQyxhQUFhLElBQWIsRUFBbUJ6cEMsS0FBbkIsRUFBMEJpSixHQUExQixDQUFQOztBQUVGO0FBQ0UsWUFBSSsvQixXQUFKLEVBQWlCLE1BQU0sSUFBSXBvQyxTQUFKLENBQWMsdUJBQXVCZ25DLFFBQXJDLENBQU47QUFDakJBLG1CQUFXLENBQUNBLFdBQVcsRUFBWixFQUFnQmhuQixXQUFoQixFQUFYO0FBQ0Fvb0Isc0JBQWMsSUFBZDtBQTNCSjtBQTZCRDtBQUNGOztBQUVEO0FBQ0E7QUFDQS9DLE9BQU83akMsU0FBUCxDQUFpQnFtQyxTQUFqQixHQUE2QixJQUE3Qjs7QUFFQSxTQUFTaUIsSUFBVCxDQUFlbEIsQ0FBZixFQUFrQmxGLENBQWxCLEVBQXFCN2lDLENBQXJCLEVBQXdCO0FBQ3RCLE1BQUluQyxJQUFJa3FDLEVBQUVsRixDQUFGLENBQVI7QUFDQWtGLElBQUVsRixDQUFGLElBQU9rRixFQUFFL25DLENBQUYsQ0FBUDtBQUNBK25DLElBQUUvbkMsQ0FBRixJQUFPbkMsQ0FBUDtBQUNEOztBQUVEMm5DLE9BQU83akMsU0FBUCxDQUFpQnVuQyxNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLE1BQUlud0IsTUFBTSxLQUFLamIsTUFBZjtBQUNBLE1BQUlpYixNQUFNLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUl5b0IsVUFBSixDQUFlLDJDQUFmLENBQU47QUFDRDtBQUNELE9BQUssSUFBSTNqQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlrYixHQUFwQixFQUF5QmxiLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0JvckMsU0FBSyxJQUFMLEVBQVdwckMsQ0FBWCxFQUFjQSxJQUFJLENBQWxCO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVREOztBQVdBMm5DLE9BQU83akMsU0FBUCxDQUFpQnduQyxNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLE1BQUlwd0IsTUFBTSxLQUFLamIsTUFBZjtBQUNBLE1BQUlpYixNQUFNLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUl5b0IsVUFBSixDQUFlLDJDQUFmLENBQU47QUFDRDtBQUNELE9BQUssSUFBSTNqQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlrYixHQUFwQixFQUF5QmxiLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0JvckMsU0FBSyxJQUFMLEVBQVdwckMsQ0FBWCxFQUFjQSxJQUFJLENBQWxCO0FBQ0FvckMsU0FBSyxJQUFMLEVBQVdwckMsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVZEOztBQVlBMm5DLE9BQU83akMsU0FBUCxDQUFpQnluQyxNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLE1BQUlyd0IsTUFBTSxLQUFLamIsTUFBZjtBQUNBLE1BQUlpYixNQUFNLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUl5b0IsVUFBSixDQUFlLDJDQUFmLENBQU47QUFDRDtBQUNELE9BQUssSUFBSTNqQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlrYixHQUFwQixFQUF5QmxiLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0JvckMsU0FBSyxJQUFMLEVBQVdwckMsQ0FBWCxFQUFjQSxJQUFJLENBQWxCO0FBQ0FvckMsU0FBSyxJQUFMLEVBQVdwckMsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0FvckMsU0FBSyxJQUFMLEVBQVdwckMsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0FvckMsU0FBSyxJQUFMLEVBQVdwckMsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVpEOztBQWNBMm5DLE9BQU83akMsU0FBUCxDQUFpQnVCLFFBQWpCLEdBQTRCLFNBQVNBLFFBQVQsR0FBcUI7QUFDL0MsTUFBSXBGLFNBQVMsS0FBS0EsTUFBTCxHQUFjLENBQTNCO0FBQ0EsTUFBSUEsV0FBVyxDQUFmLEVBQWtCLE9BQU8sRUFBUDtBQUNsQixNQUFJd0IsVUFBVXhCLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEIsT0FBTzhxQyxVQUFVLElBQVYsRUFBZ0IsQ0FBaEIsRUFBbUI5cUMsTUFBbkIsQ0FBUDtBQUM1QixTQUFPNHFDLGFBQWF2a0MsS0FBYixDQUFtQixJQUFuQixFQUF5QjdFLFNBQXpCLENBQVA7QUFDRCxDQUxEOztBQU9Ba21DLE9BQU83akMsU0FBUCxDQUFpQjBuQyxNQUFqQixHQUEwQixTQUFTQSxNQUFULENBQWlCdEIsQ0FBakIsRUFBb0I7QUFDNUMsTUFBSSxDQUFDdkMsT0FBT21DLFFBQVAsQ0FBZ0JJLENBQWhCLENBQUwsRUFBeUIsTUFBTSxJQUFJNW5DLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ3pCLE1BQUksU0FBUzRuQyxDQUFiLEVBQWdCLE9BQU8sSUFBUDtBQUNoQixTQUFPdkMsT0FBT3lDLE9BQVAsQ0FBZSxJQUFmLEVBQXFCRixDQUFyQixNQUE0QixDQUFuQztBQUNELENBSkQ7O0FBTUF2QyxPQUFPN2pDLFNBQVAsQ0FBaUIybkMsT0FBakIsR0FBMkIsU0FBU0EsT0FBVCxHQUFvQjtBQUM3QyxNQUFJanBCLE1BQU0sRUFBVjtBQUNBLE1BQUl1RixNQUFNcHBCLFFBQVFrcEMsaUJBQWxCO0FBQ0EsTUFBSSxLQUFLNW5DLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNuQnVpQixVQUFNLEtBQUtuZCxRQUFMLENBQWMsS0FBZCxFQUFxQixDQUFyQixFQUF3QjBpQixHQUF4QixFQUE2QnZuQixLQUE3QixDQUFtQyxPQUFuQyxFQUE0Q1UsSUFBNUMsQ0FBaUQsR0FBakQsQ0FBTjtBQUNBLFFBQUksS0FBS2pCLE1BQUwsR0FBYzhuQixHQUFsQixFQUF1QnZGLE9BQU8sT0FBUDtBQUN4QjtBQUNELFNBQU8sYUFBYUEsR0FBYixHQUFtQixHQUExQjtBQUNELENBUkQ7O0FBVUFtbEIsT0FBTzdqQyxTQUFQLENBQWlCc21DLE9BQWpCLEdBQTJCLFNBQVNBLE9BQVQsQ0FBa0JzQixNQUFsQixFQUEwQmhxQyxLQUExQixFQUFpQ2lKLEdBQWpDLEVBQXNDZ2hDLFNBQXRDLEVBQWlEQyxPQUFqRCxFQUEwRDtBQUNuRixNQUFJLENBQUNqRSxPQUFPbUMsUUFBUCxDQUFnQjRCLE1BQWhCLENBQUwsRUFBOEI7QUFDNUIsVUFBTSxJQUFJcHBDLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSVosVUFBVXJDLFNBQWQsRUFBeUI7QUFDdkJxQyxZQUFRLENBQVI7QUFDRDtBQUNELE1BQUlpSixRQUFRdEwsU0FBWixFQUF1QjtBQUNyQnNMLFVBQU0rZ0MsU0FBU0EsT0FBT3pyQyxNQUFoQixHQUF5QixDQUEvQjtBQUNEO0FBQ0QsTUFBSTByQyxjQUFjdHNDLFNBQWxCLEVBQTZCO0FBQzNCc3NDLGdCQUFZLENBQVo7QUFDRDtBQUNELE1BQUlDLFlBQVl2c0MsU0FBaEIsRUFBMkI7QUFDekJ1c0MsY0FBVSxLQUFLM3JDLE1BQWY7QUFDRDs7QUFFRCxNQUFJeUIsUUFBUSxDQUFSLElBQWFpSixNQUFNK2dDLE9BQU96ckMsTUFBMUIsSUFBb0MwckMsWUFBWSxDQUFoRCxJQUFxREMsVUFBVSxLQUFLM3JDLE1BQXhFLEVBQWdGO0FBQzlFLFVBQU0sSUFBSTBqQyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNEOztBQUVELE1BQUlnSSxhQUFhQyxPQUFiLElBQXdCbHFDLFNBQVNpSixHQUFyQyxFQUEwQztBQUN4QyxXQUFPLENBQVA7QUFDRDtBQUNELE1BQUlnaEMsYUFBYUMsT0FBakIsRUFBMEI7QUFDeEIsV0FBTyxDQUFDLENBQVI7QUFDRDtBQUNELE1BQUlscUMsU0FBU2lKLEdBQWIsRUFBa0I7QUFDaEIsV0FBTyxDQUFQO0FBQ0Q7O0FBRURqSixhQUFXLENBQVg7QUFDQWlKLFdBQVMsQ0FBVDtBQUNBZ2hDLGlCQUFlLENBQWY7QUFDQUMsZUFBYSxDQUFiOztBQUVBLE1BQUksU0FBU0YsTUFBYixFQUFxQixPQUFPLENBQVA7O0FBRXJCLE1BQUlwQixJQUFJc0IsVUFBVUQsU0FBbEI7QUFDQSxNQUFJcEIsSUFBSTUvQixNQUFNakosS0FBZDtBQUNBLE1BQUl3WixNQUFNcFMsS0FBS292QixHQUFMLENBQVNvUyxDQUFULEVBQVlDLENBQVosQ0FBVjs7QUFFQSxNQUFJc0IsV0FBVyxLQUFLbGlDLEtBQUwsQ0FBV2dpQyxTQUFYLEVBQXNCQyxPQUF0QixDQUFmO0FBQ0EsTUFBSUUsYUFBYUosT0FBTy9oQyxLQUFQLENBQWFqSSxLQUFiLEVBQW9CaUosR0FBcEIsQ0FBakI7O0FBRUEsT0FBSyxJQUFJM0ssSUFBSSxDQUFiLEVBQWdCQSxJQUFJa2IsR0FBcEIsRUFBeUIsRUFBRWxiLENBQTNCLEVBQThCO0FBQzVCLFFBQUk2ckMsU0FBUzdyQyxDQUFULE1BQWdCOHJDLFdBQVc5ckMsQ0FBWCxDQUFwQixFQUFtQztBQUNqQ3NxQyxVQUFJdUIsU0FBUzdyQyxDQUFULENBQUo7QUFDQXVxQyxVQUFJdUIsV0FBVzlyQyxDQUFYLENBQUo7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSXNxQyxJQUFJQyxDQUFSLEVBQVcsT0FBTyxDQUFDLENBQVI7QUFDWCxNQUFJQSxJQUFJRCxDQUFSLEVBQVcsT0FBTyxDQUFQO0FBQ1gsU0FBTyxDQUFQO0FBQ0QsQ0F6REQ7O0FBMkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVN5QixvQkFBVCxDQUErQi9CLE1BQS9CLEVBQXVDcmUsR0FBdkMsRUFBNENrZSxVQUE1QyxFQUF3RFAsUUFBeEQsRUFBa0VodEIsR0FBbEUsRUFBdUU7QUFDckU7QUFDQSxNQUFJMHRCLE9BQU8vcEMsTUFBUCxLQUFrQixDQUF0QixFQUF5QixPQUFPLENBQUMsQ0FBUjs7QUFFekI7QUFDQSxNQUFJLE9BQU80cEMsVUFBUCxLQUFzQixRQUExQixFQUFvQztBQUNsQ1AsZUFBV08sVUFBWDtBQUNBQSxpQkFBYSxDQUFiO0FBQ0QsR0FIRCxNQUdPLElBQUlBLGFBQWEsVUFBakIsRUFBNkI7QUFDbENBLGlCQUFhLFVBQWI7QUFDRCxHQUZNLE1BRUEsSUFBSUEsYUFBYSxDQUFDLFVBQWxCLEVBQThCO0FBQ25DQSxpQkFBYSxDQUFDLFVBQWQ7QUFDRDtBQUNEQSxlQUFhLENBQUNBLFVBQWQsQ0FicUUsQ0FhM0M7QUFDMUIsTUFBSWoxQixNQUFNaTFCLFVBQU4sQ0FBSixFQUF1QjtBQUNyQjtBQUNBQSxpQkFBYXZ0QixNQUFNLENBQU4sR0FBVzB0QixPQUFPL3BDLE1BQVAsR0FBZ0IsQ0FBeEM7QUFDRDs7QUFFRDtBQUNBLE1BQUk0cEMsYUFBYSxDQUFqQixFQUFvQkEsYUFBYUcsT0FBTy9wQyxNQUFQLEdBQWdCNHBDLFVBQTdCO0FBQ3BCLE1BQUlBLGNBQWNHLE9BQU8vcEMsTUFBekIsRUFBaUM7QUFDL0IsUUFBSXFjLEdBQUosRUFBUyxPQUFPLENBQUMsQ0FBUixDQUFULEtBQ0t1dEIsYUFBYUcsT0FBTy9wQyxNQUFQLEdBQWdCLENBQTdCO0FBQ04sR0FIRCxNQUdPLElBQUk0cEMsYUFBYSxDQUFqQixFQUFvQjtBQUN6QixRQUFJdnRCLEdBQUosRUFBU3V0QixhQUFhLENBQWIsQ0FBVCxLQUNLLE9BQU8sQ0FBQyxDQUFSO0FBQ047O0FBRUQ7QUFDQSxNQUFJLE9BQU9sZSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0JBLFVBQU1nYyxPQUFPNU8sSUFBUCxDQUFZcE4sR0FBWixFQUFpQjJkLFFBQWpCLENBQU47QUFDRDs7QUFFRDtBQUNBLE1BQUkzQixPQUFPbUMsUUFBUCxDQUFnQm5lLEdBQWhCLENBQUosRUFBMEI7QUFDeEI7QUFDQSxRQUFJQSxJQUFJMXJCLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixhQUFPLENBQUMsQ0FBUjtBQUNEO0FBQ0QsV0FBTytyQyxhQUFhaEMsTUFBYixFQUFxQnJlLEdBQXJCLEVBQTBCa2UsVUFBMUIsRUFBc0NQLFFBQXRDLEVBQWdEaHRCLEdBQWhELENBQVA7QUFDRCxHQU5ELE1BTU8sSUFBSSxPQUFPcVAsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ2xDQSxVQUFNQSxNQUFNLElBQVosQ0FEa0MsQ0FDakI7QUFDakIsUUFBSWdjLE9BQU9HLG1CQUFQLElBQ0EsT0FBT2pCLFdBQVcvaUMsU0FBWCxDQUFxQmdHLE9BQTVCLEtBQXdDLFVBRDVDLEVBQ3dEO0FBQ3RELFVBQUl3UyxHQUFKLEVBQVM7QUFDUCxlQUFPdXFCLFdBQVcvaUMsU0FBWCxDQUFxQmdHLE9BQXJCLENBQTZCdkksSUFBN0IsQ0FBa0N5b0MsTUFBbEMsRUFBMENyZSxHQUExQyxFQUErQ2tlLFVBQS9DLENBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPaEQsV0FBVy9pQyxTQUFYLENBQXFCNjlCLFdBQXJCLENBQWlDcGdDLElBQWpDLENBQXNDeW9DLE1BQXRDLEVBQThDcmUsR0FBOUMsRUFBbURrZSxVQUFuRCxDQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU9tQyxhQUFhaEMsTUFBYixFQUFxQixDQUFFcmUsR0FBRixDQUFyQixFQUE4QmtlLFVBQTlCLEVBQTBDUCxRQUExQyxFQUFvRGh0QixHQUFwRCxDQUFQO0FBQ0Q7O0FBRUQsUUFBTSxJQUFJaGEsU0FBSixDQUFjLHNDQUFkLENBQU47QUFDRDs7QUFFRCxTQUFTMHBDLFlBQVQsQ0FBdUJ0ZSxHQUF2QixFQUE0Qi9CLEdBQTVCLEVBQWlDa2UsVUFBakMsRUFBNkNQLFFBQTdDLEVBQXVEaHRCLEdBQXZELEVBQTREO0FBQzFELE1BQUkydkIsWUFBWSxDQUFoQjtBQUNBLE1BQUlDLFlBQVl4ZSxJQUFJenRCLE1BQXBCO0FBQ0EsTUFBSWtzQyxZQUFZeGdCLElBQUkxckIsTUFBcEI7O0FBRUEsTUFBSXFwQyxhQUFhanFDLFNBQWpCLEVBQTRCO0FBQzFCaXFDLGVBQVcxbkIsT0FBTzBuQixRQUFQLEVBQWlCaG5CLFdBQWpCLEVBQVg7QUFDQSxRQUFJZ25CLGFBQWEsTUFBYixJQUF1QkEsYUFBYSxPQUFwQyxJQUNBQSxhQUFhLFNBRGIsSUFDMEJBLGFBQWEsVUFEM0MsRUFDdUQ7QUFDckQsVUFBSTViLElBQUl6dEIsTUFBSixHQUFhLENBQWIsSUFBa0IwckIsSUFBSTFyQixNQUFKLEdBQWEsQ0FBbkMsRUFBc0M7QUFDcEMsZUFBTyxDQUFDLENBQVI7QUFDRDtBQUNEZ3NDLGtCQUFZLENBQVo7QUFDQUMsbUJBQWEsQ0FBYjtBQUNBQyxtQkFBYSxDQUFiO0FBQ0F0QyxvQkFBYyxDQUFkO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTdUMsSUFBVCxDQUFlNUIsR0FBZixFQUFvQnhxQyxDQUFwQixFQUF1QjtBQUNyQixRQUFJaXNDLGNBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsYUFBT3pCLElBQUl4cUMsQ0FBSixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBT3dxQyxJQUFJNkIsWUFBSixDQUFpQnJzQyxJQUFJaXNDLFNBQXJCLENBQVA7QUFDRDtBQUNGOztBQUVELE1BQUlqc0MsQ0FBSjtBQUNBLE1BQUlzYyxHQUFKLEVBQVM7QUFDUCxRQUFJZ3dCLGFBQWEsQ0FBQyxDQUFsQjtBQUNBLFNBQUt0c0MsSUFBSTZwQyxVQUFULEVBQXFCN3BDLElBQUlrc0MsU0FBekIsRUFBb0Nsc0MsR0FBcEMsRUFBeUM7QUFDdkMsVUFBSW9zQyxLQUFLMWUsR0FBTCxFQUFVMXRCLENBQVYsTUFBaUJvc0MsS0FBS3pnQixHQUFMLEVBQVUyZ0IsZUFBZSxDQUFDLENBQWhCLEdBQW9CLENBQXBCLEdBQXdCdHNDLElBQUlzc0MsVUFBdEMsQ0FBckIsRUFBd0U7QUFDdEUsWUFBSUEsZUFBZSxDQUFDLENBQXBCLEVBQXVCQSxhQUFhdHNDLENBQWI7QUFDdkIsWUFBSUEsSUFBSXNzQyxVQUFKLEdBQWlCLENBQWpCLEtBQXVCSCxTQUEzQixFQUFzQyxPQUFPRyxhQUFhTCxTQUFwQjtBQUN2QyxPQUhELE1BR087QUFDTCxZQUFJSyxlQUFlLENBQUMsQ0FBcEIsRUFBdUJ0c0MsS0FBS0EsSUFBSXNzQyxVQUFUO0FBQ3ZCQSxxQkFBYSxDQUFDLENBQWQ7QUFDRDtBQUNGO0FBQ0YsR0FYRCxNQVdPO0FBQ0wsUUFBSXpDLGFBQWFzQyxTQUFiLEdBQXlCRCxTQUE3QixFQUF3Q3JDLGFBQWFxQyxZQUFZQyxTQUF6QjtBQUN4QyxTQUFLbnNDLElBQUk2cEMsVUFBVCxFQUFxQjdwQyxLQUFLLENBQTFCLEVBQTZCQSxHQUE3QixFQUFrQztBQUNoQyxVQUFJaXZCLFFBQVEsSUFBWjtBQUNBLFdBQUssSUFBSXphLElBQUksQ0FBYixFQUFnQkEsSUFBSTIzQixTQUFwQixFQUErQjMzQixHQUEvQixFQUFvQztBQUNsQyxZQUFJNDNCLEtBQUsxZSxHQUFMLEVBQVUxdEIsSUFBSXdVLENBQWQsTUFBcUI0M0IsS0FBS3pnQixHQUFMLEVBQVVuWCxDQUFWLENBQXpCLEVBQXVDO0FBQ3JDeWEsa0JBQVEsS0FBUjtBQUNBO0FBQ0Q7QUFDRjtBQUNELFVBQUlBLEtBQUosRUFBVyxPQUFPanZCLENBQVA7QUFDWjtBQUNGOztBQUVELFNBQU8sQ0FBQyxDQUFSO0FBQ0Q7O0FBRUQybkMsT0FBTzdqQyxTQUFQLENBQWlCeW9DLFFBQWpCLEdBQTRCLFNBQVNBLFFBQVQsQ0FBbUI1Z0IsR0FBbkIsRUFBd0JrZSxVQUF4QixFQUFvQ1AsUUFBcEMsRUFBOEM7QUFDeEUsU0FBTyxLQUFLeC9CLE9BQUwsQ0FBYTZoQixHQUFiLEVBQWtCa2UsVUFBbEIsRUFBOEJQLFFBQTlCLE1BQTRDLENBQUMsQ0FBcEQ7QUFDRCxDQUZEOztBQUlBM0IsT0FBTzdqQyxTQUFQLENBQWlCZ0csT0FBakIsR0FBMkIsU0FBU0EsT0FBVCxDQUFrQjZoQixHQUFsQixFQUF1QmtlLFVBQXZCLEVBQW1DUCxRQUFuQyxFQUE2QztBQUN0RSxTQUFPeUMscUJBQXFCLElBQXJCLEVBQTJCcGdCLEdBQTNCLEVBQWdDa2UsVUFBaEMsRUFBNENQLFFBQTVDLEVBQXNELElBQXRELENBQVA7QUFDRCxDQUZEOztBQUlBM0IsT0FBTzdqQyxTQUFQLENBQWlCNjlCLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JoVyxHQUF0QixFQUEyQmtlLFVBQTNCLEVBQXVDUCxRQUF2QyxFQUFpRDtBQUM5RSxTQUFPeUMscUJBQXFCLElBQXJCLEVBQTJCcGdCLEdBQTNCLEVBQWdDa2UsVUFBaEMsRUFBNENQLFFBQTVDLEVBQXNELEtBQXRELENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVNrRCxRQUFULENBQW1CaEMsR0FBbkIsRUFBd0I1MkIsTUFBeEIsRUFBZ0NxaEIsTUFBaEMsRUFBd0NoMUIsTUFBeEMsRUFBZ0Q7QUFDOUNnMUIsV0FBU2dELE9BQU9oRCxNQUFQLEtBQWtCLENBQTNCO0FBQ0EsTUFBSXdYLFlBQVlqQyxJQUFJdnFDLE1BQUosR0FBYWcxQixNQUE3QjtBQUNBLE1BQUksQ0FBQ2gxQixNQUFMLEVBQWE7QUFDWEEsYUFBU3dzQyxTQUFUO0FBQ0QsR0FGRCxNQUVPO0FBQ0x4c0MsYUFBU2c0QixPQUFPaDRCLE1BQVAsQ0FBVDtBQUNBLFFBQUlBLFNBQVN3c0MsU0FBYixFQUF3QjtBQUN0QnhzQyxlQUFTd3NDLFNBQVQ7QUFDRDtBQUNGOztBQUVEO0FBQ0EsTUFBSUMsU0FBUzk0QixPQUFPM1QsTUFBcEI7QUFDQSxNQUFJeXNDLFNBQVMsQ0FBVCxLQUFlLENBQW5CLEVBQXNCLE1BQU0sSUFBSXBxQyxTQUFKLENBQWMsb0JBQWQsQ0FBTjs7QUFFdEIsTUFBSXJDLFNBQVN5c0MsU0FBUyxDQUF0QixFQUF5QjtBQUN2QnpzQyxhQUFTeXNDLFNBQVMsQ0FBbEI7QUFDRDtBQUNELE9BQUssSUFBSTFzQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLE1BQXBCLEVBQTRCLEVBQUVELENBQTlCLEVBQWlDO0FBQy9CLFFBQUlzd0IsU0FBU3piLFNBQVNqQixPQUFPbkQsTUFBUCxDQUFjelEsSUFBSSxDQUFsQixFQUFxQixDQUFyQixDQUFULEVBQWtDLEVBQWxDLENBQWI7QUFDQSxRQUFJNFUsTUFBTTBiLE1BQU4sQ0FBSixFQUFtQixPQUFPdHdCLENBQVA7QUFDbkJ3cUMsUUFBSXZWLFNBQVNqMUIsQ0FBYixJQUFrQnN3QixNQUFsQjtBQUNEO0FBQ0QsU0FBT3R3QixDQUFQO0FBQ0Q7O0FBRUQsU0FBUzJzQyxTQUFULENBQW9CbkMsR0FBcEIsRUFBeUI1MkIsTUFBekIsRUFBaUNxaEIsTUFBakMsRUFBeUNoMUIsTUFBekMsRUFBaUQ7QUFDL0MsU0FBTzJzQyxXQUFXakMsWUFBWS8yQixNQUFaLEVBQW9CNDJCLElBQUl2cUMsTUFBSixHQUFhZzFCLE1BQWpDLENBQVgsRUFBcUR1VixHQUFyRCxFQUEwRHZWLE1BQTFELEVBQWtFaDFCLE1BQWxFLENBQVA7QUFDRDs7QUFFRCxTQUFTNHNDLFVBQVQsQ0FBcUJyQyxHQUFyQixFQUEwQjUyQixNQUExQixFQUFrQ3FoQixNQUFsQyxFQUEwQ2gxQixNQUExQyxFQUFrRDtBQUNoRCxTQUFPMnNDLFdBQVdFLGFBQWFsNUIsTUFBYixDQUFYLEVBQWlDNDJCLEdBQWpDLEVBQXNDdlYsTUFBdEMsRUFBOENoMUIsTUFBOUMsQ0FBUDtBQUNEOztBQUVELFNBQVM4c0MsV0FBVCxDQUFzQnZDLEdBQXRCLEVBQTJCNTJCLE1BQTNCLEVBQW1DcWhCLE1BQW5DLEVBQTJDaDFCLE1BQTNDLEVBQW1EO0FBQ2pELFNBQU80c0MsV0FBV3JDLEdBQVgsRUFBZ0I1MkIsTUFBaEIsRUFBd0JxaEIsTUFBeEIsRUFBZ0NoMUIsTUFBaEMsQ0FBUDtBQUNEOztBQUVELFNBQVMrc0MsV0FBVCxDQUFzQnhDLEdBQXRCLEVBQTJCNTJCLE1BQTNCLEVBQW1DcWhCLE1BQW5DLEVBQTJDaDFCLE1BQTNDLEVBQW1EO0FBQ2pELFNBQU8yc0MsV0FBV2hDLGNBQWNoM0IsTUFBZCxDQUFYLEVBQWtDNDJCLEdBQWxDLEVBQXVDdlYsTUFBdkMsRUFBK0NoMUIsTUFBL0MsQ0FBUDtBQUNEOztBQUVELFNBQVNndEMsU0FBVCxDQUFvQnpDLEdBQXBCLEVBQXlCNTJCLE1BQXpCLEVBQWlDcWhCLE1BQWpDLEVBQXlDaDFCLE1BQXpDLEVBQWlEO0FBQy9DLFNBQU8yc0MsV0FBV00sZUFBZXQ1QixNQUFmLEVBQXVCNDJCLElBQUl2cUMsTUFBSixHQUFhZzFCLE1BQXBDLENBQVgsRUFBd0R1VixHQUF4RCxFQUE2RHZWLE1BQTdELEVBQXFFaDFCLE1BQXJFLENBQVA7QUFDRDs7QUFFRDBuQyxPQUFPN2pDLFNBQVAsQ0FBaUI2bEMsS0FBakIsR0FBeUIsU0FBU0EsS0FBVCxDQUFnQi8xQixNQUFoQixFQUF3QnFoQixNQUF4QixFQUFnQ2gxQixNQUFoQyxFQUF3Q3FwQyxRQUF4QyxFQUFrRDtBQUN6RTtBQUNBLE1BQUlyVSxXQUFXNTFCLFNBQWYsRUFBMEI7QUFDeEJpcUMsZUFBVyxNQUFYO0FBQ0FycEMsYUFBUyxLQUFLQSxNQUFkO0FBQ0FnMUIsYUFBUyxDQUFUO0FBQ0Y7QUFDQyxHQUxELE1BS08sSUFBSWgxQixXQUFXWixTQUFYLElBQXdCLE9BQU80MUIsTUFBUCxLQUFrQixRQUE5QyxFQUF3RDtBQUM3RHFVLGVBQVdyVSxNQUFYO0FBQ0FoMUIsYUFBUyxLQUFLQSxNQUFkO0FBQ0FnMUIsYUFBUyxDQUFUO0FBQ0Y7QUFDQyxHQUxNLE1BS0EsSUFBSWtZLFNBQVNsWSxNQUFULENBQUosRUFBc0I7QUFDM0JBLGFBQVNBLFNBQVMsQ0FBbEI7QUFDQSxRQUFJa1ksU0FBU2x0QyxNQUFULENBQUosRUFBc0I7QUFDcEJBLGVBQVNBLFNBQVMsQ0FBbEI7QUFDQSxVQUFJcXBDLGFBQWFqcUMsU0FBakIsRUFBNEJpcUMsV0FBVyxNQUFYO0FBQzdCLEtBSEQsTUFHTztBQUNMQSxpQkFBV3JwQyxNQUFYO0FBQ0FBLGVBQVNaLFNBQVQ7QUFDRDtBQUNIO0FBQ0MsR0FWTSxNQVVBO0FBQ0wsVUFBTSxJQUFJdUMsS0FBSixDQUNKLHlFQURJLENBQU47QUFHRDs7QUFFRCxNQUFJNnFDLFlBQVksS0FBS3hzQyxNQUFMLEdBQWNnMUIsTUFBOUI7QUFDQSxNQUFJaDFCLFdBQVdaLFNBQVgsSUFBd0JZLFNBQVN3c0MsU0FBckMsRUFBZ0R4c0MsU0FBU3dzQyxTQUFUOztBQUVoRCxNQUFLNzRCLE9BQU8zVCxNQUFQLEdBQWdCLENBQWhCLEtBQXNCQSxTQUFTLENBQVQsSUFBY2cxQixTQUFTLENBQTdDLENBQUQsSUFBcURBLFNBQVMsS0FBS2gxQixNQUF2RSxFQUErRTtBQUM3RSxVQUFNLElBQUkwakMsVUFBSixDQUFlLHdDQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJLENBQUMyRixRQUFMLEVBQWVBLFdBQVcsTUFBWDs7QUFFZixNQUFJb0IsY0FBYyxLQUFsQjtBQUNBLFdBQVM7QUFDUCxZQUFRcEIsUUFBUjtBQUNFLFdBQUssS0FBTDtBQUNFLGVBQU9rRCxTQUFTLElBQVQsRUFBZTU0QixNQUFmLEVBQXVCcWhCLE1BQXZCLEVBQStCaDFCLE1BQS9CLENBQVA7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0UsZUFBTzBzQyxVQUFVLElBQVYsRUFBZ0IvNEIsTUFBaEIsRUFBd0JxaEIsTUFBeEIsRUFBZ0NoMUIsTUFBaEMsQ0FBUDs7QUFFRixXQUFLLE9BQUw7QUFDRSxlQUFPNHNDLFdBQVcsSUFBWCxFQUFpQmo1QixNQUFqQixFQUF5QnFoQixNQUF6QixFQUFpQ2gxQixNQUFqQyxDQUFQOztBQUVGLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNFLGVBQU84c0MsWUFBWSxJQUFaLEVBQWtCbjVCLE1BQWxCLEVBQTBCcWhCLE1BQTFCLEVBQWtDaDFCLE1BQWxDLENBQVA7O0FBRUYsV0FBSyxRQUFMO0FBQ0U7QUFDQSxlQUFPK3NDLFlBQVksSUFBWixFQUFrQnA1QixNQUFsQixFQUEwQnFoQixNQUExQixFQUFrQ2gxQixNQUFsQyxDQUFQOztBQUVGLFdBQUssTUFBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssVUFBTDtBQUNFLGVBQU9ndEMsVUFBVSxJQUFWLEVBQWdCcjVCLE1BQWhCLEVBQXdCcWhCLE1BQXhCLEVBQWdDaDFCLE1BQWhDLENBQVA7O0FBRUY7QUFDRSxZQUFJeXFDLFdBQUosRUFBaUIsTUFBTSxJQUFJcG9DLFNBQUosQ0FBYyx1QkFBdUJnbkMsUUFBckMsQ0FBTjtBQUNqQkEsbUJBQVcsQ0FBQyxLQUFLQSxRQUFOLEVBQWdCaG5CLFdBQWhCLEVBQVg7QUFDQW9vQixzQkFBYyxJQUFkO0FBNUJKO0FBOEJEO0FBQ0YsQ0F0RUQ7O0FBd0VBL0MsT0FBTzdqQyxTQUFQLENBQWlCc3BDLE1BQWpCLEdBQTBCLFNBQVNBLE1BQVQsR0FBbUI7QUFDM0MsU0FBTztBQUNMenNDLFVBQU0sUUFERDtBQUVMb0csVUFBTWxILE1BQU1pRSxTQUFOLENBQWdCNkYsS0FBaEIsQ0FBc0JwSSxJQUF0QixDQUEyQixLQUFLOHJDLElBQUwsSUFBYSxJQUF4QyxFQUE4QyxDQUE5QztBQUZELEdBQVA7QUFJRCxDQUxEOztBQU9BLFNBQVNuQyxXQUFULENBQXNCVixHQUF0QixFQUEyQjlvQyxLQUEzQixFQUFrQ2lKLEdBQWxDLEVBQXVDO0FBQ3JDLE1BQUlqSixVQUFVLENBQVYsSUFBZWlKLFFBQVE2L0IsSUFBSXZxQyxNQUEvQixFQUF1QztBQUNyQyxXQUFPd25DLE9BQU9oQixhQUFQLENBQXFCK0QsR0FBckIsQ0FBUDtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU8vQyxPQUFPaEIsYUFBUCxDQUFxQitELElBQUk3Z0MsS0FBSixDQUFVakksS0FBVixFQUFpQmlKLEdBQWpCLENBQXJCLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNvZ0MsU0FBVCxDQUFvQlAsR0FBcEIsRUFBeUI5b0MsS0FBekIsRUFBZ0NpSixHQUFoQyxFQUFxQztBQUNuQ0EsUUFBTTdCLEtBQUtvdkIsR0FBTCxDQUFTc1MsSUFBSXZxQyxNQUFiLEVBQXFCMEssR0FBckIsQ0FBTjtBQUNBLE1BQUk4dEIsTUFBTSxFQUFWOztBQUVBLE1BQUl6NEIsSUFBSTBCLEtBQVI7QUFDQSxTQUFPMUIsSUFBSTJLLEdBQVgsRUFBZ0I7QUFDZCxRQUFJMmlDLFlBQVk5QyxJQUFJeHFDLENBQUosQ0FBaEI7QUFDQSxRQUFJcWtDLFlBQVksSUFBaEI7QUFDQSxRQUFJa0osbUJBQW9CRCxZQUFZLElBQWIsR0FBcUIsQ0FBckIsR0FDbEJBLFlBQVksSUFBYixHQUFxQixDQUFyQixHQUNDQSxZQUFZLElBQWIsR0FBcUIsQ0FBckIsR0FDQSxDQUhKOztBQUtBLFFBQUl0dEMsSUFBSXV0QyxnQkFBSixJQUF3QjVpQyxHQUE1QixFQUFpQztBQUMvQixVQUFJNmlDLFVBQUosRUFBZ0JDLFNBQWhCLEVBQTJCQyxVQUEzQixFQUF1Q0MsYUFBdkM7O0FBRUEsY0FBUUosZ0JBQVI7QUFDRSxhQUFLLENBQUw7QUFDRSxjQUFJRCxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCakosd0JBQVlpSixTQUFaO0FBQ0Q7QUFDRDtBQUNGLGFBQUssQ0FBTDtBQUNFRSx1QkFBYWhELElBQUl4cUMsSUFBSSxDQUFSLENBQWI7QUFDQSxjQUFJLENBQUN3dEMsYUFBYSxJQUFkLE1BQXdCLElBQTVCLEVBQWtDO0FBQ2hDRyw0QkFBZ0IsQ0FBQ0wsWUFBWSxJQUFiLEtBQXNCLEdBQXRCLEdBQTZCRSxhQUFhLElBQTFEO0FBQ0EsZ0JBQUlHLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QnRKLDBCQUFZc0osYUFBWjtBQUNEO0FBQ0Y7QUFDRDtBQUNGLGFBQUssQ0FBTDtBQUNFSCx1QkFBYWhELElBQUl4cUMsSUFBSSxDQUFSLENBQWI7QUFDQXl0QyxzQkFBWWpELElBQUl4cUMsSUFBSSxDQUFSLENBQVo7QUFDQSxjQUFJLENBQUN3dEMsYUFBYSxJQUFkLE1BQXdCLElBQXhCLElBQWdDLENBQUNDLFlBQVksSUFBYixNQUF1QixJQUEzRCxFQUFpRTtBQUMvREUsNEJBQWdCLENBQUNMLFlBQVksR0FBYixLQUFxQixHQUFyQixHQUEyQixDQUFDRSxhQUFhLElBQWQsS0FBdUIsR0FBbEQsR0FBeURDLFlBQVksSUFBckY7QUFDQSxnQkFBSUUsZ0JBQWdCLEtBQWhCLEtBQTBCQSxnQkFBZ0IsTUFBaEIsSUFBMEJBLGdCQUFnQixNQUFwRSxDQUFKLEVBQWlGO0FBQy9FdEosMEJBQVlzSixhQUFaO0FBQ0Q7QUFDRjtBQUNEO0FBQ0YsYUFBSyxDQUFMO0FBQ0VILHVCQUFhaEQsSUFBSXhxQyxJQUFJLENBQVIsQ0FBYjtBQUNBeXRDLHNCQUFZakQsSUFBSXhxQyxJQUFJLENBQVIsQ0FBWjtBQUNBMHRDLHVCQUFhbEQsSUFBSXhxQyxJQUFJLENBQVIsQ0FBYjtBQUNBLGNBQUksQ0FBQ3d0QyxhQUFhLElBQWQsTUFBd0IsSUFBeEIsSUFBZ0MsQ0FBQ0MsWUFBWSxJQUFiLE1BQXVCLElBQXZELElBQStELENBQUNDLGFBQWEsSUFBZCxNQUF3QixJQUEzRixFQUFpRztBQUMvRkMsNEJBQWdCLENBQUNMLFlBQVksR0FBYixLQUFxQixJQUFyQixHQUE0QixDQUFDRSxhQUFhLElBQWQsS0FBdUIsR0FBbkQsR0FBeUQsQ0FBQ0MsWUFBWSxJQUFiLEtBQXNCLEdBQS9FLEdBQXNGQyxhQUFhLElBQW5IO0FBQ0EsZ0JBQUlDLGdCQUFnQixNQUFoQixJQUEwQkEsZ0JBQWdCLFFBQTlDLEVBQXdEO0FBQ3REdEosMEJBQVlzSixhQUFaO0FBQ0Q7QUFDRjtBQWxDTDtBQW9DRDs7QUFFRCxRQUFJdEosY0FBYyxJQUFsQixFQUF3QjtBQUN0QjtBQUNBO0FBQ0FBLGtCQUFZLE1BQVo7QUFDQWtKLHlCQUFtQixDQUFuQjtBQUNELEtBTEQsTUFLTyxJQUFJbEosWUFBWSxNQUFoQixFQUF3QjtBQUM3QjtBQUNBQSxtQkFBYSxPQUFiO0FBQ0E1TCxVQUFJMzNCLElBQUosQ0FBU3VqQyxjQUFjLEVBQWQsR0FBbUIsS0FBbkIsR0FBMkIsTUFBcEM7QUFDQUEsa0JBQVksU0FBU0EsWUFBWSxLQUFqQztBQUNEOztBQUVENUwsUUFBSTMzQixJQUFKLENBQVN1akMsU0FBVDtBQUNBcmtDLFNBQUt1dEMsZ0JBQUw7QUFDRDs7QUFFRCxTQUFPSyxzQkFBc0JuVixHQUF0QixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSW9WLHVCQUF1QixNQUEzQjs7QUFFQSxTQUFTRCxxQkFBVCxDQUFnQ0UsVUFBaEMsRUFBNEM7QUFDMUMsTUFBSTV5QixNQUFNNHlCLFdBQVc3dEMsTUFBckI7QUFDQSxNQUFJaWIsT0FBTzJ5QixvQkFBWCxFQUFpQztBQUMvQixXQUFPanNCLE9BQU9DLFlBQVAsQ0FBb0J2YixLQUFwQixDQUEwQnNiLE1BQTFCLEVBQWtDa3NCLFVBQWxDLENBQVAsQ0FEK0IsQ0FDc0I7QUFDdEQ7O0FBRUQ7QUFDQSxNQUFJclYsTUFBTSxFQUFWO0FBQ0EsTUFBSXo0QixJQUFJLENBQVI7QUFDQSxTQUFPQSxJQUFJa2IsR0FBWCxFQUFnQjtBQUNkdWQsV0FBTzdXLE9BQU9DLFlBQVAsQ0FBb0J2YixLQUFwQixDQUNMc2IsTUFESyxFQUVMa3NCLFdBQVdua0MsS0FBWCxDQUFpQjNKLENBQWpCLEVBQW9CQSxLQUFLNnRDLG9CQUF6QixDQUZLLENBQVA7QUFJRDtBQUNELFNBQU9wVixHQUFQO0FBQ0Q7O0FBRUQsU0FBU3VTLFVBQVQsQ0FBcUJSLEdBQXJCLEVBQTBCOW9DLEtBQTFCLEVBQWlDaUosR0FBakMsRUFBc0M7QUFDcEMsTUFBSW9qQyxNQUFNLEVBQVY7QUFDQXBqQyxRQUFNN0IsS0FBS292QixHQUFMLENBQVNzUyxJQUFJdnFDLE1BQWIsRUFBcUIwSyxHQUFyQixDQUFOOztBQUVBLE9BQUssSUFBSTNLLElBQUkwQixLQUFiLEVBQW9CMUIsSUFBSTJLLEdBQXhCLEVBQTZCLEVBQUUzSyxDQUEvQixFQUFrQztBQUNoQyt0QyxXQUFPbnNCLE9BQU9DLFlBQVAsQ0FBb0Iyb0IsSUFBSXhxQyxDQUFKLElBQVMsSUFBN0IsQ0FBUDtBQUNEO0FBQ0QsU0FBTyt0QyxHQUFQO0FBQ0Q7O0FBRUQsU0FBUzlDLFdBQVQsQ0FBc0JULEdBQXRCLEVBQTJCOW9DLEtBQTNCLEVBQWtDaUosR0FBbEMsRUFBdUM7QUFDckMsTUFBSW9qQyxNQUFNLEVBQVY7QUFDQXBqQyxRQUFNN0IsS0FBS292QixHQUFMLENBQVNzUyxJQUFJdnFDLE1BQWIsRUFBcUIwSyxHQUFyQixDQUFOOztBQUVBLE9BQUssSUFBSTNLLElBQUkwQixLQUFiLEVBQW9CMUIsSUFBSTJLLEdBQXhCLEVBQTZCLEVBQUUzSyxDQUEvQixFQUFrQztBQUNoQyt0QyxXQUFPbnNCLE9BQU9DLFlBQVAsQ0FBb0Iyb0IsSUFBSXhxQyxDQUFKLENBQXBCLENBQVA7QUFDRDtBQUNELFNBQU8rdEMsR0FBUDtBQUNEOztBQUVELFNBQVNqRCxRQUFULENBQW1CTixHQUFuQixFQUF3QjlvQyxLQUF4QixFQUErQmlKLEdBQS9CLEVBQW9DO0FBQ2xDLE1BQUl1USxNQUFNc3ZCLElBQUl2cUMsTUFBZDs7QUFFQSxNQUFJLENBQUN5QixLQUFELElBQVVBLFFBQVEsQ0FBdEIsRUFBeUJBLFFBQVEsQ0FBUjtBQUN6QixNQUFJLENBQUNpSixHQUFELElBQVFBLE1BQU0sQ0FBZCxJQUFtQkEsTUFBTXVRLEdBQTdCLEVBQWtDdlEsTUFBTXVRLEdBQU47O0FBRWxDLE1BQUk2cEIsTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJL2tDLElBQUkwQixLQUFiLEVBQW9CMUIsSUFBSTJLLEdBQXhCLEVBQTZCLEVBQUUzSyxDQUEvQixFQUFrQztBQUNoQytrQyxXQUFPaUosTUFBTXhELElBQUl4cUMsQ0FBSixDQUFOLENBQVA7QUFDRDtBQUNELFNBQU8ra0MsR0FBUDtBQUNEOztBQUVELFNBQVNvRyxZQUFULENBQXVCWCxHQUF2QixFQUE0QjlvQyxLQUE1QixFQUFtQ2lKLEdBQW5DLEVBQXdDO0FBQ3RDLE1BQUlzakMsUUFBUXpELElBQUk3Z0MsS0FBSixDQUFVakksS0FBVixFQUFpQmlKLEdBQWpCLENBQVo7QUFDQSxNQUFJOHRCLE1BQU0sRUFBVjtBQUNBLE9BQUssSUFBSXo0QixJQUFJLENBQWIsRUFBZ0JBLElBQUlpdUMsTUFBTWh1QyxNQUExQixFQUFrQ0QsS0FBSyxDQUF2QyxFQUEwQztBQUN4Q3k0QixXQUFPN1csT0FBT0MsWUFBUCxDQUFvQm9zQixNQUFNanVDLENBQU4sSUFBV2l1QyxNQUFNanVDLElBQUksQ0FBVixJQUFlLEdBQTlDLENBQVA7QUFDRDtBQUNELFNBQU95NEIsR0FBUDtBQUNEOztBQUVEa1AsT0FBTzdqQyxTQUFQLENBQWlCNkYsS0FBakIsR0FBeUIsU0FBU0EsS0FBVCxDQUFnQmpJLEtBQWhCLEVBQXVCaUosR0FBdkIsRUFBNEI7QUFDbkQsTUFBSXVRLE1BQU0sS0FBS2piLE1BQWY7QUFDQXlCLFVBQVEsQ0FBQyxDQUFDQSxLQUFWO0FBQ0FpSixRQUFNQSxRQUFRdEwsU0FBUixHQUFvQjZiLEdBQXBCLEdBQTBCLENBQUMsQ0FBQ3ZRLEdBQWxDOztBQUVBLE1BQUlqSixRQUFRLENBQVosRUFBZTtBQUNiQSxhQUFTd1osR0FBVDtBQUNBLFFBQUl4WixRQUFRLENBQVosRUFBZUEsUUFBUSxDQUFSO0FBQ2hCLEdBSEQsTUFHTyxJQUFJQSxRQUFRd1osR0FBWixFQUFpQjtBQUN0QnhaLFlBQVF3WixHQUFSO0FBQ0Q7O0FBRUQsTUFBSXZRLE1BQU0sQ0FBVixFQUFhO0FBQ1hBLFdBQU91USxHQUFQO0FBQ0EsUUFBSXZRLE1BQU0sQ0FBVixFQUFhQSxNQUFNLENBQU47QUFDZCxHQUhELE1BR08sSUFBSUEsTUFBTXVRLEdBQVYsRUFBZTtBQUNwQnZRLFVBQU11USxHQUFOO0FBQ0Q7O0FBRUQsTUFBSXZRLE1BQU1qSixLQUFWLEVBQWlCaUosTUFBTWpKLEtBQU47O0FBRWpCLE1BQUl3c0MsTUFBSjtBQUNBLE1BQUl2RyxPQUFPRyxtQkFBWCxFQUFnQztBQUM5Qm9HLGFBQVMsS0FBSy9GLFFBQUwsQ0FBY3ptQyxLQUFkLEVBQXFCaUosR0FBckIsQ0FBVDtBQUNBdWpDLFdBQU9qRyxTQUFQLEdBQW1CTixPQUFPN2pDLFNBQTFCO0FBQ0QsR0FIRCxNQUdPO0FBQ0wsUUFBSXFxQyxXQUFXeGpDLE1BQU1qSixLQUFyQjtBQUNBd3NDLGFBQVMsSUFBSXZHLE1BQUosQ0FBV3dHLFFBQVgsRUFBcUI5dUMsU0FBckIsQ0FBVDtBQUNBLFNBQUssSUFBSVcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbXVDLFFBQXBCLEVBQThCLEVBQUVudUMsQ0FBaEMsRUFBbUM7QUFDakNrdUMsYUFBT2x1QyxDQUFQLElBQVksS0FBS0EsSUFBSTBCLEtBQVQsQ0FBWjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT3dzQyxNQUFQO0FBQ0QsQ0FsQ0Q7O0FBb0NBOzs7QUFHQSxTQUFTRSxXQUFULENBQXNCblosTUFBdEIsRUFBOEJvWixHQUE5QixFQUFtQ3B1QyxNQUFuQyxFQUEyQztBQUN6QyxNQUFLZzFCLFNBQVMsQ0FBVixLQUFpQixDQUFqQixJQUFzQkEsU0FBUyxDQUFuQyxFQUFzQyxNQUFNLElBQUkwTyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUN0QyxNQUFJMU8sU0FBU29aLEdBQVQsR0FBZXB1QyxNQUFuQixFQUEyQixNQUFNLElBQUkwakMsVUFBSixDQUFlLHVDQUFmLENBQU47QUFDNUI7O0FBRURnRSxPQUFPN2pDLFNBQVAsQ0FBaUJ3cUMsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQnJaLE1BQXJCLEVBQTZCc1IsVUFBN0IsRUFBeUNnSSxRQUF6QyxFQUFtRDtBQUMvRXRaLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQXNSLGVBQWFBLGFBQWEsQ0FBMUI7QUFDQSxNQUFJLENBQUNnSSxRQUFMLEVBQWVILFlBQVluWixNQUFaLEVBQW9Cc1IsVUFBcEIsRUFBZ0MsS0FBS3RtQyxNQUFyQzs7QUFFZixNQUFJMHJCLE1BQU0sS0FBS3NKLE1BQUwsQ0FBVjtBQUNBLE1BQUl1WixNQUFNLENBQVY7QUFDQSxNQUFJeHVDLElBQUksQ0FBUjtBQUNBLFNBQU8sRUFBRUEsQ0FBRixHQUFNdW1DLFVBQU4sS0FBcUJpSSxPQUFPLEtBQTVCLENBQVAsRUFBMkM7QUFDekM3aUIsV0FBTyxLQUFLc0osU0FBU2oxQixDQUFkLElBQW1Cd3VDLEdBQTFCO0FBQ0Q7O0FBRUQsU0FBTzdpQixHQUFQO0FBQ0QsQ0FiRDs7QUFlQWdjLE9BQU83akMsU0FBUCxDQUFpQjJxQyxVQUFqQixHQUE4QixTQUFTQSxVQUFULENBQXFCeFosTUFBckIsRUFBNkJzUixVQUE3QixFQUF5Q2dJLFFBQXpDLEVBQW1EO0FBQy9FdFosV0FBU0EsU0FBUyxDQUFsQjtBQUNBc1IsZUFBYUEsYUFBYSxDQUExQjtBQUNBLE1BQUksQ0FBQ2dJLFFBQUwsRUFBZTtBQUNiSCxnQkFBWW5aLE1BQVosRUFBb0JzUixVQUFwQixFQUFnQyxLQUFLdG1DLE1BQXJDO0FBQ0Q7O0FBRUQsTUFBSTByQixNQUFNLEtBQUtzSixTQUFTLEVBQUVzUixVQUFoQixDQUFWO0FBQ0EsTUFBSWlJLE1BQU0sQ0FBVjtBQUNBLFNBQU9qSSxhQUFhLENBQWIsS0FBbUJpSSxPQUFPLEtBQTFCLENBQVAsRUFBeUM7QUFDdkM3aUIsV0FBTyxLQUFLc0osU0FBUyxFQUFFc1IsVUFBaEIsSUFBOEJpSSxHQUFyQztBQUNEOztBQUVELFNBQU83aUIsR0FBUDtBQUNELENBZEQ7O0FBZ0JBZ2MsT0FBTzdqQyxTQUFQLENBQWlCNHFDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0J6WixNQUFwQixFQUE0QnNaLFFBQTVCLEVBQXNDO0FBQ2pFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZblosTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLaDFCLE1BQTVCO0FBQ2YsU0FBTyxLQUFLZzFCLE1BQUwsQ0FBUDtBQUNELENBSEQ7O0FBS0EwUyxPQUFPN2pDLFNBQVAsQ0FBaUI2cUMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QjFaLE1BQXZCLEVBQStCc1osUUFBL0IsRUFBeUM7QUFDdkUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVluWixNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtoMUIsTUFBNUI7QUFDZixTQUFPLEtBQUtnMUIsTUFBTCxJQUFnQixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FBM0M7QUFDRCxDQUhEOztBQUtBMFMsT0FBTzdqQyxTQUFQLENBQWlCdW9DLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJwWCxNQUF2QixFQUErQnNaLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZblosTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLaDFCLE1BQTVCO0FBQ2YsU0FBUSxLQUFLZzFCLE1BQUwsS0FBZ0IsQ0FBakIsR0FBc0IsS0FBS0EsU0FBUyxDQUFkLENBQTdCO0FBQ0QsQ0FIRDs7QUFLQTBTLE9BQU83akMsU0FBUCxDQUFpQjhxQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCM1osTUFBdkIsRUFBK0JzWixRQUEvQixFQUF5QztBQUN2RSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWW5aLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS2gxQixNQUE1Qjs7QUFFZixTQUFPLENBQUUsS0FBS2cxQixNQUFMLENBQUQsR0FDSCxLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FEakIsR0FFSCxLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFGbEIsSUFHRixLQUFLQSxTQUFTLENBQWQsSUFBbUIsU0FIeEI7QUFJRCxDQVBEOztBQVNBMFMsT0FBTzdqQyxTQUFQLENBQWlCK3FDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUI1WixNQUF2QixFQUErQnNaLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZblosTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLaDFCLE1BQTVCOztBQUVmLFNBQVEsS0FBS2cxQixNQUFMLElBQWUsU0FBaEIsSUFDSCxLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFBckIsR0FDQSxLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FEcEIsR0FFRCxLQUFLQSxTQUFTLENBQWQsQ0FISyxDQUFQO0FBSUQsQ0FQRDs7QUFTQTBTLE9BQU83akMsU0FBUCxDQUFpQmdyQyxTQUFqQixHQUE2QixTQUFTQSxTQUFULENBQW9CN1osTUFBcEIsRUFBNEJzUixVQUE1QixFQUF3Q2dJLFFBQXhDLEVBQWtEO0FBQzdFdFosV0FBU0EsU0FBUyxDQUFsQjtBQUNBc1IsZUFBYUEsYUFBYSxDQUExQjtBQUNBLE1BQUksQ0FBQ2dJLFFBQUwsRUFBZUgsWUFBWW5aLE1BQVosRUFBb0JzUixVQUFwQixFQUFnQyxLQUFLdG1DLE1BQXJDOztBQUVmLE1BQUkwckIsTUFBTSxLQUFLc0osTUFBTCxDQUFWO0FBQ0EsTUFBSXVaLE1BQU0sQ0FBVjtBQUNBLE1BQUl4dUMsSUFBSSxDQUFSO0FBQ0EsU0FBTyxFQUFFQSxDQUFGLEdBQU11bUMsVUFBTixLQUFxQmlJLE9BQU8sS0FBNUIsQ0FBUCxFQUEyQztBQUN6QzdpQixXQUFPLEtBQUtzSixTQUFTajFCLENBQWQsSUFBbUJ3dUMsR0FBMUI7QUFDRDtBQUNEQSxTQUFPLElBQVA7O0FBRUEsTUFBSTdpQixPQUFPNmlCLEdBQVgsRUFBZ0I3aUIsT0FBTzdpQixLQUFLaW1DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXhJLFVBQWhCLENBQVA7O0FBRWhCLFNBQU81YSxHQUFQO0FBQ0QsQ0FoQkQ7O0FBa0JBZ2MsT0FBTzdqQyxTQUFQLENBQWlCa3JDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0IvWixNQUFwQixFQUE0QnNSLFVBQTVCLEVBQXdDZ0ksUUFBeEMsRUFBa0Q7QUFDN0V0WixXQUFTQSxTQUFTLENBQWxCO0FBQ0FzUixlQUFhQSxhQUFhLENBQTFCO0FBQ0EsTUFBSSxDQUFDZ0ksUUFBTCxFQUFlSCxZQUFZblosTUFBWixFQUFvQnNSLFVBQXBCLEVBQWdDLEtBQUt0bUMsTUFBckM7O0FBRWYsTUFBSUQsSUFBSXVtQyxVQUFSO0FBQ0EsTUFBSWlJLE1BQU0sQ0FBVjtBQUNBLE1BQUk3aUIsTUFBTSxLQUFLc0osU0FBUyxFQUFFajFCLENBQWhCLENBQVY7QUFDQSxTQUFPQSxJQUFJLENBQUosS0FBVXd1QyxPQUFPLEtBQWpCLENBQVAsRUFBZ0M7QUFDOUI3aUIsV0FBTyxLQUFLc0osU0FBUyxFQUFFajFCLENBQWhCLElBQXFCd3VDLEdBQTVCO0FBQ0Q7QUFDREEsU0FBTyxJQUFQOztBQUVBLE1BQUk3aUIsT0FBTzZpQixHQUFYLEVBQWdCN2lCLE9BQU83aUIsS0FBS2ltQyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUl4SSxVQUFoQixDQUFQOztBQUVoQixTQUFPNWEsR0FBUDtBQUNELENBaEJEOztBQWtCQWdjLE9BQU83akMsU0FBUCxDQUFpQm1yQyxRQUFqQixHQUE0QixTQUFTQSxRQUFULENBQW1CaGEsTUFBbkIsRUFBMkJzWixRQUEzQixFQUFxQztBQUMvRCxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWW5aLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS2gxQixNQUE1QjtBQUNmLE1BQUksRUFBRSxLQUFLZzFCLE1BQUwsSUFBZSxJQUFqQixDQUFKLEVBQTRCLE9BQVEsS0FBS0EsTUFBTCxDQUFSO0FBQzVCLFNBQVEsQ0FBQyxPQUFPLEtBQUtBLE1BQUwsQ0FBUCxHQUFzQixDQUF2QixJQUE0QixDQUFDLENBQXJDO0FBQ0QsQ0FKRDs7QUFNQTBTLE9BQU83akMsU0FBUCxDQUFpQm9yQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCamEsTUFBdEIsRUFBOEJzWixRQUE5QixFQUF3QztBQUNyRSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWW5aLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS2gxQixNQUE1QjtBQUNmLE1BQUkwckIsTUFBTSxLQUFLc0osTUFBTCxJQUFnQixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FBOUM7QUFDQSxTQUFRdEosTUFBTSxNQUFQLEdBQWlCQSxNQUFNLFVBQXZCLEdBQW9DQSxHQUEzQztBQUNELENBSkQ7O0FBTUFnYyxPQUFPN2pDLFNBQVAsQ0FBaUJxckMsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQmxhLE1BQXRCLEVBQThCc1osUUFBOUIsRUFBd0M7QUFDckUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVluWixNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtoMUIsTUFBNUI7QUFDZixNQUFJMHJCLE1BQU0sS0FBS3NKLFNBQVMsQ0FBZCxJQUFvQixLQUFLQSxNQUFMLEtBQWdCLENBQTlDO0FBQ0EsU0FBUXRKLE1BQU0sTUFBUCxHQUFpQkEsTUFBTSxVQUF2QixHQUFvQ0EsR0FBM0M7QUFDRCxDQUpEOztBQU1BZ2MsT0FBTzdqQyxTQUFQLENBQWlCc3JDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JuYSxNQUF0QixFQUE4QnNaLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZblosTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLaDFCLE1BQTVCOztBQUVmLFNBQVEsS0FBS2cxQixNQUFMLENBQUQsR0FDSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FEaEIsR0FFSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFGaEIsR0FHSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFIdkI7QUFJRCxDQVBEOztBQVNBMFMsT0FBTzdqQyxTQUFQLENBQWlCdXJDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JwYSxNQUF0QixFQUE4QnNaLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZblosTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLaDFCLE1BQTVCOztBQUVmLFNBQVEsS0FBS2cxQixNQUFMLEtBQWdCLEVBQWpCLEdBQ0osS0FBS0EsU0FBUyxDQUFkLEtBQW9CLEVBRGhCLEdBRUosS0FBS0EsU0FBUyxDQUFkLEtBQW9CLENBRmhCLEdBR0osS0FBS0EsU0FBUyxDQUFkLENBSEg7QUFJRCxDQVBEOztBQVNBMFMsT0FBTzdqQyxTQUFQLENBQWlCd3JDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JyYSxNQUF0QixFQUE4QnNaLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZblosTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLaDFCLE1BQTVCO0FBQ2YsU0FBT3luQyxRQUFRMEUsSUFBUixDQUFhLElBQWIsRUFBbUJuWCxNQUFuQixFQUEyQixJQUEzQixFQUFpQyxFQUFqQyxFQUFxQyxDQUFyQyxDQUFQO0FBQ0QsQ0FIRDs7QUFLQTBTLE9BQU83akMsU0FBUCxDQUFpQnlyQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCdGEsTUFBdEIsRUFBOEJzWixRQUE5QixFQUF3QztBQUNyRSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWW5aLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS2gxQixNQUE1QjtBQUNmLFNBQU95bkMsUUFBUTBFLElBQVIsQ0FBYSxJQUFiLEVBQW1CblgsTUFBbkIsRUFBMkIsS0FBM0IsRUFBa0MsRUFBbEMsRUFBc0MsQ0FBdEMsQ0FBUDtBQUNELENBSEQ7O0FBS0EwUyxPQUFPN2pDLFNBQVAsQ0FBaUIwckMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QnZhLE1BQXZCLEVBQStCc1osUUFBL0IsRUFBeUM7QUFDdkUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVluWixNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtoMUIsTUFBNUI7QUFDZixTQUFPeW5DLFFBQVEwRSxJQUFSLENBQWEsSUFBYixFQUFtQm5YLE1BQW5CLEVBQTJCLElBQTNCLEVBQWlDLEVBQWpDLEVBQXFDLENBQXJDLENBQVA7QUFDRCxDQUhEOztBQUtBMFMsT0FBTzdqQyxTQUFQLENBQWlCMnJDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJ4YSxNQUF2QixFQUErQnNaLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZblosTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLaDFCLE1BQTVCO0FBQ2YsU0FBT3luQyxRQUFRMEUsSUFBUixDQUFhLElBQWIsRUFBbUJuWCxNQUFuQixFQUEyQixLQUEzQixFQUFrQyxFQUFsQyxFQUFzQyxDQUF0QyxDQUFQO0FBQ0QsQ0FIRDs7QUFLQSxTQUFTeWEsUUFBVCxDQUFtQmxGLEdBQW5CLEVBQXdCNXBDLEtBQXhCLEVBQStCcTBCLE1BQS9CLEVBQXVDb1osR0FBdkMsRUFBNEN0bUIsR0FBNUMsRUFBaURtUSxHQUFqRCxFQUFzRDtBQUNwRCxNQUFJLENBQUN5UCxPQUFPbUMsUUFBUCxDQUFnQlUsR0FBaEIsQ0FBTCxFQUEyQixNQUFNLElBQUlsb0MsU0FBSixDQUFjLDZDQUFkLENBQU47QUFDM0IsTUFBSTFCLFFBQVFtbkIsR0FBUixJQUFlbm5CLFFBQVFzM0IsR0FBM0IsRUFBZ0MsTUFBTSxJQUFJeUwsVUFBSixDQUFlLG1DQUFmLENBQU47QUFDaEMsTUFBSTFPLFNBQVNvWixHQUFULEdBQWU3RCxJQUFJdnFDLE1BQXZCLEVBQStCLE1BQU0sSUFBSTBqQyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNoQzs7QUFFRGdFLE9BQU83akMsU0FBUCxDQUFpQjZyQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCL3VDLEtBQXRCLEVBQTZCcTBCLE1BQTdCLEVBQXFDc1IsVUFBckMsRUFBaURnSSxRQUFqRCxFQUEyRDtBQUN4RjN0QyxVQUFRLENBQUNBLEtBQVQ7QUFDQXEwQixXQUFTQSxTQUFTLENBQWxCO0FBQ0FzUixlQUFhQSxhQUFhLENBQTFCO0FBQ0EsTUFBSSxDQUFDZ0ksUUFBTCxFQUFlO0FBQ2IsUUFBSXFCLFdBQVc5bUMsS0FBS2ltQyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUl4SSxVQUFoQixJQUE4QixDQUE3QztBQUNBbUosYUFBUyxJQUFULEVBQWU5dUMsS0FBZixFQUFzQnEwQixNQUF0QixFQUE4QnNSLFVBQTlCLEVBQTBDcUosUUFBMUMsRUFBb0QsQ0FBcEQ7QUFDRDs7QUFFRCxNQUFJcEIsTUFBTSxDQUFWO0FBQ0EsTUFBSXh1QyxJQUFJLENBQVI7QUFDQSxPQUFLaTFCLE1BQUwsSUFBZXIwQixRQUFRLElBQXZCO0FBQ0EsU0FBTyxFQUFFWixDQUFGLEdBQU11bUMsVUFBTixLQUFxQmlJLE9BQU8sS0FBNUIsQ0FBUCxFQUEyQztBQUN6QyxTQUFLdlosU0FBU2oxQixDQUFkLElBQW9CWSxRQUFRNHRDLEdBQVQsR0FBZ0IsSUFBbkM7QUFDRDs7QUFFRCxTQUFPdlosU0FBU3NSLFVBQWhCO0FBQ0QsQ0FqQkQ7O0FBbUJBb0IsT0FBTzdqQyxTQUFQLENBQWlCK3JDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JqdkMsS0FBdEIsRUFBNkJxMEIsTUFBN0IsRUFBcUNzUixVQUFyQyxFQUFpRGdJLFFBQWpELEVBQTJEO0FBQ3hGM3RDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcTBCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQXNSLGVBQWFBLGFBQWEsQ0FBMUI7QUFDQSxNQUFJLENBQUNnSSxRQUFMLEVBQWU7QUFDYixRQUFJcUIsV0FBVzltQyxLQUFLaW1DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXhJLFVBQWhCLElBQThCLENBQTdDO0FBQ0FtSixhQUFTLElBQVQsRUFBZTl1QyxLQUFmLEVBQXNCcTBCLE1BQXRCLEVBQThCc1IsVUFBOUIsRUFBMENxSixRQUExQyxFQUFvRCxDQUFwRDtBQUNEOztBQUVELE1BQUk1dkMsSUFBSXVtQyxhQUFhLENBQXJCO0FBQ0EsTUFBSWlJLE1BQU0sQ0FBVjtBQUNBLE9BQUt2WixTQUFTajFCLENBQWQsSUFBbUJZLFFBQVEsSUFBM0I7QUFDQSxTQUFPLEVBQUVaLENBQUYsSUFBTyxDQUFQLEtBQWF3dUMsT0FBTyxLQUFwQixDQUFQLEVBQW1DO0FBQ2pDLFNBQUt2WixTQUFTajFCLENBQWQsSUFBb0JZLFFBQVE0dEMsR0FBVCxHQUFnQixJQUFuQztBQUNEOztBQUVELFNBQU92WixTQUFTc1IsVUFBaEI7QUFDRCxDQWpCRDs7QUFtQkFvQixPQUFPN2pDLFNBQVAsQ0FBaUJnc0MsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQmx2QyxLQUFyQixFQUE0QnEwQixNQUE1QixFQUFvQ3NaLFFBQXBDLEVBQThDO0FBQzFFM3RDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcTBCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNzWixRQUFMLEVBQWVtQixTQUFTLElBQVQsRUFBZTl1QyxLQUFmLEVBQXNCcTBCLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLElBQWpDLEVBQXVDLENBQXZDO0FBQ2YsTUFBSSxDQUFDMFMsT0FBT0csbUJBQVosRUFBaUNsbkMsUUFBUWtJLEtBQUsyNkIsS0FBTCxDQUFXN2lDLEtBQVgsQ0FBUjtBQUNqQyxPQUFLcTBCLE1BQUwsSUFBZ0JyMEIsUUFBUSxJQUF4QjtBQUNBLFNBQU9xMEIsU0FBUyxDQUFoQjtBQUNELENBUEQ7O0FBU0EsU0FBUzhhLGlCQUFULENBQTRCdkYsR0FBNUIsRUFBaUM1cEMsS0FBakMsRUFBd0NxMEIsTUFBeEMsRUFBZ0QrYSxZQUFoRCxFQUE4RDtBQUM1RCxNQUFJcHZDLFFBQVEsQ0FBWixFQUFlQSxRQUFRLFNBQVNBLEtBQVQsR0FBaUIsQ0FBekI7QUFDZixPQUFLLElBQUlaLElBQUksQ0FBUixFQUFXd1UsSUFBSTFMLEtBQUtvdkIsR0FBTCxDQUFTc1MsSUFBSXZxQyxNQUFKLEdBQWFnMUIsTUFBdEIsRUFBOEIsQ0FBOUIsQ0FBcEIsRUFBc0RqMUIsSUFBSXdVLENBQTFELEVBQTZELEVBQUV4VSxDQUEvRCxFQUFrRTtBQUNoRXdxQyxRQUFJdlYsU0FBU2oxQixDQUFiLElBQWtCLENBQUNZLFFBQVMsUUFBUyxLQUFLb3ZDLGVBQWVod0MsQ0FBZixHQUFtQixJQUFJQSxDQUE1QixDQUFuQixNQUNoQixDQUFDZ3dDLGVBQWVod0MsQ0FBZixHQUFtQixJQUFJQSxDQUF4QixJQUE2QixDQUQvQjtBQUVEO0FBQ0Y7O0FBRUQybkMsT0FBTzdqQyxTQUFQLENBQWlCbXNDLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsQ0FBd0JydkMsS0FBeEIsRUFBK0JxMEIsTUFBL0IsRUFBdUNzWixRQUF2QyxFQUFpRDtBQUNoRjN0QyxVQUFRLENBQUNBLEtBQVQ7QUFDQXEwQixXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDc1osUUFBTCxFQUFlbUIsU0FBUyxJQUFULEVBQWU5dUMsS0FBZixFQUFzQnEwQixNQUF0QixFQUE4QixDQUE5QixFQUFpQyxNQUFqQyxFQUF5QyxDQUF6QztBQUNmLE1BQUkwUyxPQUFPRyxtQkFBWCxFQUFnQztBQUM5QixTQUFLN1MsTUFBTCxJQUFnQnIwQixRQUFRLElBQXhCO0FBQ0EsU0FBS3EwQixTQUFTLENBQWQsSUFBb0JyMEIsVUFBVSxDQUE5QjtBQUNELEdBSEQsTUFHTztBQUNMbXZDLHNCQUFrQixJQUFsQixFQUF3Qm52QyxLQUF4QixFQUErQnEwQixNQUEvQixFQUF1QyxJQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBWEQ7O0FBYUEwUyxPQUFPN2pDLFNBQVAsQ0FBaUJvc0MsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QnR2QyxLQUF4QixFQUErQnEwQixNQUEvQixFQUF1Q3NaLFFBQXZDLEVBQWlEO0FBQ2hGM3RDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcTBCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNzWixRQUFMLEVBQWVtQixTQUFTLElBQVQsRUFBZTl1QyxLQUFmLEVBQXNCcTBCLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLE1BQWpDLEVBQXlDLENBQXpDO0FBQ2YsTUFBSTBTLE9BQU9HLG1CQUFYLEVBQWdDO0FBQzlCLFNBQUs3UyxNQUFMLElBQWdCcjBCLFVBQVUsQ0FBMUI7QUFDQSxTQUFLcTBCLFNBQVMsQ0FBZCxJQUFvQnIwQixRQUFRLElBQTVCO0FBQ0QsR0FIRCxNQUdPO0FBQ0xtdkMsc0JBQWtCLElBQWxCLEVBQXdCbnZDLEtBQXhCLEVBQStCcTBCLE1BQS9CLEVBQXVDLEtBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FYRDs7QUFhQSxTQUFTa2IsaUJBQVQsQ0FBNEIzRixHQUE1QixFQUFpQzVwQyxLQUFqQyxFQUF3Q3EwQixNQUF4QyxFQUFnRCthLFlBQWhELEVBQThEO0FBQzVELE1BQUlwdkMsUUFBUSxDQUFaLEVBQWVBLFFBQVEsYUFBYUEsS0FBYixHQUFxQixDQUE3QjtBQUNmLE9BQUssSUFBSVosSUFBSSxDQUFSLEVBQVd3VSxJQUFJMUwsS0FBS292QixHQUFMLENBQVNzUyxJQUFJdnFDLE1BQUosR0FBYWcxQixNQUF0QixFQUE4QixDQUE5QixDQUFwQixFQUFzRGoxQixJQUFJd1UsQ0FBMUQsRUFBNkQsRUFBRXhVLENBQS9ELEVBQWtFO0FBQ2hFd3FDLFFBQUl2VixTQUFTajFCLENBQWIsSUFBbUJZLFVBQVUsQ0FBQ292QyxlQUFlaHdDLENBQWYsR0FBbUIsSUFBSUEsQ0FBeEIsSUFBNkIsQ0FBeEMsR0FBNkMsSUFBL0Q7QUFDRDtBQUNGOztBQUVEMm5DLE9BQU83akMsU0FBUCxDQUFpQnNzQyxhQUFqQixHQUFpQyxTQUFTQSxhQUFULENBQXdCeHZDLEtBQXhCLEVBQStCcTBCLE1BQS9CLEVBQXVDc1osUUFBdkMsRUFBaUQ7QUFDaEYzdEMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FxMEIsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3NaLFFBQUwsRUFBZW1CLFNBQVMsSUFBVCxFQUFlOXVDLEtBQWYsRUFBc0JxMEIsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsVUFBakMsRUFBNkMsQ0FBN0M7QUFDZixNQUFJMFMsT0FBT0csbUJBQVgsRUFBZ0M7QUFDOUIsU0FBSzdTLFNBQVMsQ0FBZCxJQUFvQnIwQixVQUFVLEVBQTlCO0FBQ0EsU0FBS3EwQixTQUFTLENBQWQsSUFBb0JyMEIsVUFBVSxFQUE5QjtBQUNBLFNBQUtxMEIsU0FBUyxDQUFkLElBQW9CcjBCLFVBQVUsQ0FBOUI7QUFDQSxTQUFLcTBCLE1BQUwsSUFBZ0JyMEIsUUFBUSxJQUF4QjtBQUNELEdBTEQsTUFLTztBQUNMdXZDLHNCQUFrQixJQUFsQixFQUF3QnZ2QyxLQUF4QixFQUErQnEwQixNQUEvQixFQUF1QyxJQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBYkQ7O0FBZUEwUyxPQUFPN2pDLFNBQVAsQ0FBaUJ1c0MsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3Qnp2QyxLQUF4QixFQUErQnEwQixNQUEvQixFQUF1Q3NaLFFBQXZDLEVBQWlEO0FBQ2hGM3RDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcTBCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNzWixRQUFMLEVBQWVtQixTQUFTLElBQVQsRUFBZTl1QyxLQUFmLEVBQXNCcTBCLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLFVBQWpDLEVBQTZDLENBQTdDO0FBQ2YsTUFBSTBTLE9BQU9HLG1CQUFYLEVBQWdDO0FBQzlCLFNBQUs3UyxNQUFMLElBQWdCcjBCLFVBQVUsRUFBMUI7QUFDQSxTQUFLcTBCLFNBQVMsQ0FBZCxJQUFvQnIwQixVQUFVLEVBQTlCO0FBQ0EsU0FBS3EwQixTQUFTLENBQWQsSUFBb0JyMEIsVUFBVSxDQUE5QjtBQUNBLFNBQUtxMEIsU0FBUyxDQUFkLElBQW9CcjBCLFFBQVEsSUFBNUI7QUFDRCxHQUxELE1BS087QUFDTHV2QyxzQkFBa0IsSUFBbEIsRUFBd0J2dkMsS0FBeEIsRUFBK0JxMEIsTUFBL0IsRUFBdUMsS0FBdkM7QUFDRDtBQUNELFNBQU9BLFNBQVMsQ0FBaEI7QUFDRCxDQWJEOztBQWVBMFMsT0FBTzdqQyxTQUFQLENBQWlCd3NDLFVBQWpCLEdBQThCLFNBQVNBLFVBQVQsQ0FBcUIxdkMsS0FBckIsRUFBNEJxMEIsTUFBNUIsRUFBb0NzUixVQUFwQyxFQUFnRGdJLFFBQWhELEVBQTBEO0FBQ3RGM3RDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcTBCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNzWixRQUFMLEVBQWU7QUFDYixRQUFJZ0MsUUFBUXpuQyxLQUFLaW1DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXhJLFVBQUosR0FBaUIsQ0FBN0IsQ0FBWjs7QUFFQW1KLGFBQVMsSUFBVCxFQUFlOXVDLEtBQWYsRUFBc0JxMEIsTUFBdEIsRUFBOEJzUixVQUE5QixFQUEwQ2dLLFFBQVEsQ0FBbEQsRUFBcUQsQ0FBQ0EsS0FBdEQ7QUFDRDs7QUFFRCxNQUFJdndDLElBQUksQ0FBUjtBQUNBLE1BQUl3dUMsTUFBTSxDQUFWO0FBQ0EsTUFBSWdDLE1BQU0sQ0FBVjtBQUNBLE9BQUt2YixNQUFMLElBQWVyMEIsUUFBUSxJQUF2QjtBQUNBLFNBQU8sRUFBRVosQ0FBRixHQUFNdW1DLFVBQU4sS0FBcUJpSSxPQUFPLEtBQTVCLENBQVAsRUFBMkM7QUFDekMsUUFBSTV0QyxRQUFRLENBQVIsSUFBYTR2QyxRQUFRLENBQXJCLElBQTBCLEtBQUt2YixTQUFTajFCLENBQVQsR0FBYSxDQUFsQixNQUF5QixDQUF2RCxFQUEwRDtBQUN4RHd3QyxZQUFNLENBQU47QUFDRDtBQUNELFNBQUt2YixTQUFTajFCLENBQWQsSUFBbUIsQ0FBRVksUUFBUTR0QyxHQUFULElBQWlCLENBQWxCLElBQXVCZ0MsR0FBdkIsR0FBNkIsSUFBaEQ7QUFDRDs7QUFFRCxTQUFPdmIsU0FBU3NSLFVBQWhCO0FBQ0QsQ0FyQkQ7O0FBdUJBb0IsT0FBTzdqQyxTQUFQLENBQWlCMnNDLFVBQWpCLEdBQThCLFNBQVNBLFVBQVQsQ0FBcUI3dkMsS0FBckIsRUFBNEJxMEIsTUFBNUIsRUFBb0NzUixVQUFwQyxFQUFnRGdJLFFBQWhELEVBQTBEO0FBQ3RGM3RDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcTBCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNzWixRQUFMLEVBQWU7QUFDYixRQUFJZ0MsUUFBUXpuQyxLQUFLaW1DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXhJLFVBQUosR0FBaUIsQ0FBN0IsQ0FBWjs7QUFFQW1KLGFBQVMsSUFBVCxFQUFlOXVDLEtBQWYsRUFBc0JxMEIsTUFBdEIsRUFBOEJzUixVQUE5QixFQUEwQ2dLLFFBQVEsQ0FBbEQsRUFBcUQsQ0FBQ0EsS0FBdEQ7QUFDRDs7QUFFRCxNQUFJdndDLElBQUl1bUMsYUFBYSxDQUFyQjtBQUNBLE1BQUlpSSxNQUFNLENBQVY7QUFDQSxNQUFJZ0MsTUFBTSxDQUFWO0FBQ0EsT0FBS3ZiLFNBQVNqMUIsQ0FBZCxJQUFtQlksUUFBUSxJQUEzQjtBQUNBLFNBQU8sRUFBRVosQ0FBRixJQUFPLENBQVAsS0FBYXd1QyxPQUFPLEtBQXBCLENBQVAsRUFBbUM7QUFDakMsUUFBSTV0QyxRQUFRLENBQVIsSUFBYTR2QyxRQUFRLENBQXJCLElBQTBCLEtBQUt2YixTQUFTajFCLENBQVQsR0FBYSxDQUFsQixNQUF5QixDQUF2RCxFQUEwRDtBQUN4RHd3QyxZQUFNLENBQU47QUFDRDtBQUNELFNBQUt2YixTQUFTajFCLENBQWQsSUFBbUIsQ0FBRVksUUFBUTR0QyxHQUFULElBQWlCLENBQWxCLElBQXVCZ0MsR0FBdkIsR0FBNkIsSUFBaEQ7QUFDRDs7QUFFRCxTQUFPdmIsU0FBU3NSLFVBQWhCO0FBQ0QsQ0FyQkQ7O0FBdUJBb0IsT0FBTzdqQyxTQUFQLENBQWlCNHNDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0I5dkMsS0FBcEIsRUFBMkJxMEIsTUFBM0IsRUFBbUNzWixRQUFuQyxFQUE2QztBQUN4RTN0QyxVQUFRLENBQUNBLEtBQVQ7QUFDQXEwQixXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDc1osUUFBTCxFQUFlbUIsU0FBUyxJQUFULEVBQWU5dUMsS0FBZixFQUFzQnEwQixNQUF0QixFQUE4QixDQUE5QixFQUFpQyxJQUFqQyxFQUF1QyxDQUFDLElBQXhDO0FBQ2YsTUFBSSxDQUFDMFMsT0FBT0csbUJBQVosRUFBaUNsbkMsUUFBUWtJLEtBQUsyNkIsS0FBTCxDQUFXN2lDLEtBQVgsQ0FBUjtBQUNqQyxNQUFJQSxRQUFRLENBQVosRUFBZUEsUUFBUSxPQUFPQSxLQUFQLEdBQWUsQ0FBdkI7QUFDZixPQUFLcTBCLE1BQUwsSUFBZ0JyMEIsUUFBUSxJQUF4QjtBQUNBLFNBQU9xMEIsU0FBUyxDQUFoQjtBQUNELENBUkQ7O0FBVUEwUyxPQUFPN2pDLFNBQVAsQ0FBaUI2c0MsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1Qi92QyxLQUF2QixFQUE4QnEwQixNQUE5QixFQUFzQ3NaLFFBQXRDLEVBQWdEO0FBQzlFM3RDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcTBCLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUNzWixRQUFMLEVBQWVtQixTQUFTLElBQVQsRUFBZTl1QyxLQUFmLEVBQXNCcTBCLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLE1BQWpDLEVBQXlDLENBQUMsTUFBMUM7QUFDZixNQUFJMFMsT0FBT0csbUJBQVgsRUFBZ0M7QUFDOUIsU0FBSzdTLE1BQUwsSUFBZ0JyMEIsUUFBUSxJQUF4QjtBQUNBLFNBQUtxMEIsU0FBUyxDQUFkLElBQW9CcjBCLFVBQVUsQ0FBOUI7QUFDRCxHQUhELE1BR087QUFDTG12QyxzQkFBa0IsSUFBbEIsRUFBd0JudkMsS0FBeEIsRUFBK0JxMEIsTUFBL0IsRUFBdUMsSUFBdkM7QUFDRDtBQUNELFNBQU9BLFNBQVMsQ0FBaEI7QUFDRCxDQVhEOztBQWFBMFMsT0FBTzdqQyxTQUFQLENBQWlCOHNDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJod0MsS0FBdkIsRUFBOEJxMEIsTUFBOUIsRUFBc0NzWixRQUF0QyxFQUFnRDtBQUM5RTN0QyxVQUFRLENBQUNBLEtBQVQ7QUFDQXEwQixXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDc1osUUFBTCxFQUFlbUIsU0FBUyxJQUFULEVBQWU5dUMsS0FBZixFQUFzQnEwQixNQUF0QixFQUE4QixDQUE5QixFQUFpQyxNQUFqQyxFQUF5QyxDQUFDLE1BQTFDO0FBQ2YsTUFBSTBTLE9BQU9HLG1CQUFYLEVBQWdDO0FBQzlCLFNBQUs3UyxNQUFMLElBQWdCcjBCLFVBQVUsQ0FBMUI7QUFDQSxTQUFLcTBCLFNBQVMsQ0FBZCxJQUFvQnIwQixRQUFRLElBQTVCO0FBQ0QsR0FIRCxNQUdPO0FBQ0xtdkMsc0JBQWtCLElBQWxCLEVBQXdCbnZDLEtBQXhCLEVBQStCcTBCLE1BQS9CLEVBQXVDLEtBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FYRDs7QUFhQTBTLE9BQU83akMsU0FBUCxDQUFpQitzQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCandDLEtBQXZCLEVBQThCcTBCLE1BQTlCLEVBQXNDc1osUUFBdEMsRUFBZ0Q7QUFDOUUzdEMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FxMEIsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3NaLFFBQUwsRUFBZW1CLFNBQVMsSUFBVCxFQUFlOXVDLEtBQWYsRUFBc0JxMEIsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsVUFBakMsRUFBNkMsQ0FBQyxVQUE5QztBQUNmLE1BQUkwUyxPQUFPRyxtQkFBWCxFQUFnQztBQUM5QixTQUFLN1MsTUFBTCxJQUFnQnIwQixRQUFRLElBQXhCO0FBQ0EsU0FBS3EwQixTQUFTLENBQWQsSUFBb0JyMEIsVUFBVSxDQUE5QjtBQUNBLFNBQUtxMEIsU0FBUyxDQUFkLElBQW9CcjBCLFVBQVUsRUFBOUI7QUFDQSxTQUFLcTBCLFNBQVMsQ0FBZCxJQUFvQnIwQixVQUFVLEVBQTlCO0FBQ0QsR0FMRCxNQUtPO0FBQ0x1dkMsc0JBQWtCLElBQWxCLEVBQXdCdnZDLEtBQXhCLEVBQStCcTBCLE1BQS9CLEVBQXVDLElBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FiRDs7QUFlQTBTLE9BQU83akMsU0FBUCxDQUFpQmd0QyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCbHdDLEtBQXZCLEVBQThCcTBCLE1BQTlCLEVBQXNDc1osUUFBdEMsRUFBZ0Q7QUFDOUUzdEMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FxMEIsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3NaLFFBQUwsRUFBZW1CLFNBQVMsSUFBVCxFQUFlOXVDLEtBQWYsRUFBc0JxMEIsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsVUFBakMsRUFBNkMsQ0FBQyxVQUE5QztBQUNmLE1BQUlyMEIsUUFBUSxDQUFaLEVBQWVBLFFBQVEsYUFBYUEsS0FBYixHQUFxQixDQUE3QjtBQUNmLE1BQUkrbUMsT0FBT0csbUJBQVgsRUFBZ0M7QUFDOUIsU0FBSzdTLE1BQUwsSUFBZ0JyMEIsVUFBVSxFQUExQjtBQUNBLFNBQUtxMEIsU0FBUyxDQUFkLElBQW9CcjBCLFVBQVUsRUFBOUI7QUFDQSxTQUFLcTBCLFNBQVMsQ0FBZCxJQUFvQnIwQixVQUFVLENBQTlCO0FBQ0EsU0FBS3EwQixTQUFTLENBQWQsSUFBb0JyMEIsUUFBUSxJQUE1QjtBQUNELEdBTEQsTUFLTztBQUNMdXZDLHNCQUFrQixJQUFsQixFQUF3QnZ2QyxLQUF4QixFQUErQnEwQixNQUEvQixFQUF1QyxLQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBZEQ7O0FBZ0JBLFNBQVM4YixZQUFULENBQXVCdkcsR0FBdkIsRUFBNEI1cEMsS0FBNUIsRUFBbUNxMEIsTUFBbkMsRUFBMkNvWixHQUEzQyxFQUFnRHRtQixHQUFoRCxFQUFxRG1RLEdBQXJELEVBQTBEO0FBQ3hELE1BQUlqRCxTQUFTb1osR0FBVCxHQUFlN0QsSUFBSXZxQyxNQUF2QixFQUErQixNQUFNLElBQUkwakMsVUFBSixDQUFlLG9CQUFmLENBQU47QUFDL0IsTUFBSTFPLFNBQVMsQ0FBYixFQUFnQixNQUFNLElBQUkwTyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNqQjs7QUFFRCxTQUFTcU4sVUFBVCxDQUFxQnhHLEdBQXJCLEVBQTBCNXBDLEtBQTFCLEVBQWlDcTBCLE1BQWpDLEVBQXlDK2EsWUFBekMsRUFBdUR6QixRQUF2RCxFQUFpRTtBQUMvRCxNQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNid0MsaUJBQWF2RyxHQUFiLEVBQWtCNXBDLEtBQWxCLEVBQXlCcTBCLE1BQXpCLEVBQWlDLENBQWpDLEVBQW9DLHNCQUFwQyxFQUE0RCxDQUFDLHNCQUE3RDtBQUNEO0FBQ0R5UyxVQUFRaUMsS0FBUixDQUFjYSxHQUFkLEVBQW1CNXBDLEtBQW5CLEVBQTBCcTBCLE1BQTFCLEVBQWtDK2EsWUFBbEMsRUFBZ0QsRUFBaEQsRUFBb0QsQ0FBcEQ7QUFDQSxTQUFPL2EsU0FBUyxDQUFoQjtBQUNEOztBQUVEMFMsT0FBTzdqQyxTQUFQLENBQWlCbXRDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJyd0MsS0FBdkIsRUFBOEJxMEIsTUFBOUIsRUFBc0NzWixRQUF0QyxFQUFnRDtBQUM5RSxTQUFPeUMsV0FBVyxJQUFYLEVBQWlCcHdDLEtBQWpCLEVBQXdCcTBCLE1BQXhCLEVBQWdDLElBQWhDLEVBQXNDc1osUUFBdEMsQ0FBUDtBQUNELENBRkQ7O0FBSUE1RyxPQUFPN2pDLFNBQVAsQ0FBaUJvdEMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QnR3QyxLQUF2QixFQUE4QnEwQixNQUE5QixFQUFzQ3NaLFFBQXRDLEVBQWdEO0FBQzlFLFNBQU95QyxXQUFXLElBQVgsRUFBaUJwd0MsS0FBakIsRUFBd0JxMEIsTUFBeEIsRUFBZ0MsS0FBaEMsRUFBdUNzWixRQUF2QyxDQUFQO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTNEMsV0FBVCxDQUFzQjNHLEdBQXRCLEVBQTJCNXBDLEtBQTNCLEVBQWtDcTBCLE1BQWxDLEVBQTBDK2EsWUFBMUMsRUFBd0R6QixRQUF4RCxFQUFrRTtBQUNoRSxNQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNid0MsaUJBQWF2RyxHQUFiLEVBQWtCNXBDLEtBQWxCLEVBQXlCcTBCLE1BQXpCLEVBQWlDLENBQWpDLEVBQW9DLHVCQUFwQyxFQUE2RCxDQUFDLHVCQUE5RDtBQUNEO0FBQ0R5UyxVQUFRaUMsS0FBUixDQUFjYSxHQUFkLEVBQW1CNXBDLEtBQW5CLEVBQTBCcTBCLE1BQTFCLEVBQWtDK2EsWUFBbEMsRUFBZ0QsRUFBaEQsRUFBb0QsQ0FBcEQ7QUFDQSxTQUFPL2EsU0FBUyxDQUFoQjtBQUNEOztBQUVEMFMsT0FBTzdqQyxTQUFQLENBQWlCc3RDLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsQ0FBd0J4d0MsS0FBeEIsRUFBK0JxMEIsTUFBL0IsRUFBdUNzWixRQUF2QyxFQUFpRDtBQUNoRixTQUFPNEMsWUFBWSxJQUFaLEVBQWtCdndDLEtBQWxCLEVBQXlCcTBCLE1BQXpCLEVBQWlDLElBQWpDLEVBQXVDc1osUUFBdkMsQ0FBUDtBQUNELENBRkQ7O0FBSUE1RyxPQUFPN2pDLFNBQVAsQ0FBaUJ1dEMsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3Qnp3QyxLQUF4QixFQUErQnEwQixNQUEvQixFQUF1Q3NaLFFBQXZDLEVBQWlEO0FBQ2hGLFNBQU80QyxZQUFZLElBQVosRUFBa0J2d0MsS0FBbEIsRUFBeUJxMEIsTUFBekIsRUFBaUMsS0FBakMsRUFBd0NzWixRQUF4QyxDQUFQO0FBQ0QsQ0FGRDs7QUFJQTtBQUNBNUcsT0FBTzdqQyxTQUFQLENBQWlCaW1DLElBQWpCLEdBQXdCLFNBQVNBLElBQVQsQ0FBZTJCLE1BQWYsRUFBdUI0RixXQUF2QixFQUFvQzV2QyxLQUFwQyxFQUEyQ2lKLEdBQTNDLEVBQWdEO0FBQ3RFLE1BQUksQ0FBQ2pKLEtBQUwsRUFBWUEsUUFBUSxDQUFSO0FBQ1osTUFBSSxDQUFDaUosR0FBRCxJQUFRQSxRQUFRLENBQXBCLEVBQXVCQSxNQUFNLEtBQUsxSyxNQUFYO0FBQ3ZCLE1BQUlxeEMsZUFBZTVGLE9BQU96ckMsTUFBMUIsRUFBa0NxeEMsY0FBYzVGLE9BQU96ckMsTUFBckI7QUFDbEMsTUFBSSxDQUFDcXhDLFdBQUwsRUFBa0JBLGNBQWMsQ0FBZDtBQUNsQixNQUFJM21DLE1BQU0sQ0FBTixJQUFXQSxNQUFNakosS0FBckIsRUFBNEJpSixNQUFNakosS0FBTjs7QUFFNUI7QUFDQSxNQUFJaUosUUFBUWpKLEtBQVosRUFBbUIsT0FBTyxDQUFQO0FBQ25CLE1BQUlncUMsT0FBT3pyQyxNQUFQLEtBQWtCLENBQWxCLElBQXVCLEtBQUtBLE1BQUwsS0FBZ0IsQ0FBM0MsRUFBOEMsT0FBTyxDQUFQOztBQUU5QztBQUNBLE1BQUlxeEMsY0FBYyxDQUFsQixFQUFxQjtBQUNuQixVQUFNLElBQUkzTixVQUFKLENBQWUsMkJBQWYsQ0FBTjtBQUNEO0FBQ0QsTUFBSWppQyxRQUFRLENBQVIsSUFBYUEsU0FBUyxLQUFLekIsTUFBL0IsRUFBdUMsTUFBTSxJQUFJMGpDLFVBQUosQ0FBZSwyQkFBZixDQUFOO0FBQ3ZDLE1BQUloNUIsTUFBTSxDQUFWLEVBQWEsTUFBTSxJQUFJZzVCLFVBQUosQ0FBZSx5QkFBZixDQUFOOztBQUViO0FBQ0EsTUFBSWg1QixNQUFNLEtBQUsxSyxNQUFmLEVBQXVCMEssTUFBTSxLQUFLMUssTUFBWDtBQUN2QixNQUFJeXJDLE9BQU96ckMsTUFBUCxHQUFnQnF4QyxXQUFoQixHQUE4QjNtQyxNQUFNakosS0FBeEMsRUFBK0M7QUFDN0NpSixVQUFNK2dDLE9BQU96ckMsTUFBUCxHQUFnQnF4QyxXQUFoQixHQUE4QjV2QyxLQUFwQztBQUNEOztBQUVELE1BQUl3WixNQUFNdlEsTUFBTWpKLEtBQWhCO0FBQ0EsTUFBSTFCLENBQUo7O0FBRUEsTUFBSSxTQUFTMHJDLE1BQVQsSUFBbUJocUMsUUFBUTR2QyxXQUEzQixJQUEwQ0EsY0FBYzNtQyxHQUE1RCxFQUFpRTtBQUMvRDtBQUNBLFNBQUszSyxJQUFJa2IsTUFBTSxDQUFmLEVBQWtCbGIsS0FBSyxDQUF2QixFQUEwQixFQUFFQSxDQUE1QixFQUErQjtBQUM3QjByQyxhQUFPMXJDLElBQUlzeEMsV0FBWCxJQUEwQixLQUFLdHhDLElBQUkwQixLQUFULENBQTFCO0FBQ0Q7QUFDRixHQUxELE1BS08sSUFBSXdaLE1BQU0sSUFBTixJQUFjLENBQUN5c0IsT0FBT0csbUJBQTFCLEVBQStDO0FBQ3BEO0FBQ0EsU0FBSzluQyxJQUFJLENBQVQsRUFBWUEsSUFBSWtiLEdBQWhCLEVBQXFCLEVBQUVsYixDQUF2QixFQUEwQjtBQUN4QjByQyxhQUFPMXJDLElBQUlzeEMsV0FBWCxJQUEwQixLQUFLdHhDLElBQUkwQixLQUFULENBQTFCO0FBQ0Q7QUFDRixHQUxNLE1BS0E7QUFDTG1sQyxlQUFXL2lDLFNBQVgsQ0FBcUIrVSxHQUFyQixDQUF5QnRYLElBQXpCLENBQ0VtcUMsTUFERixFQUVFLEtBQUt2RCxRQUFMLENBQWN6bUMsS0FBZCxFQUFxQkEsUUFBUXdaLEdBQTdCLENBRkYsRUFHRW8yQixXQUhGO0FBS0Q7O0FBRUQsU0FBT3AyQixHQUFQO0FBQ0QsQ0E5Q0Q7O0FBZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0F5c0IsT0FBTzdqQyxTQUFQLENBQWlCdWxDLElBQWpCLEdBQXdCLFNBQVNBLElBQVQsQ0FBZTFkLEdBQWYsRUFBb0JqcUIsS0FBcEIsRUFBMkJpSixHQUEzQixFQUFnQzIrQixRQUFoQyxFQUEwQztBQUNoRTtBQUNBLE1BQUksT0FBTzNkLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixRQUFJLE9BQU9qcUIsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QjRuQyxpQkFBVzVuQyxLQUFYO0FBQ0FBLGNBQVEsQ0FBUjtBQUNBaUosWUFBTSxLQUFLMUssTUFBWDtBQUNELEtBSkQsTUFJTyxJQUFJLE9BQU8wSyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDbEMyK0IsaUJBQVczK0IsR0FBWDtBQUNBQSxZQUFNLEtBQUsxSyxNQUFYO0FBQ0Q7QUFDRCxRQUFJMHJCLElBQUkxckIsTUFBSixLQUFlLENBQW5CLEVBQXNCO0FBQ3BCLFVBQUltaUIsT0FBT3VKLElBQUl0SixVQUFKLENBQWUsQ0FBZixDQUFYO0FBQ0EsVUFBSUQsT0FBTyxHQUFYLEVBQWdCO0FBQ2R1SixjQUFNdkosSUFBTjtBQUNEO0FBQ0Y7QUFDRCxRQUFJa25CLGFBQWFqcUMsU0FBYixJQUEwQixPQUFPaXFDLFFBQVAsS0FBb0IsUUFBbEQsRUFBNEQ7QUFDMUQsWUFBTSxJQUFJaG5DLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ0Q7QUFDRCxRQUFJLE9BQU9nbkMsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxDQUFDM0IsT0FBTzhCLFVBQVAsQ0FBa0JILFFBQWxCLENBQXJDLEVBQWtFO0FBQ2hFLFlBQU0sSUFBSWhuQyxTQUFKLENBQWMsdUJBQXVCZ25DLFFBQXJDLENBQU47QUFDRDtBQUNGLEdBckJELE1BcUJPLElBQUksT0FBTzNkLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQ0EsVUFBTUEsTUFBTSxHQUFaO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJanFCLFFBQVEsQ0FBUixJQUFhLEtBQUt6QixNQUFMLEdBQWN5QixLQUEzQixJQUFvQyxLQUFLekIsTUFBTCxHQUFjMEssR0FBdEQsRUFBMkQ7QUFDekQsVUFBTSxJQUFJZzVCLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ0Q7O0FBRUQsTUFBSWg1QixPQUFPakosS0FBWCxFQUFrQjtBQUNoQixXQUFPLElBQVA7QUFDRDs7QUFFREEsVUFBUUEsVUFBVSxDQUFsQjtBQUNBaUosUUFBTUEsUUFBUXRMLFNBQVIsR0FBb0IsS0FBS1ksTUFBekIsR0FBa0MwSyxRQUFRLENBQWhEOztBQUVBLE1BQUksQ0FBQ2doQixHQUFMLEVBQVVBLE1BQU0sQ0FBTjs7QUFFVixNQUFJM3JCLENBQUo7QUFDQSxNQUFJLE9BQU8yckIsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFNBQUszckIsSUFBSTBCLEtBQVQsRUFBZ0IxQixJQUFJMkssR0FBcEIsRUFBeUIsRUFBRTNLLENBQTNCLEVBQThCO0FBQzVCLFdBQUtBLENBQUwsSUFBVTJyQixHQUFWO0FBQ0Q7QUFDRixHQUpELE1BSU87QUFDTCxRQUFJc2lCLFFBQVF0RyxPQUFPbUMsUUFBUCxDQUFnQm5lLEdBQWhCLElBQ1JBLEdBRFEsR0FFUmdmLFlBQVksSUFBSWhELE1BQUosQ0FBV2hjLEdBQVgsRUFBZ0IyZCxRQUFoQixFQUEwQmprQyxRQUExQixFQUFaLENBRko7QUFHQSxRQUFJNlYsTUFBTSt5QixNQUFNaHVDLE1BQWhCO0FBQ0EsU0FBS0QsSUFBSSxDQUFULEVBQVlBLElBQUkySyxNQUFNakosS0FBdEIsRUFBNkIsRUFBRTFCLENBQS9CLEVBQWtDO0FBQ2hDLFdBQUtBLElBQUkwQixLQUFULElBQWtCdXNDLE1BQU1qdUMsSUFBSWtiLEdBQVYsQ0FBbEI7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNELENBekREOztBQTJEQTtBQUNBOztBQUVBLElBQUlxMkIsb0JBQW9CLG9CQUF4Qjs7QUFFQSxTQUFTQyxXQUFULENBQXNCaHZCLEdBQXRCLEVBQTJCO0FBQ3pCO0FBQ0FBLFFBQU1pdkIsV0FBV2p2QixHQUFYLEVBQWdCeGhCLE9BQWhCLENBQXdCdXdDLGlCQUF4QixFQUEyQyxFQUEzQyxDQUFOO0FBQ0E7QUFDQSxNQUFJL3VCLElBQUl2aUIsTUFBSixHQUFhLENBQWpCLEVBQW9CLE9BQU8sRUFBUDtBQUNwQjtBQUNBLFNBQU91aUIsSUFBSXZpQixNQUFKLEdBQWEsQ0FBYixLQUFtQixDQUExQixFQUE2QjtBQUMzQnVpQixVQUFNQSxNQUFNLEdBQVo7QUFDRDtBQUNELFNBQU9BLEdBQVA7QUFDRDs7QUFFRCxTQUFTaXZCLFVBQVQsQ0FBcUJqdkIsR0FBckIsRUFBMEI7QUFDeEIsTUFBSUEsSUFBSWtCLElBQVIsRUFBYyxPQUFPbEIsSUFBSWtCLElBQUosRUFBUDtBQUNkLFNBQU9sQixJQUFJeGhCLE9BQUosQ0FBWSxZQUFaLEVBQTBCLEVBQTFCLENBQVA7QUFDRDs7QUFFRCxTQUFTZ3RDLEtBQVQsQ0FBZ0JoSixDQUFoQixFQUFtQjtBQUNqQixNQUFJQSxJQUFJLEVBQVIsRUFBWSxPQUFPLE1BQU1BLEVBQUUzL0IsUUFBRixDQUFXLEVBQVgsQ0FBYjtBQUNaLFNBQU8yL0IsRUFBRTMvQixRQUFGLENBQVcsRUFBWCxDQUFQO0FBQ0Q7O0FBRUQsU0FBU3NsQyxXQUFULENBQXNCLzJCLE1BQXRCLEVBQThCODlCLEtBQTlCLEVBQXFDO0FBQ25DQSxVQUFRQSxTQUFTQyxRQUFqQjtBQUNBLE1BQUl0TixTQUFKO0FBQ0EsTUFBSXBrQyxTQUFTMlQsT0FBTzNULE1BQXBCO0FBQ0EsTUFBSTJ4QyxnQkFBZ0IsSUFBcEI7QUFDQSxNQUFJM0QsUUFBUSxFQUFaOztBQUVBLE9BQUssSUFBSWp1QyxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLE1BQXBCLEVBQTRCLEVBQUVELENBQTlCLEVBQWlDO0FBQy9CcWtDLGdCQUFZendCLE9BQU95TyxVQUFQLENBQWtCcmlCLENBQWxCLENBQVo7O0FBRUE7QUFDQSxRQUFJcWtDLFlBQVksTUFBWixJQUFzQkEsWUFBWSxNQUF0QyxFQUE4QztBQUM1QztBQUNBLFVBQUksQ0FBQ3VOLGFBQUwsRUFBb0I7QUFDbEI7QUFDQSxZQUFJdk4sWUFBWSxNQUFoQixFQUF3QjtBQUN0QjtBQUNBLGNBQUksQ0FBQ3FOLFNBQVMsQ0FBVixJQUFlLENBQUMsQ0FBcEIsRUFBdUJ6RCxNQUFNbnRDLElBQU4sQ0FBVyxJQUFYLEVBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ3ZCO0FBQ0QsU0FKRCxNQUlPLElBQUlkLElBQUksQ0FBSixLQUFVQyxNQUFkLEVBQXNCO0FBQzNCO0FBQ0EsY0FBSSxDQUFDeXhDLFNBQVMsQ0FBVixJQUFlLENBQUMsQ0FBcEIsRUFBdUJ6RCxNQUFNbnRDLElBQU4sQ0FBVyxJQUFYLEVBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ3ZCO0FBQ0Q7O0FBRUQ7QUFDQTh3Qyx3QkFBZ0J2TixTQUFoQjs7QUFFQTtBQUNEOztBQUVEO0FBQ0EsVUFBSUEsWUFBWSxNQUFoQixFQUF3QjtBQUN0QixZQUFJLENBQUNxTixTQUFTLENBQVYsSUFBZSxDQUFDLENBQXBCLEVBQXVCekQsTUFBTW50QyxJQUFOLENBQVcsSUFBWCxFQUFpQixJQUFqQixFQUF1QixJQUF2QjtBQUN2Qjh3Qyx3QkFBZ0J2TixTQUFoQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQUEsa0JBQVksQ0FBQ3VOLGdCQUFnQixNQUFoQixJQUEwQixFQUExQixHQUErQnZOLFlBQVksTUFBNUMsSUFBc0QsT0FBbEU7QUFDRCxLQTdCRCxNQTZCTyxJQUFJdU4sYUFBSixFQUFtQjtBQUN4QjtBQUNBLFVBQUksQ0FBQ0YsU0FBUyxDQUFWLElBQWUsQ0FBQyxDQUFwQixFQUF1QnpELE1BQU1udEMsSUFBTixDQUFXLElBQVgsRUFBaUIsSUFBakIsRUFBdUIsSUFBdkI7QUFDeEI7O0FBRUQ4d0Msb0JBQWdCLElBQWhCOztBQUVBO0FBQ0EsUUFBSXZOLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsVUFBSSxDQUFDcU4sU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEJ6RCxZQUFNbnRDLElBQU4sQ0FBV3VqQyxTQUFYO0FBQ0QsS0FIRCxNQUdPLElBQUlBLFlBQVksS0FBaEIsRUFBdUI7QUFDNUIsVUFBSSxDQUFDcU4sU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEJ6RCxZQUFNbnRDLElBQU4sQ0FDRXVqQyxhQUFhLEdBQWIsR0FBbUIsSUFEckIsRUFFRUEsWUFBWSxJQUFaLEdBQW1CLElBRnJCO0FBSUQsS0FOTSxNQU1BLElBQUlBLFlBQVksT0FBaEIsRUFBeUI7QUFDOUIsVUFBSSxDQUFDcU4sU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEJ6RCxZQUFNbnRDLElBQU4sQ0FDRXVqQyxhQUFhLEdBQWIsR0FBbUIsSUFEckIsRUFFRUEsYUFBYSxHQUFiLEdBQW1CLElBQW5CLEdBQTBCLElBRjVCLEVBR0VBLFlBQVksSUFBWixHQUFtQixJQUhyQjtBQUtELEtBUE0sTUFPQSxJQUFJQSxZQUFZLFFBQWhCLEVBQTBCO0FBQy9CLFVBQUksQ0FBQ3FOLFNBQVMsQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ3RCekQsWUFBTW50QyxJQUFOLENBQ0V1akMsYUFBYSxJQUFiLEdBQW9CLElBRHRCLEVBRUVBLGFBQWEsR0FBYixHQUFtQixJQUFuQixHQUEwQixJQUY1QixFQUdFQSxhQUFhLEdBQWIsR0FBbUIsSUFBbkIsR0FBMEIsSUFINUIsRUFJRUEsWUFBWSxJQUFaLEdBQW1CLElBSnJCO0FBTUQsS0FSTSxNQVFBO0FBQ0wsWUFBTSxJQUFJemlDLEtBQUosQ0FBVSxvQkFBVixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPcXNDLEtBQVA7QUFDRDs7QUFFRCxTQUFTbkIsWUFBVCxDQUF1QnRxQixHQUF2QixFQUE0QjtBQUMxQixNQUFJcXZCLFlBQVksRUFBaEI7QUFDQSxPQUFLLElBQUk3eEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJd2lCLElBQUl2aUIsTUFBeEIsRUFBZ0MsRUFBRUQsQ0FBbEMsRUFBcUM7QUFDbkM7QUFDQTZ4QyxjQUFVL3dDLElBQVYsQ0FBZTBoQixJQUFJSCxVQUFKLENBQWVyaUIsQ0FBZixJQUFvQixJQUFuQztBQUNEO0FBQ0QsU0FBTzZ4QyxTQUFQO0FBQ0Q7O0FBRUQsU0FBUzNFLGNBQVQsQ0FBeUIxcUIsR0FBekIsRUFBOEJrdkIsS0FBOUIsRUFBcUM7QUFDbkMsTUFBSWx3QixDQUFKLEVBQU9zd0IsRUFBUCxFQUFXQyxFQUFYO0FBQ0EsTUFBSUYsWUFBWSxFQUFoQjtBQUNBLE9BQUssSUFBSTd4QyxJQUFJLENBQWIsRUFBZ0JBLElBQUl3aUIsSUFBSXZpQixNQUF4QixFQUFnQyxFQUFFRCxDQUFsQyxFQUFxQztBQUNuQyxRQUFJLENBQUMweEMsU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7O0FBRXRCbHdCLFFBQUlnQixJQUFJSCxVQUFKLENBQWVyaUIsQ0FBZixDQUFKO0FBQ0E4eEMsU0FBS3R3QixLQUFLLENBQVY7QUFDQXV3QixTQUFLdndCLElBQUksR0FBVDtBQUNBcXdCLGNBQVUvd0MsSUFBVixDQUFlaXhDLEVBQWY7QUFDQUYsY0FBVS93QyxJQUFWLENBQWVneEMsRUFBZjtBQUNEOztBQUVELFNBQU9ELFNBQVA7QUFDRDs7QUFFRCxTQUFTakgsYUFBVCxDQUF3QnBvQixHQUF4QixFQUE2QjtBQUMzQixTQUFPaWxCLE9BQU9qQixXQUFQLENBQW1CZ0wsWUFBWWh2QixHQUFaLENBQW5CLENBQVA7QUFDRDs7QUFFRCxTQUFTb3FCLFVBQVQsQ0FBcUJyakMsR0FBckIsRUFBMEJ5b0MsR0FBMUIsRUFBK0IvYyxNQUEvQixFQUF1Q2gxQixNQUF2QyxFQUErQztBQUM3QyxPQUFLLElBQUlELElBQUksQ0FBYixFQUFnQkEsSUFBSUMsTUFBcEIsRUFBNEIsRUFBRUQsQ0FBOUIsRUFBaUM7QUFDL0IsUUFBS0EsSUFBSWkxQixNQUFKLElBQWMrYyxJQUFJL3hDLE1BQW5CLElBQStCRCxLQUFLdUosSUFBSXRKLE1BQTVDLEVBQXFEO0FBQ3JEK3hDLFFBQUloeUMsSUFBSWkxQixNQUFSLElBQWtCMXJCLElBQUl2SixDQUFKLENBQWxCO0FBQ0Q7QUFDRCxTQUFPQSxDQUFQO0FBQ0Q7O0FBRUQsU0FBU2lxQyxLQUFULENBQWdCdGUsR0FBaEIsRUFBcUI7QUFDbkIsU0FBT0EsUUFBUUEsR0FBZixDQURtQixDQUNBO0FBQ3BCLEM7Ozs7Ozs7Ozs7QUM1dkREOzs7O0FBSUE7QUFDQWp0QixPQUFPQyxPQUFQLEdBQWlCLFVBQVNzekMsWUFBVCxFQUF1QjtBQUN2QyxLQUFJaHZDLE9BQU8sRUFBWDs7QUFFQTtBQUNBQSxNQUFLb0MsUUFBTCxHQUFnQixTQUFTQSxRQUFULEdBQW9CO0FBQ25DLFNBQU8sS0FBSzRJLEdBQUwsQ0FBUyxVQUFVOFEsSUFBVixFQUFnQjtBQUMvQixPQUFJcFAsVUFBVXVpQyx1QkFBdUJuekIsSUFBdkIsRUFBNkJrekIsWUFBN0IsQ0FBZDtBQUNBLE9BQUdsekIsS0FBSyxDQUFMLENBQUgsRUFBWTtBQUNYLFdBQU8sWUFBWUEsS0FBSyxDQUFMLENBQVosR0FBc0IsR0FBdEIsR0FBNEJwUCxPQUE1QixHQUFzQyxHQUE3QztBQUNBLElBRkQsTUFFTztBQUNOLFdBQU9BLE9BQVA7QUFDQTtBQUNELEdBUE0sRUFPSnpPLElBUEksQ0FPQyxFQVBELENBQVA7QUFRQSxFQVREOztBQVdBO0FBQ0ErQixNQUFLakQsQ0FBTCxHQUFTLFVBQVNteUMsT0FBVCxFQUFrQkMsVUFBbEIsRUFBOEI7QUFDdEMsTUFBRyxPQUFPRCxPQUFQLEtBQW1CLFFBQXRCLEVBQ0NBLFVBQVUsQ0FBQyxDQUFDLElBQUQsRUFBT0EsT0FBUCxFQUFnQixFQUFoQixDQUFELENBQVY7QUFDRCxNQUFJRSx5QkFBeUIsRUFBN0I7QUFDQSxPQUFJLElBQUlyeUMsSUFBSSxDQUFaLEVBQWVBLElBQUksS0FBS0MsTUFBeEIsRUFBZ0NELEdBQWhDLEVBQXFDO0FBQ3BDLE9BQUlhLEtBQUssS0FBS2IsQ0FBTCxFQUFRLENBQVIsQ0FBVDtBQUNBLE9BQUcsT0FBT2EsRUFBUCxLQUFjLFFBQWpCLEVBQ0N3eEMsdUJBQXVCeHhDLEVBQXZCLElBQTZCLElBQTdCO0FBQ0Q7QUFDRCxPQUFJYixJQUFJLENBQVIsRUFBV0EsSUFBSW15QyxRQUFRbHlDLE1BQXZCLEVBQStCRCxHQUEvQixFQUFvQztBQUNuQyxPQUFJK2UsT0FBT296QixRQUFRbnlDLENBQVIsQ0FBWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBRyxPQUFPK2UsS0FBSyxDQUFMLENBQVAsS0FBbUIsUUFBbkIsSUFBK0IsQ0FBQ3N6Qix1QkFBdUJ0ekIsS0FBSyxDQUFMLENBQXZCLENBQW5DLEVBQW9FO0FBQ25FLFFBQUdxekIsY0FBYyxDQUFDcnpCLEtBQUssQ0FBTCxDQUFsQixFQUEyQjtBQUMxQkEsVUFBSyxDQUFMLElBQVVxekIsVUFBVjtBQUNBLEtBRkQsTUFFTyxJQUFHQSxVQUFILEVBQWU7QUFDckJyekIsVUFBSyxDQUFMLElBQVUsTUFBTUEsS0FBSyxDQUFMLENBQU4sR0FBZ0IsU0FBaEIsR0FBNEJxekIsVUFBNUIsR0FBeUMsR0FBbkQ7QUFDQTtBQUNEbnZDLFNBQUtuQyxJQUFMLENBQVVpZSxJQUFWO0FBQ0E7QUFDRDtBQUNELEVBeEJEO0FBeUJBLFFBQU85YixJQUFQO0FBQ0EsQ0ExQ0Q7O0FBNENBLFNBQVNpdkMsc0JBQVQsQ0FBZ0NuekIsSUFBaEMsRUFBc0NrekIsWUFBdEMsRUFBb0Q7QUFDbkQsS0FBSXRpQyxVQUFVb1AsS0FBSyxDQUFMLEtBQVcsRUFBekI7QUFDQSxLQUFJdXpCLGFBQWF2ekIsS0FBSyxDQUFMLENBQWpCO0FBQ0EsS0FBSSxDQUFDdXpCLFVBQUwsRUFBaUI7QUFDaEIsU0FBTzNpQyxPQUFQO0FBQ0E7O0FBRUQsS0FBSXNpQyxZQUFKLEVBQWtCO0FBQ2pCLE1BQUlNLGdCQUFnQkMsVUFBVUYsVUFBVixDQUFwQjtBQUNBLE1BQUlHLGFBQWFILFdBQVdweEIsT0FBWCxDQUFtQmpULEdBQW5CLENBQXVCLFVBQVVtRCxNQUFWLEVBQWtCO0FBQ3pELFVBQU8sbUJBQW1Ca2hDLFdBQVdJLFVBQTlCLEdBQTJDdGhDLE1BQTNDLEdBQW9ELEtBQTNEO0FBQ0EsR0FGZ0IsQ0FBakI7O0FBSUEsU0FBTyxDQUFDekIsT0FBRCxFQUFVN0IsTUFBVixDQUFpQjJrQyxVQUFqQixFQUE2QjNrQyxNQUE3QixDQUFvQyxDQUFDeWtDLGFBQUQsQ0FBcEMsRUFBcURyeEMsSUFBckQsQ0FBMEQsSUFBMUQsQ0FBUDtBQUNBOztBQUVELFFBQU8sQ0FBQ3lPLE9BQUQsRUFBVXpPLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDQTs7QUFFRDtBQUNBLFNBQVNzeEMsU0FBVCxDQUFtQkcsU0FBbkIsRUFBOEI7QUFDNUIsS0FBSWxMLFNBQVMsSUFBSUUsTUFBSixDQUFXM2dDLEtBQUtDLFNBQUwsQ0FBZTByQyxTQUFmLENBQVgsRUFBc0N0dEMsUUFBdEMsQ0FBK0MsUUFBL0MsQ0FBYjtBQUNBLEtBQUkwQixPQUFPLGlFQUFpRTBnQyxNQUE1RTs7QUFFQSxRQUFPLFNBQVMxZ0MsSUFBVCxHQUFnQixLQUF2QjtBQUNELEM7Ozs7Ozs7Ozs7QUMxRURwSSxRQUFReXRDLElBQVIsR0FBZSxVQUFVcEMsTUFBVixFQUFrQi9VLE1BQWxCLEVBQTBCMmQsSUFBMUIsRUFBZ0NDLElBQWhDLEVBQXNDQyxNQUF0QyxFQUE4QztBQUMzRCxNQUFJdDBDLENBQUosRUFBTzJELENBQVA7QUFDQSxNQUFJNHdDLE9BQU9ELFNBQVMsQ0FBVCxHQUFhRCxJQUFiLEdBQW9CLENBQS9CO0FBQ0EsTUFBSUcsT0FBTyxDQUFDLEtBQUtELElBQU4sSUFBYyxDQUF6QjtBQUNBLE1BQUlFLFFBQVFELFFBQVEsQ0FBcEI7QUFDQSxNQUFJRSxRQUFRLENBQUMsQ0FBYjtBQUNBLE1BQUlsekMsSUFBSTR5QyxPQUFRRSxTQUFTLENBQWpCLEdBQXNCLENBQTlCO0FBQ0EsTUFBSUssSUFBSVAsT0FBTyxDQUFDLENBQVIsR0FBWSxDQUFwQjtBQUNBLE1BQUloYSxJQUFJb1IsT0FBTy9VLFNBQVNqMUIsQ0FBaEIsQ0FBUjs7QUFFQUEsT0FBS216QyxDQUFMOztBQUVBMzBDLE1BQUlvNkIsSUFBSyxDQUFDLEtBQU0sQ0FBQ3NhLEtBQVIsSUFBa0IsQ0FBM0I7QUFDQXRhLFFBQU8sQ0FBQ3NhLEtBQVI7QUFDQUEsV0FBU0gsSUFBVDtBQUNBLFNBQU9HLFFBQVEsQ0FBZixFQUFrQjEwQyxJQUFJQSxJQUFJLEdBQUosR0FBVXdyQyxPQUFPL1UsU0FBU2oxQixDQUFoQixDQUFkLEVBQWtDQSxLQUFLbXpDLENBQXZDLEVBQTBDRCxTQUFTLENBQXJFLEVBQXdFLENBQUU7O0FBRTFFL3dDLE1BQUkzRCxJQUFLLENBQUMsS0FBTSxDQUFDMDBDLEtBQVIsSUFBa0IsQ0FBM0I7QUFDQTEwQyxRQUFPLENBQUMwMEMsS0FBUjtBQUNBQSxXQUFTTCxJQUFUO0FBQ0EsU0FBT0ssUUFBUSxDQUFmLEVBQWtCL3dDLElBQUlBLElBQUksR0FBSixHQUFVNm5DLE9BQU8vVSxTQUFTajFCLENBQWhCLENBQWQsRUFBa0NBLEtBQUttekMsQ0FBdkMsRUFBMENELFNBQVMsQ0FBckUsRUFBd0UsQ0FBRTs7QUFFMUUsTUFBSTEwQyxNQUFNLENBQVYsRUFBYTtBQUNYQSxRQUFJLElBQUl5MEMsS0FBUjtBQUNELEdBRkQsTUFFTyxJQUFJejBDLE1BQU13MEMsSUFBVixFQUFnQjtBQUNyQixXQUFPN3dDLElBQUlpeEMsR0FBSixHQUFXLENBQUN4YSxJQUFJLENBQUMsQ0FBTCxHQUFTLENBQVYsSUFBZStZLFFBQWpDO0FBQ0QsR0FGTSxNQUVBO0FBQ0x4dkMsUUFBSUEsSUFBSTJHLEtBQUtpbUMsR0FBTCxDQUFTLENBQVQsRUFBWThELElBQVosQ0FBUjtBQUNBcjBDLFFBQUlBLElBQUl5MEMsS0FBUjtBQUNEO0FBQ0QsU0FBTyxDQUFDcmEsSUFBSSxDQUFDLENBQUwsR0FBUyxDQUFWLElBQWV6MkIsQ0FBZixHQUFtQjJHLEtBQUtpbUMsR0FBTCxDQUFTLENBQVQsRUFBWXZ3QyxJQUFJcTBDLElBQWhCLENBQTFCO0FBQ0QsQ0EvQkQ7O0FBaUNBbDBDLFFBQVFnckMsS0FBUixHQUFnQixVQUFVSyxNQUFWLEVBQWtCcHBDLEtBQWxCLEVBQXlCcTBCLE1BQXpCLEVBQWlDMmQsSUFBakMsRUFBdUNDLElBQXZDLEVBQTZDQyxNQUE3QyxFQUFxRDtBQUNuRSxNQUFJdDBDLENBQUosRUFBTzJELENBQVAsRUFBVXFmLENBQVY7QUFDQSxNQUFJdXhCLE9BQU9ELFNBQVMsQ0FBVCxHQUFhRCxJQUFiLEdBQW9CLENBQS9CO0FBQ0EsTUFBSUcsT0FBTyxDQUFDLEtBQUtELElBQU4sSUFBYyxDQUF6QjtBQUNBLE1BQUlFLFFBQVFELFFBQVEsQ0FBcEI7QUFDQSxNQUFJSyxLQUFNUixTQUFTLEVBQVQsR0FBYy9wQyxLQUFLaW1DLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQyxFQUFiLElBQW1Cam1DLEtBQUtpbUMsR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDLEVBQWIsQ0FBakMsR0FBb0QsQ0FBOUQ7QUFDQSxNQUFJL3VDLElBQUk0eUMsT0FBTyxDQUFQLEdBQVlFLFNBQVMsQ0FBN0I7QUFDQSxNQUFJSyxJQUFJUCxPQUFPLENBQVAsR0FBVyxDQUFDLENBQXBCO0FBQ0EsTUFBSWhhLElBQUloNEIsUUFBUSxDQUFSLElBQWNBLFVBQVUsQ0FBVixJQUFlLElBQUlBLEtBQUosR0FBWSxDQUF6QyxHQUE4QyxDQUE5QyxHQUFrRCxDQUExRDs7QUFFQUEsVUFBUWtJLEtBQUtzRyxHQUFMLENBQVN4TyxLQUFULENBQVI7O0FBRUEsTUFBSWdVLE1BQU1oVSxLQUFOLEtBQWdCQSxVQUFVK3dDLFFBQTlCLEVBQXdDO0FBQ3RDeHZDLFFBQUl5UyxNQUFNaFUsS0FBTixJQUFlLENBQWYsR0FBbUIsQ0FBdkI7QUFDQXBDLFFBQUl3MEMsSUFBSjtBQUNELEdBSEQsTUFHTztBQUNMeDBDLFFBQUlzSyxLQUFLMjZCLEtBQUwsQ0FBVzM2QixLQUFLb1gsR0FBTCxDQUFTdGYsS0FBVCxJQUFrQmtJLEtBQUt3cUMsR0FBbEMsQ0FBSjtBQUNBLFFBQUkxeUMsU0FBUzRnQixJQUFJMVksS0FBS2ltQyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUN2d0MsQ0FBYixDQUFiLElBQWdDLENBQXBDLEVBQXVDO0FBQ3JDQTtBQUNBZ2pCLFdBQUssQ0FBTDtBQUNEO0FBQ0QsUUFBSWhqQixJQUFJeTBDLEtBQUosSUFBYSxDQUFqQixFQUFvQjtBQUNsQnJ5QyxlQUFTeXlDLEtBQUs3eEIsQ0FBZDtBQUNELEtBRkQsTUFFTztBQUNMNWdCLGVBQVN5eUMsS0FBS3ZxQyxLQUFLaW1DLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSWtFLEtBQWhCLENBQWQ7QUFDRDtBQUNELFFBQUlyeUMsUUFBUTRnQixDQUFSLElBQWEsQ0FBakIsRUFBb0I7QUFDbEJoakI7QUFDQWdqQixXQUFLLENBQUw7QUFDRDs7QUFFRCxRQUFJaGpCLElBQUl5MEMsS0FBSixJQUFhRCxJQUFqQixFQUF1QjtBQUNyQjd3QyxVQUFJLENBQUo7QUFDQTNELFVBQUl3MEMsSUFBSjtBQUNELEtBSEQsTUFHTyxJQUFJeDBDLElBQUl5MEMsS0FBSixJQUFhLENBQWpCLEVBQW9CO0FBQ3pCOXdDLFVBQUksQ0FBQ3ZCLFFBQVE0Z0IsQ0FBUixHQUFZLENBQWIsSUFBa0IxWSxLQUFLaW1DLEdBQUwsQ0FBUyxDQUFULEVBQVk4RCxJQUFaLENBQXRCO0FBQ0FyMEMsVUFBSUEsSUFBSXkwQyxLQUFSO0FBQ0QsS0FITSxNQUdBO0FBQ0w5d0MsVUFBSXZCLFFBQVFrSSxLQUFLaW1DLEdBQUwsQ0FBUyxDQUFULEVBQVlrRSxRQUFRLENBQXBCLENBQVIsR0FBaUNucUMsS0FBS2ltQyxHQUFMLENBQVMsQ0FBVCxFQUFZOEQsSUFBWixDQUFyQztBQUNBcjBDLFVBQUksQ0FBSjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT3EwQyxRQUFRLENBQWYsRUFBa0I3SSxPQUFPL1UsU0FBU2oxQixDQUFoQixJQUFxQm1DLElBQUksSUFBekIsRUFBK0JuQyxLQUFLbXpDLENBQXBDLEVBQXVDaHhDLEtBQUssR0FBNUMsRUFBaUQwd0MsUUFBUSxDQUEzRSxFQUE4RSxDQUFFOztBQUVoRnIwQyxNQUFLQSxLQUFLcTBDLElBQU4sR0FBYzF3QyxDQUFsQjtBQUNBNHdDLFVBQVFGLElBQVI7QUFDQSxTQUFPRSxPQUFPLENBQWQsRUFBaUIvSSxPQUFPL1UsU0FBU2oxQixDQUFoQixJQUFxQnhCLElBQUksSUFBekIsRUFBK0J3QixLQUFLbXpDLENBQXBDLEVBQXVDMzBDLEtBQUssR0FBNUMsRUFBaUR1MEMsUUFBUSxDQUExRSxFQUE2RSxDQUFFOztBQUUvRS9JLFNBQU8vVSxTQUFTajFCLENBQVQsR0FBYW16QyxDQUFwQixLQUEwQnZhLElBQUksR0FBOUI7QUFDRCxDQWxERCxDOzs7Ozs7Ozs7QUNqQ0EsSUFBSXZ6QixXQUFXLEdBQUdBLFFBQWxCOztBQUVBM0csT0FBT0MsT0FBUCxHQUFpQmtCLE1BQU1DLE9BQU4sSUFBaUIsVUFBVTR0QixHQUFWLEVBQWU7QUFDL0MsU0FBT3JvQixTQUFTOUQsSUFBVCxDQUFjbXNCLEdBQWQsS0FBc0IsZ0JBQTdCO0FBQ0QsQ0FGRCxDOzs7Ozs7Ozs7QUNEQTs7Ozs7Ozs7Ozs7OztBQWFBaHZCLE9BQU9DLE9BQVAsR0FBaUIsVUFBVTQwQyxHQUFWLEVBQWU7QUFDOUI7QUFDQSxLQUFJaitCLFdBQVcsT0FBTzdXLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE9BQU82VyxRQUF2RDs7QUFFQSxLQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNiLFFBQU0sSUFBSTFULEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0Q7O0FBRUY7QUFDQSxLQUFJLENBQUMyeEMsR0FBRCxJQUFRLE9BQU9BLEdBQVAsS0FBZSxRQUEzQixFQUFxQztBQUNuQyxTQUFPQSxHQUFQO0FBQ0E7O0FBRUQsS0FBSUMsVUFBVWwrQixTQUFTa2IsUUFBVCxHQUFvQixJQUFwQixHQUEyQmxiLFNBQVNzc0IsSUFBbEQ7QUFDQSxLQUFJNlIsYUFBYUQsVUFBVWwrQixTQUFTZ0MsUUFBVCxDQUFrQnRXLE9BQWxCLENBQTBCLFdBQTFCLEVBQXVDLEdBQXZDLENBQTNCOztBQUVEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLEtBQUkweUMsV0FBV0gsSUFBSXZ5QyxPQUFKLENBQVkscURBQVosRUFBbUUsVUFBUzJ5QyxTQUFULEVBQW9CQyxPQUFwQixFQUE2QjtBQUM5RztBQUNBLE1BQUlDLGtCQUFrQkQsUUFDcEJsd0IsSUFEb0IsR0FFcEIxaUIsT0FGb0IsQ0FFWixVQUZZLEVBRUEsVUFBU2tOLENBQVQsRUFBWTRsQyxFQUFaLEVBQWU7QUFBRSxVQUFPQSxFQUFQO0FBQVksR0FGN0IsRUFHcEI5eUMsT0FIb0IsQ0FHWixVQUhZLEVBR0EsVUFBU2tOLENBQVQsRUFBWTRsQyxFQUFaLEVBQWU7QUFBRSxVQUFPQSxFQUFQO0FBQVksR0FIN0IsQ0FBdEI7O0FBS0E7QUFDQSxNQUFJLCtDQUErQ3ZyQyxJQUEvQyxDQUFvRHNyQyxlQUFwRCxDQUFKLEVBQTBFO0FBQ3hFLFVBQU9GLFNBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUlJLE1BQUo7O0FBRUEsTUFBSUYsZ0JBQWdCL3BDLE9BQWhCLENBQXdCLElBQXhCLE1BQWtDLENBQXRDLEVBQXlDO0FBQ3RDO0FBQ0ZpcUMsWUFBU0YsZUFBVDtBQUNBLEdBSEQsTUFHTyxJQUFJQSxnQkFBZ0IvcEMsT0FBaEIsQ0FBd0IsR0FBeEIsTUFBaUMsQ0FBckMsRUFBd0M7QUFDOUM7QUFDQWlxQyxZQUFTUCxVQUFVSyxlQUFuQixDQUY4QyxDQUVWO0FBQ3BDLEdBSE0sTUFHQTtBQUNOO0FBQ0FFLFlBQVNOLGFBQWFJLGdCQUFnQjd5QyxPQUFoQixDQUF3QixPQUF4QixFQUFpQyxFQUFqQyxDQUF0QixDQUZNLENBRXNEO0FBQzVEOztBQUVEO0FBQ0EsU0FBTyxTQUFTZ0csS0FBS0MsU0FBTCxDQUFlOHNDLE1BQWYsQ0FBVCxHQUFrQyxHQUF6QztBQUNBLEVBNUJjLENBQWY7O0FBOEJBO0FBQ0EsUUFBT0wsUUFBUDtBQUNBLENBMUVELEM7Ozs7OztBQ2RBO0FBQ0E7OztBQUdBO0FBQ0Esa0RBQW1ELG1CQUFtQixrREFBa0QsYUFBYSxjQUFjLGlCQUFpQix5QkFBeUIsV0FBVyxlQUFlLGtCQUFrQix5QkFBeUIsV0FBVyxlQUFlLGtCQUFrQjs7QUFFOVM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqU0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYjcxZGUzNTcxNjViYWE4MTcwZjUiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgdW5kZWZpbmVkKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIHVuZGVmaW5lZCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSkgcmV0dXJuXG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCBcIlwiKVxuXHRcdFx0XHRlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXkyLCB2YWx1ZSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0TGF0ZUF0dHJzKHZub2RlKSB7XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwidmFsdWVcIiwgbnVsbCwgYXR0cnMyLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMyLnNlbGVjdGVkSW5kZXgsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cnModm5vZGUsIG9sZCwgYXR0cnMyLCBucykge1xuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5Miwgb2xkICYmIG9sZFtrZXkyXSwgYXR0cnMyW2tleTJdLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRpZiAoYXR0cnMyID09IG51bGwgfHwgIShrZXkyIGluIGF0dHJzMikpIHtcblx0XHRcdFx0XHRpZiAoa2V5MiA9PT0gXCJjbGFzc05hbWVcIikga2V5MiA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZWxzZSBpZiAoa2V5MiAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXHQvL3N0eWxlXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgc3R5bGUpIHtcblx0XHRpZiAob2xkID09PSBzdHlsZSkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIiwgb2xkID0gbnVsbFxuXHRcdGlmIChzdHlsZSA9PSBudWxsKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0ZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGQgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRcdGZvciAodmFyIGtleTIgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXkyXSA9IHN0eWxlW2tleTJdXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkICE9IG51bGwgJiYgdHlwZW9mIG9sZCAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleTIgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleTJdID0gXCJcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkyIGluIGVsZW1lbnQpIGVsZW1lbnRba2V5Ml0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleTIuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gPT09IGNhbGxiYWNrKSByZXR1cm5cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5Ml0gPSBjYWxsYmFja1xuXHRcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyKGRvbSwgdm5vZGVzKSB7XG5cdFx0aWYgKCFkb20pIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKVxuXHRcdHZhciBob29rcyA9IFtdXG5cdFx0dmFyIGFjdGl2ZSA9ICRkb2MuYWN0aXZlRWxlbWVudFxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCB1bmRlZmluZWQpXG5cdFx0ZG9tLnZub2RlcyA9IHZub2Rlc1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIGhvb2tzW2ldKClcblx0XHRpZiAoJGRvYy5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpXG5cdH1cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0RXZlbnRDYWxsYmFjazogc2V0RXZlbnRDYWxsYmFja31cbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrKSB7XG5cdC8vNjBmcHMgdHJhbnNsYXRlcyB0byAxNi42bXMsIHJvdW5kIGl0IGRvd24gc2luY2Ugc2V0VGltZW91dCByZXF1aXJlcyBpbnRcblx0dmFyIHRpbWUgPSAxNlxuXHR2YXIgbGFzdCA9IDAsIHBlbmRpbmcgPSBudWxsXG5cdHZhciB0aW1lb3V0ID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dFxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KClcblx0XHRpZiAobGFzdCA9PT0gMCB8fCBub3cgLSBsYXN0ID49IHRpbWUpIHtcblx0XHRcdGxhc3QgPSBub3dcblx0XHRcdGNhbGxiYWNrKClcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuXHRcdFx0cGVuZGluZyA9IHRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrKClcblx0XHRcdFx0bGFzdCA9IERhdGUubm93KClcblx0XHRcdH0sIHRpbWUgLSAobm93IC0gbGFzdCkpXG5cdFx0fVxuXHR9XG59XG52YXIgXzExID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgcmVuZGVyU2VydmljZSA9IGNvcmVSZW5kZXJlcigkd2luZG93KVxuXHRyZW5kZXJTZXJ2aWNlLnNldEV2ZW50Q2FsbGJhY2soZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLnJlZHJhdyAhPT0gZmFsc2UpIHJlZHJhdygpXG5cdH0pXG5cdHZhciBjYWxsYmFja3MgPSBbXVxuXHRmdW5jdGlvbiBzdWJzY3JpYmUoa2V5MSwgY2FsbGJhY2spIHtcblx0XHR1bnN1YnNjcmliZShrZXkxKVxuXHRcdGNhbGxiYWNrcy5wdXNoKGtleTEsIHRocm90dGxlKGNhbGxiYWNrKSlcblx0fVxuXHRmdW5jdGlvbiB1bnN1YnNjcmliZShrZXkxKSB7XG5cdFx0dmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2Yoa2V5MSlcblx0XHRpZiAoaW5kZXggPiAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMilcblx0fVxuXHRmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdGNhbGxiYWNrc1tpXSgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiB7c3Vic2NyaWJlOiBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSwgcmVkcmF3OiByZWRyYXcsIHJlbmRlcjogcmVuZGVyU2VydmljZS5yZW5kZXJ9XG59XG52YXIgcmVkcmF3U2VydmljZSA9IF8xMSh3aW5kb3cpXG5yZXF1ZXN0U2VydmljZS5zZXRDb21wbGV0aW9uQ2FsbGJhY2socmVkcmF3U2VydmljZS5yZWRyYXcpXG52YXIgXzE2ID0gZnVuY3Rpb24ocmVkcmF3U2VydmljZTApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudCkge1xuXHRcdGlmIChjb21wb25lbnQgPT09IG51bGwpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBbXSlcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnVuc3Vic2NyaWJlKHJvb3QpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNvbXBvbmVudC52aWV3ID09IG51bGwgJiYgdHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJtLm1vdW50KGVsZW1lbnQsIGNvbXBvbmVudCkgZXhwZWN0cyBhIGNvbXBvbmVudCwgbm90IGEgdm5vZGVcIilcblx0XHRcblx0XHR2YXIgcnVuMCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFZub2RlKGNvbXBvbmVudCkpXG5cdFx0fVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4wKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnJlZHJhdygpXG5cdH1cbn1cbm0ubW91bnQgPSBfMTYocmVkcmF3U2VydmljZSlcbnZhciBQcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG52YXIgcGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRpZiAoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PSBudWxsKSByZXR1cm4ge31cblx0aWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSlcblx0dmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCImXCIpLCBkYXRhMCA9IHt9LCBjb3VudGVycyA9IHt9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IGVudHJpZXNbaV0uc3BsaXQoXCI9XCIpXG5cdFx0dmFyIGtleTUgPSBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMF0pXG5cdFx0dmFyIHZhbHVlID0gZW50cnkubGVuZ3RoID09PSAyID8gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzFdKSA6IFwiXCJcblx0XHRpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWVcblx0XHRlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB2YWx1ZSA9IGZhbHNlXG5cdFx0dmFyIGxldmVscyA9IGtleTUuc3BsaXQoL1xcXVxcWz98XFxbLylcblx0XHR2YXIgY3Vyc29yID0gZGF0YTBcblx0XHRpZiAoa2V5NS5pbmRleE9mKFwiW1wiKSA+IC0xKSBsZXZlbHMucG9wKClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzW2pdLCBuZXh0TGV2ZWwgPSBsZXZlbHNbaiArIDFdXG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBuZXh0TGV2ZWwgPT0gXCJcIiB8fCAhaXNOYU4ocGFyc2VJbnQobmV4dExldmVsLCAxMCkpXG5cdFx0XHR2YXIgaXNWYWx1ZSA9IGogPT09IGxldmVscy5sZW5ndGggLSAxXG5cdFx0XHRpZiAobGV2ZWwgPT09IFwiXCIpIHtcblx0XHRcdFx0dmFyIGtleTUgPSBsZXZlbHMuc2xpY2UoMCwgaikuam9pbigpXG5cdFx0XHRcdGlmIChjb3VudGVyc1trZXk1XSA9PSBudWxsKSBjb3VudGVyc1trZXk1XSA9IDBcblx0XHRcdFx0bGV2ZWwgPSBjb3VudGVyc1trZXk1XSsrXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3Vyc29yW2xldmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdGN1cnNvcltsZXZlbF0gPSBpc1ZhbHVlID8gdmFsdWUgOiBpc051bWJlciA/IFtdIDoge31cblx0XHRcdH1cblx0XHRcdGN1cnNvciA9IGN1cnNvcltsZXZlbF1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGEwXG59XG52YXIgY29yZVJvdXRlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gdHlwZW9mICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPT09IFwiZnVuY3Rpb25cIlxuXHR2YXIgY2FsbEFzeW5jMCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gbm9ybWFsaXplMShmcmFnbWVudDApIHtcblx0XHR2YXIgZGF0YSA9ICR3aW5kb3cubG9jYXRpb25bZnJhZ21lbnQwXS5yZXBsYWNlKC8oPzolW2EtZjg5XVthLWYwLTldKSsvZ2ltLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0aWYgKGZyYWdtZW50MCA9PT0gXCJwYXRobmFtZVwiICYmIGRhdGFbMF0gIT09IFwiL1wiKSBkYXRhID0gXCIvXCIgKyBkYXRhXG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHR2YXIgYXN5bmNJZFxuXHRmdW5jdGlvbiBkZWJvdW5jZUFzeW5jKGNhbGxiYWNrMCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChhc3luY0lkICE9IG51bGwpIHJldHVyblxuXHRcdFx0YXN5bmNJZCA9IGNhbGxBc3luYzAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFzeW5jSWQgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrMCgpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSkge1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKVxuXHRcdHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpXG5cdFx0dmFyIHBhdGhFbmQgPSBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRcdHZhciBxdWVyeVBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSwgcXVlcnlFbmQpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBxdWVyeVBhcmFtcykgcXVlcnlEYXRhW2tleTRdID0gcXVlcnlQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0aWYgKGhhc2hJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgaGFzaFBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShoYXNoSW5kZXggKyAxKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gaGFzaFBhcmFtcykgaGFzaERhdGFba2V5NF0gPSBoYXNoUGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdHJldHVybiBwYXRoLnNsaWNlKDAsIHBhdGhFbmQpXG5cdH1cblx0dmFyIHJvdXRlciA9IHtwcmVmaXg6IFwiIyFcIn1cblx0cm91dGVyLmdldFBhdGggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZTIgPSByb3V0ZXIucHJlZml4LmNoYXJBdCgwKVxuXHRcdHN3aXRjaCAodHlwZTIpIHtcblx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBub3JtYWxpemUxKFwiaGFzaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aClcblx0XHRcdGNhc2UgXCI/XCI6IHJldHVybiBub3JtYWxpemUxKFwic2VhcmNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gbm9ybWFsaXplMShcInBhdGhuYW1lXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdH1cblx0fVxuXHRyb3V0ZXIuc2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHR2YXIgcXVlcnlEYXRhID0ge30sIGhhc2hEYXRhID0ge31cblx0XHRwYXRoID0gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpXG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBkYXRhKSBxdWVyeURhdGFba2V5NF0gPSBkYXRhW2tleTRdXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXSspL2csIGZ1bmN0aW9uKG1hdGNoMiwgdG9rZW4pIHtcblx0XHRcdFx0ZGVsZXRlIHF1ZXJ5RGF0YVt0b2tlbl1cblx0XHRcdFx0cmV0dXJuIGRhdGFbdG9rZW5dXG5cdFx0XHR9KVxuXHRcdH1cblx0XHR2YXIgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKHF1ZXJ5RGF0YSlcblx0XHRpZiAocXVlcnkpIHBhdGggKz0gXCI/XCIgKyBxdWVyeVxuXHRcdHZhciBoYXNoID0gYnVpbGRRdWVyeVN0cmluZyhoYXNoRGF0YSlcblx0XHRpZiAoaGFzaCkgcGF0aCArPSBcIiNcIiArIGhhc2hcblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnN0YXRlIDogbnVsbFxuXHRcdFx0dmFyIHRpdGxlID0gb3B0aW9ucyA/IG9wdGlvbnMudGl0bGUgOiBudWxsXG5cdFx0XHQkd2luZG93Lm9ucG9wc3RhdGUoKVxuXHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0XHRlbHNlICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHR9XG5cdFx0ZWxzZSAkd2luZG93LmxvY2F0aW9uLmhyZWYgPSByb3V0ZXIucHJlZml4ICsgcGF0aFxuXHR9XG5cdHJvdXRlci5kZWZpbmVSb3V0ZXMgPSBmdW5jdGlvbihyb3V0ZXMsIHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZ1bmN0aW9uIHJlc29sdmVSb3V0ZSgpIHtcblx0XHRcdHZhciBwYXRoID0gcm91dGVyLmdldFBhdGgoKVxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9XG5cdFx0XHR2YXIgcGF0aG5hbWUgPSBwYXJzZVBhdGgocGF0aCwgcGFyYW1zLCBwYXJhbXMpXG5cdFx0XHR2YXIgc3RhdGUgPSAkd2luZG93Lmhpc3Rvcnkuc3RhdGVcblx0XHRcdGlmIChzdGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGsgaW4gc3RhdGUpIHBhcmFtc1trXSA9IHN0YXRlW2tdXG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciByb3V0ZTAgaW4gcm91dGVzKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChcIl5cIiArIHJvdXRlMC5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZywgXCIoLio/KVwiKS5yZXBsYWNlKC86W15cXC9dKy9nLCBcIihbXlxcXFwvXSspXCIpICsgXCJcXC8/JFwiKVxuXHRcdFx0XHRpZiAobWF0Y2hlci50ZXN0KHBhdGhuYW1lKSkge1xuXHRcdFx0XHRcdHBhdGhuYW1lLnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5cyA9IHJvdXRlMC5tYXRjaCgvOlteXFwvXSsvZykgfHwgW11cblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTIpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zW2tleXNbaV0ucmVwbGFjZSgvOnxcXC4vZywgXCJcIildID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpXSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc29sdmUocm91dGVzW3JvdXRlMF0sIHBhcmFtcywgcGF0aCwgcm91dGUwKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlamVjdChwYXRoLCBwYXJhbXMpXG5cdFx0fVxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkgJHdpbmRvdy5vbnBvcHN0YXRlID0gZGVib3VuY2VBc3luYyhyZXNvbHZlUm91dGUpXG5cdFx0ZWxzZSBpZiAocm91dGVyLnByZWZpeC5jaGFyQXQoMCkgPT09IFwiI1wiKSAkd2luZG93Lm9uaGFzaGNoYW5nZSA9IHJlc29sdmVSb3V0ZVxuXHRcdHJlc29sdmVSb3V0ZSgpXG5cdH1cblx0cmV0dXJuIHJvdXRlclxufVxudmFyIF8yMCA9IGZ1bmN0aW9uKCR3aW5kb3csIHJlZHJhd1NlcnZpY2UwKSB7XG5cdHZhciByb3V0ZVNlcnZpY2UgPSBjb3JlUm91dGVyKCR3aW5kb3cpXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHYpIHtyZXR1cm4gdn1cblx0dmFyIHJlbmRlcjEsIGNvbXBvbmVudCwgYXR0cnMzLCBjdXJyZW50UGF0aCwgbGFzdFVwZGF0ZVxuXHR2YXIgcm91dGUgPSBmdW5jdGlvbihyb290LCBkZWZhdWx0Um91dGUsIHJvdXRlcykge1xuXHRcdGlmIChyb290ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIGBtLnJvdXRlYCBpcyBub3QgdW5kZWZpbmVkXCIpXG5cdFx0dmFyIHJ1bjEgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZW5kZXIxICE9IG51bGwpIHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCByZW5kZXIxKFZub2RlKGNvbXBvbmVudCwgYXR0cnMzLmtleSwgYXR0cnMzKSkpXG5cdFx0fVxuXHRcdHZhciBiYWlsID0gZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0aWYgKHBhdGggIT09IGRlZmF1bHRSb3V0ZSkgcm91dGVTZXJ2aWNlLnNldFBhdGgoZGVmYXVsdFJvdXRlLCBudWxsLCB7cmVwbGFjZTogdHJ1ZX0pXG5cdFx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGRlZmF1bHQgcm91dGUgXCIgKyBkZWZhdWx0Um91dGUpXG5cdFx0fVxuXHRcdHJvdXRlU2VydmljZS5kZWZpbmVSb3V0ZXMocm91dGVzLCBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIHBhdGgpIHtcblx0XHRcdHZhciB1cGRhdGUgPSBsYXN0VXBkYXRlID0gZnVuY3Rpb24ocm91dGVSZXNvbHZlciwgY29tcCkge1xuXHRcdFx0XHRpZiAodXBkYXRlICE9PSBsYXN0VXBkYXRlKSByZXR1cm5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcCAhPSBudWxsICYmICh0eXBlb2YgY29tcC52aWV3ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNvbXAgPT09IFwiZnVuY3Rpb25cIik/IGNvbXAgOiBcImRpdlwiXG5cdFx0XHRcdGF0dHJzMyA9IHBhcmFtcywgY3VycmVudFBhdGggPSBwYXRoLCBsYXN0VXBkYXRlID0gbnVsbFxuXHRcdFx0XHRyZW5kZXIxID0gKHJvdXRlUmVzb2x2ZXIucmVuZGVyIHx8IGlkZW50aXR5KS5iaW5kKHJvdXRlUmVzb2x2ZXIpXG5cdFx0XHRcdHJ1bjEoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBheWxvYWQudmlldyB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGUoe30sIHBheWxvYWQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHBheWxvYWQub25tYXRjaCkge1xuXHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShwYXlsb2FkLm9ubWF0Y2gocGFyYW1zLCBwYXRoKSkudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKHBheWxvYWQsIHJlc29sdmVkKVxuXHRcdFx0XHRcdH0sIGJhaWwpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB1cGRhdGUocGF5bG9hZCwgXCJkaXZcIilcblx0XHRcdH1cblx0XHR9LCBiYWlsKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4xKVxuXHR9XG5cdHJvdXRlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRpZiAobGFzdFVwZGF0ZSAhPSBudWxsKSBvcHRpb25zID0ge3JlcGxhY2U6IHRydWV9XG5cdFx0bGFzdFVwZGF0ZSA9IG51bGxcblx0XHRyb3V0ZVNlcnZpY2Uuc2V0UGF0aChwYXRoLCBkYXRhLCBvcHRpb25zKVxuXHR9XG5cdHJvdXRlLmdldCA9IGZ1bmN0aW9uKCkge3JldHVybiBjdXJyZW50UGF0aH1cblx0cm91dGUucHJlZml4ID0gZnVuY3Rpb24ocHJlZml4MCkge3JvdXRlU2VydmljZS5wcmVmaXggPSBwcmVmaXgwfVxuXHRyb3V0ZS5saW5rID0gZnVuY3Rpb24odm5vZGUxKSB7XG5cdFx0dm5vZGUxLmRvbS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHJvdXRlU2VydmljZS5wcmVmaXggKyB2bm9kZTEuYXR0cnMuaHJlZilcblx0XHR2bm9kZTEuZG9tLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGUud2hpY2ggPT09IDIpIHJldHVyblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRlLnJlZHJhdyA9IGZhbHNlXG5cdFx0XHR2YXIgaHJlZiA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuXHRcdFx0aWYgKGhyZWYuaW5kZXhPZihyb3V0ZVNlcnZpY2UucHJlZml4KSA9PT0gMCkgaHJlZiA9IGhyZWYuc2xpY2Uocm91dGVTZXJ2aWNlLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRyb3V0ZS5zZXQoaHJlZiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdHJvdXRlLnBhcmFtID0gZnVuY3Rpb24oa2V5Mykge1xuXHRcdGlmKHR5cGVvZiBhdHRyczMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGtleTMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBhdHRyczNba2V5M11cblx0XHRyZXR1cm4gYXR0cnMzXG5cdH1cblx0cmV0dXJuIHJvdXRlXG59XG5tLnJvdXRlID0gXzIwKHdpbmRvdywgcmVkcmF3U2VydmljZSlcbm0ud2l0aEF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSwgY2FsbGJhY2sxLCBjb250ZXh0KSB7XG5cdHJldHVybiBmdW5jdGlvbihlKSB7XG5cdFx0Y2FsbGJhY2sxLmNhbGwoY29udGV4dCB8fCB0aGlzLCBhdHRyTmFtZSBpbiBlLmN1cnJlbnRUYXJnZXQgPyBlLmN1cnJlbnRUYXJnZXRbYXR0ck5hbWVdIDogZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpXG5cdH1cbn1cbnZhciBfMjggPSBjb3JlUmVuZGVyZXIod2luZG93KVxubS5yZW5kZXIgPSBfMjgucmVuZGVyXG5tLnJlZHJhdyA9IHJlZHJhd1NlcnZpY2UucmVkcmF3XG5tLnJlcXVlc3QgPSByZXF1ZXN0U2VydmljZS5yZXF1ZXN0XG5tLmpzb25wID0gcmVxdWVzdFNlcnZpY2UuanNvbnBcbm0ucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmdcbm0uYnVpbGRRdWVyeVN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmdcbm0udmVyc2lvbiA9IFwiMS4xLjFcIlxubS52bm9kZSA9IFZub2RlXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IG1cbmVsc2Ugd2luZG93Lm0gPSBtXG59KCkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWl0aHJpbC9taXRocmlsLmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQuanMnXG5cbm0ubW91bnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKSwgQ29tcG9uZW50KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VudHJ5LmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vcHJvY2Vzcy9icm93c2VyLmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJ1xuaW1wb3J0IE1hcmtkb3duSXQgZnJvbSAnbWFya2Rvd24taXQnXG5pbXBvcnQgbW9kZWwgZnJvbSAnLi9tb2RlbC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5cbmNvbnN0IG1kID0gbmV3IE1hcmtkb3duSXQoKTtcblxuY29uc3QgQ2VsbCA9IHtcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17YG1kbC1jZWxsIG1kbC1jZWxsLS0ke3Zub2RlLmF0dHJzLnNwYW59LWNvbCAke3Zub2RlLmF0dHJzLmNscyB8fCAnJ31gfT5cbiAgICAgIHt2bm9kZS5hdHRycy5pbm5lcn1cbiAgICA8L2Rpdj5cbiAgfVxufTtcblxuY29uc3QgVGl0bGUgPSB7XG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBjb25zdCBtb2RlbCA9IHZub2RlLmF0dHJzLm1vZGVsO1xuICAgIGNvbnN0IGlubmVyID0gPGlucHV0IHR5cGU9J3RleHQnIGNsYXNzTmFtZT17c3R5bGVzLnRpdGxlfVxuICAgICAgb25jaGFuZ2U9e20ud2l0aEF0dHIoJ3ZhbHVlJywgdiA9PiBtb2RlbC5kYXRhLnRpdGxlID0gdil9XG4gICAgICB2YWx1ZT17bW9kZWwuZGF0YS50aXRsZX1cbiAgICAvPlxuICAgIHJldHVybiA8Q2VsbCBzcGFuPXsxMn0gaW5uZXI9e2lubmVyfSAvPlxuICB9XG59O1xuXG5jb25zdCBUYWdzID0ge1xuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgY29uc3QgbW9kZWwgPSB2bm9kZS5hdHRycy5tb2RlbDtcbiAgICBjb25zdCBpbm5lciA9IDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzc05hbWU9e3N0eWxlcy50YWdzfVxuICAgICAgb25jaGFuZ2U9e20ud2l0aEF0dHIoJ3ZhbHVlJywgdiA9PiBtb2RlbC5kYXRhLnRhZ3MgPSB2LnNwbGl0KCcsJykpfVxuICAgICAgdmFsdWU9e21vZGVsLmRhdGEudGFncy5qb2luKCcsJyl9XG4gICAgLz5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuY29uc3QgRWRpdG9yID0ge1xuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSA8ZGl2IGNvbnRlbnRFZGl0YWJsZT17dHJ1ZX0gb25pbnB1dD17KCkgPT4gY29uc29sZS5sb2coJ2lucHV0Jyl9PlxuICAgICAge3Zub2RlLmF0dHJzLm1vZGVsLmRhdGEuYm9keX1cbiAgICA8L2Rpdj5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17Nn0gY2xzPXtzdHlsZXMuZWRpdG9yfSBpbm5lcj17aW5uZXJ9IC8+XG4gIH1cbn07XG5cbmNvbnN0IFByZXZpZXcgPSB7XG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICByZXR1cm4gPENlbGwgc3Bhbj17Nn0gY2xzPXtzdHlsZXMucHJldmlld30gaW5uZXI9e1xuICAgICAgbS50cnVzdChtZC5yZW5kZXIodm5vZGUuYXR0cnMubW9kZWwuZGF0YS5ib2R5KSlcbiAgICB9IC8+XG4gIH1cbn07XG5cbmNvbnN0IFNhdmUgPSB7XG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBjb25zdCBtb2RlbCA9IHZub2RlLm1vZGVsO1xuICAgIGNvbnN0IGlubmVyID0gPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPSdtZGwtYnV0dG9uIG1kbC1qcy1idXR0b24gbWRsLWJ1dHRvbi0tcmFpc2VkIG1kbC1idXR0b24tLWNvbG9yZWQnXG4gICAgICBvbmNsaWNrPXttb2RlbC5zYXZlfT5cbiAgICAgIHNhdmVcbiAgICA8L2J1dHRvbj5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICBtb2RlbC5mZXRjaCgpO1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgaWYgKG1vZGVsLmZldGNoZWQpIHtcbiAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nbWRsLWdyaWQnPlxuICAgICAgICA8VGl0bGUgbW9kZWw9e21vZGVsfSAvPlxuICAgICAgICA8VGFncyBtb2RlbD17bW9kZWx9IC8+XG4gICAgICAgIDxFZGl0b3IgbW9kZWw9e21vZGVsfSAvPlxuICAgICAgICA8UHJldmlldyBtb2RlbD17bW9kZWx9IC8+XG4gICAgICAgIDxTYXZlIG1vZGVsPXttb2RlbH0gLz5cbiAgICAgIDwvZGl2PlxuICAgIH1cbiAgICByZXR1cm4gPGRpdj7jg4fjg7zjgr/lj5blvpfkuK0uLi48L2Rpdj5cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50LmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcblxuY29uc3QgdXJsID0gIGAvYXBpL2FydGljbGVzLyR7bG9jYXRpb24uaHJlZi5zcGxpdCgnLycpLnNsaWNlKDQpLmpvaW4oJy8nKX1gO1xuXG5jb25zdCBNb2RlbCA9IHtcbiAgZGF0YToge30sXG4gIGZldGNoZWQ6IGZhbHNlLFxuXG4gIGZldGNoOiAoKSA9PiB7XG4gICAgcmV0dXJuIG0ucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiB1cmwsXG4gICAgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBNb2RlbC5mZXRjaGVkID0gdHJ1ZTtcbiAgICAgIE1vZGVsLmRhdGEgPSByZXNwb25zZTtcbiAgICB9KTtcbiAgfSxcbiAgc2F2ZTogKCkgPT4ge1xuICAgIHJldHVybiBtLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6IHVybCxcbiAgICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIE1vZGVsLmRhdGEgPSByZXNwb25zZTtcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTW9kZWxcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21vZGVsLmpzIiwiLy8gVXRpbGl0aWVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbn1cblxuLy8gTWVyZ2Ugb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLy8gUmVtb3ZlIGVsZW1lbnQgZnJvbSBhcnJheSBhbmQgcHV0IGFub3RoZXIgYXJyYXkgYXQgdGhvc2UgcG9zaXRpb24uXG4vLyBVc2VmdWwgZm9yIHNvbWUgb3BlcmF0aW9ucyB3aXRoIHRva2Vuc1xuZnVuY3Rpb24gYXJyYXlSZXBsYWNlQXQoc3JjLCBwb3MsIG5ld0VsZW1lbnRzKSB7XG4gIHJldHVybiBbXS5jb25jYXQoc3JjLnNsaWNlKDAsIHBvcyksIG5ld0VsZW1lbnRzLCBzcmMuc2xpY2UocG9zICsgMSkpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRW50aXR5Q29kZShjKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIC8vIGJyb2tlbiBzZXF1ZW5jZVxuICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIC8vIG5ldmVyIHVzZWRcbiAgaWYgKGMgPj0gMHhGREQwICYmIGMgPD0gMHhGREVGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoKGMgJiAweEZGRkYpID09PSAweEZGRkYgfHwgKGMgJiAweEZGRkYpID09PSAweEZGRkUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIC8vIGNvbnRyb2wgY29kZXNcbiAgaWYgKGMgPj0gMHgwMCAmJiBjIDw9IDB4MDgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID09PSAweDBCKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDBFICYmIGMgPD0gMHgxRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPj0gMHg3RiAmJiBjIDw9IDB4OUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIC8vIG91dCBvZiByYW5nZVxuICBpZiAoYyA+IDB4MTBGRkZGKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIGlmIChjID4gMHhmZmZmKSB7XG4gICAgYyAtPSAweDEwMDAwO1xuICAgIHZhciBzdXJyb2dhdGUxID0gMHhkODAwICsgKGMgPj4gMTApLFxuICAgICAgICBzdXJyb2dhdGUyID0gMHhkYzAwICsgKGMgJiAweDNmZik7XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzdXJyb2dhdGUxLCBzdXJyb2dhdGUyKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbn1cblxuXG52YXIgVU5FU0NBUEVfTURfUkUgID0gL1xcXFwoWyFcIiMkJSYnKCkqKyxcXC0uXFwvOjs8PT4/QFtcXFxcXFxdXl9ge3x9fl0pL2c7XG52YXIgRU5USVRZX1JFICAgICAgID0gLyYoW2EteiNdW2EtejAtOV17MSwzMX0pOy9naTtcbnZhciBVTkVTQ0FQRV9BTExfUkUgPSBuZXcgUmVnRXhwKFVORVNDQVBFX01EX1JFLnNvdXJjZSArICd8JyArIEVOVElUWV9SRS5zb3VyY2UsICdnaScpO1xuXG52YXIgRElHSVRBTF9FTlRJVFlfVEVTVF9SRSA9IC9eIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSkvaTtcblxudmFyIGVudGl0aWVzID0gcmVxdWlyZSgnLi9lbnRpdGllcycpO1xuXG5mdW5jdGlvbiByZXBsYWNlRW50aXR5UGF0dGVybihtYXRjaCwgbmFtZSkge1xuICB2YXIgY29kZSA9IDA7XG5cbiAgaWYgKGhhcyhlbnRpdGllcywgbmFtZSkpIHtcbiAgICByZXR1cm4gZW50aXRpZXNbbmFtZV07XG4gIH1cblxuICBpZiAobmFtZS5jaGFyQ29kZUF0KDApID09PSAweDIzLyogIyAqLyAmJiBESUdJVEFMX0VOVElUWV9URVNUX1JFLnRlc3QobmFtZSkpIHtcbiAgICBjb2RlID0gbmFtZVsxXS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgcGFyc2VJbnQobmFtZS5zbGljZSgyKSwgMTYpXG4gICAgOlxuICAgICAgcGFyc2VJbnQobmFtZS5zbGljZSgxKSwgMTApO1xuICAgIGlmIChpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG4vKmZ1bmN0aW9uIHJlcGxhY2VFbnRpdGllcyhzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoRU5USVRZX1JFLCByZXBsYWNlRW50aXR5UGF0dGVybik7XG59Ki9cblxuZnVuY3Rpb24gdW5lc2NhcGVNZChzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCdcXFxcJykgPCAwKSB7IHJldHVybiBzdHI7IH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFVORVNDQVBFX01EX1JFLCAnJDEnKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVBbGwoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCAmJiBzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFVORVNDQVBFX0FMTF9SRSwgZnVuY3Rpb24gKG1hdGNoLCBlc2NhcGVkLCBlbnRpdHkpIHtcbiAgICBpZiAoZXNjYXBlZCkgeyByZXR1cm4gZXNjYXBlZDsgfVxuICAgIHJldHVybiByZXBsYWNlRW50aXR5UGF0dGVybihtYXRjaCwgZW50aXR5KTtcbiAgfSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBIVE1MX0VTQ0FQRV9URVNUX1JFID0gL1smPD5cIl0vO1xudmFyIEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUgPSAvWyY8PlwiXS9nO1xudmFyIEhUTUxfUkVQTEFDRU1FTlRTID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90Oydcbn07XG5cbmZ1bmN0aW9uIHJlcGxhY2VVbnNhZmVDaGFyKGNoKSB7XG4gIHJldHVybiBIVE1MX1JFUExBQ0VNRU5UU1tjaF07XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIGlmIChIVE1MX0VTQ0FQRV9URVNUX1JFLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFLCByZXBsYWNlVW5zYWZlQ2hhcik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIFJFR0VYUF9FU0NBUEVfUkUgPSAvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVSRShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYUF9FU0NBUEVfUkUsICdcXFxcJCYnKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNTcGFjZShjb2RlKSB7XG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgMHgwOTpcbiAgICBjYXNlIDB4MjA6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFpzICh1bmljb2RlIGNsYXNzKSB8fCBbXFx0XFxmXFx2XFxyXFxuXVxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNvZGUpIHtcbiAgaWYgKGNvZGUgPj0gMHgyMDAwICYmIGNvZGUgPD0gMHgyMDBBKSB7IHJldHVybiB0cnVlOyB9XG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgMHgwOTogLy8gXFx0XG4gICAgY2FzZSAweDBBOiAvLyBcXG5cbiAgICBjYXNlIDB4MEI6IC8vIFxcdlxuICAgIGNhc2UgMHgwQzogLy8gXFxmXG4gICAgY2FzZSAweDBEOiAvLyBcXHJcbiAgICBjYXNlIDB4MjA6XG4gICAgY2FzZSAweEEwOlxuICAgIGNhc2UgMHgxNjgwOlxuICAgIGNhc2UgMHgyMDJGOlxuICAgIGNhc2UgMHgyMDVGOlxuICAgIGNhc2UgMHgzMDAwOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xudmFyIFVOSUNPREVfUFVOQ1RfUkUgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXgnKTtcblxuLy8gQ3VycmVudGx5IHdpdGhvdXQgYXN0cmFsIGNoYXJhY3RlcnMgc3VwcG9ydC5cbmZ1bmN0aW9uIGlzUHVuY3RDaGFyKGNoKSB7XG4gIHJldHVybiBVTklDT0RFX1BVTkNUX1JFLnRlc3QoY2gpO1xufVxuXG5cbi8vIE1hcmtkb3duIEFTQ0lJIHB1bmN0dWF0aW9uIGNoYXJhY3RlcnMuXG4vL1xuLy8gISwgXCIsICMsICQsICUsICYsICcsICgsICksICosICssICwsIC0sIC4sIC8sIDosIDssIDwsID0sID4sID8sIEAsIFssIFxcLCBdLCBeLCBfLCBgLCB7LCB8LCB9LCBvciB+XG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbi8vXG4vLyBEb24ndCBjb25mdXNlIHdpdGggdW5pY29kZSBwdW5jdHVhdGlvbiAhISEgSXQgbGFja3Mgc29tZSBjaGFycyBpbiBhc2NpaSByYW5nZS5cbi8vXG5mdW5jdGlvbiBpc01kQXNjaWlQdW5jdChjaCkge1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAweDIxLyogISAqLzpcbiAgICBjYXNlIDB4MjIvKiBcIiAqLzpcbiAgICBjYXNlIDB4MjMvKiAjICovOlxuICAgIGNhc2UgMHgyNC8qICQgKi86XG4gICAgY2FzZSAweDI1LyogJSAqLzpcbiAgICBjYXNlIDB4MjYvKiAmICovOlxuICAgIGNhc2UgMHgyNy8qICcgKi86XG4gICAgY2FzZSAweDI4LyogKCAqLzpcbiAgICBjYXNlIDB4MjkvKiApICovOlxuICAgIGNhc2UgMHgyQS8qICogKi86XG4gICAgY2FzZSAweDJCLyogKyAqLzpcbiAgICBjYXNlIDB4MkMvKiAsICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDJFLyogLiAqLzpcbiAgICBjYXNlIDB4MkYvKiAvICovOlxuICAgIGNhc2UgMHgzQS8qIDogKi86XG4gICAgY2FzZSAweDNCLyogOyAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4M0YvKiA/ICovOlxuICAgIGNhc2UgMHg0MC8qIEAgKi86XG4gICAgY2FzZSAweDVCLyogWyAqLzpcbiAgICBjYXNlIDB4NUMvKiBcXCAqLzpcbiAgICBjYXNlIDB4NUQvKiBdICovOlxuICAgIGNhc2UgMHg1RS8qIF4gKi86XG4gICAgY2FzZSAweDVGLyogXyAqLzpcbiAgICBjYXNlIDB4NjAvKiBgICovOlxuICAgIGNhc2UgMHg3Qi8qIHsgKi86XG4gICAgY2FzZSAweDdDLyogfCAqLzpcbiAgICBjYXNlIDB4N0QvKiB9ICovOlxuICAgIGNhc2UgMHg3RS8qIH4gKi86XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEhlcGxlciB0byB1bmlmeSBbcmVmZXJlbmNlIGxhYmVsc10uXG4vL1xuZnVuY3Rpb24gbm9ybWFsaXplUmVmZXJlbmNlKHN0cikge1xuICAvLyB1c2UgLnRvVXBwZXJDYXNlKCkgaW5zdGVhZCBvZiAudG9Mb3dlckNhc2UoKVxuICAvLyBoZXJlIHRvIGF2b2lkIGEgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlXG4gIC8vIG1lbWJlcnMgKG1vc3Qgbm90YWJseSwgYF9fcHJvdG9fX2ApXG4gIHJldHVybiBzdHIudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKS50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBSZS1leHBvcnQgbGlicmFyaWVzIGNvbW1vbmx5IHVzZWQgaW4gYm90aCBtYXJrZG93bi1pdCBhbmQgaXRzIHBsdWdpbnMsXG4vLyBzbyBwbHVnaW5zIHdvbid0IGhhdmUgdG8gZGVwZW5kIG9uIHRoZW0gZXhwbGljaXRseSwgd2hpY2ggcmVkdWNlcyB0aGVpclxuLy8gYnVuZGxlZCBzaXplIChlLmcuIGEgYnJvd3NlciBidWlsZCkuXG4vL1xuZXhwb3J0cy5saWIgICAgICAgICAgICAgICAgID0ge307XG5leHBvcnRzLmxpYi5tZHVybCAgICAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xuZXhwb3J0cy5saWIudWNtaWNybyAgICAgICAgID0gcmVxdWlyZSgndWMubWljcm8nKTtcblxuZXhwb3J0cy5hc3NpZ24gICAgICAgICAgICAgID0gYXNzaWduO1xuZXhwb3J0cy5pc1N0cmluZyAgICAgICAgICAgID0gaXNTdHJpbmc7XG5leHBvcnRzLmhhcyAgICAgICAgICAgICAgICAgPSBoYXM7XG5leHBvcnRzLnVuZXNjYXBlTWQgICAgICAgICAgPSB1bmVzY2FwZU1kO1xuZXhwb3J0cy51bmVzY2FwZUFsbCAgICAgICAgID0gdW5lc2NhcGVBbGw7XG5leHBvcnRzLmlzVmFsaWRFbnRpdHlDb2RlICAgPSBpc1ZhbGlkRW50aXR5Q29kZTtcbmV4cG9ydHMuZnJvbUNvZGVQb2ludCAgICAgICA9IGZyb21Db2RlUG9pbnQ7XG4vLyBleHBvcnRzLnJlcGxhY2VFbnRpdGllcyAgICAgPSByZXBsYWNlRW50aXRpZXM7XG5leHBvcnRzLmVzY2FwZUh0bWwgICAgICAgICAgPSBlc2NhcGVIdG1sO1xuZXhwb3J0cy5hcnJheVJlcGxhY2VBdCAgICAgID0gYXJyYXlSZXBsYWNlQXQ7XG5leHBvcnRzLmlzU3BhY2UgICAgICAgICAgICAgPSBpc1NwYWNlO1xuZXhwb3J0cy5pc1doaXRlU3BhY2UgICAgICAgID0gaXNXaGl0ZVNwYWNlO1xuZXhwb3J0cy5pc01kQXNjaWlQdW5jdCAgICAgID0gaXNNZEFzY2lpUHVuY3Q7XG5leHBvcnRzLmlzUHVuY3RDaGFyICAgICAgICAgPSBpc1B1bmN0Q2hhcjtcbmV4cG9ydHMuZXNjYXBlUkUgICAgICAgICAgICA9IGVzY2FwZVJFO1xuZXhwb3J0cy5ub3JtYWxpemVSZWZlcmVuY2UgID0gbm9ybWFsaXplUmVmZXJlbmNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwiLyoqXG4gKiBjbGFzcyBSdWxlclxuICpcbiAqIEhlbHBlciBjbGFzcywgdXNlZCBieSBbW01hcmtkb3duSXQjY29yZV1dLCBbW01hcmtkb3duSXQjYmxvY2tdXSBhbmRcbiAqIFtbTWFya2Rvd25JdCNpbmxpbmVdXSB0byBtYW5hZ2Ugc2VxdWVuY2VzIG9mIGZ1bmN0aW9ucyAocnVsZXMpOlxuICpcbiAqIC0ga2VlcCBydWxlcyBpbiBkZWZpbmVkIG9yZGVyXG4gKiAtIGFzc2lnbiB0aGUgbmFtZSB0byBlYWNoIHJ1bGVcbiAqIC0gZW5hYmxlL2Rpc2FibGUgcnVsZXNcbiAqIC0gYWRkL3JlcGxhY2UgcnVsZXNcbiAqIC0gYWxsb3cgYXNzaWduIHJ1bGVzIHRvIGFkZGl0aW9uYWwgbmFtZWQgY2hhaW5zIChpbiB0aGUgc2FtZSlcbiAqIC0gY2FjaGVpbmcgbGlzdHMgb2YgYWN0aXZlIHJ1bGVzXG4gKlxuICogWW91IHdpbGwgbm90IG5lZWQgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHkgdW50aWwgd3JpdGUgcGx1Z2lucy4gRm9yIHNpbXBsZVxuICogcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSwgW1tNYXJrZG93bkl0LmVuYWJsZV1dIGFuZFxuICogW1tNYXJrZG93bkl0LnVzZV1dLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogbmV3IFJ1bGVyKClcbiAqKi9cbmZ1bmN0aW9uIFJ1bGVyKCkge1xuICAvLyBMaXN0IG9mIGFkZGVkIHJ1bGVzLiBFYWNoIGVsZW1lbnQgaXM6XG4gIC8vXG4gIC8vIHtcbiAgLy8gICBuYW1lOiBYWFgsXG4gIC8vICAgZW5hYmxlZDogQm9vbGVhbixcbiAgLy8gICBmbjogRnVuY3Rpb24oKSxcbiAgLy8gICBhbHQ6IFsgbmFtZTIsIG5hbWUzIF1cbiAgLy8gfVxuICAvL1xuICB0aGlzLl9fcnVsZXNfXyA9IFtdO1xuXG4gIC8vIENhY2hlZCBydWxlIGNoYWlucy5cbiAgLy9cbiAgLy8gRmlyc3QgbGV2ZWwgLSBjaGFpbiBuYW1lLCAnJyBmb3IgZGVmYXVsdC5cbiAgLy8gU2Vjb25kIGxldmVsIC0gZGlnaW5hbCBhbmNob3IgZm9yIGZhc3QgZmlsdGVyaW5nIGJ5IGNoYXJjb2Rlcy5cbiAgLy9cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIG1ldGhvZHMsIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseVxuXG5cbi8vIEZpbmQgcnVsZSBpbmRleCBieSBuYW1lXG4vL1xuUnVsZXIucHJvdG90eXBlLl9fZmluZF9fID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9fcnVsZXNfXy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLl9fcnVsZXNfX1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vLyBCdWlsZCBydWxlcyBsb29rdXAgY2FjaGVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19jb21waWxlX18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNoYWlucyA9IFsgJycgXTtcblxuICAvLyBjb2xsZWN0IHVuaXF1ZSBuYW1lc1xuICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBydWxlLmFsdC5mb3JFYWNoKGZ1bmN0aW9uIChhbHROYW1lKSB7XG4gICAgICBpZiAoY2hhaW5zLmluZGV4T2YoYWx0TmFtZSkgPCAwKSB7XG4gICAgICAgIGNoYWlucy5wdXNoKGFsdE5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBzZWxmLl9fY2FjaGVfXyA9IHt9O1xuXG4gIGNoYWlucy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXSA9IFtdO1xuICAgIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIGlmICghcnVsZS5lbmFibGVkKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAoY2hhaW4gJiYgcnVsZS5hbHQuaW5kZXhPZihjaGFpbikgPCAwKSB7IHJldHVybjsgfVxuXG4gICAgICBzZWxmLl9fY2FjaGVfX1tjaGFpbl0ucHVzaChydWxlLmZuKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuYXQobmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgbmFtZSB0byByZXBsYWNlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBuZXcgcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogbmV3IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogUmVwbGFjZSBydWxlIGJ5IG5hbWUgd2l0aCBuZXcgZnVuY3Rpb24gJiBvcHRpb25zLiBUaHJvd3MgZXJyb3IgaWYgbmFtZSBub3RcbiAqIGZvdW5kLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogUmVwbGFjZSBleGlzdGluZyB0eXBvcmdhcGhlciByZXBsYWNlbWVudCBydWxlIHdpdGggbmV3IG9uZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5hdCgncmVwbGFjZW1lbnRzJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgbmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uZm4gPSBmbjtcbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmFsdCA9IG9wdC5hbHQgfHwgW107XG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5iZWZvcmUoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBiZWZvcmVOYW1lIChTdHJpbmcpOiBuZXcgcnVsZSB3aWxsIGJlIGFkZGVkIGJlZm9yZSB0aGlzIG9uZS5cbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgdG8gY2hhaW4gYmVmb3JlIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmFmdGVyXV0sIFtbUnVsZXIucHVzaF1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmJsb2NrLnJ1bGVyLmJlZm9yZSgncGFyYWdyYXBoJywgJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uIChiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhiZWZvcmVOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGJlZm9yZU5hbWUpOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hZnRlcihhZnRlck5hbWUsIHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gYWZ0ZXJOYW1lIChTdHJpbmcpOiBuZXcgcnVsZSB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBhZnRlciBvbmUgd2l0aCBnaXZlbiBuYW1lLiBTZWUgYWxzb1xuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuaW5saW5lLnJ1bGVyLmFmdGVyKCd0ZXh0JywgJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmFmdGVyID0gZnVuY3Rpb24gKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18oYWZ0ZXJOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGFmdGVyTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXggKyAxLCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cbi8qKlxuICogUnVsZXIucHVzaChydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogUHVzaCBuZXcgcnVsZSB0byB0aGUgZW5kIG9mIGNoYWluLiBTZWUgYWxzb1xuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5hZnRlcl1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmNvcmUucnVsZXIucHVzaCgnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fX3J1bGVzX18ucHVzaCh7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGUobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSkgLT4gQXJyYXlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGVuYWJsZVxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICBpZiAoaWdub3JlSW52YWxpZCkgeyByZXR1cm47IH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZXMgbWFuYWdlcjogaW52YWxpZCBydWxlIG5hbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSB0cnVlO1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZW5hYmxlT25seShsaXN0IFssIGlnbm9yZUludmFsaWRdKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlICh3aGl0ZWxpc3QpLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMsIGFuZCBkaXNhYmxlIGV2ZXJ5dGhpbmcgZWxzZS4gSWYgYW55IHJ1bGUgbmFtZVxuICogbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZGlzYWJsZV1dLCBbW1J1bGVyLmVuYWJsZV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmVuYWJsZU9ubHkgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkgeyBydWxlLmVuYWJsZWQgPSBmYWxzZTsgfSk7XG5cbiAgdGhpcy5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZCk7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZGlzYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZGlzYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIERpc2FibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgYW55IHJ1bGUgbmFtZSBub3QgZm91bmQgLSB0aHJvdyBFcnJvci5cbiAqIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFJldHVybnMgbGlzdCBvZiBmb3VuZCBydWxlIG5hbWVzIChpZiBubyBleGNlcHRpb24gaGFwcGVuZWQpLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZW5hYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFNlYXJjaCBieSBuYW1lIGFuZCBkaXNhYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IGZhbHNlO1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZ2V0UnVsZXMoY2hhaW5OYW1lKSAtPiBBcnJheVxuICpcbiAqIFJldHVybiBhcnJheSBvZiBhY3RpdmUgZnVuY3Rpb25zIChydWxlcykgZm9yIGdpdmVuIGNoYWluIG5hbWUuIEl0IGFuYWx5emVzXG4gKiBydWxlcyBjb25maWd1cmF0aW9uLCBjb21waWxlcyBjYWNoZXMgaWYgbm90IGV4aXN0cyBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogRGVmYXVsdCBjaGFpbiBuYW1lIGlzIGAnJ2AgKGVtcHR5IHN0cmluZykuIEl0IGNhbid0IGJlIHNraXBwZWQuIFRoYXQnc1xuICogZG9uZSBpbnRlbnRpb25hbGx5LCB0byBrZWVwIHNpZ25hdHVyZSBtb25vbW9ycGhpYyBmb3IgaGlnaCBzcGVlZC5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5nZXRSdWxlcyA9IGZ1bmN0aW9uIChjaGFpbk5hbWUpIHtcbiAgaWYgKHRoaXMuX19jYWNoZV9fID09PSBudWxsKSB7XG4gICAgdGhpcy5fX2NvbXBpbGVfXygpO1xuICB9XG5cbiAgLy8gQ2hhaW4gY2FuIGJlIGVtcHR5LCBpZiBydWxlcyBkaXNhYmxlZC4gQnV0IHdlIHN0aWxsIGhhdmUgdG8gcmV0dXJuIEFycmF5LlxuICByZXR1cm4gdGhpcy5fX2NhY2hlX19bY2hhaW5OYW1lXSB8fCBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUnVsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlci5qcyIsIi8vIFRva2VuIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKipcbiAqIGNsYXNzIFRva2VuXG4gKiovXG5cbi8qKlxuICogbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZylcbiAqXG4gKiBDcmVhdGUgbmV3IHRva2VuIGFuZCBmaWxsIHBhc3NlZCBwcm9wZXJ0aWVzLlxuICoqL1xuZnVuY3Rpb24gVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIC8qKlxuICAgKiBUb2tlbiN0eXBlIC0+IFN0cmluZ1xuICAgKlxuICAgKiBUeXBlIG9mIHRoZSB0b2tlbiAoc3RyaW5nLCBlLmcuIFwicGFyYWdyYXBoX29wZW5cIilcbiAgICoqL1xuICB0aGlzLnR5cGUgICAgID0gdHlwZTtcblxuICAvKipcbiAgICogVG9rZW4jdGFnIC0+IFN0cmluZ1xuICAgKlxuICAgKiBodG1sIHRhZyBuYW1lLCBlLmcuIFwicFwiXG4gICAqKi9cbiAgdGhpcy50YWcgICAgICA9IHRhZztcblxuICAvKipcbiAgICogVG9rZW4jYXR0cnMgLT4gQXJyYXlcbiAgICpcbiAgICogSHRtbCBhdHRyaWJ1dGVzLiBGb3JtYXQ6IGBbIFsgbmFtZTEsIHZhbHVlMSBdLCBbIG5hbWUyLCB2YWx1ZTIgXSBdYFxuICAgKiovXG4gIHRoaXMuYXR0cnMgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtYXAgLT4gQXJyYXlcbiAgICpcbiAgICogU291cmNlIG1hcCBpbmZvLiBGb3JtYXQ6IGBbIGxpbmVfYmVnaW4sIGxpbmVfZW5kIF1gXG4gICAqKi9cbiAgdGhpcy5tYXAgICAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI25lc3RpbmcgLT4gTnVtYmVyXG4gICAqXG4gICAqIExldmVsIGNoYW5nZSAobnVtYmVyIGluIHstMSwgMCwgMX0gc2V0KSwgd2hlcmU6XG4gICAqXG4gICAqIC0gIGAxYCBtZWFucyB0aGUgdGFnIGlzIG9wZW5pbmdcbiAgICogLSAgYDBgIG1lYW5zIHRoZSB0YWcgaXMgc2VsZi1jbG9zaW5nXG4gICAqIC0gYC0xYCBtZWFucyB0aGUgdGFnIGlzIGNsb3NpbmdcbiAgICoqL1xuICB0aGlzLm5lc3RpbmcgID0gbmVzdGluZztcblxuICAvKipcbiAgICogVG9rZW4jbGV2ZWwgLT4gTnVtYmVyXG4gICAqXG4gICAqIG5lc3RpbmcgbGV2ZWwsIHRoZSBzYW1lIGFzIGBzdGF0ZS5sZXZlbGBcbiAgICoqL1xuICB0aGlzLmxldmVsICAgID0gMDtcblxuICAvKipcbiAgICogVG9rZW4jY2hpbGRyZW4gLT4gQXJyYXlcbiAgICpcbiAgICogQW4gYXJyYXkgb2YgY2hpbGQgbm9kZXMgKGlubGluZSBhbmQgaW1nIHRva2VucylcbiAgICoqL1xuICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jY29udGVudCAtPiBTdHJpbmdcbiAgICpcbiAgICogSW4gYSBjYXNlIG9mIHNlbGYtY2xvc2luZyB0YWcgKGNvZGUsIGh0bWwsIGZlbmNlLCBldGMuKSxcbiAgICogaXQgaGFzIGNvbnRlbnRzIG9mIHRoaXMgdGFnLlxuICAgKiovXG4gIHRoaXMuY29udGVudCAgPSAnJztcblxuICAvKipcbiAgICogVG9rZW4jbWFya3VwIC0+IFN0cmluZ1xuICAgKlxuICAgKiAnKicgb3IgJ18nIGZvciBlbXBoYXNpcywgZmVuY2Ugc3RyaW5nIGZvciBmZW5jZSwgZXRjLlxuICAgKiovXG4gIHRoaXMubWFya3VwICAgPSAnJztcblxuICAvKipcbiAgICogVG9rZW4jaW5mbyAtPiBTdHJpbmdcbiAgICpcbiAgICogZmVuY2UgaW5mb3N0cmluZ1xuICAgKiovXG4gIHRoaXMuaW5mbyAgICAgPSAnJztcblxuICAvKipcbiAgICogVG9rZW4jbWV0YSAtPiBPYmplY3RcbiAgICpcbiAgICogQSBwbGFjZSBmb3IgcGx1Z2lucyB0byBzdG9yZSBhbiBhcmJpdHJhcnkgZGF0YVxuICAgKiovXG4gIHRoaXMubWV0YSAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNibG9jayAtPiBCb29sZWFuXG4gICAqXG4gICAqIFRydWUgZm9yIGJsb2NrLWxldmVsIHRva2VucywgZmFsc2UgZm9yIGlubGluZSB0b2tlbnMuXG4gICAqIFVzZWQgaW4gcmVuZGVyZXIgdG8gY2FsY3VsYXRlIGxpbmUgYnJlYWtzXG4gICAqKi9cbiAgdGhpcy5ibG9jayAgICA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNoaWRkZW4gLT4gQm9vbGVhblxuICAgKlxuICAgKiBJZiBpdCdzIHRydWUsIGlnbm9yZSB0aGlzIGVsZW1lbnQgd2hlbiByZW5kZXJpbmcuIFVzZWQgZm9yIHRpZ2h0IGxpc3RzXG4gICAqIHRvIGhpZGUgcGFyYWdyYXBocy5cbiAgICoqL1xuICB0aGlzLmhpZGRlbiAgID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySW5kZXgobmFtZSkgLT4gTnVtYmVyXG4gKlxuICogU2VhcmNoIGF0dHJpYnV0ZSBpbmRleCBieSBuYW1lLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJJbmRleCA9IGZ1bmN0aW9uIGF0dHJJbmRleChuYW1lKSB7XG4gIHZhciBhdHRycywgaSwgbGVuO1xuXG4gIGlmICghdGhpcy5hdHRycykgeyByZXR1cm4gLTE7IH1cblxuICBhdHRycyA9IHRoaXMuYXR0cnM7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gYXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXR0cnNbaV1bMF0gPT09IG5hbWUpIHsgcmV0dXJuIGk7IH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clB1c2goYXR0ckRhdGEpXG4gKlxuICogQWRkIGBbIG5hbWUsIHZhbHVlIF1gIGF0dHJpYnV0ZSB0byBsaXN0LiBJbml0IGF0dHJzIGlmIG5lY2Vzc2FyeVxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJQdXNoID0gZnVuY3Rpb24gYXR0clB1c2goYXR0ckRhdGEpIHtcbiAgaWYgKHRoaXMuYXR0cnMpIHtcbiAgICB0aGlzLmF0dHJzLnB1c2goYXR0ckRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnMgPSBbIGF0dHJEYXRhIF07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyU2V0KG5hbWUsIHZhbHVlKVxuICpcbiAqIFNldCBgbmFtZWAgYXR0cmlidXRlIHRvIGB2YWx1ZWAuIE92ZXJyaWRlIG9sZCB2YWx1ZSBpZiBleGlzdHMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0clNldCA9IGZ1bmN0aW9uIGF0dHJTZXQobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLFxuICAgICAgYXR0ckRhdGEgPSBbIG5hbWUsIHZhbHVlIF07XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzW2lkeF0gPSBhdHRyRGF0YTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJHZXQobmFtZSlcbiAqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGF0dHJpYnV0ZSBgbmFtZWAsIG9yIG51bGwgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckdldCA9IGZ1bmN0aW9uIGF0dHJHZXQobmFtZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksIHZhbHVlID0gbnVsbDtcbiAgaWYgKGlkeCA+PSAwKSB7XG4gICAgdmFsdWUgPSB0aGlzLmF0dHJzW2lkeF1bMV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJKb2luKG5hbWUsIHZhbHVlKVxuICpcbiAqIEpvaW4gdmFsdWUgdG8gZXhpc3RpbmcgYXR0cmlidXRlIHZpYSBzcGFjZS4gT3IgY3JlYXRlIG5ldyBhdHRyaWJ1dGUgaWYgbm90XG4gKiBleGlzdHMuIFVzZWZ1bCB0byBvcGVyYXRlIHdpdGggdG9rZW4gY2xhc3Nlcy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySm9pbiA9IGZ1bmN0aW9uIGF0dHJKb2luKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKTtcblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goWyBuYW1lLCB2YWx1ZSBdKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzW2lkeF1bMV0gPSB0aGlzLmF0dHJzW2lkeF1bMV0gKyAnICcgKyB2YWx1ZTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRva2VuO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvdG9rZW4uanMiLCJtb2R1bGUuZXhwb3J0cz0vWyEtIyUtXFwqLC0vOjtcXD9AXFxbLVxcXV9cXHtcXH1cXHhBMVxceEE3XFx4QUJcXHhCNlxceEI3XFx4QkJcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQ0XFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgwMVxcdURENkZ8XFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1REM0Qi1cXHVEQzRGXFx1REM1QlxcdURDNURcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REU2MC1cXHVERTZDXFx1REYzQy1cXHVERjNFXXxcXHVEODA3W1xcdURDNDEtXFx1REM0NVxcdURDNzBcXHVEQzcxXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODJGXFx1REM5RnxcXHVEODM2W1xcdURFODctXFx1REU4Ql18XFx1RDgzQVtcXHVERDVFXFx1REQ1Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCIvLyBIVE1MNSBlbnRpdGllcyBtYXA6IHsgbmFtZSAtPiB1dGYxNnN0cmluZyB9XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBxdW90ZXM6MCovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2VudGl0aWVzL21hcHMvZW50aXRpZXMuanNvbicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzIiwiLy8gUmVnZXhwcyB0byBtYXRjaCBodG1sIGVsZW1lbnRzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dHJfbmFtZSAgICAgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xuXG52YXIgdW5xdW90ZWQgICAgICA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBzaW5nbGVfcXVvdGVkID0gXCInW14nXSonXCI7XG52YXIgZG91YmxlX3F1b3RlZCA9ICdcIlteXCJdKlwiJztcblxudmFyIGF0dHJfdmFsdWUgID0gJyg/OicgKyB1bnF1b3RlZCArICd8JyArIHNpbmdsZV9xdW90ZWQgKyAnfCcgKyBkb3VibGVfcXVvdGVkICsgJyknO1xuXG52YXIgYXR0cmlidXRlICAgPSAnKD86XFxcXHMrJyArIGF0dHJfbmFtZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJfdmFsdWUgKyAnKT8pJztcblxudmFyIG9wZW5fdGFnICAgID0gJzxbQS1aYS16XVtBLVphLXowLTlcXFxcLV0qJyArIGF0dHJpYnV0ZSArICcqXFxcXHMqXFxcXC8/Pic7XG5cbnZhciBjbG9zZV90YWcgICA9ICc8XFxcXC9bQS1aYS16XVtBLVphLXowLTlcXFxcLV0qXFxcXHMqPic7XG52YXIgY29tbWVudCAgICAgPSAnPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPic7XG52YXIgcHJvY2Vzc2luZyAgPSAnPFs/XS4qP1s/XT4nO1xudmFyIGRlY2xhcmF0aW9uID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBjZGF0YSAgICAgICA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xuXG52YXIgSFRNTF9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJ3wnICsgY29tbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBwcm9jZXNzaW5nICsgJ3wnICsgZGVjbGFyYXRpb24gKyAnfCcgKyBjZGF0YSArICcpJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpO1xuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xubW9kdWxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IEhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qcyIsIi8vIFByb2Nlc3MgKnRoaXMqIGFuZCBfdGhhdF9cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChtYXJrZXIgIT09IDB4NUYgLyogXyAqLyAmJiBtYXJrZXIgIT09IDB4MkEgLyogKiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIG1hcmtlciA9PT0gMHgyQSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNjYW5uZWQubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgIC8vIENoYXIgY29kZSBvZiB0aGUgc3RhcnRpbmcgbWFya2VyIChudW1iZXIpLlxuICAgICAgLy9cbiAgICAgIG1hcmtlcjogbWFya2VyLFxuXG4gICAgICAvLyBUb3RhbCBsZW5ndGggb2YgdGhlc2Ugc2VyaWVzIG9mIGRlbGltaXRlcnMuXG4gICAgICAvL1xuICAgICAgbGVuZ3RoOiBzY2FubmVkLmxlbmd0aCxcblxuICAgICAgLy8gQW4gYW1vdW50IG9mIGNoYXJhY3RlcnMgYmVmb3JlIHRoaXMgb25lIHRoYXQncyBlcXVpdmFsZW50IHRvXG4gICAgICAvLyBjdXJyZW50IG9uZS4gSW4gcGxhaW4gRW5nbGlzaDogaWYgdGhpcyBkZWxpbWl0ZXIgZG9lcyBub3Qgb3BlblxuICAgICAgLy8gYW4gZW1waGFzaXMsIG5laXRoZXIgZG8gcHJldmlvdXMgYGp1bXBgIGNoYXJhY3RlcnMuXG4gICAgICAvL1xuICAgICAgLy8gVXNlZCB0byBza2lwIHNlcXVlbmNlcyBsaWtlIFwiKioqKipcIiBpbiBvbmUgc3RlcCwgZm9yIDFzdCBhc3Rlcmlza1xuICAgICAgLy8gdmFsdWUgd2lsbCBiZSAwLCBmb3IgMm5kIGl0J3MgMSBhbmQgc28gb24uXG4gICAgICAvL1xuICAgICAganVtcDogICBpLFxuXG4gICAgICAvLyBBIHBvc2l0aW9uIG9mIHRoZSB0b2tlbiB0aGlzIGRlbGltaXRlciBjb3JyZXNwb25kcyB0by5cbiAgICAgIC8vXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuXG4gICAgICAvLyBUb2tlbiBsZXZlbC5cbiAgICAgIC8vXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuXG4gICAgICAvLyBJZiB0aGlzIGRlbGltaXRlciBpcyBtYXRjaGVkIGFzIGEgdmFsaWQgb3BlbmVyLCBgZW5kYCB3aWxsIGJlXG4gICAgICAvLyBlcXVhbCB0byBpdHMgcG9zaXRpb24sIG90aGVyd2lzZSBpdCdzIGAtMWAuXG4gICAgICAvL1xuICAgICAgZW5kOiAgICAtMSxcblxuICAgICAgLy8gQm9vbGVhbiBmbGFncyB0aGF0IGRldGVybWluZSBpZiB0aGlzIGRlbGltaXRlciBjb3VsZCBvcGVuIG9yIGNsb3NlXG4gICAgICAvLyBhbiBlbXBoYXNpcy5cbiAgICAgIC8vXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlKSB7XG4gIHZhciBpLFxuICAgICAgc3RhcnREZWxpbSxcbiAgICAgIGVuZERlbGltLFxuICAgICAgdG9rZW4sXG4gICAgICBjaCxcbiAgICAgIGlzU3Ryb25nLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBzdGFydERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg1Ri8qIF8gKi8gJiYgc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4MkEvKiAqICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIG9ubHkgb3BlbmluZyBtYXJrZXJzXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIC8vIElmIHRoZSBuZXh0IGRlbGltaXRlciBoYXMgdGhlIHNhbWUgbWFya2VyIGFuZCBpcyBhZGphY2VudCB0byB0aGlzIG9uZSxcbiAgICAvLyBtZXJnZSB0aG9zZSBpbnRvIG9uZSBzdHJvbmcgZGVsaW1pdGVyLlxuICAgIC8vXG4gICAgLy8gYDxlbT48ZW0+d2hhdGV2ZXI8L2VtPjwvZW0+YCAtPiBgPHN0cm9uZz53aGF0ZXZlcjwvc3Ryb25nPmBcbiAgICAvL1xuICAgIGlzU3Ryb25nID0gaSArIDEgPCBtYXggJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSArIDFdLmVuZCA9PT0gc3RhcnREZWxpbS5lbmQgLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS50b2tlbiA9PT0gc3RhcnREZWxpbS50b2tlbiArIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgLSAxXS50b2tlbiA9PT0gZW5kRGVsaW0udG9rZW4gLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS5tYXJrZXIgPT09IHN0YXJ0RGVsaW0ubWFya2VyO1xuXG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0RGVsaW0ubWFya2VyKTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19vcGVuJyA6ICdlbV9vcGVuJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfY2xvc2UnIDogJ2VtX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoaXNTdHJvbmcpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW2kgKyAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgLSAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIi8vIH5+c3RyaWtlIHRocm91Z2h+flxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBJbnNlcnQgZWFjaCBtYXJrZXIgYXMgYSBzZXBhcmF0ZSB0ZXh0IHRva2VuLCBhbmQgYWRkIGl0IHRvIGRlbGltaXRlciBsaXN0XG4vL1xubW9kdWxlLmV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLCBsZW4sIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIHRydWUpO1xuICBsZW4gPSBzY2FubmVkLmxlbmd0aDtcbiAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgaWYgKGxlbiA8IDIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGxlbiAlIDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2g7XG4gICAgbGVuLS07XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2ggKyBjaDtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgIGp1bXA6ICAgaSxcbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuICAgICAgZW5kOiAgICAtMSxcbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSkge1xuICB2YXIgaSwgaixcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgbG9uZU1hcmtlcnMgPSBbXSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4N0UvKiB+ICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3Nfb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9ICdzJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3NfY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSAnfn4nO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW4gLSAxXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0uY29udGVudCA9PT0gJ34nKSB7XG5cbiAgICAgIGxvbmVNYXJrZXJzLnB1c2goZW5kRGVsaW0udG9rZW4gLSAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBhIG1hcmtlciBzZXF1ZW5jZSBoYXMgYW4gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBpdCdzIHNwbGl0dGVkXG4gIC8vIGxpa2UgdGhpczogYH5+fn5+YCAtPiBgfmAgKyBgfn5gICsgYH5+YCwgbGVhdmluZyBvbmUgbWFya2VyIGF0IHRoZVxuICAvLyBzdGFydCBvZiB0aGUgc2VxdWVuY2UuXG4gIC8vXG4gIC8vIFNvLCB3ZSBoYXZlIHRvIG1vdmUgYWxsIHRob3NlIG1hcmtlcnMgYWZ0ZXIgc3Vic2VxdWVudCBzX2Nsb3NlIHRhZ3MuXG4gIC8vXG4gIHdoaWxlIChsb25lTWFya2Vycy5sZW5ndGgpIHtcbiAgICBpID0gbG9uZU1hcmtlcnMucG9wKCk7XG4gICAgaiA9IGkgKyAxO1xuXG4gICAgd2hpbGUgKGogPCBzdGF0ZS50b2tlbnMubGVuZ3RoICYmIHN0YXRlLnRva2Vuc1tqXS50eXBlID09PSAnc19jbG9zZScpIHtcbiAgICAgIGorKztcbiAgICB9XG5cbiAgICBqLS07XG5cbiAgICBpZiAoaSAhPT0gaikge1xuICAgICAgdG9rZW4gPSBzdGF0ZS50b2tlbnNbal07XG4gICAgICBzdGF0ZS50b2tlbnNbal0gPSBzdGF0ZS50b2tlbnNbaV07XG4gICAgICBzdGF0ZS50b2tlbnNbaV0gPSB0b2tlbjtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx4MUZcXHg3Ri1cXHg5Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcyIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyc1xuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJzsgfVxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7IH1cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nOyB9XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7IH1cblxuXG5mdW5jdGlvbiBlc2NhcGVSRShzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKTsgfVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZnV6enlMaW5rOiB0cnVlLFxuICBmdXp6eUVtYWlsOiB0cnVlLFxuICBmdXp6eUlQOiBmYWxzZVxufTtcblxuXG5mdW5jdGlvbiBpc09wdGlvbnNPYmoob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmogfHwge30pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrKSB7XG4gICAgcmV0dXJuIGFjYyB8fCBkZWZhdWx0T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgfSwgZmFsc2UpO1xufVxuXG5cbnZhciBkZWZhdWx0U2NoZW1hcyA9IHtcbiAgJ2h0dHA6Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLmh0dHApIHtcbiAgICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ15cXFxcL1xcXFwvJyArIHNlbGYucmUuc3JjX2F1dGggKyBzZWxmLnJlLnNyY19ob3N0X3BvcnRfc3RyaWN0ICsgc2VsZi5yZS5zcmNfcGF0aCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdodHRwczonOiAgJ2h0dHA6JyxcbiAgJ2Z0cDonOiAgICAnaHR0cDonLFxuICAnLy8nOiAgICAgIHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5ub19odHRwKSB7XG4gICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLm5vX2h0dHAgPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXicgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2F1dGggK1xuICAgICAgICAgIC8vIERvbid0IGFsbG93IHNpbmdsZS1sZXZlbCBkb21haW5zLCBiZWNhdXNlIG9mIGZhbHNlIHBvc2l0aXZlcyBsaWtlICcvL3Rlc3QnXG4gICAgICAgICAgLy8gd2l0aCBjb2RlIGNvbW1lbnRzXG4gICAgICAgICAgJyg/OmxvY2FsaG9zdHwoPzooPzonICsgc2VsZi5yZS5zcmNfZG9tYWluICsgJylcXFxcLikrJyArIHNlbGYucmUuc3JjX2RvbWFpbl9yb290ICsgJyknICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wb3J0ICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19ob3N0X3Rlcm1pbmF0b3IgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BhdGgsXG5cbiAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYucmUubm9faHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIC8vIHNob3VsZCBub3QgYmUgYDovL2AgJiBgLy8vYCwgdGhhdCBwcm90ZWN0cyBmcm9tIGVycm9ycyBpbiBwcm90b2NvbCBuYW1lXG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnOicpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICcvJykgeyByZXR1cm4gMDsgfVxuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm5vX2h0dHApWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgJ21haWx0bzonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubWFpbHRvKSB7XG4gICAgICAgIHNlbGYucmUubWFpbHRvID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICsgc2VsZi5yZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHNlbGYucmUuc3JjX2hvc3Rfc3RyaWN0LCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLm1haWx0by50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubWFpbHRvKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbn07XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG5cbi8vIFJFIHBhdHRlcm4gZm9yIDItY2hhcmFjdGVyIHRsZHMgKGF1dG9nZW5lcmF0ZWQgYnkgLi9zdXBwb3J0L3RsZHNfMmNoYXJfZ2VuLmpzKVxudmFyIHRsZHNfMmNoX3NyY19yZSA9ICdhW2NkZWZnaWxtbm9xcnN0dXd4el18YlthYmRlZmdoaWptbm9yc3R2d3l6XXxjW2FjZGZnaGlrbG1ub3J1dnd4eXpdfGRbZWprbW96XXxlW2NlZ3JzdHVdfGZbaWprbW9yXXxnW2FiZGVmZ2hpbG1ucHFyc3R1d3ldfGhba21ucnR1XXxpW2RlbG1ub3Fyc3RdfGpbZW1vcF18a1tlZ2hpbW5wcnd5el18bFthYmNpa3JzdHV2eV18bVthY2RlZ2hrbG1ub3BxcnN0dXZ3eHl6XXxuW2FjZWZnaWxvcHJ1el18b218cFthZWZnaGtsbW5yc3R3eV18cWF8cltlb3N1d118c1thYmNkZWdoaWprbG1ub3J0dXZ4eXpdfHRbY2RmZ2hqa2xtbm9ydHZ3el18dVthZ2tzeXpdfHZbYWNlZ2ludV18d1tmc118eVtldF18elthbXddJztcblxuLy8gRE9OJ1QgdHJ5IHRvIG1ha2UgUFJzIHdpdGggY2hhbmdlcy4gRXh0ZW5kIFRMRHMgd2l0aCBMaW5raWZ5SXQudGxkcygpIGluc3RlYWRcbnZhciB0bGRzX2RlZmF1bHQgPSAnYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YQnLnNwbGl0KCd8Jyk7XG5cbi8qZXNsaW50LWVuYWJsZSBtYXgtbGVuKi9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gcmVzZXRTY2FuQ2FjaGUoc2VsZikge1xuICBzZWxmLl9faW5kZXhfXyA9IC0xO1xuICBzZWxmLl9fdGV4dF9jYWNoZV9fICAgPSAnJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yKHJlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGV4dCwgcG9zKSB7XG4gICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICBpZiAocmUudGVzdCh0YWlsKSkge1xuICAgICAgcmV0dXJuIHRhaWwubWF0Y2gocmUpWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vcm1hbGl6ZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIHNlbGYpIHtcbiAgICBzZWxmLm5vcm1hbGl6ZShtYXRjaCk7XG4gIH07XG59XG5cbi8vIFNjaGVtYXMgY29tcGlsZXIuIEJ1aWxkIHJlZ2V4cHMuXG4vL1xuZnVuY3Rpb24gY29tcGlsZShzZWxmKSB7XG5cbiAgLy8gTG9hZCAmIGNsb25lIFJFIHBhdHRlcm5zLlxuICB2YXIgcmUgPSBzZWxmLnJlID0gcmVxdWlyZSgnLi9saWIvcmUnKShzZWxmLl9fb3B0c19fKTtcblxuICAvLyBEZWZpbmUgZHluYW1pYyBwYXR0ZXJuc1xuICB2YXIgdGxkcyA9IHNlbGYuX190bGRzX18uc2xpY2UoKTtcblxuICBzZWxmLm9uQ29tcGlsZSgpO1xuXG4gIGlmICghc2VsZi5fX3RsZHNfcmVwbGFjZWRfXykge1xuICAgIHRsZHMucHVzaCh0bGRzXzJjaF9zcmNfcmUpO1xuICB9XG4gIHRsZHMucHVzaChyZS5zcmNfeG4pO1xuXG4gIHJlLnNyY190bGRzID0gdGxkcy5qb2luKCd8Jyk7XG5cbiAgZnVuY3Rpb24gdW50cGwodHBsKSB7IHJldHVybiB0cGwucmVwbGFjZSgnJVRMRFMlJywgcmUuc3JjX3RsZHMpOyB9XG5cbiAgcmUuZW1haWxfZnV6enkgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfZW1haWxfZnV6enkpLCAnaScpO1xuICByZS5saW5rX2Z1enp5ICAgICAgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19ub19pcF9mdXp6eSA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19ub19pcF9mdXp6eSksICdpJyk7XG4gIHJlLmhvc3RfZnV6enlfdGVzdCAgPSBSZWdFeHAodW50cGwocmUudHBsX2hvc3RfZnV6enlfdGVzdCksICdpJyk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBlYWNoIHNjaGVtYVxuICAvL1xuXG4gIHZhciBhbGlhc2VzID0gW107XG5cbiAgc2VsZi5fX2NvbXBpbGVkX18gPSB7fTsgLy8gUmVzZXQgY29tcGlsZWQgZGF0YVxuXG4gIGZ1bmN0aW9uIHNjaGVtYUVycm9yKG5hbWUsIHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignKExpbmtpZnlJdCkgSW52YWxpZCBzY2hlbWEgXCInICsgbmFtZSArICdcIjogJyArIHZhbCk7XG4gIH1cblxuICBPYmplY3Qua2V5cyhzZWxmLl9fc2NoZW1hc19fKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbCA9IHNlbGYuX19zY2hlbWFzX19bbmFtZV07XG5cbiAgICAvLyBza2lwIGRpc2FibGVkIG1ldGhvZHNcbiAgICBpZiAodmFsID09PSBudWxsKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGNvbXBpbGVkID0geyB2YWxpZGF0ZTogbnVsbCwgbGluazogbnVsbCB9O1xuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV0gPSBjb21waWxlZDtcblxuICAgIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBpZiAoaXNSZWdFeHAodmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IGNyZWF0ZVZhbGlkYXRvcih2YWwudmFsaWRhdGUpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSB2YWwudmFsaWRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWwubm9ybWFsaXplKSkge1xuICAgICAgICBjb21waWxlZC5ub3JtYWxpemUgPSB2YWwubm9ybWFsaXplO1xuICAgICAgfSBlbHNlIGlmICghdmFsLm5vcm1hbGl6ZSkge1xuICAgICAgICBjb21waWxlZC5ub3JtYWxpemUgPSBjcmVhdGVOb3JtYWxpemVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHZhbCkpIHtcbiAgICAgIGFsaWFzZXMucHVzaChuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICB9KTtcblxuICAvL1xuICAvLyBDb21waWxlIHBvc3Rwb25lZCBhbGlhc2VzXG4gIC8vXG5cbiAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgIGlmICghc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dKSB7XG4gICAgICAvLyBTaWxlbnRseSBmYWlsIG9uIG1pc3NlZCBzY2hlbWFzIHRvIGF2b2lkIGVycm9ucyBvbiBkaXNhYmxlLlxuICAgICAgLy8gc2NoZW1hRXJyb3IoYWxpYXMsIHNlbGYuX19zY2hlbWFzX19bYWxpYXNdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10udmFsaWRhdGUgPVxuICAgICAgc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dLnZhbGlkYXRlO1xuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS5ub3JtYWxpemUgPVxuICAgICAgc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dLm5vcm1hbGl6ZTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gRmFrZSByZWNvcmQgZm9yIGd1ZXNzZWQgbGlua3NcbiAgLy9cbiAgc2VsZi5fX2NvbXBpbGVkX19bJyddID0geyB2YWxpZGF0ZTogbnVsbCwgbm9ybWFsaXplOiBjcmVhdGVOb3JtYWxpemVyKCkgfTtcblxuICAvL1xuICAvLyBCdWlsZCBzY2hlbWEgY29uZGl0aW9uXG4gIC8vXG4gIHZhciBzbGlzdCA9IE9iamVjdC5rZXlzKHNlbGYuX19jb21waWxlZF9fKVxuICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBkaXNhYmxlZCAmIGZha2Ugc2NoZW1hc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUubGVuZ3RoID4gMCAmJiBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZXNjYXBlUkUpXG4gICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgLy8gKD8hXykgY2F1c2UgMS41eCBzbG93ZG93blxuICBzZWxmLnJlLnNjaGVtYV90ZXN0ICAgPSBSZWdFeHAoJyhefCg/IV8pKD86Wz48XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2knKTtcbiAgc2VsZi5yZS5zY2hlbWFfc2VhcmNoID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpZycpO1xuXG4gIHNlbGYucmUucHJldGVzdCAgICAgICA9IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzZWxmLnJlLnNjaGVtYV90ZXN0LnNvdXJjZSArICcpfCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNlbGYucmUuaG9zdF9mdXp6eV90ZXN0LnNvdXJjZSArICcpfCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaScpO1xuXG4gIC8vXG4gIC8vIENsZWFudXBcbiAgLy9cblxuICByZXNldFNjYW5DYWNoZShzZWxmKTtcbn1cblxuLyoqXG4gKiBjbGFzcyBNYXRjaFxuICpcbiAqIE1hdGNoIHJlc3VsdC4gU2luZ2xlIGVsZW1lbnQgb2YgYXJyYXksIHJldHVybmVkIGJ5IFtbTGlua2lmeUl0I21hdGNoXV1cbiAqKi9cbmZ1bmN0aW9uIE1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBzdGFydCA9IHNlbGYuX19pbmRleF9fLFxuICAgICAgZW5kICAgPSBzZWxmLl9fbGFzdF9pbmRleF9fLFxuICAgICAgdGV4dCAgPSBzZWxmLl9fdGV4dF9jYWNoZV9fLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIC8qKlxuICAgKiBNYXRjaCNzY2hlbWEgLT4gU3RyaW5nXG4gICAqXG4gICAqIFByZWZpeCAocHJvdG9jb2wpIGZvciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnNjaGVtYSAgICA9IHNlbGYuX19zY2hlbWFfXy50b0xvd2VyQ2FzZSgpO1xuICAvKipcbiAgICogTWF0Y2gjaW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIEZpcnN0IHBvc2l0aW9uIG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMuaW5kZXggICAgID0gc3RhcnQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI2xhc3RJbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogTmV4dCBwb3NpdGlvbiBhZnRlciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmxhc3RJbmRleCA9IGVuZCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjcmF3IC0+IFN0cmluZ1xuICAgKlxuICAgKiBNYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnJhdyAgICAgICA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN0ZXh0IC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3RtYWxpemVkIHRleHQgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy50ZXh0ICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdXJsIC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3JtYWxpemVkIHVybCBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnVybCAgICAgICA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBtYXRjaCA9IG5ldyBNYXRjaChzZWxmLCBzaGlmdCk7XG5cbiAgc2VsZi5fX2NvbXBpbGVkX19bbWF0Y2guc2NoZW1hXS5ub3JtYWxpemUobWF0Y2gsIHNlbGYpO1xuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuXG4vKipcbiAqIGNsYXNzIExpbmtpZnlJdFxuICoqL1xuXG4vKipcbiAqIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucylcbiAqIC0gc2NoZW1hcyAoT2JqZWN0KTogT3B0aW9uYWwuIEFkZGl0aW9uYWwgc2NoZW1hcyB0byB2YWxpZGF0ZSAocHJlZml4L3ZhbGlkYXRvcilcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogeyBmdXp6eUxpbmt8ZnV6enlFbWFpbHxmdXp6eUlQOiB0cnVlfGZhbHNlIH1cbiAqXG4gKiBDcmVhdGVzIG5ldyBsaW5raWZpZXIgaW5zdGFuY2Ugd2l0aCBvcHRpb25hbCBhZGRpdGlvbmFsIHNjaGVtYXMuXG4gKiBDYW4gYmUgY2FsbGVkIHdpdGhvdXQgYG5ld2Aga2V5d29yZCBmb3IgY29udmVuaWVuY2UuXG4gKlxuICogQnkgZGVmYXVsdCB1bmRlcnN0YW5kczpcbiAqXG4gKiAtIGBodHRwKHMpOi8vLi4uYCAsIGBmdHA6Ly8uLi5gLCBgbWFpbHRvOi4uLmAgJiBgLy8uLi5gIGxpbmtzXG4gKiAtIFwiZnV6enlcIiBsaW5rcyBhbmQgZW1haWxzIChleGFtcGxlLmNvbSwgZm9vQGJhci5jb20pLlxuICpcbiAqIGBzY2hlbWFzYCBpcyBhbiBvYmplY3QsIHdoZXJlIGVhY2gga2V5L3ZhbHVlIGRlc2NyaWJlcyBwcm90b2NvbC9ydWxlOlxuICpcbiAqIC0gX19rZXlfXyAtIGxpbmsgcHJlZml4ICh1c3VhbGx5LCBwcm90b2NvbCBuYW1lIHdpdGggYDpgIGF0IHRoZSBlbmQsIGBza3lwZTpgXG4gKiAgIGZvciBleGFtcGxlKS4gYGxpbmtpZnktaXRgIG1ha2VzIHNodXJlIHRoYXQgcHJlZml4IGlzIG5vdCBwcmVjZWVkZWQgd2l0aFxuICogICBhbHBoYW51bWVyaWMgY2hhciBhbmQgc3ltYm9scy4gT25seSB3aGl0ZXNwYWNlcyBhbmQgcHVuY3R1YXRpb24gYWxsb3dlZC5cbiAqIC0gX192YWx1ZV9fIC0gcnVsZSB0byBjaGVjayB0YWlsIGFmdGVyIGxpbmsgcHJlZml4XG4gKiAgIC0gX1N0cmluZ18gLSBqdXN0IGFsaWFzIHRvIGV4aXN0aW5nIHJ1bGVcbiAqICAgLSBfT2JqZWN0X1xuICogICAgIC0gX3ZhbGlkYXRlXyAtIHZhbGlkYXRvciBmdW5jdGlvbiAoc2hvdWxkIHJldHVybiBtYXRjaGVkIGxlbmd0aCBvbiBzdWNjZXNzKSxcbiAqICAgICAgIG9yIGBSZWdFeHBgLlxuICogICAgIC0gX25vcm1hbGl6ZV8gLSBvcHRpb25hbCBmdW5jdGlvbiB0byBub3JtYWxpemUgdGV4dCAmIHVybCBvZiBtYXRjaGVkIHJlc3VsdFxuICogICAgICAgKGZvciBleGFtcGxlLCBmb3IgQHR3aXR0ZXIgbWVudGlvbnMpLlxuICpcbiAqIGBvcHRpb25zYDpcbiAqXG4gKiAtIF9fZnV6enlMaW5rX18gLSByZWNvZ25pZ2UgVVJMLXMgd2l0aG91dCBgaHR0cChzKTpgIHByZWZpeC4gRGVmYXVsdCBgdHJ1ZWAuXG4gKiAtIF9fZnV6enlJUF9fIC0gYWxsb3cgSVBzIGluIGZ1enp5IGxpbmtzIGFib3ZlLiBDYW4gY29uZmxpY3Qgd2l0aCBzb21lIHRleHRzXG4gKiAgIGxpa2UgdmVyc2lvbiBudW1iZXJzLiBEZWZhdWx0IGBmYWxzZWAuXG4gKiAtIF9fZnV6enlFbWFpbF9fIC0gcmVjb2duaXplIGVtYWlscyB3aXRob3V0IGBtYWlsdG86YCBwcmVmaXguXG4gKlxuICoqL1xuZnVuY3Rpb24gTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmtpZnlJdCkpIHtcbiAgICByZXR1cm4gbmV3IExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmIChpc09wdGlvbnNPYmooc2NoZW1hcykpIHtcbiAgICAgIG9wdGlvbnMgPSBzY2hlbWFzO1xuICAgICAgc2NoZW1hcyA9IHt9O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX19vcHRzX18gICAgICAgICAgID0gYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgLy8gQ2FjaGUgbGFzdCB0ZXN0ZWQgcmVzdWx0LiBVc2VkIHRvIHNraXAgcmVwZWF0aW5nIHN0ZXBzIG9uIG5leHQgYG1hdGNoYCBjYWxsLlxuICB0aGlzLl9faW5kZXhfXyAgICAgICAgICA9IC0xO1xuICB0aGlzLl9fbGFzdF9pbmRleF9fICAgICA9IC0xOyAvLyBOZXh0IHNjYW4gcG9zaXRpb25cbiAgdGhpcy5fX3NjaGVtYV9fICAgICAgICAgPSAnJztcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyAgICAgPSAnJztcblxuICB0aGlzLl9fc2NoZW1hc19fICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdFNjaGVtYXMsIHNjaGVtYXMpO1xuICB0aGlzLl9fY29tcGlsZWRfXyAgICAgICA9IHt9O1xuXG4gIHRoaXMuX190bGRzX18gICAgICAgICAgID0gdGxkc19kZWZhdWx0O1xuICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fICA9IGZhbHNlO1xuXG4gIHRoaXMucmUgPSB7fTtcblxuICBjb21waWxlKHRoaXMpO1xufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNhZGQoc2NoZW1hLCBkZWZpbml0aW9uKVxuICogLSBzY2hlbWEgKFN0cmluZyk6IHJ1bGUgbmFtZSAoZml4ZWQgcGF0dGVybiBwcmVmaXgpXG4gKiAtIGRlZmluaXRpb24gKFN0cmluZ3xSZWdFeHB8T2JqZWN0KTogc2NoZW1hIGRlZmluaXRpb25cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgZGVmaW5pdGlvbi4gU2VlIGNvbnN0cnVjdG9yIGRlc2NyaXB0aW9uIGZvciBkZXRhaWxzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoc2NoZW1hLCBkZWZpbml0aW9uKSB7XG4gIHRoaXMuX19zY2hlbWFzX19bc2NoZW1hXSA9IGRlZmluaXRpb247XG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjc2V0KG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogU2V0IHJlY29nbml0aW9uIG9wdGlvbnMgZm9yIGxpbmtzIHdpdGhvdXQgc2NoZW1hLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICB0aGlzLl9fb3B0c19fID0gYXNzaWduKHRoaXMuX19vcHRzX18sIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdCh0ZXh0KSAtPiBCb29sZWFuXG4gKlxuICogU2VhcmNoZXMgbGlua2lmaWFibGUgcGF0dGVybiBhbmQgcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2VzcyBvciBgZmFsc2VgIG9uIGZhaWwuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHRleHQpIHtcbiAgLy8gUmVzZXQgc2NhbiBjYWNoZVxuICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gdGV4dDtcbiAgdGhpcy5fX2luZGV4X18gICAgICA9IC0xO1xuXG4gIGlmICghdGV4dC5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdmFyIG0sIG1sLCBtZSwgbGVuLCBzaGlmdCwgbmV4dCwgcmUsIHRsZF9wb3MsIGF0X3BvcztcblxuICAvLyB0cnkgdG8gc2NhbiBmb3IgbGluayB3aXRoIHNjaGVtYSAtIHRoYXQncyB0aGUgbW9zdCBzaW1wbGUgcnVsZVxuICBpZiAodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KHRleHQpKSB7XG4gICAgcmUgPSB0aGlzLnJlLnNjaGVtYV9zZWFyY2g7XG4gICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG0gPSByZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dCwgbVsyXSwgcmUubGFzdEluZGV4KTtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9IG1bMl07XG4gICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBtLmluZGV4ICsgbVsxXS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtLmluZGV4ICsgbVswXS5sZW5ndGggKyBsZW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5TGluayAmJiB0aGlzLl9fY29tcGlsZWRfX1snaHR0cDonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgbGlua3NcbiAgICB0bGRfcG9zID0gdGV4dC5zZWFyY2godGhpcy5yZS5ob3N0X2Z1enp5X3Rlc3QpO1xuICAgIGlmICh0bGRfcG9zID49IDApIHtcbiAgICAgIC8vIGlmIHRsZCBpcyBsb2NhdGVkIGFmdGVyIGZvdW5kIGxpbmsgLSBubyBuZWVkIHRvIGNoZWNrIGZ1enp5IHBhdHRlcm5cbiAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgdGxkX3BvcyA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgIGlmICgobWwgPSB0ZXh0Lm1hdGNoKHRoaXMuX19vcHRzX18uZnV6enlJUCA/IHRoaXMucmUubGlua19mdXp6eSA6IHRoaXMucmUubGlua19ub19pcF9mdXp6eSkpICE9PSBudWxsKSB7XG5cbiAgICAgICAgICBzaGlmdCA9IG1sLmluZGV4ICsgbWxbMV0ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJyc7XG4gICAgICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gc2hpZnQ7XG4gICAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbWwuaW5kZXggKyBtbFswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlFbWFpbCAmJiB0aGlzLl9fY29tcGlsZWRfX1snbWFpbHRvOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBlbWFpbHNcbiAgICBhdF9wb3MgPSB0ZXh0LmluZGV4T2YoJ0AnKTtcbiAgICBpZiAoYXRfcG9zID49IDApIHtcbiAgICAgIC8vIFdlIGNhbid0IHNraXAgdGhpcyBjaGVjaywgYmVjYXVzZSB0aGlzIGNhc2VzIGFyZSBwb3NzaWJsZTpcbiAgICAgIC8vIDE5Mi4xNjguMS4xQGdtYWlsLmNvbSwgbXkuaW5AZXhhbXBsZS5jb21cbiAgICAgIGlmICgobWUgPSB0ZXh0Lm1hdGNoKHRoaXMucmUuZW1haWxfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgIHNoaWZ0ID0gbWUuaW5kZXggKyBtZVsxXS5sZW5ndGg7XG4gICAgICAgIG5leHQgID0gbWUuaW5kZXggKyBtZVswXS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fIHx8XG4gICAgICAgICAgICAoc2hpZnQgPT09IHRoaXMuX19pbmRleF9fICYmIG5leHQgPiB0aGlzLl9fbGFzdF9pbmRleF9fKSkge1xuICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSAnbWFpbHRvOic7XG4gICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX19pbmRleF9fID49IDA7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3ByZXRlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFZlcnkgcXVpY2sgY2hlY2ssIHRoYXQgY2FuIGdpdmUgZmFsc2UgcG9zaXRpdmVzLiBSZXR1cm5zIHRydWUgaWYgbGluayBNQVkgQkVcbiAqIGNhbiBleGlzdHMuIENhbiBiZSB1c2VkIGZvciBzcGVlZCBvcHRpbWl6YXRpb24sIHdoZW4geW91IG5lZWQgdG8gY2hlY2sgdGhhdFxuICogbGluayBOT1QgZXhpc3RzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5wcmV0ZXN0ID0gZnVuY3Rpb24gcHJldGVzdCh0ZXh0KSB7XG4gIHJldHVybiB0aGlzLnJlLnByZXRlc3QudGVzdCh0ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdFNjaGVtYUF0KHRleHQsIG5hbWUsIHBvc2l0aW9uKSAtPiBOdW1iZXJcbiAqIC0gdGV4dCAoU3RyaW5nKTogdGV4dCB0byBzY2FuXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgKHNjaGVtYSkgbmFtZVxuICogLSBwb3NpdGlvbiAoTnVtYmVyKTogdGV4dCBvZmZzZXQgdG8gY2hlY2sgZnJvbVxuICpcbiAqIFNpbWlsYXIgdG8gW1tMaW5raWZ5SXQjdGVzdF1dIGJ1dCBjaGVja3Mgb25seSBzcGVjaWZpYyBwcm90b2NvbCB0YWlsIGV4YWN0bHlcbiAqIGF0IGdpdmVuIHBvc2l0aW9uLiBSZXR1cm5zIGxlbmd0aCBvZiBmb3VuZCBwYXR0ZXJuICgwIG9uIGZhaWwpLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0U2NoZW1hQXQgPSBmdW5jdGlvbiB0ZXN0U2NoZW1hQXQodGV4dCwgc2NoZW1hLCBwb3MpIHtcbiAgLy8gSWYgbm90IHN1cHBvcnRlZCBzY2hlbWEgY2hlY2sgcmVxdWVzdGVkIC0gdGVybWluYXRlXG4gIGlmICghdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXS52YWxpZGF0ZSh0ZXh0LCBwb3MsIHRoaXMpO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNtYXRjaCh0ZXh0KSAtPiBBcnJheXxudWxsXG4gKlxuICogUmV0dXJucyBhcnJheSBvZiBmb3VuZCBsaW5rIGRlc2NyaXB0aW9ucyBvciBgbnVsbGAgb24gZmFpbC4gV2Ugc3Ryb25nbHlcbiAqIHJlY29tbWVuZCB0byB1c2UgW1tMaW5raWZ5SXQjdGVzdF1dIGZpcnN0LCBmb3IgYmVzdCBzcGVlZC5cbiAqXG4gKiAjIyMjIyBSZXN1bHQgbWF0Y2ggZGVzY3JpcHRpb25cbiAqXG4gKiAtIF9fc2NoZW1hX18gLSBsaW5rIHNjaGVtYSwgY2FuIGJlIGVtcHR5IGZvciBmdXp6eSBsaW5rcywgb3IgYC8vYCBmb3JcbiAqICAgcHJvdG9jb2wtbmV1dHJhbCAgbGlua3MuXG4gKiAtIF9faW5kZXhfXyAtIG9mZnNldCBvZiBtYXRjaGVkIHRleHRcbiAqIC0gX19sYXN0SW5kZXhfXyAtIGluZGV4IG9mIG5leHQgY2hhciBhZnRlciBtYXRoY2ggZW5kXG4gKiAtIF9fcmF3X18gLSBtYXRjaGVkIHRleHRcbiAqIC0gX190ZXh0X18gLSBub3JtYWxpemVkIHRleHRcbiAqIC0gX191cmxfXyAtIGxpbmssIGdlbmVyYXRlZCBmcm9tIG1hdGNoZWQgdGV4dFxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHRleHQpIHtcbiAgdmFyIHNoaWZ0ID0gMCwgcmVzdWx0ID0gW107XG5cbiAgLy8gVHJ5IHRvIHRha2UgcHJldmlvdXMgZWxlbWVudCBmcm9tIGNhY2hlLCBpZiAudGVzdCgpIGNhbGxlZCBiZWZvcmVcbiAgaWYgKHRoaXMuX19pbmRleF9fID49IDAgJiYgdGhpcy5fX3RleHRfY2FjaGVfXyA9PT0gdGV4dCkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG4gICAgc2hpZnQgPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgLy8gQ3V0IGhlYWQgaWYgY2FjaGUgd2FzIHVzZWRcbiAgdmFyIHRhaWwgPSBzaGlmdCA/IHRleHQuc2xpY2Uoc2hpZnQpIDogdGV4dDtcblxuICAvLyBTY2FuIHN0cmluZyB1bnRpbCBlbmQgcmVhY2hlZFxuICB3aGlsZSAodGhpcy50ZXN0KHRhaWwpKSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcblxuICAgIHRhaWwgPSB0YWlsLnNsaWNlKHRoaXMuX19sYXN0X2luZGV4X18pO1xuICAgIHNoaWZ0ICs9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3RsZHMobGlzdCBbLCBrZWVwT2xkXSkgLT4gdGhpc1xuICogLSBsaXN0IChBcnJheSk6IGxpc3Qgb2YgdGxkc1xuICogLSBrZWVwT2xkIChCb29sZWFuKTogbWVyZ2Ugd2l0aCBjdXJyZW50IGxpc3QgaWYgYHRydWVgIChgZmFsc2VgIGJ5IGRlZmF1bHQpXG4gKlxuICogTG9hZCAob3IgbWVyZ2UpIG5ldyB0bGRzIGxpc3QuIFRob3NlIGFyZSB1c2VyIGZvciBmdXp6eSBsaW5rcyAod2l0aG91dCBwcmVmaXgpXG4gKiB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMuIEJ5IGRlZmF1bHQgdGhpcyBhbGdvcnl0aG0gdXNlZDpcbiAqXG4gKiAtIGhvc3RuYW1lIHdpdGggYW55IDItbGV0dGVyIHJvb3Qgem9uZXMgYXJlIG9rLlxuICogLSBiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhFxuICogICBhcmUgb2suXG4gKiAtIGVuY29kZWQgKGB4bi0tLi4uYCkgcm9vdCB6b25lcyBhcmUgb2suXG4gKlxuICogSWYgbGlzdCBpcyByZXBsYWNlZCwgdGhlbiBleGFjdCBtYXRjaCBmb3IgMi1jaGFycyByb290IHpvbmVzIHdpbGwgYmUgY2hlY2tlZC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGxkcyA9IGZ1bmN0aW9uIHRsZHMobGlzdCwga2VlcE9sZCkge1xuICBsaXN0ID0gQXJyYXkuaXNBcnJheShsaXN0KSA/IGxpc3QgOiBbIGxpc3QgXTtcblxuICBpZiAoIWtlZXBPbGQpIHtcbiAgICB0aGlzLl9fdGxkc19fID0gbGlzdC5zbGljZSgpO1xuICAgIHRoaXMuX190bGRzX3JlcGxhY2VkX18gPSB0cnVlO1xuICAgIGNvbXBpbGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9fdGxkc19fID0gdGhpcy5fX3RsZHNfXy5jb25jYXQobGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwsIGlkeCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwgIT09IGFycltpZHggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG5cbiAgY29tcGlsZSh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpbmtpZnlJdCNub3JtYWxpemUobWF0Y2gpXG4gKlxuICogRGVmYXVsdCBub3JtYWxpemVyIChpZiBzY2hlbWEgZG9lcyBub3QgZGVmaW5lIGl0J3Mgb3duKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1hdGNoKSB7XG5cbiAgLy8gRG8gbWluaW1hbCBwb3NzaWJsZSBjaGFuZ2VzIGJ5IGRlZmF1bHQuIE5lZWQgdG8gY29sbGVjdCBmZWVkYmFjayBwcmlvclxuICAvLyB0byBtb3ZlIGZvcndhcmQgaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQvaXNzdWVzLzFcblxuICBpZiAoIW1hdGNoLnNjaGVtYSkgeyBtYXRjaC51cmwgPSAnaHR0cDovLycgKyBtYXRjaC51cmw7IH1cblxuICBpZiAobWF0Y2guc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QobWF0Y2gudXJsKSkge1xuICAgIG1hdGNoLnVybCA9ICdtYWlsdG86JyArIG1hdGNoLnVybDtcbiAgfVxufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNvbkNvbXBpbGUoKVxuICpcbiAqIE92ZXJyaWRlIHRvIG1vZGlmeSBiYXNpYyBSZWdFeHAtcy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUub25Db21waWxlID0gZnVuY3Rpb24gb25Db21waWxlKCkge1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtpZnlJdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbGlua2lmeS1pdC9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciByZSA9IHt9O1xuXG4gIC8vIFVzZSBkaXJlY3QgZXh0cmFjdCBpbnN0ZWFkIG9mIGByZWdlbmVyYXRlYCB0byByZWR1c2UgYnJvd3NlcmlmaWVkIHNpemVcbiAgcmUuc3JjX0FueSA9IHJlcXVpcmUoJ3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfQ2MgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1ogICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1AgICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpLnNvdXJjZTtcblxuICAvLyBcXHB7XFxaXFxQXFxDY1xcQ0Z9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sICsgZm9ybWF0ICsgcHVuY3R1YXRpb24pXG4gIHJlLnNyY19aUENjID0gWyByZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBcXHB7XFxaXFxDY30gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wpXG4gIHJlLnNyY19aQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gRXhwZXJpbWVudGFsLiBMaXN0IG9mIGNoYXJzLCBjb21wbGV0ZWx5IHByb2hpYml0ZWQgaW4gbGlua3NcbiAgLy8gYmVjYXVzZSBjYW4gc2VwYXJhdGUgaXQgZnJvbSBvdGhlciBwYXJ0IG9mIHRleHRcbiAgdmFyIHRleHRfc2VwYXJhdG9ycyA9ICdbPjxcXHVmZjVjXSc7XG5cbiAgLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcbiAgLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxuICAvLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXG4gIHJlLnNyY19wc2V1ZG9fbGV0dGVyICAgICAgID0gJyg/Oig/IScgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArIHJlLnNyY19BbnkgKyAnKSc7XG4gIC8vIFRoZSBzYW1lIGFzIGFib3RoZSBidXQgd2l0aG91dCBbMC05XVxuICAvLyB2YXIgc3JjX3BzZXVkb19sZXR0ZXJfbm9uX2QgPSAnKD86KD8hWzAtOV18JyArIHNyY19aUENjICsgJyknICsgc3JjX0FueSArICcpJztcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHJlLnNyY19pcDQgPVxuXG4gICAgJyg/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPyknO1xuXG4gIC8vIFByb2hpYml0IGFueSBvZiBcIkAvW10oKVwiIGluIHVzZXIvcGFzcyB0byBhdm9pZCB3cm9uZyBkb21haW4gZmV0Y2guXG4gIHJlLnNyY19hdXRoICAgID0gJyg/Oig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbQC9cXFxcW1xcXFxdKCldKS4pK0ApPyc7XG5cbiAgcmUuc3JjX3BvcnQgPVxuXG4gICAgJyg/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpPyc7XG5cbiAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9XG5cbiAgICAnKD89JHwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgcmUuc3JjX1pQQ2MgKyAnKSknO1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtXSkufCcgK1xuICAgICAgICAgICdcXFxcWyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xcXFxcXSkuKSpcXFxcXXwnICtcbiAgICAgICAgICAnXFxcXCgoPzooPyEnICsgcmUuc3JjX1pDYyArICd8WyldKS4pKlxcXFwpfCcgK1xuICAgICAgICAgICdcXFxceyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18JyArXG4gICAgICAgICAgJ1xcXFxcIig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbXCJdKS4pK1xcXFxcInwnICtcbiAgICAgICAgICBcIlxcXFwnKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyddKS4pK1xcXFwnfFwiICtcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKS58JyArICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICAnXFxcXC57MiwzfVthLXpBLVowLTklL118JyArIC8vIGdpdGh1YiBoYXMgLi4uIGluIGNvbW1pdCByYW5nZSBsaW5rcy4gUmVzdHJpY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGVuZ2xpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBlcmNlbnQtZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGFydHMgb2YgZmlsZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgbW9yZSBleGFtcGxlcyBmb3VuZC5cbiAgICAgICAgICAnXFxcXC4oPyEnICsgcmUuc3JjX1pDYyArICd8Wy5dKS58JyArXG4gICAgICAgICAgKG9wdHMgJiYgb3B0c1snLS0tJ10gP1xuICAgICAgICAgICAgJ1xcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXwnIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXG4gICAgICAgICAgOlxuICAgICAgICAgICAgJ1xcXFwtK3wnXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ1xcXFwsKD8hJyArIHJlLnNyY19aQ2MgKyAnKS58JyArICAgICAgLy8gYWxsb3cgYCwsLGAgaW4gcGF0aHNcbiAgICAgICAgICAnXFxcXCEoPyEnICsgcmUuc3JjX1pDYyArICd8WyFdKS58JyArXG4gICAgICAgICAgJ1xcXFw/KD8hJyArIHJlLnNyY19aQ2MgKyAnfFs/XSkuJyArXG4gICAgICAgICcpKycgK1xuICAgICAgJ3xcXFxcLycgK1xuICAgICcpPyc7XG5cbiAgcmUuc3JjX2VtYWlsX25hbWUgPVxuXG4gICAgJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFxcIlxcXFwuYS16QS1aMC05X10rJztcblxuICByZS5zcmNfeG4gPVxuXG4gICAgJ3huLS1bYS16MC05XFxcXC1dezEsNTl9JztcblxuICAvLyBNb3JlIHRvIHJlYWQgYWJvdXQgZG9tYWluIG5hbWVzXG4gIC8vIGh0dHA6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzYzODI2MC9cblxuICByZS5zcmNfZG9tYWluX3Jvb3QgPVxuXG4gICAgLy8gQWxsb3cgbGV0dGVycyAmIGRpZ2l0cyAoaHR0cDovL3Rlc3QxKVxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnezEsNjN9JyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19kb21haW4gPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAgICd8JyArXG4gICAgICAvLyBkb24ndCBhbGxvdyBgLS1gIGluIGRvbWFpbiBuYW1lcywgYmVjYXVzZTpcbiAgICAgIC8vIC0gdGhhdCBjYW4gY29uZmxpY3Qgd2l0aCBtYXJrZG93biAmbWRhc2g7IC8gJm5kYXNoO1xuICAgICAgLy8gLSBub2JvZHkgdXNlIHRob3NlIGFueXdheVxuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcoPzotKD8hLSl8JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyl7MCw2MX0nICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICcpJztcblxuICByZS5zcmNfaG9zdCA9XG5cbiAgICAnKD86JyArXG4gICAgLy8gRG9uJ3QgbmVlZCBJUCBjaGVjaywgYmVjYXVzZSBkaWdpdHMgYXJlIGFscmVhZHkgYWxsb3dlZCBpbiBub3JtYWwgZG9tYWluIG5hbWVzXG4gICAgLy8gICBzcmNfaXA0ICtcbiAgICAvLyAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikqJyArIHJlLnNyY19kb21haW4vKl9yb290Ki8gKyAnKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9mdXp6eSA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfaXA0ICtcbiAgICAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgPVxuXG4gICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknO1xuXG4gIHJlLnNyY19ob3N0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS5zcmNfaG9zdF9wb3J0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE1haW4gcnVsZXNcblxuICAvLyBSdWRlIHRlc3QgZnV6enkgbGlua3MgYnkgaG9zdCwgZm9yIHF1aWNrIGRlbnlcbiAgcmUudHBsX2hvc3RfZnV6enlfdGVzdCA9XG5cbiAgICAnbG9jYWxob3N0fHd3d1xcXFwufFxcXFwuXFxcXGR7MSwzfVxcXFwufCg/OlxcXFwuKD86JVRMRFMlKSg/OicgKyByZS5zcmNfWlBDYyArICd8PnwkKSknO1xuXG4gIHJlLnRwbF9lbWFpbF9mdXp6eSA9XG5cbiAgICAgICcoXnwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xcXFxcKHwnICsgcmUuc3JjX1pDYyArICcpKCcgKyByZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCArICcpJztcblxuICByZS50cGxfbGlua19mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZS50cGxfbGlua19ub19pcF9mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZXR1cm4gcmU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2xpYi9yZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9pbmRleC5qcyIsIi8vIExpc3Qgb2YgdmFsaWQgaHRtbCBibG9ja3MgbmFtZXMsIGFjY29ydGluZyB0byBjb21tb25tYXJrIHNwZWNcbi8vIGh0dHA6Ly9qZ20uZ2l0aHViLmlvL0NvbW1vbk1hcmsvc3BlYy5odG1sI2h0bWwtYmxvY2tzXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2FkZHJlc3MnLFxuICAnYXJ0aWNsZScsXG4gICdhc2lkZScsXG4gICdiYXNlJyxcbiAgJ2Jhc2Vmb250JyxcbiAgJ2Jsb2NrcXVvdGUnLFxuICAnYm9keScsXG4gICdjYXB0aW9uJyxcbiAgJ2NlbnRlcicsXG4gICdjb2wnLFxuICAnY29sZ3JvdXAnLFxuICAnZGQnLFxuICAnZGV0YWlscycsXG4gICdkaWFsb2cnLFxuICAnZGlyJyxcbiAgJ2RpdicsXG4gICdkbCcsXG4gICdkdCcsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdmcmFtZScsXG4gICdmcmFtZXNldCcsXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICdoZWFkJyxcbiAgJ2hlYWRlcicsXG4gICdocicsXG4gICdodG1sJyxcbiAgJ2lmcmFtZScsXG4gICdsZWdlbmQnLFxuICAnbGknLFxuICAnbGluaycsXG4gICdtYWluJyxcbiAgJ21lbnUnLFxuICAnbWVudWl0ZW0nLFxuICAnbWV0YScsXG4gICduYXYnLFxuICAnbm9mcmFtZXMnLFxuICAnb2wnLFxuICAnb3B0Z3JvdXAnLFxuICAnb3B0aW9uJyxcbiAgJ3AnLFxuICAncGFyYW0nLFxuICAncHJlJyxcbiAgJ3NlY3Rpb24nLFxuICAnc291cmNlJyxcbiAgJ3RpdGxlJyxcbiAgJ3N1bW1hcnknLFxuICAndGFibGUnLFxuICAndGJvZHknLFxuICAndGQnLFxuICAndGZvb3QnLFxuICAndGgnLFxuICAndGhlYWQnLFxuICAndGl0bGUnLFxuICAndHInLFxuICAndHJhY2snLFxuICAndWwnXG5dO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzIiwiLy8gSnVzdCBhIHNob3J0Y3V0IGZvciBidWxrIGV4cG9ydFxuJ3VzZSBzdHJpY3QnO1xuXG5cbmV4cG9ydHMucGFyc2VMaW5rTGFiZWwgICAgICAgPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfbGFiZWwnKTtcbmV4cG9ydHMucGFyc2VMaW5rRGVzdGluYXRpb24gPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfZGVzdGluYXRpb24nKTtcbmV4cG9ydHMucGFyc2VMaW5rVGl0bGUgICAgICAgPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfdGl0bGUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCIvLyBQYXJzZSBsaW5rIGRlc3RpbmF0aW9uXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1NwYWNlICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsIGxldmVsLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgzQyAvKiA8ICovKSB7XG4gICAgcG9zKys7XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoY29kZSA9PT0gMHgwQSAvKiBcXG4gKi8gfHwgaXNTcGFjZShjb2RlKSkgeyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICBpZiAoY29kZSA9PT0gMHgzRSAvKiA+ICovKSB7XG4gICAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgLy8gbm8gY2xvc2luZyAnPidcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gdGhpcyBzaG91bGQgYmUgLi4uIH0gZWxzZSB7IC4uLiBicmFuY2hcblxuICBsZXZlbCA9IDA7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjb2RlID09PSAweDIwKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBhc2NpaSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDB4MjAgfHwgY29kZSA9PT0gMHg3RikgeyBicmVhazsgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovKSB7XG4gICAgICBsZXZlbCsrO1xuICAgICAgaWYgKGxldmVsID4gMSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI5IC8qICkgKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICByZXN1bHQucG9zID0gcG9zO1xuICByZXN1bHQub2sgPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIi8vIFBhcnNlIGxpbmsgbGFiZWxcbi8vXG4vLyB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgKFwiW1wiKSBhbHJlYWR5IG1hdGNoZXM7XG4vLyByZXR1cm5zIHRoZSBlbmQgb2YgdGhlIGxhYmVsXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGFydCwgZGlzYWJsZU5lc3RlZCkge1xuICB2YXIgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsIHByZXZQb3MsXG4gICAgICBsYWJlbEVuZCA9IC0xLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zO1xuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcbiAgbGV2ZWwgPSAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBtYXgpIHtcbiAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZQb3MgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubWQuaW5saW5lLnNraXBUb2tlbihzdGF0ZSk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICBpZiAocHJldlBvcyA9PT0gc3RhdGUucG9zIC0gMSkge1xuICAgICAgICAvLyBpbmNyZWFzZSBsZXZlbCBpZiB3ZSBmaW5kIHRleHQgYFtgLCB3aGljaCBpcyBub3QgYSBwYXJ0IG9mIGFueSB0b2tlblxuICAgICAgICBsZXZlbCsrO1xuICAgICAgfSBlbHNlIGlmIChkaXNhYmxlTmVzdGVkKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZCkge1xuICAgIGxhYmVsRW5kID0gc3RhdGUucG9zO1xuICB9XG5cbiAgLy8gcmVzdG9yZSBvbGQgc3RhdGVcbiAgc3RhdGUucG9zID0gb2xkUG9zO1xuXG4gIHJldHVybiBsYWJlbEVuZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCIvLyBQYXJzZSBsaW5rIHRpdGxlXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSxcbiAgICAgIG1hcmtlcixcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIG1hcmtlciA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHgyMiAvKiBcIiAqLyAmJiBtYXJrZXIgIT09IDB4MjcgLyogJyAqLyAmJiBtYXJrZXIgIT09IDB4MjggLyogKCAqLykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcG9zKys7XG5cbiAgLy8gaWYgb3BlbmluZyBtYXJrZXIgaXMgXCIoXCIsIHN3aXRjaCBpdCB0byBjbG9zaW5nIG1hcmtlciBcIilcIlxuICBpZiAobWFya2VyID09PSAweDI4KSB7IG1hcmtlciA9IDB4Mjk7IH1cblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCIvLyBNYWluIHBhcnNlciBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG52YXIgaGVscGVycyAgICAgID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcbnZhciBtZHVybCAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xudmFyIHB1bnljb2RlICAgICA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGNvbmZpZyA9IHtcbiAgJ2RlZmF1bHQnOiByZXF1aXJlKCcuL3ByZXNldHMvZGVmYXVsdCcpLFxuICB6ZXJvOiByZXF1aXJlKCcuL3ByZXNldHMvemVybycpLFxuICBjb21tb25tYXJrOiByZXF1aXJlKCcuL3ByZXNldHMvY29tbW9ubWFyaycpXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vIFRoaXMgdmFsaWRhdG9yIGNhbiBwcm9oaWJpdCBtb3JlIHRoYW4gcmVhbGx5IG5lZWRlZCB0byBwcmV2ZW50IFhTUy4gSXQncyBhXG4vLyB0cmFkZW9mZiB0byBrZWVwIGNvZGUgc2ltcGxlIGFuZCB0byBiZSBzZWN1cmUgYnkgZGVmYXVsdC5cbi8vXG4vLyBJZiB5b3UgbmVlZCBkaWZmZXJlbnQgc2V0dXAgLSBvdmVycmlkZSB2YWxpZGF0b3IgbWV0aG9kIGFzIHlvdSB3aXNoLiBPclxuLy8gcmVwbGFjZSBpdCB3aXRoIGR1bW15IGZ1bmN0aW9uIGFuZCB1c2UgZXh0ZXJuYWwgc2FuaXRpemVyLlxuLy9cblxudmFyIEJBRF9QUk9UT19SRSA9IC9eKHZic2NyaXB0fGphdmFzY3JpcHR8ZmlsZXxkYXRhKTovO1xudmFyIEdPT0RfREFUQV9SRSA9IC9eZGF0YTppbWFnZVxcLyhnaWZ8cG5nfGpwZWd8d2VicCk7LztcblxuZnVuY3Rpb24gdmFsaWRhdGVMaW5rKHVybCkge1xuICAvLyB1cmwgc2hvdWxkIGJlIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludCwgYW5kIGV4aXN0aW5nIGVudGl0aWVzIGFyZSBkZWNvZGVkXG4gIHZhciBzdHIgPSB1cmwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIEJBRF9QUk9UT19SRS50ZXN0KHN0cikgPyAoR09PRF9EQVRBX1JFLnRlc3Qoc3RyKSA/IHRydWUgOiBmYWxzZSkgOiB0cnVlO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBSRUNPREVfSE9TVE5BTUVfRk9SID0gWyAnaHR0cDonLCAnaHR0cHM6JywgJ21haWx0bzonIF07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmsodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvVW5pY29kZShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBNYXJrZG93bkl0XG4gKlxuICogTWFpbiBwYXJzZXIvcmVuZGVyZXIgY2xhc3MuXG4gKlxuICogIyMjIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XG4gKiB2YXIgTWFya2Rvd25JdCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JyksXG4gKiAgICAgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gbm9kZS5qcywgdGhlIHNhbWUsIGJ1dCB3aXRoIHN1Z2FyOlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxuICogLy8gTm90ZSwgdGhlcmUgYXJlIG5vIGRhc2guXG4gKiB2YXIgbWQgPSB3aW5kb3cubWFya2Rvd25pdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKiBgYGBcbiAqXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSgnX19tYXJrZG93bi1pdF9fIHJ1bGV6eiEnKTtcbiAqIGBgYFxuICoqL1xuXG4vKipcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcbiAqIC0gcHJlc2V0TmFtZSAoU3RyaW5nKTogb3B0aW9uYWwsIGBjb21tb25tYXJrYCAvIGB6ZXJvYFxuICogLSBvcHRpb25zIChPYmplY3QpXG4gKlxuICogQ3JlYXRlcyBwYXJzZXIgaW5zdGFuc2Ugd2l0aCBnaXZlbiBjb25maWcuIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YC5cbiAqXG4gKiAjIyMjIyBwcmVzZXROYW1lXG4gKlxuICogTWFya2Rvd25JdCBwcm92aWRlcyBuYW1lZCBwcmVzZXRzIGFzIGEgY29udmVuaWVuY2UgdG8gcXVpY2tseVxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cbiAqXG4gKiAtIFtcImNvbW1vbm1hcmtcIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQuanMpIC1cbiAqICAgc2ltaWxhciB0byBHRk0sIHVzZWQgd2hlbiBubyBwcmVzZXQgbmFtZSBnaXZlbi4gRW5hYmxlcyBhbGwgYXZhaWxhYmxlIHJ1bGVzLFxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXG4gKiAtIFtcInplcm9cIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL3plcm8uanMpIC1cbiAqICAgYWxsIHJ1bGVzIGRpc2FibGVkLiBVc2VmdWwgdG8gcXVpY2tseSBzZXR1cCB5b3VyIGNvbmZpZyB2aWEgYC5lbmFibGUoKWAuXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiAjIyMjIyBvcHRpb25zOlxuICpcbiAqIC0gX19odG1sX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlLiBCZSBjYXJlZnVsIVxuICogICBUaGF0J3Mgbm90IHNhZmUhIFlvdSBtYXkgbmVlZCBleHRlcm5hbCBzYW5pdGl6ZXIgdG8gcHJvdGVjdCBvdXRwdXQgZnJvbSBYU1MuXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxuICogLSBfX3hodG1sT3V0X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGFkZCAnLycgd2hlbiBjbG9zaW5nIHNpbmdsZSB0YWdzXG4gKiAgIChgPGJyIC8+YCkuIFRoaXMgaXMgbmVlZGVkIG9ubHkgZm9yIGZ1bGwgQ29tbW9uTWFyayBjb21wYXRpYmlsaXR5LiBJbiByZWFsXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXG4gKiAtIF9fYnJlYWtzX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGNvbnZlcnQgYFxcbmAgaW4gcGFyYWdyYXBocyBpbnRvIGA8YnI+YC5cbiAqIC0gX19sYW5nUHJlZml4X18gLSBgbGFuZ3VhZ2UtYC4gQ1NTIGxhbmd1YWdlIGNsYXNzIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrcy5cbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxuICogLSBfX2xpbmtpZnlfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dCB0byBsaW5rcy5cbiAqIC0gX190eXBvZ3JhcGhlcl9fICAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIFtzb21lIGxhbmd1YWdlLW5ldXRyYWxcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcbiAgICAgIHByZXNldE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlcklubGluZV1dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW0NvcmVdXSBjaGFpbiBleGVjdXRvci4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tSZW5kZXJlcl1dLiBVc2UgaXQgdG8gbW9kaWZ5IG91dHB1dCBsb29rLiBPciB0byBhZGQgcmVuZGVyaW5nXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBmdW5jdGlvbiBteVRva2VuKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNlbGYpIHtcbiAgICogICAvLy4uLlxuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH07XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxuICAgKiovXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNsaW5raWZ5IC0+IExpbmtpZnlJdFxuICAgKlxuICAgKiBbbGlua2lmeS1pdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQpIGluc3RhbmNlLlxuICAgKiBVc2VkIGJ5IFtsaW5raWZ5XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcylcbiAgICogcnVsZS5cbiAgICoqL1xuICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdmFsaWRhdGVMaW5rKHVybCkgLT4gQm9vbGVhblxuICAgKlxuICAgKiBMaW5rIHZhbGlkYXRpb24gZnVuY3Rpb24uIENvbW1vbk1hcmsgYWxsb3dzIHRvbyBtdWNoIGluIGxpbmtzLiBCeSBkZWZhdWx0XG4gICAqIHdlIGRpc2FibGUgYGphdmFzY3JpcHQ6YCwgYHZic2NyaXB0OmAsIGBmaWxlOmAgc2NoZW1hcywgYW5kIGFsbW9zdCBhbGwgYGRhdGE6Li4uYCBzY2hlbWFzXG4gICAqIGV4Y2VwdCBzb21lIGVtYmVkZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW91cjpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gICAqIG1kLnZhbGlkYXRlTGluayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICogYGBgXG4gICAqKi9cbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRlY29kZSBsaW5rIHVybCB0byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdGBcbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG5cblxuICAvLyBFeHBvc2UgdXRpbHMgJiBoZWxwZXJzIGZvciBlYXN5IGFjY2VzIGZyb20gcGx1Z2luc1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3V0aWxzIC0+IHV0aWxzXG4gICAqXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvY29tbW9uL3V0aWxzLmpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHM7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXG4gICAqXG4gICAqIExpbmsgY29tcG9uZW50cyBwYXJzZXIgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXG4gICAqKi9cbiAgdGhpcy5oZWxwZXJzID0gdXRpbHMuYXNzaWduKHt9LCBoZWxwZXJzKTtcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKTsgfVxufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlLCBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5jb25maWd1cmUocHJlc2V0cylcbiAqXG4gKiBCYXRjaCBsb2FkIG9mIGFsbCBvcHRpb25zIGFuZCBjb21wZW5lbnQgc2V0dGluZ3MuIFRoaXMgaXMgaW50ZXJuYWwgbWV0aG9kLFxuICogYW5kIHlvdSBwcm9iYWJseSB3aWxsIG5vdCBuZWVkIGl0LiBCdXQgaWYgeW91IHdpdGggLSBzZWUgYXZhaWxhYmxlIHByZXNldHNcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgcHJlc2V0cyBpbnN0ZWFkIG9mIGRpcmVjdCBjb25maWcgbG9hZHMuIFRoYXRcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocHJlc2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHByZXNldHMpKSB7XG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgcHJlc2V0cyA9IGNvbmZpZ1twcmVzZXROYW1lXTtcbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJyk7IH1cbiAgfVxuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0LCBjYW5cXCd0IGJlIGVtcHR5Jyk7IH1cblxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBsaXN0IG9yIHJ1bGVzLiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhcHByb3ByaWF0ZSBjb21wb25lbnRzLFxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxuICogbm90IHNldCAtIHRocm93cyBleGNlcHRpb24uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLmVuYWJsZShbJ3N1YicsICdzdXAnXSlcbiAqICAgICAgICAgICAgIC5kaXNhYmxlKCdzbWFydHF1b3RlcycpO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC51c2UocGx1Z2luLCBwYXJhbXMpXG4gKlxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXG4gKiBJdCdzIGp1c3QgYSBzdWdhciB0byBjYWxsIGBwbHVnaW4obWQsIHBhcmFtcylgIHdpdGggY3VycmluZy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAudXNlKGl0ZXJhdG9yLCAnZm9vX3JlcGxhY2UnLCAndGV4dCcsIGZ1bmN0aW9uICh0b2tlbnMsIGlkeCkge1xuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICogICAgICAgICAgICAgfSk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4gLyosIHBhcmFtcywgLi4uICovKSB7XG4gIHZhciBhcmdzID0gWyB0aGlzIF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFBhcnNlIGlucHV0IHN0cmluZyBhbmQgcmV0dXJucyBsaXN0IG9mIGJsb2NrIHRva2VucyAoc3BlY2lhbCB0b2tlbiB0eXBlXG4gKiBcImlubGluZVwiIHdpbGwgY29udGFpbiBsaXN0IG9mIGlubGluZSB0b2tlbnMpLiBZb3Ugc2hvdWxkIG5vdCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBkaXJlY3RseSwgdW50aWwgeW91IHdyaXRlIGN1c3RvbSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIHRvIHByb2R1Y2VcbiAqIEFTVCkuXG4gKlxuICogYGVudmAgaXMgdXNlZCB0byBwYXNzIGRhdGEgYmV0d2VlbiBcImRpc3RyaWJ1dGVkXCIgcnVsZXMgYW5kIHJldHVybiBhZGRpdGlvbmFsXG4gKiBtZXRhZGF0YSBsaWtlIHJlZmVyZW5jZSBpbmZvLCBuZWVkZWQgZm9yIHRoZSByZW5kZXJlci4gSXQgYWxzbyBjYW4gYmUgdXNlZCB0b1xuICogaW5qZWN0IGRhdGEgaW4gc3BlY2lmaWMgY2FzZXMuIFVzdWFsbHksIHlvdSB3aWxsIGJlIG9rIHRvIHBhc3MgYHt9YCxcbiAqIGFuZCB0aGVuIHBhc3MgdXBkYXRlZCBvYmplY3QgdG8gcmVuZGVyZXIuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nJyk7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcihzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBSZW5kZXIgbWFya2Rvd24gc3RyaW5nIGludG8gaHRtbC4gSXQgZG9lcyBhbGwgbWFnaWMgZm9yIHlvdSA6KS5cbiAqXG4gKiBgZW52YCBjYW4gYmUgdXNlZCB0byBpbmplY3QgYWRkaXRpb25hbCBtZXRhZGF0YSAoYHt9YCBieSBkZWZhdWx0KS5cbiAqIEJ1dCB5b3Ugd2lsbCBub3QgbmVlZCBpdCB3aXRoIGhpZ2ggcHJvYmFiaWxpdHkuIFNlZSBhbHNvIGNvbW1lbnRcbiAqIGluIFtbTWFya2Rvd25JdC5wYXJzZV1dLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlSW5saW5lKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LnBhcnNlXV0gYnV0IHNraXAgYWxsIGJsb2NrIHJ1bGVzLiBJdCByZXR1cm5zIHRoZVxuICogYmxvY2sgdG9rZW5zIGxpc3Qgd2l0aCB0aGUgc2luZ2xlIGBpbmxpbmVgIGVsZW1lbnQsIGNvbnRhaW5pbmcgcGFyc2VkIGlubGluZVxuICogdG9rZW5zIGluIGBjaGlsZHJlbmAgcHJvcGVydHkuIEFsc28gdXBkYXRlcyBgZW52YCBvYmplY3QuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICBzdGF0ZS5pbmxpbmVNb2RlID0gdHJ1ZTtcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXJJbmxpbmUoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogU2ltaWxhciB0byBbW01hcmtkb3duSXQucmVuZGVyXV0gYnV0IGZvciBzaW5nbGUgcGFyYWdyYXBoIGNvbnRlbnQuIFJlc3VsdFxuICogd2lsbCBOT1QgYmUgd3JhcHBlZCBpbnRvIGA8cD5gIHRhZ3MuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlSW5saW5lKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9pbmRleC5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VyQmxvY2tcbiAqXG4gKiBCbG9jay1sZXZlbCB0b2tlbml6ZXIuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICAvLyBGaXJzdCAyIHBhcmFtcyAtIHJ1bGUgbmFtZSAmIHNvdXJjZS4gU2Vjb25kYXJ5IGFycmF5IC0gbGlzdCBvZiBydWxlcyxcbiAgLy8gd2hpY2ggY2FuIGJlIHRlcm1pbmF0ZWQgYnkgdGhpcyBvbmUuXG4gIFsgJ3RhYmxlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3RhYmxlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScgXSBdLFxuICBbICdjb2RlJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9jb2RlJykgXSxcbiAgWyAnZmVuY2UnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZmVuY2UnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdibG9ja3F1b3RlJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ibG9ja3F1b3RlJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnbGlzdCcgXSBdLFxuICBbICdocicsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ocicpLCAgICAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2xpc3QnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xpc3QnKSwgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ3JlZmVyZW5jZScsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZScpIF0sXG4gIFsgJ2hlYWRpbmcnLCAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hlYWRpbmcnKSwgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ2xoZWFkaW5nJywgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xoZWFkaW5nJykgXSxcbiAgWyAnaHRtbF9ibG9jaycsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHRtbF9ibG9jaycpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncGFyYWdyYXBoJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcGFyYWdyYXBoJykgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBQYXJzZXJCbG9jaygpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJCbG9jaygpIHtcbiAgLyoqXG4gICAqIFBhcnNlckJsb2NrI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGJsb2NrIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSwgeyBhbHQ6IChfcnVsZXNbaV1bMl0gfHwgW10pLnNsaWNlKCkgfSk7XG4gIH1cbn1cblxuXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXG4vL1xuUGFyc2VyQmxvY2sucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGxpbmUgPSBzdGFydExpbmUsXG4gICAgICBoYXNFbXB0eUxpbmVzID0gZmFsc2UsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChsaW5lIDwgZW5kTGluZSkge1xuICAgIHN0YXRlLmxpbmUgPSBsaW5lID0gc3RhdGUuc2tpcEVtcHR5TGluZXMobGluZSk7XG4gICAgaWYgKGxpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy8gVGVybWluYXRpb24gY29uZGl0aW9uIGZvciBuZXN0ZWQgY2FsbHMuXG4gICAgLy8gTmVzdGVkIGNhbGxzIGN1cnJlbnRseSB1c2VkIGZvciBibG9ja3F1b3RlcyAmIGxpc3RzXG4gICAgaWYgKHN0YXRlLnNDb3VudFtsaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgLy8gSWYgbmVzdGluZyBsZXZlbCBleGNlZWRlZCAtIHNraXAgdGFpbCB0byB0aGUgZW5kLiBUaGF0J3Mgbm90IG9yZGluYXJ5XG4gICAgLy8gc2l0dWF0aW9uIGFuZCB3ZSBzaG91bGQgbm90IGNhcmUgYWJvdXQgY29udGVudC5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPj0gbWF4TmVzdGluZykge1xuICAgICAgc3RhdGUubGluZSA9IGVuZExpbmU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLmxpbmVgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGxpbmUsIGVuZExpbmUsIGZhbHNlKTtcbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIHNldCBzdGF0ZS50aWdodCBpZmYgd2UgaGFkIGFuIGVtcHR5IGxpbmUgYmVmb3JlIGN1cnJlbnQgdGFnXG4gICAgLy8gaS5lLiBsYXRlc3QgZW1wdHkgbGluZSBzaG91bGQgbm90IGNvdW50XG4gICAgc3RhdGUudGlnaHQgPSAhaGFzRW1wdHlMaW5lcztcblxuICAgIC8vIHBhcmFncmFwaCBtaWdodCBcImVhdFwiIG9uZSBuZXdsaW5lIGFmdGVyIGl0IGluIG5lc3RlZCBsaXN0c1xuICAgIGlmIChzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKSkge1xuICAgICAgaGFzRW1wdHlMaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgbGluZSA9IHN0YXRlLmxpbmU7XG5cbiAgICBpZiAobGluZSA8IGVuZExpbmUgJiYgc3RhdGUuaXNFbXB0eShsaW5lKSkge1xuICAgICAgaGFzRW1wdHlMaW5lcyA9IHRydWU7XG4gICAgICBsaW5lKys7XG4gICAgICBzdGF0ZS5saW5lID0gbGluZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXJzZXJCbG9jay5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBibG9jayB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VyQmxvY2sucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXNyYykgeyByZXR1cm47IH1cblxuICBzdGF0ZSA9IG5ldyB0aGlzLlN0YXRlKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKTtcblxuICB0aGlzLnRva2VuaXplKHN0YXRlLCBzdGF0ZS5saW5lLCBzdGF0ZS5saW5lTWF4KTtcbn07XG5cblxuUGFyc2VyQmxvY2sucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jaycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyQmxvY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIENvcmVcbiAqXG4gKiBUb3AtbGV2ZWwgcnVsZXMgZXhlY3V0b3IuIEdsdWVzIGJsb2NrL2lubGluZSBwYXJzZXJzIGFuZCBkb2VzIGludGVybWVkaWF0ZVxuICogdHJhbnNmb3JtYXRpb25zLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgWyAnbm9ybWFsaXplJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbm9ybWFsaXplJykgICAgICBdLFxuICBbICdibG9jaycsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ibG9jaycpICAgICAgICAgIF0sXG4gIFsgJ2lubGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2lubGluZScpICAgICAgICAgXSxcbiAgWyAnbGlua2lmeScsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbGlua2lmeScpICAgICAgICBdLFxuICBbICdyZXBsYWNlbWVudHMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9yZXBsYWNlbWVudHMnKSAgIF0sXG4gIFsgJ3NtYXJ0cXVvdGVzJywgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzJykgICAgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBDb3JlKClcbiAqKi9cbmZ1bmN0aW9uIENvcmUoKSB7XG4gIC8qKlxuICAgKiBDb3JlI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGNvcmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ29yZS5wcm9jZXNzKHN0YXRlKVxuICpcbiAqIEV4ZWN1dGVzIGNvcmUgY2hhaW4gcnVsZXMuXG4gKiovXG5Db3JlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBpLCBsLCBydWxlcztcblxuICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cbkNvcmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19jb3JlL3N0YXRlX2NvcmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VySW5saW5lXG4gKlxuICogVG9rZW5pemVzIHBhcmFncmFwaCBjb250ZW50LlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFBhcnNlciBydWxlc1xuXG52YXIgX3J1bGVzID0gW1xuICBbICd0ZXh0JywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0JykgXSxcbiAgWyAnbmV3bGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbmV3bGluZScpIF0sXG4gIFsgJ2VzY2FwZScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VzY2FwZScpIF0sXG4gIFsgJ2JhY2t0aWNrcycsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhY2t0aWNrcycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS50b2tlbml6ZSBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnRva2VuaXplIF0sXG4gIFsgJ2xpbmsnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2xpbmsnKSBdLFxuICBbICdpbWFnZScsICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9pbWFnZScpIF0sXG4gIFsgJ2F1dG9saW5rJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2F1dG9saW5rJykgXSxcbiAgWyAnaHRtbF9pbmxpbmUnLCAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUnKSBdLFxuICBbICdlbnRpdHknLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbnRpdHknKSBdXG5dO1xuXG52YXIgX3J1bGVzMiA9IFtcbiAgWyAnYmFsYW5jZV9wYWlycycsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS5wb3N0UHJvY2VzcyBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ3RleHRfY29sbGFwc2UnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlcklubGluZSgpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJJbmxpbmUoKSB7XG4gIHZhciBpO1xuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgaW5saW5lIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gU2Vjb25kIHJ1bGVyIHVzZWQgZm9yIHBvc3QtcHJvY2Vzc2luZ1xuICAgKiAoZS5nLiBpbiBlbXBoYXNpcy1saWtlIHJ1bGVzKS5cbiAgICoqL1xuICB0aGlzLnJ1bGVyMiA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlcjIucHVzaChfcnVsZXMyW2ldWzBdLCBfcnVsZXMyW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8vIFNraXAgc2luZ2xlIHRva2VuIGJ5IHJ1bm5pbmcgYWxsIHJ1bGVzIGluIHZhbGlkYXRpb24gbW9kZTtcbi8vIHJldHVybnMgYHRydWVgIGlmIGFueSBydWxlIHJlcG9ydGVkIHN1Y2Nlc3Ncbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnNraXBUb2tlbiA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgb2ssIGksIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nLFxuICAgICAgY2FjaGUgPSBzdGF0ZS5jYWNoZTtcblxuXG4gIGlmICh0eXBlb2YgY2FjaGVbcG9zXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5wb3MgPSBjYWNoZVtwb3NdO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIEluY3JlbWVudCBzdGF0ZS5sZXZlbCBhbmQgZGVjcmVtZW50IGl0IGxhdGVyIHRvIGxpbWl0IHJlY3Vyc2lvbi5cbiAgICAgIC8vIEl0J3MgaGFybWxlc3MgdG8gZG8gaGVyZSwgYmVjYXVzZSBubyB0b2tlbnMgYXJlIGNyZWF0ZWQuIEJ1dCBpZGVhbGx5LFxuICAgICAgLy8gd2UnZCBuZWVkIGEgc2VwYXJhdGUgcHJpdmF0ZSBzdGF0ZSB2YXJpYWJsZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgLy9cbiAgICAgIHN0YXRlLmxldmVsKys7XG4gICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCB0cnVlKTtcbiAgICAgIHN0YXRlLmxldmVsLS07XG5cbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUb28gbXVjaCBuZXN0aW5nLCBqdXN0IHNraXAgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGFyYWdyYXBoLlxuICAgIC8vXG4gICAgLy8gTk9URTogdGhpcyB3aWxsIGNhdXNlIGxpbmtzIHRvIGJlaGF2ZSBpbmNvcnJlY3RseSBpbiB0aGUgZm9sbG93aW5nIGNhc2UsXG4gICAgLy8gICAgICAgd2hlbiBhbiBhbW91bnQgb2YgYFtgIGlzIGV4YWN0bHkgZXF1YWwgdG8gYG1heE5lc3RpbmcgKyAxYDpcbiAgICAvL1xuICAgIC8vICAgICAgIFtbW1tbW1tbW1tbW1tbW1tbW1tbW2Zvb10oKVxuICAgIC8vXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCB3aGVuIENNIHN0YW5kYXJkIHdpbGwgYWxsb3cgbmVzdGVkIGxpbmtzXG4gICAgLy8gICAgICAgKHdlIGNhbiByZXBsYWNlIGl0IGJ5IHByZXZlbnRpbmcgbGlua3MgZnJvbSBiZWluZyBwYXJzZWQgaW5cbiAgICAvLyAgICAgICB2YWxpZGF0aW9uIG1vZGUpXG4gICAgLy9cbiAgICBzdGF0ZS5wb3MgPSBzdGF0ZS5wb3NNYXg7XG4gIH1cblxuICBpZiAoIW9rKSB7IHN0YXRlLnBvcysrOyB9XG4gIGNhY2hlW3Bvc10gPSBzdGF0ZS5wb3M7XG59O1xuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBlbmQgPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBlbmQpIHtcbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnBvc2BcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvaykge1xuICAgICAgaWYgKHN0YXRlLnBvcyA+PSBlbmQpIHsgYnJlYWs7IH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3N0YXRlLnBvcysrXTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgc3RhdGUucHVzaFBlbmRpbmcoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlcklubGluZS5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBpbmxpbmUgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlcklubGluZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIGksIHJ1bGVzLCBsZW47XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLlN0YXRlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKTtcblxuICB0aGlzLnRva2VuaXplKHN0YXRlKTtcblxuICBydWxlcyA9IHRoaXMucnVsZXIyLmdldFJ1bGVzKCcnKTtcbiAgbGVuID0gcnVsZXMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJJbmxpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwiLy8gQ29tbW9ubWFyayBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICB0cnVlLCAgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICB0cnVlLCAgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdibG9ja3F1b3RlJyxcbiAgICAgICAgJ2NvZGUnLFxuICAgICAgICAnZmVuY2UnLFxuICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICdocicsXG4gICAgICAgICdodG1sX2Jsb2NrJyxcbiAgICAgICAgJ2xoZWFkaW5nJyxcbiAgICAgICAgJ2xpc3QnLFxuICAgICAgICAncmVmZXJlbmNlJyxcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYXV0b2xpbmsnLFxuICAgICAgICAnYmFja3RpY2tzJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ2VudGl0eScsXG4gICAgICAgICdlc2NhcGUnLFxuICAgICAgICAnaHRtbF9pbmxpbmUnLFxuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAnbGluaycsXG4gICAgICAgICduZXdsaW5lJyxcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzIiwiLy8gbWFya2Rvd24taXQgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgZmFsc2UsICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDEwMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHt9LFxuICAgIGJsb2NrOiB7fSxcbiAgICBpbmxpbmU6IHt9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCIvLyBcIlplcm9cIiBwcmVzZXQsIHdpdGggbm90aGluZyBlbmFibGVkLiBVc2VmdWwgZm9yIG1hbnVhbCBjb25maWd1cmluZyBvZiBzaW1wbGVcbi8vIG1vZGVzLiBGb3IgZXhhbXBsZSwgdG8gcGFyc2UgYm9sZC9pdGFsaWMgb25seS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwiLyoqXG4gKiBjbGFzcyBSZW5kZXJlclxuICpcbiAqIEdlbmVyYXRlcyBIVE1MIGZyb20gcGFyc2VkIHRva2VuIHN0cmVhbS4gRWFjaCBpbnN0YW5jZSBoYXMgaW5kZXBlbmRlbnRcbiAqIGNvcHkgb2YgcnVsZXMuIFRob3NlIGNhbiBiZSByZXdyaXR0ZW4gd2l0aCBlYXNlLiBBbHNvLCB5b3UgY2FuIGFkZCBuZXdcbiAqIHJ1bGVzIGlmIHlvdSBjcmVhdGUgcGx1Z2luIGFuZCBhZGRzIG5ldyB0b2tlbiB0eXBlcy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXNzaWduICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5hc3NpZ247XG52YXIgdW5lc2NhcGVBbGwgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcbnZhciBlc2NhcGVIdG1sICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmVzY2FwZUh0bWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmF1bHRfcnVsZXMgPSB7fTtcblxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz4nICtcbiAgICAgICAgICBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICtcbiAgICAgICAgICAnPC9jb2RlPic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9ibG9jayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgcmV0dXJuICAnPHByZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz48Y29kZT4nICtcbiAgICAgICAgICBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICtcbiAgICAgICAgICAnPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuZmVuY2UgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdLFxuICAgICAgaW5mbyA9IHRva2VuLmluZm8gPyB1bmVzY2FwZUFsbCh0b2tlbi5pbmZvKS50cmltKCkgOiAnJyxcbiAgICAgIGxhbmdOYW1lID0gJycsXG4gICAgICBoaWdobGlnaHRlZCwgaSwgdG1wQXR0cnMsIHRtcFRva2VuO1xuXG4gIGlmIChpbmZvKSB7XG4gICAgbGFuZ05hbWUgPSBpbmZvLnNwbGl0KC9cXHMrL2cpWzBdO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBvcHRpb25zLmhpZ2hsaWdodCh0b2tlbi5jb250ZW50LCBsYW5nTmFtZSkgfHwgZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBoaWdobGlnaHRlZCA9IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XG4gIH1cblxuICBpZiAoaGlnaGxpZ2h0ZWQuaW5kZXhPZignPHByZScpID09PSAwKSB7XG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkICsgJ1xcbic7XG4gIH1cblxuICAvLyBJZiBsYW5ndWFnZSBleGlzdHMsIGluamVjdCBjbGFzcyBnZW50bHksIHdpdGhvdXQgbXVkb2Z5aW5nIG9yaWdpbmFsIHRva2VuLlxuICAvLyBNYXkgYmUsIG9uZSBkYXkgd2Ugd2lsbCBhZGQgLmNsb25lKCkgZm9yIHRva2VuIGFuZCBzaW1wbGlmeSB0aGlzIHBhcnQsIGJ1dFxuICAvLyBub3cgd2UgcHJlZmVyIHRvIGtlZXAgdGhpbmdzIGxvY2FsLlxuICBpZiAoaW5mbykge1xuICAgIGkgICAgICAgID0gdG9rZW4uYXR0ckluZGV4KCdjbGFzcycpO1xuICAgIHRtcEF0dHJzID0gdG9rZW4uYXR0cnMgPyB0b2tlbi5hdHRycy5zbGljZSgpIDogW107XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRtcEF0dHJzLnB1c2goWyAnY2xhc3MnLCBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZSBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wQXR0cnNbaV1bMV0gKz0gJyAnICsgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWU7XG4gICAgfVxuXG4gICAgLy8gRmFrZSB0b2tlbiBqdXN0IHRvIHJlbmRlciBhdHRyaWJ1dGVzXG4gICAgdG1wVG9rZW4gPSB7XG4gICAgICBhdHRyczogdG1wQXR0cnNcbiAgICB9O1xuXG4gICAgcmV0dXJuICAnPHByZT48Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG1wVG9rZW4pICsgJz4nXG4gICAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICB9XG5cblxuICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPidcbiAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5pbWFnZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gXCJhbHRcIiBhdHRyIE1VU1QgYmUgc2V0LCBldmVuIGlmIGVtcHR5LiBCZWNhdXNlIGl0J3MgbWFuZGF0b3J5IGFuZFxuICAvLyBzaG91bGQgYmUgcGxhY2VkIG9uIHByb3BlciBwb3NpdGlvbiBmb3IgdGVzdHMuXG4gIC8vXG4gIC8vIFJlcGxhY2UgY29udGVudCB3aXRoIGFjdHVhbCB2YWx1ZVxuXG4gIHRva2VuLmF0dHJzW3Rva2VuLmF0dHJJbmRleCgnYWx0JyldWzFdID1cbiAgICBzbGYucmVuZGVySW5saW5lQXNUZXh0KHRva2VuLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuXG4gIHJldHVybiBzbGYucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmhhcmRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbic7XG59O1xuZGVmYXVsdF9ydWxlcy5zb2Z0YnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy5icmVha3MgPyAob3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nKSA6ICdcXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLnRleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KTtcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5odG1sX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuZGVmYXVsdF9ydWxlcy5odG1sX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xufTtcblxuXG4vKipcbiAqIG5ldyBSZW5kZXJlcigpXG4gKlxuICogQ3JlYXRlcyBuZXcgW1tSZW5kZXJlcl1dIGluc3RhbmNlIGFuZCBmaWxsIFtbUmVuZGVyZXIjcnVsZXNdXSB3aXRoIGRlZmF1bHRzLlxuICoqL1xuZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcmVyI3J1bGVzIC0+IE9iamVjdFxuICAgKlxuICAgKiBDb250YWlucyByZW5kZXIgcnVsZXMgZm9yIHRva2Vucy4gQ2FuIGJlIHVwZGF0ZWQgYW5kIGV4dGVuZGVkLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfb3BlbiAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPGI+JzsgfTtcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX2Nsb3NlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzwvYj4nOyB9O1xuICAgKlxuICAgKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKC4uLik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBFYWNoIHJ1bGUgaXMgY2FsbGVkIGFzIGluZGVwZW5kZWQgc3RhdGljIGZ1bmN0aW9uIHdpdGggZml4ZWQgc2lnbmF0dXJlOlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGZ1bmN0aW9uIG15X3Rva2VuX3JlbmRlcih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCByZW5kZXJlcikge1xuICAgKiAgIC8vIC4uLlxuICAgKiAgIHJldHVybiByZW5kZXJlZEhUTUw7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXMgPSBhc3NpZ24oe30sIGRlZmF1bHRfcnVsZXMpO1xufVxuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyQXR0cnModG9rZW4pIC0+IFN0cmluZ1xuICpcbiAqIFJlbmRlciB0b2tlbiBhdHRyaWJ1dGVzIHRvIHN0cmluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJBdHRycyA9IGZ1bmN0aW9uIHJlbmRlckF0dHJzKHRva2VuKSB7XG4gIHZhciBpLCBsLCByZXN1bHQ7XG5cbiAgaWYgKCF0b2tlbi5hdHRycykgeyByZXR1cm4gJyc7IH1cblxuICByZXN1bHQgPSAnJztcblxuICBmb3IgKGkgPSAwLCBsID0gdG9rZW4uYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMF0pICsgJz1cIicgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzFdKSArICdcIic7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb2YgdG9rZW5zXG4gKiAtIGlkeCAoTnVtYmVkKTogdG9rZW4gaW5kZXggdG8gcmVuZGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqXG4gKiBEZWZhdWx0IHRva2VuIHJlbmRlcmVyLiBDYW4gYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBmdW5jdGlvblxuICogaW4gW1tSZW5kZXJlciNydWxlc11dLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRva2VuID0gZnVuY3Rpb24gcmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIHtcbiAgdmFyIG5leHRUb2tlbixcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbmVlZExmID0gZmFsc2UsXG4gICAgICB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIC8vIFRpZ2h0IGxpc3QgcGFyYWdyYXBoc1xuICBpZiAodG9rZW4uaGlkZGVuKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gSW5zZXJ0IGEgbmV3bGluZSBiZXR3ZWVuIGhpZGRlbiBwYXJhZ3JhcGggYW5kIHN1YnNlcXVlbnQgb3BlbmluZ1xuICAvLyBibG9jay1sZXZlbCB0YWcuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlLCBoZXJlIHdlIHNob3VsZCBpbnNlcnQgYSBuZXdsaW5lIGJlZm9yZSBibG9ja3F1b3RlOlxuICAvLyAgLSBhXG4gIC8vICAgID5cbiAgLy9cbiAgaWYgKHRva2VuLmJsb2NrICYmIHRva2VuLm5lc3RpbmcgIT09IC0xICYmIGlkeCAmJiB0b2tlbnNbaWR4IC0gMV0uaGlkZGVuKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nO1xuICB9XG5cbiAgLy8gQWRkIHRva2VuIG5hbWUsIGUuZy4gYDxpbWdgXG4gIHJlc3VsdCArPSAodG9rZW4ubmVzdGluZyA9PT0gLTEgPyAnPC8nIDogJzwnKSArIHRva2VuLnRhZztcblxuICAvLyBFbmNvZGUgYXR0cmlidXRlcywgZS5nLiBgPGltZyBzcmM9XCJmb29cImBcbiAgcmVzdWx0ICs9IHRoaXMucmVuZGVyQXR0cnModG9rZW4pO1xuXG4gIC8vIEFkZCBhIHNsYXNoIGZvciBzZWxmLWNsb3NpbmcgdGFncywgZS5nLiBgPGltZyBzcmM9XCJmb29cIiAvYFxuICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMCAmJiBvcHRpb25zLnhodG1sT3V0KSB7XG4gICAgcmVzdWx0ICs9ICcgLyc7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGFkZCBhIG5ld2xpbmUgYWZ0ZXIgdGhpcyB0YWdcbiAgaWYgKHRva2VuLmJsb2NrKSB7XG4gICAgbmVlZExmID0gdHJ1ZTtcblxuICAgIGlmICh0b2tlbi5uZXN0aW5nID09PSAxKSB7XG4gICAgICBpZiAoaWR4ICsgMSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dFRva2VuID0gdG9rZW5zW2lkeCArIDFdO1xuXG4gICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSA9PT0gJ2lubGluZScgfHwgbmV4dFRva2VuLmhpZGRlbikge1xuICAgICAgICAgIC8vIEJsb2NrLWxldmVsIHRhZyBjb250YWluaW5nIGFuIGlubGluZSB0YWcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2UgaWYgKG5leHRUb2tlbi5uZXN0aW5nID09PSAtMSAmJiBuZXh0VG9rZW4udGFnID09PSB0b2tlbi50YWcpIHtcbiAgICAgICAgICAvLyBPcGVuaW5nIHRhZyArIGNsb3NpbmcgdGFnIG9mIHRoZSBzYW1lIHR5cGUuIEUuZy4gYDxsaT48L2xpPmAuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCArPSBuZWVkTGYgPyAnPlxcbicgOiAnPic7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmUodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRoZSBzYW1lIGFzIFtbUmVuZGVyZXIucmVuZGVyXV0sIGJ1dCBmb3Igc2luZ2xlIHRva2VuIG9mIGBpbmxpbmVgIHR5cGUuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHQgKz0gcnVsZXNbdHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogUmVuZGVyZXIucmVuZGVySW5saW5lQXNUZXh0KHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBTcGVjaWFsIGtsdWRnZSBmb3IgaW1hZ2UgYGFsdGAgYXR0cmlidXRlcyB0byBjb25mb3JtIENvbW1vbk1hcmsgc3BlYy5cbiAqIERvbid0IHRyeSB0byB1c2UgaXQhIFNwZWMgcmVxdWlyZXMgdG8gc2hvdyBgYWx0YCBjb250ZW50IHdpdGggc3RyaXBwZWQgbWFya3VwLFxuICogaW5zdGVhZCBvZiBzaW1wbGUgZXNjYXBpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lQXNUZXh0ID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbnNbaV0uY29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUYWtlcyB0b2tlbiBzdHJlYW0gYW5kIGdlbmVyYXRlcyBIVE1MLiBQcm9iYWJseSwgeW91IHdpbGwgbmV2ZXIgbmVlZCB0byBjYWxsXG4gKiB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIGksIGxlbiwgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnaW5saW5lJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lKHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qcyIsIi8vIEJsb2NrIHF1b3Rlc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBhZGp1c3RUYWIsXG4gICAgICBjaCxcbiAgICAgIGksXG4gICAgICBpbml0aWFsLFxuICAgICAgaXNPdXRkZW50ZWQsXG4gICAgICBsLFxuICAgICAgbGFzdExpbmVFbXB0eSxcbiAgICAgIGxpbmVzLFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRCTWFya3MsXG4gICAgICBvbGRCU0NvdW50LFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFNDb3VudCxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0b2tlbixcbiAgICAgIG9sZExpbmVNYXggPSBzdGF0ZS5saW5lTWF4LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNoZWNrIHRoZSBibG9jayBxdW90ZSBtYXJrZXJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gd2Uga25vdyB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgYSB2YWxpZCBibG9ja3F1b3RlLFxuICAvLyBzbyBubyBwb2ludCB0cnlpbmcgdG8gZmluZCB0aGUgZW5kIG9mIGl0IGluIHNpbGVudCBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBza2lwIHNwYWNlcyBhZnRlciBcIj5cIiBhbmQgcmUtY2FsY3VsYXRlIG9mZnNldFxuICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyBwb3MgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgLy8gJyA+ICAgdGVzdCAnXG4gICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgIHBvcysrO1xuICAgIGluaXRpYWwrKztcbiAgICBvZmZzZXQrKztcbiAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgaWYgKChzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgLy8gJyAgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICBwb3MrKztcbiAgICAgIGluaXRpYWwrKztcbiAgICAgIG9mZnNldCsrO1xuICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgIC8vICAgICAgICAgdG8gbWFrZSBleHRyYSBzcGFjZSBhcHBlYXJcbiAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgfVxuXG4gIG9sZEJNYXJrcyA9IFsgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gPSBwb3M7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIG9sZEJTQ291bnQgPSBbIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICBvbGRTQ291bnQgPSBbIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICBvbGRUU2hpZnQgPSBbIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2Jsb2NrcXVvdGUnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdibG9ja3F1b3RlJztcblxuICAvLyBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgYmxvY2tcbiAgLy9cbiAgLy8gQmxvY2sgZW5kcyB3aXRoIGVpdGhlcjpcbiAgLy8gIDEuIGFuIGVtcHR5IGxpbmUgb3V0c2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vXG4gIC8vICAgICBgYGBcbiAgLy8gIDIuIGFuIGVtcHR5IGxpbmUgaW5zaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+XG4gIC8vICAgICB0ZXN0XG4gIC8vICAgICBgYGBcbiAgLy8gIDMuIGFub3RoZXIgdGFnOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy8gICAgICAtIC0gLVxuICAvLyAgICAgYGBgXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAxOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAvLyBjaGVjayBpZiBpdCdzIG91dGRlbnRlZCwgaS5lLiBpdCdzIGluc2lkZSBsaXN0IGl0ZW0gYW5kIGluZGVudGVkXG4gICAgLy8gbGVzcyB0aGFuIHNhaWQgbGlzdCBpdGVtOlxuICAgIC8vXG4gICAgLy8gYGBgXG4gICAgLy8gMS4gYW55dGhpbmdcbiAgICAvLyAgICA+IGN1cnJlbnQgYmxvY2txdW90ZVxuICAgIC8vIDIuIGNoZWNraW5nIHRoaXMgbGluZVxuICAgIC8vIGBgYFxuICAgIGlzT3V0ZGVudGVkID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudDtcblxuICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgLy8gQ2FzZSAxOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGlzIGxpbmUgaXMgZW1wdHkuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspID09PSAweDNFLyogPiAqLyAmJiAhaXNPdXRkZW50ZWQpIHtcbiAgICAgIC8vIFRoaXMgbGluZSBpcyBpbnNpZGUgdGhlIGJsb2NrcXVvdGUuXG5cbiAgICAgIC8vIHNraXAgc3BhY2VzIGFmdGVyIFwiPlwiIGFuZCByZS1jYWxjdWxhdGUgb2Zmc2V0XG4gICAgICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIHBvcyAtIChzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG5cbiAgICAgIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjAgLyogc3BhY2UgKi8pIHtcbiAgICAgICAgLy8gJyA+ICAgdGVzdCAnXG4gICAgICAgIC8vICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZTpcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGluaXRpYWwrKztcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG5cbiAgICAgICAgaWYgKChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSArIG9mZnNldCkgJSA0ID09PSAzKSB7XG4gICAgICAgICAgLy8gJyAgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGluaXRpYWwrKztcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICsgc2hpZnQgYnNDb3VudCBzbGlnaHRseVxuICAgICAgICAgIC8vICAgICAgICAgdG8gbWFrZSBleHRyYSBzcGFjZSBhcHBlYXJcbiAgICAgICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuYk1hcmtzW25leHRMaW5lXSA9IHBvcztcblxuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4O1xuXG4gICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgMSArIChzcGFjZUFmdGVyTWFya2VyID8gMSA6IDApO1xuXG4gICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsO1xuXG4gICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ2FzZSAyOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGUgbGFzdCBsaW5lIHdhcyBlbXB0eS5cbiAgICBpZiAobGFzdExpbmVFbXB0eSkgeyBicmVhazsgfVxuXG4gICAgLy8gQ2FzZSAzOiBhbm90aGVyIHRhZyBmb3VuZC5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgIC8vIFF1aXJrIHRvIGVuZm9yY2UgXCJoYXJkIHRlcm1pbmF0aW9uIG1vZGVcIiBmb3IgcGFyYWdyYXBocztcbiAgICAgIC8vIG5vcm1hbGx5IGlmIHlvdSBjYWxsIGB0b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSlgLFxuICAgICAgLy8gcGFyYWdyYXBocyB3aWxsIGxvb2sgYmVsb3cgbmV4dExpbmUgZm9yIHBhcmFncmFwaCBjb250aW51YXRpb24sXG4gICAgICAvLyBidXQgaWYgYmxvY2txdW90ZSBpcyB0ZXJtaW5hdGVkIGJ5IGFub3RoZXIgdGFnLCB0aGV5IHNob3VsZG4ndFxuICAgICAgc3RhdGUubGluZU1heCA9IG5leHRMaW5lO1xuXG4gICAgICBpZiAoc3RhdGUuYmxrSW5kZW50ICE9PSAwKSB7XG4gICAgICAgIC8vIHN0YXRlLmJsa0luZGVudCB3YXMgbm9uLXplcm8sIHdlIG5vdyBzZXQgaXQgdG8gemVybyxcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgYWxsIG9mZnNldHMgdG8gYXBwZWFyIGFzXG4gICAgICAgIC8vIGlmIGluZGVudCB3YXNuJ3QgY2hhbmdlZFxuICAgICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC09IHN0YXRlLmJsa0luZGVudDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlzT3V0ZGVudGVkKSBicmVhaztcblxuICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG5cbiAgICAvLyBBIG5lZ2F0aXZlIGluZGVudGF0aW9uIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAvL1xuICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSAtMTtcbiAgfVxuXG4gIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgc3RhdGUuYmxrSW5kZW50ID0gMDtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX29wZW4nLCAnYmxvY2txdW90ZScsIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG4gIHRva2VuLm1hcCAgICA9IGxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSk7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9jbG9zZScsICdibG9ja3F1b3RlJywgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG5cbiAgc3RhdGUubGluZU1heCA9IG9sZExpbmVNYXg7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XG5cbiAgLy8gUmVzdG9yZSBvcmlnaW5hbCB0U2hpZnQ7IHRoaXMgbWlnaHQgbm90IGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgcGFyc2VyXG4gIC8vIGhhcyBhbHJlYWR5IGJlZW4gaGVyZSwgYnV0IGp1c3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBkbyB0aGF0LlxuICBmb3IgKGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldO1xuICAgIHN0YXRlLnRTaGlmdFtpICsgc3RhcnRMaW5lXSA9IG9sZFRTaGlmdFtpXTtcbiAgICBzdGF0ZS5zQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRTQ291bnRbaV07XG4gICAgc3RhdGUuYnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZEJTQ291bnRbaV07XG4gIH1cbiAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCIvLyBDb2RlIGJsb2NrICg0IHNwYWNlcyBwYWRkZWQpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvZGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgbmV4dExpbmUsIGxhc3QsIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA8IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFzdCA9IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgaWYgKHN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGxhc3QgPSBuZXh0TGluZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBsYXN0O1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2Jsb2NrJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbGFzdCwgNCArIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2NvZGUuanMiLCIvLyBmZW5jZXMgKGBgYCBsYW5nLCB+fn4gbGFuZylcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGxlbiwgcGFyYW1zLCBuZXh0TGluZSwgbWVtLCB0b2tlbiwgbWFya3VwLFxuICAgICAgaGF2ZUVuZE1hcmtlciA9IGZhbHNlLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAzID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8gJiYgbWFya2VyICE9PSAweDYwIC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBzY2FuIG1hcmtlciBsZW5ndGhcbiAgbWVtID0gcG9zO1xuICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gIGxlbiA9IHBvcyAtIG1lbTtcblxuICBpZiAobGVuIDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrdXAgPSBzdGF0ZS5zcmMuc2xpY2UobWVtLCBwb3MpO1xuICBwYXJhbXMgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGlmIChwYXJhbXMuaW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpID49IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2luY2Ugc3RhcnQgaXMgZm91bmQsIHdlIGNhbiByZXBvcnQgc3VjY2VzcyBoZXJlIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2VhcmNoIGVuZCBvZiBibG9ja1xuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcblxuICBmb3IgKDs7KSB7XG4gICAgbmV4dExpbmUrKztcbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkge1xuICAgICAgLy8gdW5jbG9zZWQgYmxvY2sgc2hvdWxkIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIGRvY3VtZW50LlxuICAgICAgLy8gYWxzbyBibG9jayBzZWVtcyB0byBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBwYXJlbnRcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcyA9IG1lbSA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIC8vIG5vbi1lbXB0eSBsaW5lIHdpdGggbmVnYXRpdmUgaW5kZW50IHNob3VsZCBzdG9wIHRoZSBsaXN0OlxuICAgICAgLy8gLSBgYGBcbiAgICAgIC8vICB0ZXN0XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gbWFya2VyKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAvLyBjbG9zaW5nIGZlbmNlIHNob3VsZCBiZSBpbmRlbnRlZCBsZXNzIHRoYW4gNCBzcGFjZXNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgICAvLyBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIG9uZVxuICAgIGlmIChwb3MgLSBtZW0gPCBsZW4pIHsgY29udGludWU7IH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0YWlsIGhhcyBzcGFjZXMgb25seVxuICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgIGlmIChwb3MgPCBtYXgpIHsgY29udGludWU7IH1cblxuICAgIGhhdmVFbmRNYXJrZXIgPSB0cnVlO1xuICAgIC8vIGZvdW5kIVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gSWYgYSBmZW5jZSBoYXMgaGVhZGluZyBzcGFjZXMsIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBpdHMgaW5uZXIgYmxvY2tcbiAgbGVuID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgKGhhdmVFbmRNYXJrZXIgPyAxIDogMCk7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2ZlbmNlJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uaW5mbyAgICA9IHBhcmFtcztcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSArIDEsIG5leHRMaW5lLCBsZW4sIHRydWUpO1xuICB0b2tlbi5tYXJrdXAgID0gbWFya3VwO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIi8vIGhlYWRpbmcgKCMsICMjLCAuLi4pXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsZXZlbCwgdG1wLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCAgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHgyMy8qICMgKi8gfHwgcG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjb3VudCBoZWFkaW5nIGxldmVsXG4gIGxldmVsID0gMTtcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIHdoaWxlIChjaCA9PT0gMHgyMy8qICMgKi8gJiYgcG9zIDwgbWF4ICYmIGxldmVsIDw9IDYpIHtcbiAgICBsZXZlbCsrO1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB9XG5cbiAgaWYgKGxldmVsID4gNiB8fCAocG9zIDwgbWF4ICYmICFpc1NwYWNlKGNoKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIExldCdzIGN1dCB0YWlscyBsaWtlICcgICAgIyMjICAnIGZyb20gdGhlIGVuZCBvZiBzdHJpbmdcblxuICBtYXggPSBzdGF0ZS5za2lwU3BhY2VzQmFjayhtYXgsIHBvcyk7XG4gIHRtcCA9IHN0YXRlLnNraXBDaGFyc0JhY2sobWF4LCAweDIzLCBwb3MpOyAvLyAjXG4gIGlmICh0bXAgPiBwb3MgJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdCh0bXAgLSAxKSkpIHtcbiAgICBtYXggPSB0bXA7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS50cmltKCk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwiLy8gSG9yaXpvbnRhbCBydWxlXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGNudCwgY2gsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAvLyBDaGVjayBociBtYXJrZXJcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBtYXJrZXJzIGNhbiBiZSBtaXhlZCB3aXRoIHNwYWNlcywgYnV0IHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCAzIG9mIHRoZW1cblxuICBjbnQgPSAxO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKGNoICE9PSBtYXJrZXIgJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChjaCA9PT0gbWFya2VyKSB7IGNudCsrOyB9XG4gIH1cblxuICBpZiAoY250IDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaHInLCAnaHInLCAwKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4ubWFya3VwID0gQXJyYXkoY250ICsgMSkuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwiLy8gSFRNTCBibG9ja1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGJsb2NrX25hbWVzID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfYmxvY2tzJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcblxuLy8gQW4gYXJyYXkgb2Ygb3BlbmluZyBhbmQgY29ycmVzcG9uZGluZyBjbG9zaW5nIHNlcXVlbmNlcyBmb3IgaHRtbCB0YWdzLFxuLy8gbGFzdCBhcmd1bWVudCBkZWZpbmVzIHdoZXRoZXIgaXQgY2FuIHRlcm1pbmF0ZSBhIHBhcmFncmFwaCBvciBub3Rcbi8vXG52YXIgSFRNTF9TRVFVRU5DRVMgPSBbXG4gIFsgL148KHNjcmlwdHxwcmV8c3R5bGUpKD89KFxcc3w+fCQpKS9pLCAvPFxcLyhzY3JpcHR8cHJlfHN0eWxlKT4vaSwgdHJ1ZSBdLFxuICBbIC9ePCEtLS8sICAgICAgICAvLS0+LywgICB0cnVlIF0sXG4gIFsgL148XFw/LywgICAgICAgICAvXFw/Pi8sICAgdHJ1ZSBdLFxuICBbIC9ePCFbQS1aXS8sICAgICAvPi8sICAgICB0cnVlIF0sXG4gIFsgL148IVxcW0NEQVRBXFxbLywgL1xcXVxcXT4vLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cCgnXjwvPygnICsgYmxvY2tfbmFtZXMuam9pbignfCcpICsgJykoPz0oXFxcXHN8Lz8+fCQpKScsICdpJyksIC9eJC8sIHRydWUgXSxcbiAgWyBuZXcgUmVnRXhwKEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUuc291cmNlICsgJ1xcXFxzKiQnKSwgIC9eJC8sIGZhbHNlIF1cbl07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2Jsb2NrKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgaSwgbmV4dExpbmUsIHRva2VuLCBsaW5lVGV4dCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGluZVRleHQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBIVE1MX1NFUVVFTkNFUy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVswXS50ZXN0KGxpbmVUZXh0KSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKGkgPT09IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7XG4gICAgLy8gdHJ1ZSBpZiB0aGlzIHNlcXVlbmNlIGNhbiBiZSBhIHRlcm1pbmF0b3IsIGZhbHNlIG90aGVyd2lzZVxuICAgIHJldHVybiBIVE1MX1NFUVVFTkNFU1tpXVsyXTtcbiAgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBJZiB3ZSBhcmUgaGVyZSAtIHdlIGRldGVjdGVkIEhUTUwgYmxvY2suXG4gIC8vIExldCdzIHJvbGwgZG93biB0aWxsIGJsb2NrIGVuZC5cbiAgaWYgKCFIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgIGlmIChsaW5lVGV4dC5sZW5ndGggIT09IDApIHsgbmV4dExpbmUrKzsgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfYmxvY2snLCAnJywgMCk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgbmV4dExpbmUgXTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHRtbF9ibG9jay5qcyIsIi8vIGxoZWFkaW5nICgtLS0sID09PSlcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgcG9zLCBtYXgsIGxldmVsLCBtYXJrZXIsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsIG9sZFBhcmVudFR5cGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyk7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJzsgLy8gdXNlIHBhcmFncmFwaCB0byBtYXRjaCB0ZXJtaW5hdG9yUnVsZXNcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy9cbiAgICAvLyBDaGVjayBmb3IgdW5kZXJsaW5lIGluIHNldGV4dCBoZWFkZXJcbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gMHgyRC8qIC0gKi8gfHwgbWFya2VyID09PSAweDNELyogPSAqLykge1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgICAgICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgICAgICAgIGxldmVsID0gKG1hcmtlciA9PT0gMHgzRC8qID0gKi8gPyAxIDogMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBpZiAoIWxldmVsKSB7XG4gICAgLy8gRGlkbid0IGZpbmQgdmFsaWQgdW5kZXJsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSAtIDEgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzIiwiLy8gTGlzdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuLy8gU2VhcmNoIGBbLSsqXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYXJ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBtYXJrZXIsIHBvcywgbWF4LCBjaDtcblxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIC8vIENoZWNrIGJ1bGxldFxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJCLyogKyAqLykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAtdGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbi8vIFNlYXJjaCBgXFxkK1suKV1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFydGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgcG9zID0gc3RhcnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIGNoYXJzIChkaWdpdCArIGRvdClcbiAgaWYgKHBvcyArIDEgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIGlmIChjaCA8IDB4MzAvKiAwICovIHx8IGNoID4gMHgzOS8qIDkgKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgZm9yICg7Oykge1xuICAgIC8vIEVPTCAtPiBmYWlsXG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmIChjaCA+PSAweDMwLyogMCAqLyAmJiBjaCA8PSAweDM5LyogOSAqLykge1xuXG4gICAgICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBubyBtb3JlIHRoYW4gOSBkaWdpdHNcbiAgICAgIC8vIChwcmV2ZW50cyBpbnRlZ2VyIG92ZXJmbG93IGluIGJyb3dzZXJzKVxuICAgICAgaWYgKHBvcyAtIHN0YXJ0ID49IDEwKSB7IHJldHVybiAtMTsgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmb3VuZCB2YWxpZCBtYXJrZXJcbiAgICBpZiAoY2ggPT09IDB4MjkvKiApICovIHx8IGNoID09PSAweDJlLyogLiAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgMS50ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICB2YXIgaSwgbCxcbiAgICAgIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xuXG4gIGZvciAoaSA9IGlkeCArIDIsIGwgPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbaSArIDJdLmhpZGRlbiA9IHRydWU7XG4gICAgICBzdGF0ZS50b2tlbnNbaV0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGkgKz0gMjtcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgIGksXG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRBZnRlck1hcmtlcixcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc09yZGVyZWQsXG4gICAgICBpdGVtTGluZXMsXG4gICAgICBsLFxuICAgICAgbGlzdExpbmVzLFxuICAgICAgbGlzdFRva0lkeCxcbiAgICAgIG1hcmtlckNoYXJDb2RlLFxuICAgICAgbWFya2VyVmFsdWUsXG4gICAgICBtYXgsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZExJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgb2xkVGlnaHQsXG4gICAgICBwb3MsXG4gICAgICBwb3NBZnRlck1hcmtlcixcbiAgICAgIHByZXZFbXB0eUVuZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gZmFsc2UsXG4gICAgICB0aWdodCA9IHRydWU7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc3Vic3RyKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIHN0YXJ0IC0gMSkpO1xuXG4gICAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgb3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gICAgLy8gYSBwYXJhZ3JhcGgsIGl0IHNob3VsZCBzdGFydCB3aXRoIDEuXG4gICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXG4gIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcblxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X29wZW4nLCAnb2wnLCAxKTtcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X29wZW4nLCAndWwnLCAxKTtcbiAgfVxuXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgY29udGVudFN0YXJ0ID0gcG9zO1xuXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXgpIHtcbiAgICAgIC8vIHRyaW1taW5nIHNwYWNlIGluIFwiLSAgICBcXG4gIDNcIiBjYXNlLCBpbmRlbnQgaXMgMSBoZXJlXG4gICAgICBpbmRlbnRBZnRlck1hcmtlciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gb2Zmc2V0IC0gaW5pdGlhbDtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiA0IHNwYWNlcywgdGhlIGluZGVudCBpcyAxXG4gICAgLy8gKHRoZSByZXN0IGlzIGp1c3QgaW5kZW50ZWQgY29kZSBibG9jaylcbiAgICBpZiAoaW5kZW50QWZ0ZXJNYXJrZXIgPiA0KSB7IGluZGVudEFmdGVyTWFya2VyID0gMTsgfVxuXG4gICAgLy8gXCIgIC0gIHRlc3RcIlxuICAgIC8vICBeXl5eXiAtIGNhbGN1bGF0aW5nIHRvdGFsIGxlbmd0aCBvZiB0aGlzIHRoaW5nXG4gICAgaW5kZW50ID0gaW5pdGlhbCArIGluZGVudEFmdGVyTWFya2VyO1xuXG4gICAgLy8gUnVuIHN1YnBhcnNlciAmIHdyaXRlIHRva2Vuc1xuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9vcGVuJywgJ2xpJywgMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG4gICAgdG9rZW4ubWFwICAgID0gaXRlbUxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICAgIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgICBvbGRUaWdodCA9IHN0YXRlLnRpZ2h0O1xuICAgIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG9sZExJbmRlbnQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBpbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQ7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCAmJiBzdGF0ZS5pc0VtcHR5KHN0YXJ0TGluZSArIDEpKSB7XG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciB0aGlzIGNhc2VcbiAgICAgIC8vIChsaXN0IGl0ZW0gaXMgZW1wdHksIGxpc3QgdGVybWluYXRlcyBiZWZvcmUgXCJmb29cIik6XG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgLy8gICAtXG4gICAgICAvL1xuICAgICAgLy8gICAgIGZvb1xuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIHN0YXRlLmxpbmUgPSBNYXRoLm1pbihzdGF0ZS5saW5lICsgMiwgZW5kTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICB0aWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBJdGVtIGJlY29tZSBsb29zZSBpZiBmaW5pc2ggd2l0aCBlbXB0eSBsaW5lLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGQgZmlsdGVyIGxhc3QgZWxlbWVudCwgYmVjYXVzZSBpdCBtZWFucyBsaXN0IGZpbmlzaFxuICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gc3RhcnRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBvbGRUU2hpZnQ7XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvbGRMSW5kZW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fY2xvc2UnLCAnbGknLCAtMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgaXRlbUxpbmVzWzFdID0gbmV4dExpbmU7XG4gICAgY29udGVudFN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy9cbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIHRlcm1pbmF0aW5nIGJsb2NrIGZvdW5kXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiBsaXN0IGhhcyBhbm90aGVyIHR5cGVcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlckNoYXJDb2RlICE9PSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpKSB7IGJyZWFrOyB9XG4gIH1cblxuICAvLyBGaW5pbGl6ZSBsaXN0XG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9jbG9zZScsICdvbCcsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X2Nsb3NlJywgJ3VsJywgLTEpO1xuICB9XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIGxpc3RMaW5lc1sxXSA9IG5leHRMaW5lO1xuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgLy8gbWFyayBwYXJhZ3JhcGhzIHRpZ2h0IGlmIG5lZWRlZFxuICBpZiAodGlnaHQpIHtcbiAgICBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBsaXN0VG9rSWR4KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xpc3QuanMiLCIvLyBQYXJhZ3JhcGhcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyYWdyYXBoKHN0YXRlLCBzdGFydExpbmUvKiwgZW5kTGluZSovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpLFxuICAgICAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJztcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfb3BlbicsICdwJywgMSk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfY2xvc2UnLCAncCcsIC0xKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanMiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZmVyZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBfZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGRlc3RFbmRQb3MsXG4gICAgICBkZXN0RW5kTGluZU5vLFxuICAgICAgZW5kTGluZSxcbiAgICAgIGhyZWYsXG4gICAgICBpLFxuICAgICAgbCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgcmVzLFxuICAgICAgc3RhcnQsXG4gICAgICBzdHIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0aXRsZSxcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2ltcGxlIGNoZWNrIHRvIHF1aWNrbHkgaW50ZXJydXB0IHNjYW4gb24gW2xpbmtdKHVybCkgYXQgdGhlIHN0YXJ0IG9mIGxpbmUuXG4gIC8vIENhbiBiZSB1c2VmdWwgb24gcHJhY3RpY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9pc3N1ZXMvNTRcbiAgd2hpbGUgKCsrcG9zIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUQgLyogXSAqLyAmJlxuICAgICAgICBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgLSAxKSAhPT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBpZiAocG9zICsgMSA9PT0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3JlZmVyZW5jZScpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3JlZmVyZW5jZSc7XG5cbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBzdHIgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG4gIG1heCA9IHN0ci5sZW5ndGg7XG5cbiAgZm9yIChwb3MgPSAxOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsYWJlbEVuZCA9IHBvcztcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MEEgLyogXFxuICovKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8pIHtcbiAgICAgIHBvcysrO1xuICAgICAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhYmVsRW5kIDwgMCB8fCBzdHIuY2hhckNvZGVBdChsYWJlbEVuZCArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgIF5eXiBza2lwIG9wdGlvbmFsIHdoaXRlc3BhY2UgaGVyZVxuICBmb3IgKHBvcyA9IGxhYmVsRW5kICsgMjsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgXl5eXl5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAoIXJlcy5vaykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gcmVzLnBvcztcbiAgbGluZXMgKz0gcmVzLmxpbmVzO1xuXG4gIC8vIHNhdmUgY3Vyc29yIHN0YXRlLCB3ZSBjb3VsZCByZXF1aXJlIHRvIHJvbGxiYWNrIGxhdGVyXG4gIGRlc3RFbmRQb3MgPSBwb3M7XG4gIGRlc3RFbmRMaW5lTm8gPSBsaW5lcztcblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgXl5eIHNraXBwaW5nIHRob3NlIHNwYWNlc1xuICBzdGFydCA9IHBvcztcbiAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCk7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgcG9zID0gcmVzLnBvcztcbiAgICBsaW5lcyArPSByZXMubGluZXM7XG4gIH0gZWxzZSB7XG4gICAgdGl0bGUgPSAnJztcbiAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgfVxuXG4gIC8vIHNraXAgdHJhaWxpbmcgc3BhY2VzIHVudGlsIHRoZSByZXN0IG9mIHRoZSBsaW5lXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgYWZ0ZXIgdGl0bGUsXG4gICAgICAvLyBidXQgaXQgY291bGQgc3RpbGwgYmUgYSB2YWxpZCByZWZlcmVuY2UgaWYgd2Ugcm9sbCBiYWNrXG4gICAgICB0aXRsZSA9ICcnO1xuICAgICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHN0ci5zbGljZSgxLCBsYWJlbEVuZCkpO1xuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gQ29tbW9uTWFyayAwLjIwIGRpc2FsbG93cyBlbXB0eSBsYWJlbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBSZWZlcmVuY2UgY2FuIG5vdCB0ZXJtaW5hdGUgYW55dGhpbmcuIFRoaXMgY2hlY2sgaXMgZm9yIHNhZmV0eSBvbmx5LlxuICAvKmlzdGFuYnVsIGlnbm9yZSBpZiovXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzID0ge307XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID0geyB0aXRsZTogdGl0bGUsIGhyZWY6IGhyZWYgfTtcbiAgfVxuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyBsaW5lcyArIDE7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5qcyIsIi8vIFBhcnNlciBzdGF0ZSBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gU3RhdGVCbG9jayhzcmMsIG1kLCBlbnYsIHRva2Vucykge1xuICB2YXIgY2gsIHMsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBvZmZzZXQsIGluZGVudF9mb3VuZDtcblxuICB0aGlzLnNyYyA9IHNyYztcblxuICAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxuICB0aGlzLm1kICAgICA9IG1kO1xuXG4gIHRoaXMuZW52ID0gZW52O1xuXG4gIC8vXG4gIC8vIEludGVybmFsIHN0YXRlIHZhcnRpYWJsZXNcbiAgLy9cblxuICB0aGlzLnRva2VucyA9IHRva2VucztcblxuICB0aGlzLmJNYXJrcyA9IFtdOyAgLy8gbGluZSBiZWdpbiBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMuZU1hcmtzID0gW107ICAvLyBsaW5lIGVuZCBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMudFNoaWZ0ID0gW107ICAvLyBvZmZzZXRzIG9mIHRoZSBmaXJzdCBub24tc3BhY2UgY2hhcmFjdGVycyAodGFicyBub3QgZXhwYW5kZWQpXG4gIHRoaXMuc0NvdW50ID0gW107ICAvLyBpbmRlbnRzIGZvciBlYWNoIGxpbmUgKHRhYnMgZXhwYW5kZWQpXG5cbiAgLy8gQW4gYW1vdW50IG9mIHZpcnR1YWwgc3BhY2VzICh0YWJzIGV4cGFuZGVkKSBiZXR3ZWVuIGJlZ2lubmluZ1xuICAvLyBvZiBlYWNoIGxpbmUgKGJNYXJrcykgYW5kIHJlYWwgYmVnaW5uaW5nIG9mIHRoYXQgbGluZS5cbiAgLy9cbiAgLy8gSXQgZXhpc3RzIG9ubHkgYXMgYSBoYWNrIGJlY2F1c2UgYmxvY2txdW90ZXMgb3ZlcnJpZGUgYk1hcmtzXG4gIC8vIGxvc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgcHJvY2Vzcy5cbiAgLy9cbiAgLy8gSXQncyB1c2VkIG9ubHkgd2hlbiBleHBhbmRpbmcgdGFicywgeW91IGNhbiB0aGluayBhYm91dCBpdCBhc1xuICAvLyBhbiBpbml0aWFsIHRhYiBsZW5ndGgsIGUuZy4gYnNDb3VudD0yMSBhcHBsaWVkIHRvIHN0cmluZyBgXFx0MTIzYFxuICAvLyBtZWFucyBmaXJzdCB0YWIgc2hvdWxkIGJlIGV4cGFuZGVkIHRvIDQtMjElNCA9PT0gMyBzcGFjZXMuXG4gIC8vXG4gIHRoaXMuYnNDb3VudCA9IFtdO1xuXG4gIC8vIGJsb2NrIHBhcnNlciB2YXJpYWJsZXNcbiAgdGhpcy5ibGtJbmRlbnQgID0gMDsgLy8gcmVxdWlyZWQgYmxvY2sgY29udGVudCBpbmRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gKGZvciBleGFtcGxlLCBpZiB3ZSBhcmUgaW4gbGlzdClcbiAgdGhpcy5saW5lICAgICAgID0gMDsgLy8gbGluZSBpbmRleCBpbiBzcmNcbiAgdGhpcy5saW5lTWF4ICAgID0gMDsgLy8gbGluZXMgY291bnRcbiAgdGhpcy50aWdodCAgICAgID0gZmFsc2U7ICAvLyBsb29zZS90aWdodCBtb2RlIGZvciBsaXN0c1xuICB0aGlzLmRkSW5kZW50ICAgPSAtMTsgLy8gaW5kZW50IG9mIHRoZSBjdXJyZW50IGRkIGJsb2NrICgtMSBpZiB0aGVyZSBpc24ndCBhbnkpXG5cbiAgLy8gY2FuIGJlICdibG9ja3F1b3RlJywgJ2xpc3QnLCAncm9vdCcsICdwYXJhZ3JhcGgnIG9yICdyZWZlcmVuY2UnXG4gIC8vIHVzZWQgaW4gbGlzdHMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgaW50ZXJydXB0IGEgcGFyYWdyYXBoXG4gIHRoaXMucGFyZW50VHlwZSA9ICdyb290JztcblxuICB0aGlzLmxldmVsID0gMDtcblxuICAvLyByZW5kZXJlclxuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIC8vIENyZWF0ZSBjYWNoZXNcbiAgLy8gR2VuZXJhdGUgbWFya2Vycy5cbiAgcyA9IHRoaXMuc3JjO1xuICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcblxuICBmb3IgKHN0YXJ0ID0gcG9zID0gaW5kZW50ID0gb2Zmc2V0ID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgcG9zKyspIHtcbiAgICBjaCA9IHMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpbmRlbnRfZm91bmQpIHtcbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpbmRlbnQrKztcblxuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNCAtIG9mZnNldCAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlbnRfZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSB8fCBwb3MgPT09IGxlbiAtIDEpIHtcbiAgICAgIGlmIChjaCAhPT0gMHgwQSkgeyBwb3MrKzsgfVxuICAgICAgdGhpcy5iTWFya3MucHVzaChzdGFydCk7XG4gICAgICB0aGlzLmVNYXJrcy5wdXNoKHBvcyk7XG4gICAgICB0aGlzLnRTaGlmdC5wdXNoKGluZGVudCk7XG4gICAgICB0aGlzLnNDb3VudC5wdXNoKG9mZnNldCk7XG4gICAgICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICAgICAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIGZha2UgZW50cnkgdG8gc2ltcGxpZnkgY2FjaGUgYm91bmRzIGNoZWNrc1xuICB0aGlzLmJNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy5lTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMudFNoaWZ0LnB1c2goMCk7XG4gIHRoaXMuc0NvdW50LnB1c2goMCk7XG4gIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gIHRoaXMubGluZU1heCA9IHRoaXMuYk1hcmtzLmxlbmd0aCAtIDE7IC8vIGRvbid0IGNvdW50IGxhc3QgZmFrZSBsaW5lXG59XG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vL1xuU3RhdGVCbG9jay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG4gIHRva2VuLmJsb2NrID0gdHJ1ZTtcblxuICBpZiAobmVzdGluZyA8IDApIHsgdGhpcy5sZXZlbC0tOyB9XG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxuXG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShsaW5lKSB7XG4gIHJldHVybiB0aGlzLmJNYXJrc1tsaW5lXSArIHRoaXMudFNoaWZ0W2xpbmVdID49IHRoaXMuZU1hcmtzW2xpbmVdO1xufTtcblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXMgPSBmdW5jdGlvbiBza2lwRW1wdHlMaW5lcyhmcm9tKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMubGluZU1heDsgZnJvbSA8IG1heDsgZnJvbSsrKSB7XG4gICAgaWYgKHRoaXMuYk1hcmtzW2Zyb21dICsgdGhpcy50U2hpZnRbZnJvbV0gPCB0aGlzLmVNYXJrc1tmcm9tXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tO1xufTtcblxuLy8gU2tpcCBzcGFjZXMgZnJvbSBnaXZlbiBwb3NpdGlvbi5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXMgPSBmdW5jdGlvbiBza2lwU3BhY2VzKHBvcykge1xuICB2YXIgY2g7XG5cbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uIGluIHJldmVyc2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzQmFjayA9IGZ1bmN0aW9uIHNraXBTcGFjZXNCYWNrKHBvcywgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKCFpc1NwYWNlKHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgZnJvbSBnaXZlbiBwb3NpdGlvblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzID0gZnVuY3Rpb24gc2tpcENoYXJzKHBvcywgY29kZSkge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBpZiAodGhpcy5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBjb2RlKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyByZXZlcnNlIGZyb20gZ2l2ZW4gcG9zaXRpb24gLSAxXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnNCYWNrID0gZnVuY3Rpb24gc2tpcENoYXJzQmFjayhwb3MsIGNvZGUsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zOyB9XG5cbiAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgIGlmIChjb2RlICE9PSB0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBjdXQgbGluZXMgcmFuZ2UgZnJvbSBzb3VyY2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5nZXRMaW5lcyA9IGZ1bmN0aW9uIGdldExpbmVzKGJlZ2luLCBlbmQsIGluZGVudCwga2VlcExhc3RMRikge1xuICB2YXIgaSwgbGluZUluZGVudCwgY2gsIGZpcnN0LCBsYXN0LCBxdWV1ZSwgbGluZVN0YXJ0LFxuICAgICAgbGluZSA9IGJlZ2luO1xuXG4gIGlmIChiZWdpbiA+PSBlbmQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBxdWV1ZSA9IG5ldyBBcnJheShlbmQgLSBiZWdpbik7XG5cbiAgZm9yIChpID0gMDsgbGluZSA8IGVuZDsgbGluZSsrLCBpKyspIHtcbiAgICBsaW5lSW5kZW50ID0gMDtcbiAgICBsaW5lU3RhcnQgPSBmaXJzdCA9IHRoaXMuYk1hcmtzW2xpbmVdO1xuXG4gICAgaWYgKGxpbmUgKyAxIDwgZW5kIHx8IGtlZXBMYXN0TEYpIHtcbiAgICAgIC8vIE5vIG5lZWQgZm9yIGJvdW5kcyBjaGVjayBiZWNhdXNlIHdlIGhhdmUgZmFrZSBlbnRyeSBvbiB0YWlsLlxuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdO1xuICAgIH1cblxuICAgIHdoaWxlIChmaXJzdCA8IGxhc3QgJiYgbGluZUluZGVudCA8IGluZGVudCkge1xuICAgICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KGZpcnN0KTtcblxuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIGxpbmVJbmRlbnQgKz0gNCAtIChsaW5lSW5kZW50ICsgdGhpcy5ic0NvdW50W2xpbmVdKSAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0IC0gbGluZVN0YXJ0IDwgdGhpcy50U2hpZnRbbGluZV0pIHtcbiAgICAgICAgLy8gcGF0Y2hlZCB0U2hpZnQgbWFza2VkIGNoYXJhY3RlcnMgdG8gbG9vayBsaWtlIHNwYWNlcyAoYmxvY2txdW90ZXMsIGxpc3QgbWFya2VycylcbiAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0Kys7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVJbmRlbnQgPiBpbmRlbnQpIHtcbiAgICAgIC8vIHBhcnRpYWxseSBleHBhbmRpbmcgdGFicyBpbiBjb2RlIGJsb2NrcywgZS5nICdcXHRcXHRmb29iYXInXG4gICAgICAvLyB3aXRoIGluZGVudD0yIGJlY29tZXMgJyAgXFx0Zm9vYmFyJ1xuICAgICAgcXVldWVbaV0gPSBuZXcgQXJyYXkobGluZUluZGVudCAtIGluZGVudCArIDEpLmpvaW4oJyAnKSArIHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVbaV0gPSB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXVlLmpvaW4oJycpO1xufTtcblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVCbG9jay5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQmxvY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jay5qcyIsIi8vIEdGTSB0YWJsZSwgbm9uLXN0YW5kYXJkXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbmZ1bmN0aW9uIGdldExpbmUoc3RhdGUsIGxpbmUpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLmJNYXJrc1tsaW5lXSArIHN0YXRlLmJsa0luZGVudCxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tsaW5lXTtcblxuICByZXR1cm4gc3RhdGUuc3JjLnN1YnN0cihwb3MsIG1heCAtIHBvcyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRTcGxpdChzdHIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgcG9zID0gMCxcbiAgICAgIG1heCA9IHN0ci5sZW5ndGgsXG4gICAgICBjaCxcbiAgICAgIGVzY2FwZXMgPSAwLFxuICAgICAgbGFzdFBvcyA9IDAsXG4gICAgICBiYWNrVGlja2VkID0gZmFsc2UsXG4gICAgICBsYXN0QmFja1RpY2sgPSAwO1xuXG4gIGNoICA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGlmIChjaCA9PT0gMHg2MC8qIGAgKi8pIHtcbiAgICAgIGlmIChiYWNrVGlja2VkKSB7XG4gICAgICAgIC8vIG1ha2UgXFxgIGNsb3NlIGNvZGUgc2VxdWVuY2UsIGJ1dCBub3Qgb3BlbiBpdDtcbiAgICAgICAgLy8gdGhlIHJlYXNvbiBpczogYFxcYCBpcyBjb3JyZWN0IGNvZGUgYmxvY2tcbiAgICAgICAgYmFja1RpY2tlZCA9IGZhbHNlO1xuICAgICAgICBsYXN0QmFja1RpY2sgPSBwb3M7XG4gICAgICB9IGVsc2UgaWYgKGVzY2FwZXMgJSAyID09PSAwKSB7XG4gICAgICAgIGJhY2tUaWNrZWQgPSB0cnVlO1xuICAgICAgICBsYXN0QmFja1RpY2sgPSBwb3M7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Yy8qIHwgKi8gJiYgKGVzY2FwZXMgJSAyID09PSAwKSAmJiAhYmFja1RpY2tlZCkge1xuICAgICAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhsYXN0UG9zLCBwb3MpKTtcbiAgICAgIGxhc3RQb3MgPSBwb3MgKyAxO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHg1Yy8qIFxcICovKSB7XG4gICAgICBlc2NhcGVzKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVzY2FwZXMgPSAwO1xuICAgIH1cblxuICAgIHBvcysrO1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIGFuIHVuLWNsb3NlZCBiYWNrdGljaywgZ28gYmFjayB0byBqdXN0IGFmdGVyXG4gICAgLy8gdGhlIGxhc3QgYmFja3RpY2ssIGJ1dCBhcyBpZiBpdCB3YXMgYSBub3JtYWwgY2hhcmFjdGVyXG4gICAgaWYgKHBvcyA9PT0gbWF4ICYmIGJhY2tUaWNrZWQpIHtcbiAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZTtcbiAgICAgIHBvcyA9IGxhc3RCYWNrVGljayArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICB9XG5cbiAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhsYXN0UG9zKSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRhYmxlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxpbmVUZXh0LCBwb3MsIGksIG5leHRMaW5lLCBjb2x1bW5zLCBjb2x1bW5Db3VudCwgdG9rZW4sXG4gICAgICBhbGlnbnMsIHQsIHRhYmxlTGluZXMsIHRib2R5TGluZXM7XG5cbiAgLy8gc2hvdWxkIGhhdmUgYXQgbGVhc3QgdHdvIGxpbmVzXG4gIGlmIChzdGFydExpbmUgKyAyID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlY29uZCBsaW5lIHNob3VsZCBiZSAnfCcsICctJywgJzonLFxuICAvLyBhbmQgbm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCBidXQgc3BhY2VzO1xuICAvLyBiYXNpY2FsbHksIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgL15bLTp8XVstOnxcXHNdKiQvIHJlZ2V4cFxuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICBpZiAocG9zID49IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIGlmIChjaCAhPT0gMHg3Qy8qIHwgKi8gJiYgY2ggIT09IDB4MkQvKiAtICovICYmIGNoICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICB3aGlsZSAocG9zIDwgc3RhdGUuZU1hcmtzW25leHRMaW5lXSkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCAhPT0gMHg3Qy8qIHwgKi8gJiYgY2ggIT09IDB4MkQvKiAtICovICYmIGNoICE9PSAweDNBLyogOiAqLyAmJiAhaXNTcGFjZShjaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lICsgMSk7XG5cbiAgY29sdW1ucyA9IGxpbmVUZXh0LnNwbGl0KCd8Jyk7XG4gIGFsaWducyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHQgPSBjb2x1bW5zW2ldLnRyaW0oKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIC8vIGFsbG93IGVtcHR5IGNvbHVtbnMgYmVmb3JlIGFuZCBhZnRlciB0YWJsZSwgYnV0IG5vdCBpbiBiZXR3ZWVuIGNvbHVtbnM7XG4gICAgICAvLyBlLmcuIGFsbG93IGAgfC0tLXwgYCwgZGlzYWxsb3cgYCAtLS18fC0tLSBgXG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBjb2x1bW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXjo/LSs6PyQvLnRlc3QodCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHQuY2hhckNvZGVBdCh0Lmxlbmd0aCAtIDEpID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2godC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLyA/ICdjZW50ZXInIDogJ3JpZ2h0Jyk7XG4gICAgfSBlbHNlIGlmICh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBhbGlnbnMucHVzaCgnbGVmdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGlnbnMucHVzaCgnJyk7XG4gICAgfVxuICB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUpLnRyaW0oKTtcbiAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ3wnKSA9PT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuICBjb2x1bW5zID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0LnJlcGxhY2UoL15cXHx8XFx8JC9nLCAnJykpO1xuXG4gIC8vIGhlYWRlciByb3cgd2lsbCBkZWZpbmUgYW4gYW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIGVudGlyZSB0YWJsZSxcbiAgLy8gYW5kIGFsaWduIHJvdyBzaG91bGRuJ3QgYmUgc21hbGxlciB0aGFuIHRoYXQgKHRoZSByZXN0IG9mIHRoZSByb3dzIGNhbilcbiAgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgaWYgKGNvbHVtbkNvdW50ID4gYWxpZ25zLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGFibGVfb3BlbicsICd0YWJsZScsIDEpO1xuICB0b2tlbi5tYXAgPSB0YWJsZUxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0aGVhZF9vcGVuJywgJ3RoZWFkJywgMSk7XG4gIHRva2VuLm1hcCA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfb3BlbicsICd0cicsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0aF9vcGVuJywgJ3RoJywgMSk7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICB9XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0aF9jbG9zZScsICd0aCcsIC0xKTtcbiAgfVxuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX2Nsb3NlJywgJ3RyJywgLTEpO1xuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0aGVhZF9jbG9zZScsICd0aGVhZCcsIC0xKTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0Ym9keV9vcGVuJywgJ3Rib2R5JywgMSk7XG4gIHRva2VuLm1hcCA9IHRib2R5TGluZXMgPSBbIHN0YXJ0TGluZSArIDIsIDAgXTtcblxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMjsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgbmV4dExpbmUpLnRyaW0oKTtcbiAgICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyBicmVhazsgfVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgYnJlYWs7IH1cbiAgICBjb2x1bW5zID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0LnJlcGxhY2UoL15cXHx8XFx8JC9nLCAnJykpO1xuXG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGRfb3BlbicsICd0ZCcsIDEpO1xuICAgICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgICB0b2tlbi5hdHRycyAgPSBbIFsgJ3N0eWxlJywgJ3RleHQtYWxpZ246JyArIGFsaWduc1tpXSBdIF07XG4gICAgICB9XG5cbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCAgPSBjb2x1bW5zW2ldID8gY29sdW1uc1tpXS50cmltKCkgOiAnJztcbiAgICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGRfY2xvc2UnLCAndGQnLCAtMSk7XG4gICAgfVxuICAgIHRva2VuID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIH1cbiAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0Ym9keV9jbG9zZScsICd0Ym9keScsIC0xKTtcbiAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0YWJsZV9jbG9zZScsICd0YWJsZScsIC0xKTtcblxuICB0YWJsZUxpbmVzWzFdID0gdGJvZHlMaW5lc1sxXSA9IG5leHRMaW5lO1xuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2soc3RhdGUpIHtcbiAgdmFyIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYztcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgMCwgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLm1kLmJsb2NrLnBhcnNlKHN0YXRlLnNyYywgc3RhdGUubWQsIHN0YXRlLmVudiwgc3RhdGUudG9rZW5zKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5saW5lKHN0YXRlKSB7XG4gIHZhciB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsIHRvaywgaSwgbDtcblxuICAvLyBQYXJzZSBpbmxpbmVzXG4gIGZvciAoaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdG9rID0gdG9rZW5zW2ldO1xuICAgIGlmICh0b2sudHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHN0YXRlLm1kLmlubGluZS5wYXJzZSh0b2suY29udGVudCwgc3RhdGUubWQsIHN0YXRlLmVudiwgdG9rLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2lubGluZS5qcyIsIi8vIFJlcGxhY2UgbGluay1saWtlIHRleHRzIHdpdGggbGluayBub2Rlcy5cbi8vXG4vLyBDdXJyZW50bHkgcmVzdHJpY3RlZCBieSBgbWQudmFsaWRhdGVMaW5rKClgIHRvIGh0dHAvaHR0cHMvZnRwXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhcnJheVJlcGxhY2VBdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmFycmF5UmVwbGFjZUF0O1xuXG5cbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5raWZ5KHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dCwgcG9zLCBsYXN0UG9zLFxuICAgICAgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsIHVybCwgZnVsbFVybCwgdXJsVGV4dCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbGlua3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmxpbmtpZnkpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjdXJyZW50VG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBtYXJrZG93biBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSBjdXJyZW50VG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09ICdsaW5rX29wZW4nKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2h0bWxfaW5saW5lJykge1xuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh0bWxMaW5rTGV2ZWwgPiAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcblxuICAgICAgICB0ZXh0ID0gY3VycmVudFRva2VuLmNvbnRlbnQ7XG4gICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0KTtcblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxldmVsID0gY3VycmVudFRva2VuLmxldmVsO1xuICAgICAgICBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcblxuICAgICAgICAgIHVybCA9IGxpbmtzW2xuXS51cmw7XG4gICAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdXJsVGV4dCA9IGxpbmtzW2xuXS50ZXh0O1xuXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggZG9tYWluIG5hbWUuIFNvIHdlIHByZXBlbmQgaHR0cDovLyBpbiB0aG9zZSBjYXNlcyxcbiAgICAgICAgICAvLyBhbmQgcmVtb3ZlIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIWxpbmtzW2xuXS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnaHR0cDovLycgKyB1cmxUZXh0KS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5rc1tsbl0uc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnbWFpbHRvOicgKyB1cmxUZXh0KS5yZXBsYWNlKC9ebWFpbHRvOi8sICcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyA9IGxpbmtzW2xuXS5pbmRleDtcblxuICAgICAgICAgIGlmIChwb3MgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbCsrO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHVybFRleHQ7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSAtLWxldmVsO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXG4gICAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gYXJyYXlSZXBsYWNlQXQodG9rZW5zLCBpLCBub2Rlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzIiwiLy8gTm9ybWFsaXplIGlucHV0IHN0cmluZ1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIE5FV0xJTkVTX1JFICA9IC9cXHJbXFxuXFx1MDA4NV0/fFtcXHUyNDI0XFx1MjAyOFxcdTAwODVdL2c7XG52YXIgTlVMTF9SRSAgICAgID0gL1xcdTAwMDAvZztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgc3RyO1xuXG4gIC8vIE5vcm1hbGl6ZSBuZXdsaW5lc1xuICBzdHIgPSBzdGF0ZS5zcmMucmVwbGFjZShORVdMSU5FU19SRSwgJ1xcbicpO1xuXG4gIC8vIFJlcGxhY2UgTlVMTCBjaGFyYWN0ZXJzXG4gIHN0ciA9IHN0ci5yZXBsYWNlKE5VTExfUkUsICdcXHVGRkZEJyk7XG5cbiAgc3RhdGUuc3JjID0gc3RyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwiLy8gU2ltcGxlIHR5cG9ncmFwaHljIHJlcGxhY2VtZW50c1xuLy9cbi8vIChjKSAoQykg4oaSIMKpXG4vLyAodG0pIChUTSkg4oaSIOKEolxuLy8gKHIpIChSKSDihpIgwq5cbi8vICstIOKGkiDCsVxuLy8gKHApIChQKSAtPiDCp1xuLy8gLi4uIOKGkiDigKYgKGFsc28gPy4uLi4g4oaSID8uLiwgIS4uLi4g4oaSICEuLilcbi8vID8/Pz8/Pz8/IOKGkiA/Pz8sICEhISEhIOKGkiAhISEsIGAsLGAg4oaSIGAsYFxuLy8gLS0g4oaSICZuZGFzaDssIC0tLSDihpIgJm1kYXNoO1xuLy9cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzpcbi8vIC0gZnJhY3Rpb25hbHMgMS8yLCAxLzQsIDMvNCAtPiDCvSwgwrwsIMK+XG4vLyAtIG1pbHRpcGxpY2F0aW9uIDIgeCA0IC0+IDIgw5cgNFxuXG52YXIgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS87XG5cbi8vIFdvcmthcm91bmQgZm9yIHBoYW50b21qcyAtIG5lZWQgcmVnZXggd2l0aG91dCAvZyBmbGFnLFxuLy8gb3Igcm9vdCBjaGVjayB3aWxsIGZhaWwgZXZlcnkgc2Vjb25kIHRpbWVcbnZhciBTQ09QRURfQUJCUl9URVNUX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaTtcblxudmFyIFNDT1BFRF9BQkJSX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaWc7XG52YXIgU0NPUEVEX0FCQlIgPSB7XG4gIGM6ICfCqScsXG4gIHI6ICfCricsXG4gIHA6ICfCpycsXG4gIHRtOiAn4oSiJ1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBuYW1lKSB7XG4gIHJldHVybiBTQ09QRURfQUJCUltuYW1lLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlX3Njb3BlZChpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudC5yZXBsYWNlKFNDT1BFRF9BQkJSX1JFLCByZXBsYWNlRm4pO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9yYXJlKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIGlmIChSQVJFX1JFLnRlc3QodG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy0vZywgJ8KxJylcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4sIC4uLiwgLi4uLi4uLiAtPiDigKZcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0ID8uLi4uLiAmICEuLi4uLiAtPiA/Li4gJiAhLi5cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcLnsyLH0vZywgJ+KApicpLnJlcGxhY2UoLyhbPyFdKeKApi9nLCAnJDEuLicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oWz8hXSl7NCx9L2csICckMSQxJDEnKS5yZXBsYWNlKC8sezIsfS9nLCAnLCcpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLV0pLS0tKFteLV18JCkvbWcsICckMVxcdTIwMTQkMicpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFxccyktLShcXHN8JCkvbWcsICckMVxcdTIwMTMkMicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1cXHNdKS0tKFteLVxcc118JCkvbWcsICckMVxcdTIwMTMkMicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWU7IH1cblxuICAgIGlmIChTQ09QRURfQUJCUl9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2Vfc2NvcGVkKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpZiAoUkFSRV9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICByZXBsYWNlX3JhcmUoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMiLCIvLyBDb252ZXJ0IHN0cmFpZ2h0IHF1b3RhdGlvbiBtYXJrcyB0byB0eXBvZ3JhcGhpYyBvbmVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XG5cbnZhciBRVU9URV9URVNUX1JFID0gL1snXCJdLztcbnZhciBRVU9URV9SRSA9IC9bJ1wiXS9nO1xudmFyIEFQT1NUUk9QSEUgPSAnXFx1MjAxOSc7IC8qIOKAmSAqL1xuXG5cbmZ1bmN0aW9uIHJlcGxhY2VBdChzdHIsIGluZGV4LCBjaCkge1xuICByZXR1cm4gc3RyLnN1YnN0cigwLCBpbmRleCkgKyBjaCArIHN0ci5zdWJzdHIoaW5kZXggKyAxKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc19pbmxpbmVzKHRva2Vucywgc3RhdGUpIHtcbiAgdmFyIGksIHRva2VuLCB0ZXh0LCB0LCBwb3MsIG1heCwgdGhpc0xldmVsLCBpdGVtLCBsYXN0Q2hhciwgbmV4dENoYXIsXG4gICAgICBpc0xhc3RQdW5jdENoYXIsIGlzTmV4dFB1bmN0Q2hhciwgaXNMYXN0V2hpdGVTcGFjZSwgaXNOZXh0V2hpdGVTcGFjZSxcbiAgICAgIGNhbk9wZW4sIGNhbkNsb3NlLCBqLCBpc1NpbmdsZSwgc3RhY2ssIG9wZW5RdW90ZSwgY2xvc2VRdW90ZTtcblxuICBzdGFjayA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIHRoaXNMZXZlbCA9IHRva2Vuc1tpXS5sZXZlbDtcblxuICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPD0gdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIHN0YWNrLmxlbmd0aCA9IGogKyAxO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgcG9zID0gMDtcbiAgICBtYXggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIC8qZXNsaW50IG5vLWxhYmVsczowLGJsb2NrLXNjb3BlZC12YXI6MCovXG4gICAgT1VURVI6XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgUVVPVEVfUkUubGFzdEluZGV4ID0gcG9zO1xuICAgICAgdCA9IFFVT1RFX1JFLmV4ZWModGV4dCk7XG4gICAgICBpZiAoIXQpIHsgYnJlYWs7IH1cblxuICAgICAgY2FuT3BlbiA9IGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIHBvcyA9IHQuaW5kZXggKyAxO1xuICAgICAgaXNTaW5nbGUgPSAodFswXSA9PT0gXCInXCIpO1xuXG4gICAgICAvLyBGaW5kIHByZXZpb3VzIGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbGFzdENoYXIgPSAweDIwO1xuXG4gICAgICBpZiAodC5pbmRleCAtIDEgPj0gMCkge1xuICAgICAgICBsYXN0Q2hhciA9IHRleHQuY2hhckNvZGVBdCh0LmluZGV4IC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgbGFzdENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KHRva2Vuc1tqXS5jb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgbmV4dCBjaGFyYWN0ZXIsXG4gICAgICAvLyBkZWZhdWx0IHRvIHNwYWNlIGlmIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgLy9cbiAgICAgIG5leHRDaGFyID0gMHgyMDtcblxuICAgICAgaWYgKHBvcyA8IG1heCkge1xuICAgICAgICBuZXh0Q2hhciA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgbmV4dENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XG4gICAgICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xuXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgICAgIGlzTmV4dFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuXG4gICAgICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRDaGFyID09PSAweDIyIC8qIFwiICovICYmIHRbMF0gPT09ICdcIicpIHtcbiAgICAgICAgaWYgKGxhc3RDaGFyID49IDB4MzAgLyogMCAqLyAmJiBsYXN0Q2hhciA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IDFcIlwiIC0gY291bnQgZmlyc3QgcXVvdGUgYXMgYW4gaW5jaFxuICAgICAgICAgIGNhbkNsb3NlID0gY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5PcGVuICYmIGNhbkNsb3NlKSB7XG4gICAgICAgIC8vIHRyZWF0IHRoaXMgYXMgdGhlIG1pZGRsZSBvZiB0aGUgd29yZFxuICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIGNhbkNsb3NlID0gaXNOZXh0UHVuY3RDaGFyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbk9wZW4gJiYgIWNhbkNsb3NlKSB7XG4gICAgICAgIC8vIG1pZGRsZSBvZiB3b3JkXG4gICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5DbG9zZSkge1xuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGEgY2xvc2luZyBxdW90ZSwgcmV3aW5kIHRoZSBzdGFjayB0byBnZXQgYSBtYXRjaFxuICAgICAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcbiAgICAgICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPCB0aGlzTGV2ZWwpIHsgYnJlYWs7IH1cbiAgICAgICAgICBpZiAoaXRlbS5zaW5nbGUgPT09IGlzU2luZ2xlICYmIHN0YWNrW2pdLmxldmVsID09PSB0aGlzTGV2ZWwpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcblxuICAgICAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzJdO1xuICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbM107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1swXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRva2VuLmNvbnRlbnQgKmJlZm9yZSogdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlLCBpZiB0aGV5IGFyZSBwb2ludGluZyBhdCB0aGUgc2FtZSB0b2tlbiwgcmVwbGFjZUF0XG4gICAgICAgICAgICAvLyBjb3VsZCBtZXNzIHVwIGluZGljZXMgd2hlbiBxdW90ZSBsZW5ndGggIT0gMVxuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBjbG9zZVF1b3RlKTtcbiAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50ID0gcmVwbGFjZUF0KFxuICAgICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCwgaXRlbS5wb3MsIG9wZW5RdW90ZSk7XG5cbiAgICAgICAgICAgIHBvcyArPSBjbG9zZVF1b3RlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAoaXRlbS50b2tlbiA9PT0gaSkgeyBwb3MgKz0gb3BlblF1b3RlLmxlbmd0aCAtIDE7IH1cblxuICAgICAgICAgICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICBtYXggPSB0ZXh0Lmxlbmd0aDtcblxuICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlIE9VVEVSO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3Blbikge1xuICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICB0b2tlbjogaSxcbiAgICAgICAgICBwb3M6IHQuaW5kZXgsXG4gICAgICAgICAgc2luZ2xlOiBpc1NpbmdsZSxcbiAgICAgICAgICBsZXZlbDogdGhpc0xldmVsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChjYW5DbG9zZSAmJiBpc1NpbmdsZSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc21hcnRxdW90ZXMoc3RhdGUpIHtcbiAgLyplc2xpbnQgbWF4LWRlcHRoOjAqL1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhUVVPVEVfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwcm9jZXNzX2lubGluZXMoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4sIHN0YXRlKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCIvLyBDb3JlIHN0YXRlIG9iamVjdFxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcblxuXG5mdW5jdGlvbiBTdGF0ZUNvcmUoc3JjLCBtZCwgZW52KSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy5pbmxpbmVNb2RlID0gZmFsc2U7XG4gIHRoaXMubWQgPSBtZDsgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2Vcbn1cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBjb3JlIHJ1bGVzXG5TdGF0ZUNvcmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUNvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCIvLyBQcm9jZXNzIGF1dG9saW5rcyAnPHByb3RvY29sOi4uLj4nXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKmVzbGludCBtYXgtbGVuOjAqL1xudmFyIEVNQUlMX1JFICAgID0gL148KFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopPi87XG52YXIgQVVUT0xJTktfUkUgPSAvXjwoW2EtekEtWl1bYS16QS1aMC05Ky5cXC1dezEsMzF9KTooW148PlxceDAwLVxceDIwXSopPi87XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdXRvbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciB0YWlsLCBsaW5rTWF0Y2gsIGVtYWlsTWF0Y2gsIHVybCwgZnVsbFVybCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHRhaWwgPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTtcblxuICBpZiAodGFpbC5pbmRleE9mKCc+JykgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChBVVRPTElOS19SRS50ZXN0KHRhaWwpKSB7XG4gICAgbGlua01hdGNoID0gdGFpbC5tYXRjaChBVVRPTElOS19SRSk7XG5cbiAgICB1cmwgPSBsaW5rTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGxpbmtNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRU1BSUxfUkUudGVzdCh0YWlsKSkge1xuICAgIGVtYWlsTWF0Y2ggPSB0YWlsLm1hdGNoKEVNQUlMX1JFKTtcblxuICAgIHVybCA9IGVtYWlsTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKCdtYWlsdG86JyArIHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGVtYWlsTWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIi8vIFBhcnNlIGJhY2t0aWNrc1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFja3RpY2soc3RhdGUsIHNpbGVudCkge1xuICB2YXIgc3RhcnQsIG1heCwgbWFya2VyLCBtYXRjaFN0YXJ0LCBtYXRjaEVuZCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKGNoICE9PSAweDYwLyogYCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzdGFydCA9IHBvcztcbiAgcG9zKys7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NjAvKiBgICovKSB7IHBvcysrOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpO1xuXG4gIG1hdGNoU3RhcnQgPSBtYXRjaEVuZCA9IHBvcztcblxuICB3aGlsZSAoKG1hdGNoU3RhcnQgPSBzdGF0ZS5zcmMuaW5kZXhPZignYCcsIG1hdGNoRW5kKSkgIT09IC0xKSB7XG4gICAgbWF0Y2hFbmQgPSBtYXRjaFN0YXJ0ICsgMTtcblxuICAgIHdoaWxlIChtYXRjaEVuZCA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChtYXRjaEVuZCkgPT09IDB4NjAvKiBgICovKSB7IG1hdGNoRW5kKys7IH1cblxuICAgIGlmIChtYXRjaEVuZCAtIG1hdGNoU3RhcnQgPT09IG1hcmtlci5sZW5ndGgpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2lubGluZScsICdjb2RlJywgMCk7XG4gICAgICAgIHRva2VuLm1hcmt1cCAgPSBtYXJrZXI7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXRjaFN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1sgXFxuXSsvZywgJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IG1hdGNoRW5kO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBtYXJrZXI7IH1cbiAgc3RhdGUucG9zICs9IG1hcmtlci5sZW5ndGg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWNrdGlja3MuanMiLCIvLyBGb3IgZWFjaCBvcGVuaW5nIGVtcGhhc2lzLWxpa2UgbWFya2VyIGZpbmQgYSBtYXRjaGluZyBjbG9zaW5nIG9uZVxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmtfcGFpcnMoc3RhdGUpIHtcbiAgdmFyIGksIGosIGxhc3REZWxpbSwgY3VyckRlbGltLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBsYXN0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKCFsYXN0RGVsaW0uY2xvc2UpIHsgY29udGludWU7IH1cblxuICAgIGogPSBpIC0gbGFzdERlbGltLmp1bXAgLSAxO1xuXG4gICAgd2hpbGUgKGogPj0gMCkge1xuICAgICAgY3VyckRlbGltID0gZGVsaW1pdGVyc1tqXTtcblxuICAgICAgaWYgKGN1cnJEZWxpbS5vcGVuICYmXG4gICAgICAgICAgY3VyckRlbGltLm1hcmtlciA9PT0gbGFzdERlbGltLm1hcmtlciAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5lbmQgPCAwICYmXG4gICAgICAgICAgY3VyckRlbGltLmxldmVsID09PSBsYXN0RGVsaW0ubGV2ZWwpIHtcblxuICAgICAgICAvLyB0eXBlb2ZzIGFyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHBsdWdpbnNcbiAgICAgICAgdmFyIG9kZF9tYXRjaCA9IChjdXJyRGVsaW0uY2xvc2UgfHwgbGFzdERlbGltLm9wZW4pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY3VyckRlbGltLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBsYXN0RGVsaW0ubGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnJEZWxpbS5sZW5ndGggKyBsYXN0RGVsaW0ubGVuZ3RoKSAlIDMgPT09IDA7XG5cbiAgICAgICAgaWYgKCFvZGRfbWF0Y2gpIHtcbiAgICAgICAgICBsYXN0RGVsaW0uanVtcCA9IGkgLSBqO1xuICAgICAgICAgIGxhc3REZWxpbS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgY3VyckRlbGltLmVuZCAgPSBpO1xuICAgICAgICAgIGN1cnJEZWxpbS5qdW1wID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBqIC09IGN1cnJEZWxpbS5qdW1wICsgMTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qcyIsIi8vIFByb2Nlc3MgaHRtbCBlbnRpdHkgLSAmIzEyMzssICYjeEFGOywgJnF1b3Q7LCAuLi5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW50aXRpZXMgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vZW50aXRpZXMnKTtcbnZhciBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmhhcztcbnZhciBpc1ZhbGlkRW50aXR5Q29kZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzVmFsaWRFbnRpdHlDb2RlO1xudmFyIGZyb21Db2RlUG9pbnQgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuZnJvbUNvZGVQb2ludDtcblxuXG52YXIgRElHSVRBTF9SRSA9IC9eJiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpOy9pO1xudmFyIE5BTUVEX1JFICAgPSAvXiYoW2Etel1bYS16MC05XXsxLDMxfSk7L2k7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbnRpdHkoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIGNvZGUsIG1hdGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyNi8qICYgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDEgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuXG4gICAgaWYgKGNoID09PSAweDIzIC8qICMgKi8pIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goRElHSVRBTF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICBjb2RlID0gbWF0Y2hbMV1bMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID8gcGFyc2VJbnQobWF0Y2hbMV0uc2xpY2UoMSksIDE2KSA6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgc3RhdGUucGVuZGluZyArPSBpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSA/IGZyb21Db2RlUG9pbnQoY29kZSkgOiBmcm9tQ29kZVBvaW50KDB4RkZGRCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goTkFNRURfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChoYXMoZW50aXRpZXMsIG1hdGNoWzFdKSkge1xuICAgICAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gZW50aXRpZXNbbWF0Y2hbMV1dOyB9XG4gICAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJyYnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwiLy8gUHJvY2Vlc3MgZXNjYXBlZCBjaGFycyBhbmQgaGFyZGJyZWFrc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxudmFyIEVTQ0FQRUQgPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykgeyBFU0NBUEVELnB1c2goMCk7IH1cblxuJ1xcXFwhXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXV5fYHt8fX4tJ1xuICAuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7IEVTQ0FQRURbY2guY2hhckNvZGVBdCgwKV0gPSAxOyB9KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUMvKiBcXCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MrKztcblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoIDwgMjU2ICYmIEVTQ0FQRURbY2hdICE9PSAwKSB7XG4gICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1twb3NdOyB9XG4gICAgICBzdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgICAgLy8gc2tpcCBsZWFkaW5nIHdoaXRlc3BhY2VzIGZyb20gbmV4dCBsaW5lXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zID0gcG9zO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnXFxcXCc7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCIvLyBQcm9jZXNzIGh0bWwgdGFnc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX1RBR19SRTtcblxuXG5mdW5jdGlvbiBpc0xldHRlcihjaCkge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICB2YXIgbGMgPSBjaCB8IDB4MjA7IC8vIHRvIGxvd2VyIGNhc2VcbiAgcmV0dXJuIChsYyA+PSAweDYxLyogYSAqLykgJiYgKGxjIDw9IDB4N2EvKiB6ICovKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfaW5saW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBtYXRjaCwgbWF4LCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBDaGVjayBzdGFydFxuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLyB8fFxuICAgICAgcG9zICsgMiA+PSBtYXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBRdWljayBmYWlsIG9uIHNlY29uZCBjaGFyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8gJiZcbiAgICAgIGNoICE9PSAweDNGLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4MkYvKiAvICovICYmXG4gICAgICAhaXNMZXR0ZXIoY2gpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChIVE1MX1RBR19SRSk7XG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9pbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIG1hdGNoWzBdLmxlbmd0aCk7XG4gIH1cbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzIiwiLy8gUHJvY2VzcyAhW2ltYWdlXSg8c3JjPiBcInRpdGxlXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltYWdlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlZixcbiAgICAgIHJlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICB0b2tlbnMsXG4gICAgICBzdGFydCxcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHgyMS8qICEgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDI7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuXG4gICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKFxuICAgICAgY29udGVudCxcbiAgICAgIHN0YXRlLm1kLFxuICAgICAgc3RhdGUuZW52LFxuICAgICAgdG9rZW5zID0gW11cbiAgICApO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbWFnZScsICdpbWcnLCAwKTtcbiAgICB0b2tlbi5hdHRycyAgICA9IGF0dHJzID0gWyBbICdzcmMnLCBocmVmIF0sIFsgJ2FsdCcsICcnIF0gXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwiLy8gUHJvY2VzcyBbbGlua10oPHRvPiBcInN0dWZmXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIGxhYmVsU3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZXMsXG4gICAgICByZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHRva2VuLFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAxO1xuICBsYWJlbEVuZCA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXRlLnBvcywgdHJ1ZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBtaWdodCBoYXZlIGZvdW5kIGEgdmFsaWQgc2hvcnRjdXQgbGluaywgZGlzYWJsZSByZWZlcmVuY2UgcGFyc2luZ1xuICAgIHBhcnNlUmVmZXJlbmNlID0gZmFsc2U7XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIC8vIHBhcnNpbmcgYSB2YWxpZCBzaG9ydGN1dCBsaW5rIGZhaWxlZCwgZmFsbGJhY2sgdG8gcmVmZXJlbmNlXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBhcnNlUmVmZXJlbmNlKSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucG9zID0gbGFiZWxTdGFydDtcbiAgICBzdGF0ZS5wb3NNYXggPSBsYWJlbEVuZDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgdG9rZW4uYXR0cnMgID0gYXR0cnMgPSBbIFsgJ2hyZWYnLCBocmVmIF0gXTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9saW5rLmpzIiwiLy8gUHJvY2Vlc3MgJ1xcbidcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBuZXdsaW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBtYXgsIG1heCwgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDBBLyogXFxuICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBtYXggPSBzdGF0ZS5wZW5kaW5nLmxlbmd0aCAtIDE7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICAvLyAnICBcXG4nIC0+IGhhcmRicmVha1xuICAvLyBMb29rdXAgaW4gcGVuZGluZyBjaGFycyBpcyBiYWQgcHJhY3RpY2UhIERvbid0IGNvcHkgdG8gb3RoZXIgcnVsZXMhXG4gIC8vIFBlbmRpbmcgc3RyaW5nIGlzIHN0b3JlZCBpbiBjb25jYXQgbW9kZSwgaW5kZXhlZCBsb29rdXBzIHdpbGwgY2F1c2VcbiAgLy8gY29udmVydGlvbiB0byBmbGF0IG1vZGUuXG4gIGlmICghc2lsZW50KSB7XG4gICAgaWYgKHBtYXggPj0gMCAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCkgPT09IDB4MjApIHtcbiAgICAgIGlmIChwbWF4ID49IDEgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXggLSAxKSA9PT0gMHgyMCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5yZXBsYWNlKC8gKyQvLCAnJyk7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICB9XG4gIH1cblxuICBwb3MrKztcblxuICAvLyBza2lwIGhlYWRpbmcgc3BhY2VzIGZvciBuZXh0IGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7IHBvcysrOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qcyIsIi8vIElubGluZSBwYXJzZXIgc3RhdGVcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUb2tlbiAgICAgICAgICA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xuXG5cbmZ1bmN0aW9uIFN0YXRlSW5saW5lKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy5tZCA9IG1kO1xuICB0aGlzLnRva2VucyA9IG91dFRva2VucztcblxuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMucG9zTWF4ID0gdGhpcy5zcmMubGVuZ3RoO1xuICB0aGlzLmxldmVsID0gMDtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHRoaXMucGVuZGluZ0xldmVsID0gMDtcblxuICB0aGlzLmNhY2hlID0ge307ICAgICAgICAvLyBTdG9yZXMgeyBzdGFydDogZW5kIH0gcGFpcnMuIFVzZWZ1bCBmb3IgYmFja3RyYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGltaXphdGlvbiBvZiBwYWlycyBwYXJzZSAoZW1waGFzaXMsIHN0cmlrZXMpLlxuXG4gIHRoaXMuZGVsaW1pdGVycyA9IFtdOyAgIC8vIEVtcGhhc2lzLWxpa2UgZGVsaW1pdGVyc1xufVxuXG5cbi8vIEZsdXNoIHBlbmRpbmcgdGV4dFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKCd0ZXh0JywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ID0gdGhpcy5wZW5kaW5nO1xuICB0b2tlbi5sZXZlbCA9IHRoaXMucGVuZGluZ0xldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vIElmIHBlbmRpbmcgdGV4dCBleGlzdHMgLSBmbHVzaCBpdCBhcyB0ZXh0IHRva2VuXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICB0aGlzLnB1c2hQZW5kaW5nKCk7XG4gIH1cblxuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcblxuICBpZiAobmVzdGluZyA8IDApIHsgdGhpcy5sZXZlbC0tOyB9XG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxuXG4gIHRoaXMucGVuZGluZ0xldmVsID0gdGhpcy5sZXZlbDtcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gU2NhbiBhIHNlcXVlbmNlIG9mIGVtcGhhc2lzLWxpa2UgbWFya2VycywgYW5kIGRldGVybWluZSB3aGV0aGVyXG4vLyBpdCBjYW4gc3RhcnQgYW4gZW1waGFzaXMgc2VxdWVuY2Ugb3IgZW5kIGFuIGVtcGhhc2lzIHNlcXVlbmNlLlxuLy9cbi8vICAtIHN0YXJ0IC0gcG9zaXRpb24gdG8gc2NhbiBmcm9tIChpdCBzaG91bGQgcG9pbnQgYXQgYSB2YWxpZCBtYXJrZXIpO1xuLy8gIC0gY2FuU3BsaXRXb3JkIC0gZGV0ZXJtaW5lIGlmIHRoZXNlIG1hcmtlcnMgY2FuIGJlIGZvdW5kIGluc2lkZSBhIHdvcmRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuc2NhbkRlbGltcyA9IGZ1bmN0aW9uIChzdGFydCwgY2FuU3BsaXRXb3JkKSB7XG4gIHZhciBwb3MgPSBzdGFydCwgbGFzdENoYXIsIG5leHRDaGFyLCBjb3VudCwgY2FuX29wZW4sIGNhbl9jbG9zZSxcbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UsIGlzTGFzdFB1bmN0Q2hhcixcbiAgICAgIGlzTmV4dFdoaXRlU3BhY2UsIGlzTmV4dFB1bmN0Q2hhcixcbiAgICAgIGxlZnRfZmxhbmtpbmcgPSB0cnVlLFxuICAgICAgcmlnaHRfZmxhbmtpbmcgPSB0cnVlLFxuICAgICAgbWF4ID0gdGhpcy5wb3NNYXgsXG4gICAgICBtYXJrZXIgPSB0aGlzLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICAvLyB0cmVhdCBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXG4gIGxhc3RDaGFyID0gc3RhcnQgPiAwID8gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCAtIDEpIDogMHgyMDtcblxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gbWFya2VyKSB7IHBvcysrOyB9XG5cbiAgY291bnQgPSBwb3MgLSBzdGFydDtcblxuICAvLyB0cmVhdCBlbmQgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXG4gIG5leHRDaGFyID0gcG9zIDwgbWF4ID8gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpIDogMHgyMDtcblxuICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xuXG4gIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcblxuICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgIGxlZnRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcbiAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgIGxlZnRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY2FuU3BsaXRXb3JkKSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZyAgJiYgKCFyaWdodF9mbGFua2luZyB8fCBpc0xhc3RQdW5jdENoYXIpO1xuICAgIGNhbl9jbG9zZSA9IHJpZ2h0X2ZsYW5raW5nICYmICghbGVmdF9mbGFua2luZyAgfHwgaXNOZXh0UHVuY3RDaGFyKTtcbiAgfSBlbHNlIHtcbiAgICBjYW5fb3BlbiAgPSBsZWZ0X2ZsYW5raW5nO1xuICAgIGNhbl9jbG9zZSA9IHJpZ2h0X2ZsYW5raW5nO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjYW5fb3BlbjogIGNhbl9vcGVuLFxuICAgIGNhbl9jbG9zZTogY2FuX2Nsb3NlLFxuICAgIGxlbmd0aDogICAgY291bnRcbiAgfTtcbn07XG5cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUlubGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCIvLyBTa2lwIHRleHQgY2hhcmFjdGVycyBmb3IgdGV4dCB0b2tlbiwgcGxhY2UgdGhvc2UgdG8gcGVuZGluZyBidWZmZXJcbi8vIGFuZCBpbmNyZW1lbnQgY3VycmVudCBwb3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIFJ1bGUgdG8gc2tpcCBwdXJlIHRleHRcbi8vICd7fSQlQH4rPTonIHJlc2VydmVkIGZvciBleHRlbnRpb25zXG5cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuXG4vLyAhISEhIERvbid0IGNvbmZ1c2Ugd2l0aCBcIk1hcmtkb3duIEFTQ0lJIFB1bmN0dWF0aW9uXCIgY2hhcnNcbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuZnVuY3Rpb24gaXNUZXJtaW5hdG9yQ2hhcihjaCkge1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAweDBBLyogXFxuICovOlxuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHg0MC8qIEAgKi86XG4gICAgY2FzZSAweDVCLyogWyAqLzpcbiAgICBjYXNlIDB4NUMvKiBcXCAqLzpcbiAgICBjYXNlIDB4NUQvKiBdICovOlxuICAgIGNhc2UgMHg1RS8qIF4gKi86XG4gICAgY2FzZSAweDVGLyogXyAqLzpcbiAgICBjYXNlIDB4NjAvKiBgICovOlxuICAgIGNhc2UgMHg3Qi8qIHsgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHQoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG9zID0gc3RhdGUucG9zO1xuXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5wb3NNYXggJiYgIWlzVGVybWluYXRvckNoYXIoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwb3MgPT09IHN0YXRlLnBvcykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5wb3MsIHBvcyk7IH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBBbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgZm9yIG1lbW9yeS5cbi8vXG4vLyBJdCBjb3N0cyAxMCUgb2YgcGVyZm9ybWFuY2UsIGJ1dCBhbGxvd3MgZXh0ZW5kIHRlcm1pbmF0b3JzIGxpc3QsIGlmIHBsYWNlIGl0XG4vLyB0byBgUGFyY2VySW5saW5lYCBwcm9wZXJ0eS4gUHJvYmFibHksIHdpbGwgc3dpdGNoIHRvIGl0IHNvbWV0aW1lLCBzdWNoXG4vLyBmbGV4aWJpbGl0eSByZXF1aXJlZC5cblxuLypcbnZhciBURVJNSU5BVE9SX1JFID0gL1tcXG4hIyQlJiorXFwtOjw9PkBbXFxcXFxcXV5fYHt9fl0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHQoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG9zID0gc3RhdGUucG9zLFxuICAgICAgaWR4ID0gc3RhdGUuc3JjLnNsaWNlKHBvcykuc2VhcmNoKFRFUk1JTkFUT1JfUkUpO1xuXG4gIC8vIGZpcnN0IGNoYXIgaXMgdGVybWluYXRvciAtPiBlbXB0eSB0ZXh0XG4gIGlmIChpZHggPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbm8gdGVybWluYXRvciAtPiB0ZXh0IHRpbGwgZW5kIG9mIHN0cmluZ1xuICBpZiAoaWR4IDwgMCkge1xuICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcyk7IH1cbiAgICBzdGF0ZS5wb3MgPSBzdGF0ZS5zcmMubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBwb3MgKyBpZHgpOyB9XG5cbiAgc3RhdGUucG9zICs9IGlkeDtcblxuICByZXR1cm4gdHJ1ZTtcbn07Ki9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwiLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyBpbnRvIG9uZSwgYW5kIHJlLWNhbGN1bGF0ZSBhbGwgdG9rZW4gbGV2ZWxzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dF9jb2xsYXBzZShzdGF0ZSkge1xuICB2YXIgY3VyciwgbGFzdCxcbiAgICAgIGxldmVsID0gMCxcbiAgICAgIHRva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIG1heCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgZm9yIChjdXJyID0gbGFzdCA9IDA7IGN1cnIgPCBtYXg7IGN1cnIrKykge1xuICAgIC8vIHJlLWNhbGN1bGF0ZSBsZXZlbHNcbiAgICBsZXZlbCArPSB0b2tlbnNbY3Vycl0ubmVzdGluZztcbiAgICB0b2tlbnNbY3Vycl0ubGV2ZWwgPSBsZXZlbDtcblxuICAgIGlmICh0b2tlbnNbY3Vycl0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIGN1cnIgKyAxIDwgbWF4ICYmXG4gICAgICAgIHRva2Vuc1tjdXJyICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG5cbiAgICAgIC8vIGNvbGxhcHNlIHR3byBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQgPSB0b2tlbnNbY3Vycl0uY29udGVudCArIHRva2Vuc1tjdXJyICsgMV0uY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnIgIT09IGxhc3QpIHsgdG9rZW5zW2xhc3RdID0gdG9rZW5zW2N1cnJdOyB9XG5cbiAgICAgIGxhc3QrKztcbiAgICB9XG4gIH1cblxuICBpZiAoY3VyciAhPT0gbGFzdCkge1xuICAgIHRva2Vucy5sZW5ndGggPSBsYXN0O1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbnZhciBkZWNvZGVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgY2FjaGUucHVzaChjaCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gZXhjbHVkZS5jaGFyQ29kZUF0KGkpO1xuICAgIGNhY2hlW2NoXSA9ICclJyArICgnMCcgKyBjaC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIERlY29kZSBwZXJjZW50LWVuY29kZWQgc3RyaW5nLlxuLy9cbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGV4Y2x1ZGUpIHtcbiAgdmFyIGNhY2hlO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICBleGNsdWRlID0gZGVjb2RlLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oJVthLWYwLTldezJ9KSsvZ2ksIGZ1bmN0aW9uKHNlcSkge1xuICAgIHZhciBpLCBsLCBiMSwgYjIsIGIzLCBiNCwgY2hyLFxuICAgICAgICByZXN1bHQgPSAnJztcblxuICAgIGZvciAoaSA9IDAsIGwgPSBzZXEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICBiMSA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMSwgaSArIDMpLCAxNik7XG5cbiAgICAgIGlmIChiMSA8IDB4ODApIHtcbiAgICAgICAgcmVzdWx0ICs9IGNhY2hlW2IxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEUwKSA9PT0gMHhDMCAmJiAoaSArIDMgPCBsKSkge1xuICAgICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCA2KSAmIDB4N0MwKSB8IChiMiAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGMCkgPT09IDB4RTAgJiYgKGkgKyA2IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxMikgJiAweEYwMDApIHwgKChiMiA8PCA2KSAmIDB4RkMwKSB8IChiMyAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODAwIHx8IChjaHIgPj0gMHhEODAwICYmIGNociA8PSAweERGRkYpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEY4KSA9PT0gMHhGMCAmJiAoaSArIDkgPCBsKSkge1xuICAgICAgICAvLyAxMTExMTB4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcbiAgICAgICAgYjQgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEwLCBpICsgMTIpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwICYmIChiNCAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxOCkgJiAweDFDMDAwMCkgfCAoKGIyIDw8IDEyKSAmIDB4M0YwMDApIHwgKChiMyA8PCA2KSAmIDB4RkMwKSB8IChiNCAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4MTAwMDAgfHwgY2hyID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociAtPSAweDEwMDAwO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKGNociA+PiAxMCksIDB4REMwMCArIChjaHIgJiAweDNGRikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gJ1xcdWZmZmQnO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG5cbmRlY29kZS5kZWZhdWx0Q2hhcnMgICA9ICc7Lz86QCY9KyQsIyc7XG5kZWNvZGUuY29tcG9uZW50Q2hhcnMgPSAnJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZGVjb2RlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGVuY29kZUNhY2hlID0ge307XG5cblxuLy8gQ3JlYXRlIGEgbG9va3VwIGFycmF5IHdoZXJlIGFueXRoaW5nIGJ1dCBjaGFyYWN0ZXJzIGluIGBjaGFyc2Agc3RyaW5nXG4vLyBhbmQgYWxwaGFudW1lcmljIGNoYXJzIGlzIHBlcmNlbnQtZW5jb2RlZC5cbi8vXG5mdW5jdGlvbiBnZXRFbmNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG5cbiAgICBpZiAoL15bMC05YS16XSQvaS50ZXN0KGNoKSkge1xuICAgICAgLy8gYWx3YXlzIGFsbG93IHVuZW5jb2RlZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgY2FjaGUucHVzaChjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLnB1c2goJyUnICsgKCcwJyArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZVtleGNsdWRlLmNoYXJDb2RlQXQoaSldID0gZXhjbHVkZVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBFbmNvZGUgdW5zYWZlIGNoYXJhY3RlcnMgd2l0aCBwZXJjZW50LWVuY29kaW5nLCBza2lwcGluZyBhbHJlYWR5XG4vLyBlbmNvZGVkIHNlcXVlbmNlcy5cbi8vXG4vLyAgLSBzdHJpbmcgICAgICAgLSBzdHJpbmcgdG8gZW5jb2RlXG4vLyAgLSBleGNsdWRlICAgICAgLSBsaXN0IG9mIGNoYXJhY3RlcnMgdG8gaWdub3JlIChpbiBhZGRpdGlvbiB0byBhLXpBLVowLTkpXG4vLyAgLSBrZWVwRXNjYXBlZCAgLSBkb24ndCBlbmNvZGUgJyUnIGluIGEgY29ycmVjdCBlc2NhcGUgc2VxdWVuY2UgKGRlZmF1bHQ6IHRydWUpXG4vL1xuZnVuY3Rpb24gZW5jb2RlKHN0cmluZywgZXhjbHVkZSwga2VlcEVzY2FwZWQpIHtcbiAgdmFyIGksIGwsIGNvZGUsIG5leHRDb2RlLCBjYWNoZSxcbiAgICAgIHJlc3VsdCA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBlbmNvZGUoc3RyaW5nLCBrZWVwRXNjYXBlZClcbiAgICBrZWVwRXNjYXBlZCAgPSBleGNsdWRlO1xuICAgIGV4Y2x1ZGUgPSBlbmNvZGUuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBrZWVwRXNjYXBlZCA9IHRydWU7XG4gIH1cblxuICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUgPT09IDB4MjUgLyogJSAqLyAmJiBpICsgMiA8IGwpIHtcbiAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoaSwgaSArIDMpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICByZXN1bHQgKz0gY2FjaGVbY29kZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcbiAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REJGRiAmJiBpICsgMSA8IGwpIHtcbiAgICAgICAgbmV4dENvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgIGlmIChuZXh0Q29kZSA+PSAweERDMDAgJiYgbmV4dENvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0gKyBzdHJpbmdbaSArIDFdKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmVuY29kZS5kZWZhdWx0Q2hhcnMgICA9IFwiOy8/OkAmPSskLC1fLiF+KicoKSNcIjtcbmVuY29kZS5jb21wb25lbnRDaGFycyA9IFwiLV8uIX4qJygpXCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2VuY29kZS5qcyIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ybWF0KHVybCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgcmVzdWx0ICs9IHVybC5wcm90b2NvbCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zbGFzaGVzID8gJy8vJyA6ICcnO1xuICByZXN1bHQgKz0gdXJsLmF1dGggPyB1cmwuYXV0aCArICdAJyA6ICcnO1xuXG4gIGlmICh1cmwuaG9zdG5hbWUgJiYgdXJsLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAvLyBpcHY2IGFkZHJlc3NcbiAgICByZXN1bHQgKz0gJ1snICsgdXJsLmhvc3RuYW1lICsgJ10nO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSB1cmwuaG9zdG5hbWUgfHwgJyc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLnBvcnQgPyAnOicgKyB1cmwucG9ydCA6ICcnO1xuICByZXN1bHQgKz0gdXJsLnBhdGhuYW1lIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNlYXJjaCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5oYXNoIHx8ICcnO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9mb3JtYXQuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQ2hhbmdlcyBmcm9tIGpveWVudC9ub2RlOlxuLy9cbi8vIDEuIE5vIGxlYWRpbmcgc2xhc2ggaW4gcGF0aHMsXG4vLyAgICBlLmcuIGluIGB1cmwucGFyc2UoJ2h0dHA6Ly9mb28/YmFyJylgIHBhdGhuYW1lIGlzIGBgLCBub3QgYC9gXG4vL1xuLy8gMi4gQmFja3NsYXNoZXMgYXJlIG5vdCByZXBsYWNlZCB3aXRoIHNsYXNoZXMsXG4vLyAgICBzbyBgaHR0cDpcXFxcZXhhbXBsZS5vcmdcXGAgaXMgdHJlYXRlZCBsaWtlIGEgcmVsYXRpdmUgcGF0aFxuLy9cbi8vIDMuIFRyYWlsaW5nIGNvbG9uIGlzIHRyZWF0ZWQgbGlrZSBhIHBhcnQgb2YgdGhlIHBhdGgsXG4vLyAgICBpLmUuIGluIGBodHRwOi8vZXhhbXBsZS5vcmc6Zm9vYCBwYXRobmFtZSBpcyBgOmZvb2Bcbi8vXG4vLyA0LiBOb3RoaW5nIGlzIFVSTC1lbmNvZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LFxuLy8gICAgKGluIGpveWVudC9ub2RlIHNvbWUgY2hhcnMgaW4gYXV0aCBhbmQgcGF0aHMgYXJlIGVuY29kZWQpXG4vL1xuLy8gNS4gYHVybC5wYXJzZSgpYCBkb2VzIG5vdCBoYXZlIGBwYXJzZVF1ZXJ5U3RyaW5nYCBhcmd1bWVudFxuLy9cbi8vIDYuIFJlbW92ZWQgZXh0cmFuZW91cyByZXN1bHQgcHJvcGVydGllczogYGhvc3RgLCBgcGF0aGAsIGBxdWVyeWAsIGV0Yy4sXG4vLyAgICB3aGljaCBjYW4gYmUgY29uc3RydWN0ZWQgdXNpbmcgb3RoZXIgcGFydHMgb2YgdGhlIHVybC5cbi8vXG5cblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsgJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnIF0sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsgJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJyBdLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbICdcXCcnIF0uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbICclJywgJy8nLCAnPycsICc7JywgJyMnIF0uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsgJy8nLCAnPycsICcjJyBdLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2NyaXB0LXVybCAqL1xuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNjcmlwdC11cmwgKi9cblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICB2YXIgaSwgbCwgbG93ZXJQcm90bywgaGVjLCBzbGFzaGVzLFxuICAgICAgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAocmVzdFtob3N0RW5kIC0gMV0gPT09ICc6JykgeyBob3N0RW5kLS07IH1cbiAgICB2YXIgaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KGhvc3QpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oaG9zdCkge1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxQYXJzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvcGFyc2UuanMiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUwOEUyXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkJdfFxcdUQ4MDRcXHVEQ0JEfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQW55ID0gcmVxdWlyZSgnLi9wcm9wZXJ0aWVzL0FueS9yZWdleCcpO1xuZXhwb3J0cy5DYyAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKTtcbmV4cG9ydHMuQ2YgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NmL3JlZ2V4Jyk7XG5leHBvcnRzLlAgICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5leHBvcnRzLlogICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9aL3JlZ2V4Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcIkFhY3V0ZVwiOiBcIsOBXCIsXG5cdFwiYWFjdXRlXCI6IFwiw6FcIixcblx0XCJBYnJldmVcIjogXCLEglwiLFxuXHRcImFicmV2ZVwiOiBcIsSDXCIsXG5cdFwiYWNcIjogXCLiiL5cIixcblx0XCJhY2RcIjogXCLiiL9cIixcblx0XCJhY0VcIjogXCLiiL7Ms1wiLFxuXHRcIkFjaXJjXCI6IFwiw4JcIixcblx0XCJhY2lyY1wiOiBcIsOiXCIsXG5cdFwiYWN1dGVcIjogXCLCtFwiLFxuXHRcIkFjeVwiOiBcItCQXCIsXG5cdFwiYWN5XCI6IFwi0LBcIixcblx0XCJBRWxpZ1wiOiBcIsOGXCIsXG5cdFwiYWVsaWdcIjogXCLDplwiLFxuXHRcImFmXCI6IFwi4oGhXCIsXG5cdFwiQWZyXCI6IFwi8J2UhFwiLFxuXHRcImFmclwiOiBcIvCdlJ5cIixcblx0XCJBZ3JhdmVcIjogXCLDgFwiLFxuXHRcImFncmF2ZVwiOiBcIsOgXCIsXG5cdFwiYWxlZnN5bVwiOiBcIuKEtVwiLFxuXHRcImFsZXBoXCI6IFwi4oS1XCIsXG5cdFwiQWxwaGFcIjogXCLOkVwiLFxuXHRcImFscGhhXCI6IFwizrFcIixcblx0XCJBbWFjclwiOiBcIsSAXCIsXG5cdFwiYW1hY3JcIjogXCLEgVwiLFxuXHRcImFtYWxnXCI6IFwi4qi/XCIsXG5cdFwiYW1wXCI6IFwiJlwiLFxuXHRcIkFNUFwiOiBcIiZcIixcblx0XCJhbmRhbmRcIjogXCLiqZVcIixcblx0XCJBbmRcIjogXCLiqZNcIixcblx0XCJhbmRcIjogXCLiiKdcIixcblx0XCJhbmRkXCI6IFwi4qmcXCIsXG5cdFwiYW5kc2xvcGVcIjogXCLiqZhcIixcblx0XCJhbmR2XCI6IFwi4qmaXCIsXG5cdFwiYW5nXCI6IFwi4oigXCIsXG5cdFwiYW5nZVwiOiBcIuKmpFwiLFxuXHRcImFuZ2xlXCI6IFwi4oigXCIsXG5cdFwiYW5nbXNkYWFcIjogXCLipqhcIixcblx0XCJhbmdtc2RhYlwiOiBcIuKmqVwiLFxuXHRcImFuZ21zZGFjXCI6IFwi4qaqXCIsXG5cdFwiYW5nbXNkYWRcIjogXCLipqtcIixcblx0XCJhbmdtc2RhZVwiOiBcIuKmrFwiLFxuXHRcImFuZ21zZGFmXCI6IFwi4qatXCIsXG5cdFwiYW5nbXNkYWdcIjogXCLipq5cIixcblx0XCJhbmdtc2RhaFwiOiBcIuKmr1wiLFxuXHRcImFuZ21zZFwiOiBcIuKIoVwiLFxuXHRcImFuZ3J0XCI6IFwi4oifXCIsXG5cdFwiYW5ncnR2YlwiOiBcIuKKvlwiLFxuXHRcImFuZ3J0dmJkXCI6IFwi4qadXCIsXG5cdFwiYW5nc3BoXCI6IFwi4oiiXCIsXG5cdFwiYW5nc3RcIjogXCLDhVwiLFxuXHRcImFuZ3phcnJcIjogXCLijbxcIixcblx0XCJBb2dvblwiOiBcIsSEXCIsXG5cdFwiYW9nb25cIjogXCLEhVwiLFxuXHRcIkFvcGZcIjogXCLwnZS4XCIsXG5cdFwiYW9wZlwiOiBcIvCdlZJcIixcblx0XCJhcGFjaXJcIjogXCLiqa9cIixcblx0XCJhcFwiOiBcIuKJiFwiLFxuXHRcImFwRVwiOiBcIuKpsFwiLFxuXHRcImFwZVwiOiBcIuKJilwiLFxuXHRcImFwaWRcIjogXCLiiYtcIixcblx0XCJhcG9zXCI6IFwiJ1wiLFxuXHRcIkFwcGx5RnVuY3Rpb25cIjogXCLigaFcIixcblx0XCJhcHByb3hcIjogXCLiiYhcIixcblx0XCJhcHByb3hlcVwiOiBcIuKJilwiLFxuXHRcIkFyaW5nXCI6IFwiw4VcIixcblx0XCJhcmluZ1wiOiBcIsOlXCIsXG5cdFwiQXNjclwiOiBcIvCdkpxcIixcblx0XCJhc2NyXCI6IFwi8J2StlwiLFxuXHRcIkFzc2lnblwiOiBcIuKJlFwiLFxuXHRcImFzdFwiOiBcIipcIixcblx0XCJhc3ltcFwiOiBcIuKJiFwiLFxuXHRcImFzeW1wZXFcIjogXCLiiY1cIixcblx0XCJBdGlsZGVcIjogXCLDg1wiLFxuXHRcImF0aWxkZVwiOiBcIsOjXCIsXG5cdFwiQXVtbFwiOiBcIsOEXCIsXG5cdFwiYXVtbFwiOiBcIsOkXCIsXG5cdFwiYXdjb25pbnRcIjogXCLiiLNcIixcblx0XCJhd2ludFwiOiBcIuKokVwiLFxuXHRcImJhY2tjb25nXCI6IFwi4omMXCIsXG5cdFwiYmFja2Vwc2lsb25cIjogXCLPtlwiLFxuXHRcImJhY2twcmltZVwiOiBcIuKAtVwiLFxuXHRcImJhY2tzaW1cIjogXCLiiL1cIixcblx0XCJiYWNrc2ltZXFcIjogXCLii41cIixcblx0XCJCYWNrc2xhc2hcIjogXCLiiJZcIixcblx0XCJCYXJ2XCI6IFwi4qunXCIsXG5cdFwiYmFydmVlXCI6IFwi4oq9XCIsXG5cdFwiYmFyd2VkXCI6IFwi4oyFXCIsXG5cdFwiQmFyd2VkXCI6IFwi4oyGXCIsXG5cdFwiYmFyd2VkZ2VcIjogXCLijIVcIixcblx0XCJiYnJrXCI6IFwi4o61XCIsXG5cdFwiYmJya3RicmtcIjogXCLijrZcIixcblx0XCJiY29uZ1wiOiBcIuKJjFwiLFxuXHRcIkJjeVwiOiBcItCRXCIsXG5cdFwiYmN5XCI6IFwi0LFcIixcblx0XCJiZHF1b1wiOiBcIuKAnlwiLFxuXHRcImJlY2F1c1wiOiBcIuKItVwiLFxuXHRcImJlY2F1c2VcIjogXCLiiLVcIixcblx0XCJCZWNhdXNlXCI6IFwi4oi1XCIsXG5cdFwiYmVtcHR5dlwiOiBcIuKmsFwiLFxuXHRcImJlcHNpXCI6IFwiz7ZcIixcblx0XCJiZXJub3VcIjogXCLihKxcIixcblx0XCJCZXJub3VsbGlzXCI6IFwi4oSsXCIsXG5cdFwiQmV0YVwiOiBcIs6SXCIsXG5cdFwiYmV0YVwiOiBcIs6yXCIsXG5cdFwiYmV0aFwiOiBcIuKEtlwiLFxuXHRcImJldHdlZW5cIjogXCLiiaxcIixcblx0XCJCZnJcIjogXCLwnZSFXCIsXG5cdFwiYmZyXCI6IFwi8J2Un1wiLFxuXHRcImJpZ2NhcFwiOiBcIuKLglwiLFxuXHRcImJpZ2NpcmNcIjogXCLil69cIixcblx0XCJiaWdjdXBcIjogXCLii4NcIixcblx0XCJiaWdvZG90XCI6IFwi4qiAXCIsXG5cdFwiYmlnb3BsdXNcIjogXCLiqIFcIixcblx0XCJiaWdvdGltZXNcIjogXCLiqIJcIixcblx0XCJiaWdzcWN1cFwiOiBcIuKohlwiLFxuXHRcImJpZ3N0YXJcIjogXCLimIVcIixcblx0XCJiaWd0cmlhbmdsZWRvd25cIjogXCLilr1cIixcblx0XCJiaWd0cmlhbmdsZXVwXCI6IFwi4pazXCIsXG5cdFwiYmlndXBsdXNcIjogXCLiqIRcIixcblx0XCJiaWd2ZWVcIjogXCLii4FcIixcblx0XCJiaWd3ZWRnZVwiOiBcIuKLgFwiLFxuXHRcImJrYXJvd1wiOiBcIuKkjVwiLFxuXHRcImJsYWNrbG96ZW5nZVwiOiBcIuKnq1wiLFxuXHRcImJsYWNrc3F1YXJlXCI6IFwi4paqXCIsXG5cdFwiYmxhY2t0cmlhbmdsZVwiOiBcIuKWtFwiLFxuXHRcImJsYWNrdHJpYW5nbGVkb3duXCI6IFwi4pa+XCIsXG5cdFwiYmxhY2t0cmlhbmdsZWxlZnRcIjogXCLil4JcIixcblx0XCJibGFja3RyaWFuZ2xlcmlnaHRcIjogXCLilrhcIixcblx0XCJibGFua1wiOiBcIuKQo1wiLFxuXHRcImJsazEyXCI6IFwi4paSXCIsXG5cdFwiYmxrMTRcIjogXCLilpFcIixcblx0XCJibGszNFwiOiBcIuKWk1wiLFxuXHRcImJsb2NrXCI6IFwi4paIXCIsXG5cdFwiYm5lXCI6IFwiPeKDpVwiLFxuXHRcImJuZXF1aXZcIjogXCLiiaHig6VcIixcblx0XCJiTm90XCI6IFwi4qutXCIsXG5cdFwiYm5vdFwiOiBcIuKMkFwiLFxuXHRcIkJvcGZcIjogXCLwnZS5XCIsXG5cdFwiYm9wZlwiOiBcIvCdlZNcIixcblx0XCJib3RcIjogXCLiiqVcIixcblx0XCJib3R0b21cIjogXCLiiqVcIixcblx0XCJib3d0aWVcIjogXCLii4hcIixcblx0XCJib3hib3hcIjogXCLip4lcIixcblx0XCJib3hkbFwiOiBcIuKUkFwiLFxuXHRcImJveGRMXCI6IFwi4pWVXCIsXG5cdFwiYm94RGxcIjogXCLilZZcIixcblx0XCJib3hETFwiOiBcIuKVl1wiLFxuXHRcImJveGRyXCI6IFwi4pSMXCIsXG5cdFwiYm94ZFJcIjogXCLilZJcIixcblx0XCJib3hEclwiOiBcIuKVk1wiLFxuXHRcImJveERSXCI6IFwi4pWUXCIsXG5cdFwiYm94aFwiOiBcIuKUgFwiLFxuXHRcImJveEhcIjogXCLilZBcIixcblx0XCJib3hoZFwiOiBcIuKUrFwiLFxuXHRcImJveEhkXCI6IFwi4pWkXCIsXG5cdFwiYm94aERcIjogXCLilaVcIixcblx0XCJib3hIRFwiOiBcIuKVplwiLFxuXHRcImJveGh1XCI6IFwi4pS0XCIsXG5cdFwiYm94SHVcIjogXCLiladcIixcblx0XCJib3hoVVwiOiBcIuKVqFwiLFxuXHRcImJveEhVXCI6IFwi4pWpXCIsXG5cdFwiYm94bWludXNcIjogXCLiip9cIixcblx0XCJib3hwbHVzXCI6IFwi4oqeXCIsXG5cdFwiYm94dGltZXNcIjogXCLiiqBcIixcblx0XCJib3h1bFwiOiBcIuKUmFwiLFxuXHRcImJveHVMXCI6IFwi4pWbXCIsXG5cdFwiYm94VWxcIjogXCLilZxcIixcblx0XCJib3hVTFwiOiBcIuKVnVwiLFxuXHRcImJveHVyXCI6IFwi4pSUXCIsXG5cdFwiYm94dVJcIjogXCLilZhcIixcblx0XCJib3hVclwiOiBcIuKVmVwiLFxuXHRcImJveFVSXCI6IFwi4pWaXCIsXG5cdFwiYm94dlwiOiBcIuKUglwiLFxuXHRcImJveFZcIjogXCLilZFcIixcblx0XCJib3h2aFwiOiBcIuKUvFwiLFxuXHRcImJveHZIXCI6IFwi4pWqXCIsXG5cdFwiYm94VmhcIjogXCLilatcIixcblx0XCJib3hWSFwiOiBcIuKVrFwiLFxuXHRcImJveHZsXCI6IFwi4pSkXCIsXG5cdFwiYm94dkxcIjogXCLilaFcIixcblx0XCJib3hWbFwiOiBcIuKVolwiLFxuXHRcImJveFZMXCI6IFwi4pWjXCIsXG5cdFwiYm94dnJcIjogXCLilJxcIixcblx0XCJib3h2UlwiOiBcIuKVnlwiLFxuXHRcImJveFZyXCI6IFwi4pWfXCIsXG5cdFwiYm94VlJcIjogXCLilaBcIixcblx0XCJicHJpbWVcIjogXCLigLVcIixcblx0XCJicmV2ZVwiOiBcIsuYXCIsXG5cdFwiQnJldmVcIjogXCLLmFwiLFxuXHRcImJydmJhclwiOiBcIsKmXCIsXG5cdFwiYnNjclwiOiBcIvCdkrdcIixcblx0XCJCc2NyXCI6IFwi4oSsXCIsXG5cdFwiYnNlbWlcIjogXCLigY9cIixcblx0XCJic2ltXCI6IFwi4oi9XCIsXG5cdFwiYnNpbWVcIjogXCLii41cIixcblx0XCJic29sYlwiOiBcIuKnhVwiLFxuXHRcImJzb2xcIjogXCJcXFxcXCIsXG5cdFwiYnNvbGhzdWJcIjogXCLin4hcIixcblx0XCJidWxsXCI6IFwi4oCiXCIsXG5cdFwiYnVsbGV0XCI6IFwi4oCiXCIsXG5cdFwiYnVtcFwiOiBcIuKJjlwiLFxuXHRcImJ1bXBFXCI6IFwi4qquXCIsXG5cdFwiYnVtcGVcIjogXCLiiY9cIixcblx0XCJCdW1wZXFcIjogXCLiiY5cIixcblx0XCJidW1wZXFcIjogXCLiiY9cIixcblx0XCJDYWN1dGVcIjogXCLEhlwiLFxuXHRcImNhY3V0ZVwiOiBcIsSHXCIsXG5cdFwiY2FwYW5kXCI6IFwi4qmEXCIsXG5cdFwiY2FwYnJjdXBcIjogXCLiqYlcIixcblx0XCJjYXBjYXBcIjogXCLiqYtcIixcblx0XCJjYXBcIjogXCLiiKlcIixcblx0XCJDYXBcIjogXCLii5JcIixcblx0XCJjYXBjdXBcIjogXCLiqYdcIixcblx0XCJjYXBkb3RcIjogXCLiqYBcIixcblx0XCJDYXBpdGFsRGlmZmVyZW50aWFsRFwiOiBcIuKFhVwiLFxuXHRcImNhcHNcIjogXCLiiKnvuIBcIixcblx0XCJjYXJldFwiOiBcIuKBgVwiLFxuXHRcImNhcm9uXCI6IFwiy4dcIixcblx0XCJDYXlsZXlzXCI6IFwi4oStXCIsXG5cdFwiY2NhcHNcIjogXCLiqY1cIixcblx0XCJDY2Fyb25cIjogXCLEjFwiLFxuXHRcImNjYXJvblwiOiBcIsSNXCIsXG5cdFwiQ2NlZGlsXCI6IFwiw4dcIixcblx0XCJjY2VkaWxcIjogXCLDp1wiLFxuXHRcIkNjaXJjXCI6IFwixIhcIixcblx0XCJjY2lyY1wiOiBcIsSJXCIsXG5cdFwiQ2NvbmludFwiOiBcIuKIsFwiLFxuXHRcImNjdXBzXCI6IFwi4qmMXCIsXG5cdFwiY2N1cHNzbVwiOiBcIuKpkFwiLFxuXHRcIkNkb3RcIjogXCLEilwiLFxuXHRcImNkb3RcIjogXCLEi1wiLFxuXHRcImNlZGlsXCI6IFwiwrhcIixcblx0XCJDZWRpbGxhXCI6IFwiwrhcIixcblx0XCJjZW1wdHl2XCI6IFwi4qayXCIsXG5cdFwiY2VudFwiOiBcIsKiXCIsXG5cdFwiY2VudGVyZG90XCI6IFwiwrdcIixcblx0XCJDZW50ZXJEb3RcIjogXCLCt1wiLFxuXHRcImNmclwiOiBcIvCdlKBcIixcblx0XCJDZnJcIjogXCLihK1cIixcblx0XCJDSGN5XCI6IFwi0KdcIixcblx0XCJjaGN5XCI6IFwi0YdcIixcblx0XCJjaGVja1wiOiBcIuKck1wiLFxuXHRcImNoZWNrbWFya1wiOiBcIuKck1wiLFxuXHRcIkNoaVwiOiBcIs6nXCIsXG5cdFwiY2hpXCI6IFwiz4dcIixcblx0XCJjaXJjXCI6IFwiy4ZcIixcblx0XCJjaXJjZXFcIjogXCLiiZdcIixcblx0XCJjaXJjbGVhcnJvd2xlZnRcIjogXCLihrpcIixcblx0XCJjaXJjbGVhcnJvd3JpZ2h0XCI6IFwi4oa7XCIsXG5cdFwiY2lyY2xlZGFzdFwiOiBcIuKKm1wiLFxuXHRcImNpcmNsZWRjaXJjXCI6IFwi4oqaXCIsXG5cdFwiY2lyY2xlZGRhc2hcIjogXCLiip1cIixcblx0XCJDaXJjbGVEb3RcIjogXCLiiplcIixcblx0XCJjaXJjbGVkUlwiOiBcIsKuXCIsXG5cdFwiY2lyY2xlZFNcIjogXCLik4hcIixcblx0XCJDaXJjbGVNaW51c1wiOiBcIuKKllwiLFxuXHRcIkNpcmNsZVBsdXNcIjogXCLiipVcIixcblx0XCJDaXJjbGVUaW1lc1wiOiBcIuKKl1wiLFxuXHRcImNpclwiOiBcIuKXi1wiLFxuXHRcImNpckVcIjogXCLip4NcIixcblx0XCJjaXJlXCI6IFwi4omXXCIsXG5cdFwiY2lyZm5pbnRcIjogXCLiqJBcIixcblx0XCJjaXJtaWRcIjogXCLiq69cIixcblx0XCJjaXJzY2lyXCI6IFwi4qeCXCIsXG5cdFwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6IFwi4oiyXCIsXG5cdFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6IFwi4oCdXCIsXG5cdFwiQ2xvc2VDdXJseVF1b3RlXCI6IFwi4oCZXCIsXG5cdFwiY2x1YnNcIjogXCLimaNcIixcblx0XCJjbHVic3VpdFwiOiBcIuKZo1wiLFxuXHRcImNvbG9uXCI6IFwiOlwiLFxuXHRcIkNvbG9uXCI6IFwi4oi3XCIsXG5cdFwiQ29sb25lXCI6IFwi4qm0XCIsXG5cdFwiY29sb25lXCI6IFwi4omUXCIsXG5cdFwiY29sb25lcVwiOiBcIuKJlFwiLFxuXHRcImNvbW1hXCI6IFwiLFwiLFxuXHRcImNvbW1hdFwiOiBcIkBcIixcblx0XCJjb21wXCI6IFwi4oiBXCIsXG5cdFwiY29tcGZuXCI6IFwi4oiYXCIsXG5cdFwiY29tcGxlbWVudFwiOiBcIuKIgVwiLFxuXHRcImNvbXBsZXhlc1wiOiBcIuKEglwiLFxuXHRcImNvbmdcIjogXCLiiYVcIixcblx0XCJjb25nZG90XCI6IFwi4qmtXCIsXG5cdFwiQ29uZ3J1ZW50XCI6IFwi4omhXCIsXG5cdFwiY29uaW50XCI6IFwi4oiuXCIsXG5cdFwiQ29uaW50XCI6IFwi4oivXCIsXG5cdFwiQ29udG91ckludGVncmFsXCI6IFwi4oiuXCIsXG5cdFwiY29wZlwiOiBcIvCdlZRcIixcblx0XCJDb3BmXCI6IFwi4oSCXCIsXG5cdFwiY29wcm9kXCI6IFwi4oiQXCIsXG5cdFwiQ29wcm9kdWN0XCI6IFwi4oiQXCIsXG5cdFwiY29weVwiOiBcIsKpXCIsXG5cdFwiQ09QWVwiOiBcIsKpXCIsXG5cdFwiY29weXNyXCI6IFwi4oSXXCIsXG5cdFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOiBcIuKIs1wiLFxuXHRcImNyYXJyXCI6IFwi4oa1XCIsXG5cdFwiY3Jvc3NcIjogXCLinJdcIixcblx0XCJDcm9zc1wiOiBcIuKor1wiLFxuXHRcIkNzY3JcIjogXCLwnZKeXCIsXG5cdFwiY3NjclwiOiBcIvCdkrhcIixcblx0XCJjc3ViXCI6IFwi4quPXCIsXG5cdFwiY3N1YmVcIjogXCLiq5FcIixcblx0XCJjc3VwXCI6IFwi4quQXCIsXG5cdFwiY3N1cGVcIjogXCLiq5JcIixcblx0XCJjdGRvdFwiOiBcIuKLr1wiLFxuXHRcImN1ZGFycmxcIjogXCLipLhcIixcblx0XCJjdWRhcnJyXCI6IFwi4qS1XCIsXG5cdFwiY3VlcHJcIjogXCLii55cIixcblx0XCJjdWVzY1wiOiBcIuKLn1wiLFxuXHRcImN1bGFyclwiOiBcIuKGtlwiLFxuXHRcImN1bGFycnBcIjogXCLipL1cIixcblx0XCJjdXBicmNhcFwiOiBcIuKpiFwiLFxuXHRcImN1cGNhcFwiOiBcIuKphlwiLFxuXHRcIkN1cENhcFwiOiBcIuKJjVwiLFxuXHRcImN1cFwiOiBcIuKIqlwiLFxuXHRcIkN1cFwiOiBcIuKLk1wiLFxuXHRcImN1cGN1cFwiOiBcIuKpilwiLFxuXHRcImN1cGRvdFwiOiBcIuKKjVwiLFxuXHRcImN1cG9yXCI6IFwi4qmFXCIsXG5cdFwiY3Vwc1wiOiBcIuKIqu+4gFwiLFxuXHRcImN1cmFyclwiOiBcIuKGt1wiLFxuXHRcImN1cmFycm1cIjogXCLipLxcIixcblx0XCJjdXJseWVxcHJlY1wiOiBcIuKLnlwiLFxuXHRcImN1cmx5ZXFzdWNjXCI6IFwi4oufXCIsXG5cdFwiY3VybHl2ZWVcIjogXCLii45cIixcblx0XCJjdXJseXdlZGdlXCI6IFwi4ouPXCIsXG5cdFwiY3VycmVuXCI6IFwiwqRcIixcblx0XCJjdXJ2ZWFycm93bGVmdFwiOiBcIuKGtlwiLFxuXHRcImN1cnZlYXJyb3dyaWdodFwiOiBcIuKGt1wiLFxuXHRcImN1dmVlXCI6IFwi4ouOXCIsXG5cdFwiY3V3ZWRcIjogXCLii49cIixcblx0XCJjd2NvbmludFwiOiBcIuKIslwiLFxuXHRcImN3aW50XCI6IFwi4oixXCIsXG5cdFwiY3lsY3R5XCI6IFwi4oytXCIsXG5cdFwiZGFnZ2VyXCI6IFwi4oCgXCIsXG5cdFwiRGFnZ2VyXCI6IFwi4oChXCIsXG5cdFwiZGFsZXRoXCI6IFwi4oS4XCIsXG5cdFwiZGFyclwiOiBcIuKGk1wiLFxuXHRcIkRhcnJcIjogXCLihqFcIixcblx0XCJkQXJyXCI6IFwi4oeTXCIsXG5cdFwiZGFzaFwiOiBcIuKAkFwiLFxuXHRcIkRhc2h2XCI6IFwi4qukXCIsXG5cdFwiZGFzaHZcIjogXCLiiqNcIixcblx0XCJkYmthcm93XCI6IFwi4qSPXCIsXG5cdFwiZGJsYWNcIjogXCLLnVwiLFxuXHRcIkRjYXJvblwiOiBcIsSOXCIsXG5cdFwiZGNhcm9uXCI6IFwixI9cIixcblx0XCJEY3lcIjogXCLQlFwiLFxuXHRcImRjeVwiOiBcItC0XCIsXG5cdFwiZGRhZ2dlclwiOiBcIuKAoVwiLFxuXHRcImRkYXJyXCI6IFwi4oeKXCIsXG5cdFwiRERcIjogXCLihYVcIixcblx0XCJkZFwiOiBcIuKFhlwiLFxuXHRcIkREb3RyYWhkXCI6IFwi4qSRXCIsXG5cdFwiZGRvdHNlcVwiOiBcIuKpt1wiLFxuXHRcImRlZ1wiOiBcIsKwXCIsXG5cdFwiRGVsXCI6IFwi4oiHXCIsXG5cdFwiRGVsdGFcIjogXCLOlFwiLFxuXHRcImRlbHRhXCI6IFwizrRcIixcblx0XCJkZW1wdHl2XCI6IFwi4qaxXCIsXG5cdFwiZGZpc2h0XCI6IFwi4qW/XCIsXG5cdFwiRGZyXCI6IFwi8J2Uh1wiLFxuXHRcImRmclwiOiBcIvCdlKFcIixcblx0XCJkSGFyXCI6IFwi4qWlXCIsXG5cdFwiZGhhcmxcIjogXCLih4NcIixcblx0XCJkaGFyclwiOiBcIuKHglwiLFxuXHRcIkRpYWNyaXRpY2FsQWN1dGVcIjogXCLCtFwiLFxuXHRcIkRpYWNyaXRpY2FsRG90XCI6IFwiy5lcIixcblx0XCJEaWFjcml0aWNhbERvdWJsZUFjdXRlXCI6IFwiy51cIixcblx0XCJEaWFjcml0aWNhbEdyYXZlXCI6IFwiYFwiLFxuXHRcIkRpYWNyaXRpY2FsVGlsZGVcIjogXCLLnFwiLFxuXHRcImRpYW1cIjogXCLii4RcIixcblx0XCJkaWFtb25kXCI6IFwi4ouEXCIsXG5cdFwiRGlhbW9uZFwiOiBcIuKLhFwiLFxuXHRcImRpYW1vbmRzdWl0XCI6IFwi4pmmXCIsXG5cdFwiZGlhbXNcIjogXCLimaZcIixcblx0XCJkaWVcIjogXCLCqFwiLFxuXHRcIkRpZmZlcmVudGlhbERcIjogXCLihYZcIixcblx0XCJkaWdhbW1hXCI6IFwiz51cIixcblx0XCJkaXNpblwiOiBcIuKLslwiLFxuXHRcImRpdlwiOiBcIsO3XCIsXG5cdFwiZGl2aWRlXCI6IFwiw7dcIixcblx0XCJkaXZpZGVvbnRpbWVzXCI6IFwi4ouHXCIsXG5cdFwiZGl2b254XCI6IFwi4ouHXCIsXG5cdFwiREpjeVwiOiBcItCCXCIsXG5cdFwiZGpjeVwiOiBcItGSXCIsXG5cdFwiZGxjb3JuXCI6IFwi4oyeXCIsXG5cdFwiZGxjcm9wXCI6IFwi4oyNXCIsXG5cdFwiZG9sbGFyXCI6IFwiJFwiLFxuXHRcIkRvcGZcIjogXCLwnZS7XCIsXG5cdFwiZG9wZlwiOiBcIvCdlZVcIixcblx0XCJEb3RcIjogXCLCqFwiLFxuXHRcImRvdFwiOiBcIsuZXCIsXG5cdFwiRG90RG90XCI6IFwi4oOcXCIsXG5cdFwiZG90ZXFcIjogXCLiiZBcIixcblx0XCJkb3RlcWRvdFwiOiBcIuKJkVwiLFxuXHRcIkRvdEVxdWFsXCI6IFwi4omQXCIsXG5cdFwiZG90bWludXNcIjogXCLiiLhcIixcblx0XCJkb3RwbHVzXCI6IFwi4oiUXCIsXG5cdFwiZG90c3F1YXJlXCI6IFwi4oqhXCIsXG5cdFwiZG91YmxlYmFyd2VkZ2VcIjogXCLijIZcIixcblx0XCJEb3VibGVDb250b3VySW50ZWdyYWxcIjogXCLiiK9cIixcblx0XCJEb3VibGVEb3RcIjogXCLCqFwiLFxuXHRcIkRvdWJsZURvd25BcnJvd1wiOiBcIuKHk1wiLFxuXHRcIkRvdWJsZUxlZnRBcnJvd1wiOiBcIuKHkFwiLFxuXHRcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6IFwi4oeUXCIsXG5cdFwiRG91YmxlTGVmdFRlZVwiOiBcIuKrpFwiLFxuXHRcIkRvdWJsZUxvbmdMZWZ0QXJyb3dcIjogXCLin7hcIixcblx0XCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjogXCLin7pcIixcblx0XCJEb3VibGVMb25nUmlnaHRBcnJvd1wiOiBcIuKfuVwiLFxuXHRcIkRvdWJsZVJpZ2h0QXJyb3dcIjogXCLih5JcIixcblx0XCJEb3VibGVSaWdodFRlZVwiOiBcIuKKqFwiLFxuXHRcIkRvdWJsZVVwQXJyb3dcIjogXCLih5FcIixcblx0XCJEb3VibGVVcERvd25BcnJvd1wiOiBcIuKHlVwiLFxuXHRcIkRvdWJsZVZlcnRpY2FsQmFyXCI6IFwi4oilXCIsXG5cdFwiRG93bkFycm93QmFyXCI6IFwi4qSTXCIsXG5cdFwiZG93bmFycm93XCI6IFwi4oaTXCIsXG5cdFwiRG93bkFycm93XCI6IFwi4oaTXCIsXG5cdFwiRG93bmFycm93XCI6IFwi4oeTXCIsXG5cdFwiRG93bkFycm93VXBBcnJvd1wiOiBcIuKHtVwiLFxuXHRcIkRvd25CcmV2ZVwiOiBcIsyRXCIsXG5cdFwiZG93bmRvd25hcnJvd3NcIjogXCLih4pcIixcblx0XCJkb3duaGFycG9vbmxlZnRcIjogXCLih4NcIixcblx0XCJkb3duaGFycG9vbnJpZ2h0XCI6IFwi4oeCXCIsXG5cdFwiRG93bkxlZnRSaWdodFZlY3RvclwiOiBcIuKlkFwiLFxuXHRcIkRvd25MZWZ0VGVlVmVjdG9yXCI6IFwi4qWeXCIsXG5cdFwiRG93bkxlZnRWZWN0b3JCYXJcIjogXCLipZZcIixcblx0XCJEb3duTGVmdFZlY3RvclwiOiBcIuKGvVwiLFxuXHRcIkRvd25SaWdodFRlZVZlY3RvclwiOiBcIuKln1wiLFxuXHRcIkRvd25SaWdodFZlY3RvckJhclwiOiBcIuKll1wiLFxuXHRcIkRvd25SaWdodFZlY3RvclwiOiBcIuKHgVwiLFxuXHRcIkRvd25UZWVBcnJvd1wiOiBcIuKGp1wiLFxuXHRcIkRvd25UZWVcIjogXCLiiqRcIixcblx0XCJkcmJrYXJvd1wiOiBcIuKkkFwiLFxuXHRcImRyY29yblwiOiBcIuKMn1wiLFxuXHRcImRyY3JvcFwiOiBcIuKMjFwiLFxuXHRcIkRzY3JcIjogXCLwnZKfXCIsXG5cdFwiZHNjclwiOiBcIvCdkrlcIixcblx0XCJEU2N5XCI6IFwi0IVcIixcblx0XCJkc2N5XCI6IFwi0ZVcIixcblx0XCJkc29sXCI6IFwi4qe2XCIsXG5cdFwiRHN0cm9rXCI6IFwixJBcIixcblx0XCJkc3Ryb2tcIjogXCLEkVwiLFxuXHRcImR0ZG90XCI6IFwi4ouxXCIsXG5cdFwiZHRyaVwiOiBcIuKWv1wiLFxuXHRcImR0cmlmXCI6IFwi4pa+XCIsXG5cdFwiZHVhcnJcIjogXCLih7VcIixcblx0XCJkdWhhclwiOiBcIuKlr1wiLFxuXHRcImR3YW5nbGVcIjogXCLipqZcIixcblx0XCJEWmN5XCI6IFwi0I9cIixcblx0XCJkemN5XCI6IFwi0Z9cIixcblx0XCJkemlncmFyclwiOiBcIuKfv1wiLFxuXHRcIkVhY3V0ZVwiOiBcIsOJXCIsXG5cdFwiZWFjdXRlXCI6IFwiw6lcIixcblx0XCJlYXN0ZXJcIjogXCLiqa5cIixcblx0XCJFY2Fyb25cIjogXCLEmlwiLFxuXHRcImVjYXJvblwiOiBcIsSbXCIsXG5cdFwiRWNpcmNcIjogXCLDilwiLFxuXHRcImVjaXJjXCI6IFwiw6pcIixcblx0XCJlY2lyXCI6IFwi4omWXCIsXG5cdFwiZWNvbG9uXCI6IFwi4omVXCIsXG5cdFwiRWN5XCI6IFwi0K1cIixcblx0XCJlY3lcIjogXCLRjVwiLFxuXHRcImVERG90XCI6IFwi4qm3XCIsXG5cdFwiRWRvdFwiOiBcIsSWXCIsXG5cdFwiZWRvdFwiOiBcIsSXXCIsXG5cdFwiZURvdFwiOiBcIuKJkVwiLFxuXHRcImVlXCI6IFwi4oWHXCIsXG5cdFwiZWZEb3RcIjogXCLiiZJcIixcblx0XCJFZnJcIjogXCLwnZSIXCIsXG5cdFwiZWZyXCI6IFwi8J2UolwiLFxuXHRcImVnXCI6IFwi4qqaXCIsXG5cdFwiRWdyYXZlXCI6IFwiw4hcIixcblx0XCJlZ3JhdmVcIjogXCLDqFwiLFxuXHRcImVnc1wiOiBcIuKqllwiLFxuXHRcImVnc2RvdFwiOiBcIuKqmFwiLFxuXHRcImVsXCI6IFwi4qqZXCIsXG5cdFwiRWxlbWVudFwiOiBcIuKIiFwiLFxuXHRcImVsaW50ZXJzXCI6IFwi4o+nXCIsXG5cdFwiZWxsXCI6IFwi4oSTXCIsXG5cdFwiZWxzXCI6IFwi4qqVXCIsXG5cdFwiZWxzZG90XCI6IFwi4qqXXCIsXG5cdFwiRW1hY3JcIjogXCLEklwiLFxuXHRcImVtYWNyXCI6IFwixJNcIixcblx0XCJlbXB0eVwiOiBcIuKIhVwiLFxuXHRcImVtcHR5c2V0XCI6IFwi4oiFXCIsXG5cdFwiRW1wdHlTbWFsbFNxdWFyZVwiOiBcIuKXu1wiLFxuXHRcImVtcHR5dlwiOiBcIuKIhVwiLFxuXHRcIkVtcHR5VmVyeVNtYWxsU3F1YXJlXCI6IFwi4parXCIsXG5cdFwiZW1zcDEzXCI6IFwi4oCEXCIsXG5cdFwiZW1zcDE0XCI6IFwi4oCFXCIsXG5cdFwiZW1zcFwiOiBcIuKAg1wiLFxuXHRcIkVOR1wiOiBcIsWKXCIsXG5cdFwiZW5nXCI6IFwixYtcIixcblx0XCJlbnNwXCI6IFwi4oCCXCIsXG5cdFwiRW9nb25cIjogXCLEmFwiLFxuXHRcImVvZ29uXCI6IFwixJlcIixcblx0XCJFb3BmXCI6IFwi8J2UvFwiLFxuXHRcImVvcGZcIjogXCLwnZWWXCIsXG5cdFwiZXBhclwiOiBcIuKLlVwiLFxuXHRcImVwYXJzbFwiOiBcIuKno1wiLFxuXHRcImVwbHVzXCI6IFwi4qmxXCIsXG5cdFwiZXBzaVwiOiBcIs61XCIsXG5cdFwiRXBzaWxvblwiOiBcIs6VXCIsXG5cdFwiZXBzaWxvblwiOiBcIs61XCIsXG5cdFwiZXBzaXZcIjogXCLPtVwiLFxuXHRcImVxY2lyY1wiOiBcIuKJllwiLFxuXHRcImVxY29sb25cIjogXCLiiZVcIixcblx0XCJlcXNpbVwiOiBcIuKJglwiLFxuXHRcImVxc2xhbnRndHJcIjogXCLiqpZcIixcblx0XCJlcXNsYW50bGVzc1wiOiBcIuKqlVwiLFxuXHRcIkVxdWFsXCI6IFwi4qm1XCIsXG5cdFwiZXF1YWxzXCI6IFwiPVwiLFxuXHRcIkVxdWFsVGlsZGVcIjogXCLiiYJcIixcblx0XCJlcXVlc3RcIjogXCLiiZ9cIixcblx0XCJFcXVpbGlicml1bVwiOiBcIuKHjFwiLFxuXHRcImVxdWl2XCI6IFwi4omhXCIsXG5cdFwiZXF1aXZERFwiOiBcIuKpuFwiLFxuXHRcImVxdnBhcnNsXCI6IFwi4qelXCIsXG5cdFwiZXJhcnJcIjogXCLipbFcIixcblx0XCJlckRvdFwiOiBcIuKJk1wiLFxuXHRcImVzY3JcIjogXCLihK9cIixcblx0XCJFc2NyXCI6IFwi4oSwXCIsXG5cdFwiZXNkb3RcIjogXCLiiZBcIixcblx0XCJFc2ltXCI6IFwi4qmzXCIsXG5cdFwiZXNpbVwiOiBcIuKJglwiLFxuXHRcIkV0YVwiOiBcIs6XXCIsXG5cdFwiZXRhXCI6IFwizrdcIixcblx0XCJFVEhcIjogXCLDkFwiLFxuXHRcImV0aFwiOiBcIsOwXCIsXG5cdFwiRXVtbFwiOiBcIsOLXCIsXG5cdFwiZXVtbFwiOiBcIsOrXCIsXG5cdFwiZXVyb1wiOiBcIuKCrFwiLFxuXHRcImV4Y2xcIjogXCIhXCIsXG5cdFwiZXhpc3RcIjogXCLiiINcIixcblx0XCJFeGlzdHNcIjogXCLiiINcIixcblx0XCJleHBlY3RhdGlvblwiOiBcIuKEsFwiLFxuXHRcImV4cG9uZW50aWFsZVwiOiBcIuKFh1wiLFxuXHRcIkV4cG9uZW50aWFsRVwiOiBcIuKFh1wiLFxuXHRcImZhbGxpbmdkb3RzZXFcIjogXCLiiZJcIixcblx0XCJGY3lcIjogXCLQpFwiLFxuXHRcImZjeVwiOiBcItGEXCIsXG5cdFwiZmVtYWxlXCI6IFwi4pmAXCIsXG5cdFwiZmZpbGlnXCI6IFwi76yDXCIsXG5cdFwiZmZsaWdcIjogXCLvrIBcIixcblx0XCJmZmxsaWdcIjogXCLvrIRcIixcblx0XCJGZnJcIjogXCLwnZSJXCIsXG5cdFwiZmZyXCI6IFwi8J2Uo1wiLFxuXHRcImZpbGlnXCI6IFwi76yBXCIsXG5cdFwiRmlsbGVkU21hbGxTcXVhcmVcIjogXCLil7xcIixcblx0XCJGaWxsZWRWZXJ5U21hbGxTcXVhcmVcIjogXCLilqpcIixcblx0XCJmamxpZ1wiOiBcImZqXCIsXG5cdFwiZmxhdFwiOiBcIuKZrVwiLFxuXHRcImZsbGlnXCI6IFwi76yCXCIsXG5cdFwiZmx0bnNcIjogXCLilrFcIixcblx0XCJmbm9mXCI6IFwixpJcIixcblx0XCJGb3BmXCI6IFwi8J2UvVwiLFxuXHRcImZvcGZcIjogXCLwnZWXXCIsXG5cdFwiZm9yYWxsXCI6IFwi4oiAXCIsXG5cdFwiRm9yQWxsXCI6IFwi4oiAXCIsXG5cdFwiZm9ya1wiOiBcIuKLlFwiLFxuXHRcImZvcmt2XCI6IFwi4quZXCIsXG5cdFwiRm91cmllcnRyZlwiOiBcIuKEsVwiLFxuXHRcImZwYXJ0aW50XCI6IFwi4qiNXCIsXG5cdFwiZnJhYzEyXCI6IFwiwr1cIixcblx0XCJmcmFjMTNcIjogXCLihZNcIixcblx0XCJmcmFjMTRcIjogXCLCvFwiLFxuXHRcImZyYWMxNVwiOiBcIuKFlVwiLFxuXHRcImZyYWMxNlwiOiBcIuKFmVwiLFxuXHRcImZyYWMxOFwiOiBcIuKFm1wiLFxuXHRcImZyYWMyM1wiOiBcIuKFlFwiLFxuXHRcImZyYWMyNVwiOiBcIuKFllwiLFxuXHRcImZyYWMzNFwiOiBcIsK+XCIsXG5cdFwiZnJhYzM1XCI6IFwi4oWXXCIsXG5cdFwiZnJhYzM4XCI6IFwi4oWcXCIsXG5cdFwiZnJhYzQ1XCI6IFwi4oWYXCIsXG5cdFwiZnJhYzU2XCI6IFwi4oWaXCIsXG5cdFwiZnJhYzU4XCI6IFwi4oWdXCIsXG5cdFwiZnJhYzc4XCI6IFwi4oWeXCIsXG5cdFwiZnJhc2xcIjogXCLigYRcIixcblx0XCJmcm93blwiOiBcIuKMolwiLFxuXHRcImZzY3JcIjogXCLwnZK7XCIsXG5cdFwiRnNjclwiOiBcIuKEsVwiLFxuXHRcImdhY3V0ZVwiOiBcIse1XCIsXG5cdFwiR2FtbWFcIjogXCLOk1wiLFxuXHRcImdhbW1hXCI6IFwizrNcIixcblx0XCJHYW1tYWRcIjogXCLPnFwiLFxuXHRcImdhbW1hZFwiOiBcIs+dXCIsXG5cdFwiZ2FwXCI6IFwi4qqGXCIsXG5cdFwiR2JyZXZlXCI6IFwixJ5cIixcblx0XCJnYnJldmVcIjogXCLEn1wiLFxuXHRcIkdjZWRpbFwiOiBcIsSiXCIsXG5cdFwiR2NpcmNcIjogXCLEnFwiLFxuXHRcImdjaXJjXCI6IFwixJ1cIixcblx0XCJHY3lcIjogXCLQk1wiLFxuXHRcImdjeVwiOiBcItCzXCIsXG5cdFwiR2RvdFwiOiBcIsSgXCIsXG5cdFwiZ2RvdFwiOiBcIsShXCIsXG5cdFwiZ2VcIjogXCLiiaVcIixcblx0XCJnRVwiOiBcIuKJp1wiLFxuXHRcImdFbFwiOiBcIuKqjFwiLFxuXHRcImdlbFwiOiBcIuKLm1wiLFxuXHRcImdlcVwiOiBcIuKJpVwiLFxuXHRcImdlcXFcIjogXCLiiadcIixcblx0XCJnZXFzbGFudFwiOiBcIuKpvlwiLFxuXHRcImdlc2NjXCI6IFwi4qqpXCIsXG5cdFwiZ2VzXCI6IFwi4qm+XCIsXG5cdFwiZ2VzZG90XCI6IFwi4qqAXCIsXG5cdFwiZ2VzZG90b1wiOiBcIuKqglwiLFxuXHRcImdlc2RvdG9sXCI6IFwi4qqEXCIsXG5cdFwiZ2VzbFwiOiBcIuKLm++4gFwiLFxuXHRcImdlc2xlc1wiOiBcIuKqlFwiLFxuXHRcIkdmclwiOiBcIvCdlIpcIixcblx0XCJnZnJcIjogXCLwnZSkXCIsXG5cdFwiZ2dcIjogXCLiiatcIixcblx0XCJHZ1wiOiBcIuKLmVwiLFxuXHRcImdnZ1wiOiBcIuKLmVwiLFxuXHRcImdpbWVsXCI6IFwi4oS3XCIsXG5cdFwiR0pjeVwiOiBcItCDXCIsXG5cdFwiZ2pjeVwiOiBcItGTXCIsXG5cdFwiZ2xhXCI6IFwi4qqlXCIsXG5cdFwiZ2xcIjogXCLiibdcIixcblx0XCJnbEVcIjogXCLiqpJcIixcblx0XCJnbGpcIjogXCLiqqRcIixcblx0XCJnbmFwXCI6IFwi4qqKXCIsXG5cdFwiZ25hcHByb3hcIjogXCLiqopcIixcblx0XCJnbmVcIjogXCLiqohcIixcblx0XCJnbkVcIjogXCLiialcIixcblx0XCJnbmVxXCI6IFwi4qqIXCIsXG5cdFwiZ25lcXFcIjogXCLiialcIixcblx0XCJnbnNpbVwiOiBcIuKLp1wiLFxuXHRcIkdvcGZcIjogXCLwnZS+XCIsXG5cdFwiZ29wZlwiOiBcIvCdlZhcIixcblx0XCJncmF2ZVwiOiBcImBcIixcblx0XCJHcmVhdGVyRXF1YWxcIjogXCLiiaVcIixcblx0XCJHcmVhdGVyRXF1YWxMZXNzXCI6IFwi4oubXCIsXG5cdFwiR3JlYXRlckZ1bGxFcXVhbFwiOiBcIuKJp1wiLFxuXHRcIkdyZWF0ZXJHcmVhdGVyXCI6IFwi4qqiXCIsXG5cdFwiR3JlYXRlckxlc3NcIjogXCLiibdcIixcblx0XCJHcmVhdGVyU2xhbnRFcXVhbFwiOiBcIuKpvlwiLFxuXHRcIkdyZWF0ZXJUaWxkZVwiOiBcIuKJs1wiLFxuXHRcIkdzY3JcIjogXCLwnZKiXCIsXG5cdFwiZ3NjclwiOiBcIuKEilwiLFxuXHRcImdzaW1cIjogXCLiibNcIixcblx0XCJnc2ltZVwiOiBcIuKqjlwiLFxuXHRcImdzaW1sXCI6IFwi4qqQXCIsXG5cdFwiZ3RjY1wiOiBcIuKqp1wiLFxuXHRcImd0Y2lyXCI6IFwi4qm6XCIsXG5cdFwiZ3RcIjogXCI+XCIsXG5cdFwiR1RcIjogXCI+XCIsXG5cdFwiR3RcIjogXCLiiatcIixcblx0XCJndGRvdFwiOiBcIuKLl1wiLFxuXHRcImd0bFBhclwiOiBcIuKmlVwiLFxuXHRcImd0cXVlc3RcIjogXCLiqbxcIixcblx0XCJndHJhcHByb3hcIjogXCLiqoZcIixcblx0XCJndHJhcnJcIjogXCLipbhcIixcblx0XCJndHJkb3RcIjogXCLii5dcIixcblx0XCJndHJlcWxlc3NcIjogXCLii5tcIixcblx0XCJndHJlcXFsZXNzXCI6IFwi4qqMXCIsXG5cdFwiZ3RybGVzc1wiOiBcIuKJt1wiLFxuXHRcImd0cnNpbVwiOiBcIuKJs1wiLFxuXHRcImd2ZXJ0bmVxcVwiOiBcIuKJqe+4gFwiLFxuXHRcImd2bkVcIjogXCLiianvuIBcIixcblx0XCJIYWNla1wiOiBcIsuHXCIsXG5cdFwiaGFpcnNwXCI6IFwi4oCKXCIsXG5cdFwiaGFsZlwiOiBcIsK9XCIsXG5cdFwiaGFtaWx0XCI6IFwi4oSLXCIsXG5cdFwiSEFSRGN5XCI6IFwi0KpcIixcblx0XCJoYXJkY3lcIjogXCLRilwiLFxuXHRcImhhcnJjaXJcIjogXCLipYhcIixcblx0XCJoYXJyXCI6IFwi4oaUXCIsXG5cdFwiaEFyclwiOiBcIuKHlFwiLFxuXHRcImhhcnJ3XCI6IFwi4oatXCIsXG5cdFwiSGF0XCI6IFwiXlwiLFxuXHRcImhiYXJcIjogXCLihI9cIixcblx0XCJIY2lyY1wiOiBcIsSkXCIsXG5cdFwiaGNpcmNcIjogXCLEpVwiLFxuXHRcImhlYXJ0c1wiOiBcIuKZpVwiLFxuXHRcImhlYXJ0c3VpdFwiOiBcIuKZpVwiLFxuXHRcImhlbGxpcFwiOiBcIuKAplwiLFxuXHRcImhlcmNvblwiOiBcIuKKuVwiLFxuXHRcImhmclwiOiBcIvCdlKVcIixcblx0XCJIZnJcIjogXCLihIxcIixcblx0XCJIaWxiZXJ0U3BhY2VcIjogXCLihItcIixcblx0XCJoa3NlYXJvd1wiOiBcIuKkpVwiLFxuXHRcImhrc3dhcm93XCI6IFwi4qSmXCIsXG5cdFwiaG9hcnJcIjogXCLih79cIixcblx0XCJob210aHRcIjogXCLiiLtcIixcblx0XCJob29rbGVmdGFycm93XCI6IFwi4oapXCIsXG5cdFwiaG9va3JpZ2h0YXJyb3dcIjogXCLihqpcIixcblx0XCJob3BmXCI6IFwi8J2VmVwiLFxuXHRcIkhvcGZcIjogXCLihI1cIixcblx0XCJob3JiYXJcIjogXCLigJVcIixcblx0XCJIb3Jpem9udGFsTGluZVwiOiBcIuKUgFwiLFxuXHRcImhzY3JcIjogXCLwnZK9XCIsXG5cdFwiSHNjclwiOiBcIuKEi1wiLFxuXHRcImhzbGFzaFwiOiBcIuKEj1wiLFxuXHRcIkhzdHJva1wiOiBcIsSmXCIsXG5cdFwiaHN0cm9rXCI6IFwixKdcIixcblx0XCJIdW1wRG93bkh1bXBcIjogXCLiiY5cIixcblx0XCJIdW1wRXF1YWxcIjogXCLiiY9cIixcblx0XCJoeWJ1bGxcIjogXCLigYNcIixcblx0XCJoeXBoZW5cIjogXCLigJBcIixcblx0XCJJYWN1dGVcIjogXCLDjVwiLFxuXHRcImlhY3V0ZVwiOiBcIsOtXCIsXG5cdFwiaWNcIjogXCLigaNcIixcblx0XCJJY2lyY1wiOiBcIsOOXCIsXG5cdFwiaWNpcmNcIjogXCLDrlwiLFxuXHRcIkljeVwiOiBcItCYXCIsXG5cdFwiaWN5XCI6IFwi0LhcIixcblx0XCJJZG90XCI6IFwixLBcIixcblx0XCJJRWN5XCI6IFwi0JVcIixcblx0XCJpZWN5XCI6IFwi0LVcIixcblx0XCJpZXhjbFwiOiBcIsKhXCIsXG5cdFwiaWZmXCI6IFwi4oeUXCIsXG5cdFwiaWZyXCI6IFwi8J2UplwiLFxuXHRcIklmclwiOiBcIuKEkVwiLFxuXHRcIklncmF2ZVwiOiBcIsOMXCIsXG5cdFwiaWdyYXZlXCI6IFwiw6xcIixcblx0XCJpaVwiOiBcIuKFiFwiLFxuXHRcImlpaWludFwiOiBcIuKojFwiLFxuXHRcImlpaW50XCI6IFwi4oitXCIsXG5cdFwiaWluZmluXCI6IFwi4qecXCIsXG5cdFwiaWlvdGFcIjogXCLihKlcIixcblx0XCJJSmxpZ1wiOiBcIsSyXCIsXG5cdFwiaWpsaWdcIjogXCLEs1wiLFxuXHRcIkltYWNyXCI6IFwixKpcIixcblx0XCJpbWFjclwiOiBcIsSrXCIsXG5cdFwiaW1hZ2VcIjogXCLihJFcIixcblx0XCJJbWFnaW5hcnlJXCI6IFwi4oWIXCIsXG5cdFwiaW1hZ2xpbmVcIjogXCLihJBcIixcblx0XCJpbWFncGFydFwiOiBcIuKEkVwiLFxuXHRcImltYXRoXCI6IFwixLFcIixcblx0XCJJbVwiOiBcIuKEkVwiLFxuXHRcImltb2ZcIjogXCLiirdcIixcblx0XCJpbXBlZFwiOiBcIsa1XCIsXG5cdFwiSW1wbGllc1wiOiBcIuKHklwiLFxuXHRcImluY2FyZVwiOiBcIuKEhVwiLFxuXHRcImluXCI6IFwi4oiIXCIsXG5cdFwiaW5maW5cIjogXCLiiJ5cIixcblx0XCJpbmZpbnRpZVwiOiBcIuKnnVwiLFxuXHRcImlub2RvdFwiOiBcIsSxXCIsXG5cdFwiaW50Y2FsXCI6IFwi4oq6XCIsXG5cdFwiaW50XCI6IFwi4oirXCIsXG5cdFwiSW50XCI6IFwi4oisXCIsXG5cdFwiaW50ZWdlcnNcIjogXCLihKRcIixcblx0XCJJbnRlZ3JhbFwiOiBcIuKIq1wiLFxuXHRcImludGVyY2FsXCI6IFwi4oq6XCIsXG5cdFwiSW50ZXJzZWN0aW9uXCI6IFwi4ouCXCIsXG5cdFwiaW50bGFyaGtcIjogXCLiqJdcIixcblx0XCJpbnRwcm9kXCI6IFwi4qi8XCIsXG5cdFwiSW52aXNpYmxlQ29tbWFcIjogXCLigaNcIixcblx0XCJJbnZpc2libGVUaW1lc1wiOiBcIuKBolwiLFxuXHRcIklPY3lcIjogXCLQgVwiLFxuXHRcImlvY3lcIjogXCLRkVwiLFxuXHRcIklvZ29uXCI6IFwixK5cIixcblx0XCJpb2dvblwiOiBcIsSvXCIsXG5cdFwiSW9wZlwiOiBcIvCdlYBcIixcblx0XCJpb3BmXCI6IFwi8J2VmlwiLFxuXHRcIklvdGFcIjogXCLOmVwiLFxuXHRcImlvdGFcIjogXCLOuVwiLFxuXHRcImlwcm9kXCI6IFwi4qi8XCIsXG5cdFwiaXF1ZXN0XCI6IFwiwr9cIixcblx0XCJpc2NyXCI6IFwi8J2SvlwiLFxuXHRcIklzY3JcIjogXCLihJBcIixcblx0XCJpc2luXCI6IFwi4oiIXCIsXG5cdFwiaXNpbmRvdFwiOiBcIuKLtVwiLFxuXHRcImlzaW5FXCI6IFwi4ou5XCIsXG5cdFwiaXNpbnNcIjogXCLii7RcIixcblx0XCJpc2luc3ZcIjogXCLii7NcIixcblx0XCJpc2ludlwiOiBcIuKIiFwiLFxuXHRcIml0XCI6IFwi4oGiXCIsXG5cdFwiSXRpbGRlXCI6IFwixKhcIixcblx0XCJpdGlsZGVcIjogXCLEqVwiLFxuXHRcIkl1a2N5XCI6IFwi0IZcIixcblx0XCJpdWtjeVwiOiBcItGWXCIsXG5cdFwiSXVtbFwiOiBcIsOPXCIsXG5cdFwiaXVtbFwiOiBcIsOvXCIsXG5cdFwiSmNpcmNcIjogXCLEtFwiLFxuXHRcImpjaXJjXCI6IFwixLVcIixcblx0XCJKY3lcIjogXCLQmVwiLFxuXHRcImpjeVwiOiBcItC5XCIsXG5cdFwiSmZyXCI6IFwi8J2UjVwiLFxuXHRcImpmclwiOiBcIvCdlKdcIixcblx0XCJqbWF0aFwiOiBcIsi3XCIsXG5cdFwiSm9wZlwiOiBcIvCdlYFcIixcblx0XCJqb3BmXCI6IFwi8J2Vm1wiLFxuXHRcIkpzY3JcIjogXCLwnZKlXCIsXG5cdFwianNjclwiOiBcIvCdkr9cIixcblx0XCJKc2VyY3lcIjogXCLQiFwiLFxuXHRcImpzZXJjeVwiOiBcItGYXCIsXG5cdFwiSnVrY3lcIjogXCLQhFwiLFxuXHRcImp1a2N5XCI6IFwi0ZRcIixcblx0XCJLYXBwYVwiOiBcIs6aXCIsXG5cdFwia2FwcGFcIjogXCLOulwiLFxuXHRcImthcHBhdlwiOiBcIs+wXCIsXG5cdFwiS2NlZGlsXCI6IFwixLZcIixcblx0XCJrY2VkaWxcIjogXCLEt1wiLFxuXHRcIktjeVwiOiBcItCaXCIsXG5cdFwia2N5XCI6IFwi0LpcIixcblx0XCJLZnJcIjogXCLwnZSOXCIsXG5cdFwia2ZyXCI6IFwi8J2UqFwiLFxuXHRcImtncmVlblwiOiBcIsS4XCIsXG5cdFwiS0hjeVwiOiBcItClXCIsXG5cdFwia2hjeVwiOiBcItGFXCIsXG5cdFwiS0pjeVwiOiBcItCMXCIsXG5cdFwia2pjeVwiOiBcItGcXCIsXG5cdFwiS29wZlwiOiBcIvCdlYJcIixcblx0XCJrb3BmXCI6IFwi8J2VnFwiLFxuXHRcIktzY3JcIjogXCLwnZKmXCIsXG5cdFwia3NjclwiOiBcIvCdk4BcIixcblx0XCJsQWFyclwiOiBcIuKHmlwiLFxuXHRcIkxhY3V0ZVwiOiBcIsS5XCIsXG5cdFwibGFjdXRlXCI6IFwixLpcIixcblx0XCJsYWVtcHR5dlwiOiBcIuKmtFwiLFxuXHRcImxhZ3JhblwiOiBcIuKEklwiLFxuXHRcIkxhbWJkYVwiOiBcIs6bXCIsXG5cdFwibGFtYmRhXCI6IFwizrtcIixcblx0XCJsYW5nXCI6IFwi4p+oXCIsXG5cdFwiTGFuZ1wiOiBcIuKfqlwiLFxuXHRcImxhbmdkXCI6IFwi4qaRXCIsXG5cdFwibGFuZ2xlXCI6IFwi4p+oXCIsXG5cdFwibGFwXCI6IFwi4qqFXCIsXG5cdFwiTGFwbGFjZXRyZlwiOiBcIuKEklwiLFxuXHRcImxhcXVvXCI6IFwiwqtcIixcblx0XCJsYXJyYlwiOiBcIuKHpFwiLFxuXHRcImxhcnJiZnNcIjogXCLipJ9cIixcblx0XCJsYXJyXCI6IFwi4oaQXCIsXG5cdFwiTGFyclwiOiBcIuKGnlwiLFxuXHRcImxBcnJcIjogXCLih5BcIixcblx0XCJsYXJyZnNcIjogXCLipJ1cIixcblx0XCJsYXJyaGtcIjogXCLihqlcIixcblx0XCJsYXJybHBcIjogXCLihqtcIixcblx0XCJsYXJycGxcIjogXCLipLlcIixcblx0XCJsYXJyc2ltXCI6IFwi4qWzXCIsXG5cdFwibGFycnRsXCI6IFwi4oaiXCIsXG5cdFwibGF0YWlsXCI6IFwi4qSZXCIsXG5cdFwibEF0YWlsXCI6IFwi4qSbXCIsXG5cdFwibGF0XCI6IFwi4qqrXCIsXG5cdFwibGF0ZVwiOiBcIuKqrVwiLFxuXHRcImxhdGVzXCI6IFwi4qqt77iAXCIsXG5cdFwibGJhcnJcIjogXCLipIxcIixcblx0XCJsQmFyclwiOiBcIuKkjlwiLFxuXHRcImxiYnJrXCI6IFwi4p2yXCIsXG5cdFwibGJyYWNlXCI6IFwie1wiLFxuXHRcImxicmFja1wiOiBcIltcIixcblx0XCJsYnJrZVwiOiBcIuKmi1wiLFxuXHRcImxicmtzbGRcIjogXCLipo9cIixcblx0XCJsYnJrc2x1XCI6IFwi4qaNXCIsXG5cdFwiTGNhcm9uXCI6IFwixL1cIixcblx0XCJsY2Fyb25cIjogXCLEvlwiLFxuXHRcIkxjZWRpbFwiOiBcIsS7XCIsXG5cdFwibGNlZGlsXCI6IFwixLxcIixcblx0XCJsY2VpbFwiOiBcIuKMiFwiLFxuXHRcImxjdWJcIjogXCJ7XCIsXG5cdFwiTGN5XCI6IFwi0JtcIixcblx0XCJsY3lcIjogXCLQu1wiLFxuXHRcImxkY2FcIjogXCLipLZcIixcblx0XCJsZHF1b1wiOiBcIuKAnFwiLFxuXHRcImxkcXVvclwiOiBcIuKAnlwiLFxuXHRcImxkcmRoYXJcIjogXCLipadcIixcblx0XCJsZHJ1c2hhclwiOiBcIuKli1wiLFxuXHRcImxkc2hcIjogXCLihrJcIixcblx0XCJsZVwiOiBcIuKJpFwiLFxuXHRcImxFXCI6IFwi4ommXCIsXG5cdFwiTGVmdEFuZ2xlQnJhY2tldFwiOiBcIuKfqFwiLFxuXHRcIkxlZnRBcnJvd0JhclwiOiBcIuKHpFwiLFxuXHRcImxlZnRhcnJvd1wiOiBcIuKGkFwiLFxuXHRcIkxlZnRBcnJvd1wiOiBcIuKGkFwiLFxuXHRcIkxlZnRhcnJvd1wiOiBcIuKHkFwiLFxuXHRcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjogXCLih4ZcIixcblx0XCJsZWZ0YXJyb3d0YWlsXCI6IFwi4oaiXCIsXG5cdFwiTGVmdENlaWxpbmdcIjogXCLijIhcIixcblx0XCJMZWZ0RG91YmxlQnJhY2tldFwiOiBcIuKfplwiLFxuXHRcIkxlZnREb3duVGVlVmVjdG9yXCI6IFwi4qWhXCIsXG5cdFwiTGVmdERvd25WZWN0b3JCYXJcIjogXCLipZlcIixcblx0XCJMZWZ0RG93blZlY3RvclwiOiBcIuKHg1wiLFxuXHRcIkxlZnRGbG9vclwiOiBcIuKMilwiLFxuXHRcImxlZnRoYXJwb29uZG93blwiOiBcIuKGvVwiLFxuXHRcImxlZnRoYXJwb29udXBcIjogXCLihrxcIixcblx0XCJsZWZ0bGVmdGFycm93c1wiOiBcIuKHh1wiLFxuXHRcImxlZnRyaWdodGFycm93XCI6IFwi4oaUXCIsXG5cdFwiTGVmdFJpZ2h0QXJyb3dcIjogXCLihpRcIixcblx0XCJMZWZ0cmlnaHRhcnJvd1wiOiBcIuKHlFwiLFxuXHRcImxlZnRyaWdodGFycm93c1wiOiBcIuKHhlwiLFxuXHRcImxlZnRyaWdodGhhcnBvb25zXCI6IFwi4oeLXCIsXG5cdFwibGVmdHJpZ2h0c3F1aWdhcnJvd1wiOiBcIuKGrVwiLFxuXHRcIkxlZnRSaWdodFZlY3RvclwiOiBcIuKljlwiLFxuXHRcIkxlZnRUZWVBcnJvd1wiOiBcIuKGpFwiLFxuXHRcIkxlZnRUZWVcIjogXCLiiqNcIixcblx0XCJMZWZ0VGVlVmVjdG9yXCI6IFwi4qWaXCIsXG5cdFwibGVmdHRocmVldGltZXNcIjogXCLii4tcIixcblx0XCJMZWZ0VHJpYW5nbGVCYXJcIjogXCLip49cIixcblx0XCJMZWZ0VHJpYW5nbGVcIjogXCLiirJcIixcblx0XCJMZWZ0VHJpYW5nbGVFcXVhbFwiOiBcIuKKtFwiLFxuXHRcIkxlZnRVcERvd25WZWN0b3JcIjogXCLipZFcIixcblx0XCJMZWZ0VXBUZWVWZWN0b3JcIjogXCLipaBcIixcblx0XCJMZWZ0VXBWZWN0b3JCYXJcIjogXCLipZhcIixcblx0XCJMZWZ0VXBWZWN0b3JcIjogXCLihr9cIixcblx0XCJMZWZ0VmVjdG9yQmFyXCI6IFwi4qWSXCIsXG5cdFwiTGVmdFZlY3RvclwiOiBcIuKGvFwiLFxuXHRcImxFZ1wiOiBcIuKqi1wiLFxuXHRcImxlZ1wiOiBcIuKLmlwiLFxuXHRcImxlcVwiOiBcIuKJpFwiLFxuXHRcImxlcXFcIjogXCLiiaZcIixcblx0XCJsZXFzbGFudFwiOiBcIuKpvVwiLFxuXHRcImxlc2NjXCI6IFwi4qqoXCIsXG5cdFwibGVzXCI6IFwi4qm9XCIsXG5cdFwibGVzZG90XCI6IFwi4qm/XCIsXG5cdFwibGVzZG90b1wiOiBcIuKqgVwiLFxuXHRcImxlc2RvdG9yXCI6IFwi4qqDXCIsXG5cdFwibGVzZ1wiOiBcIuKLmu+4gFwiLFxuXHRcImxlc2dlc1wiOiBcIuKqk1wiLFxuXHRcImxlc3NhcHByb3hcIjogXCLiqoVcIixcblx0XCJsZXNzZG90XCI6IFwi4ouWXCIsXG5cdFwibGVzc2VxZ3RyXCI6IFwi4ouaXCIsXG5cdFwibGVzc2VxcWd0clwiOiBcIuKqi1wiLFxuXHRcIkxlc3NFcXVhbEdyZWF0ZXJcIjogXCLii5pcIixcblx0XCJMZXNzRnVsbEVxdWFsXCI6IFwi4ommXCIsXG5cdFwiTGVzc0dyZWF0ZXJcIjogXCLiibZcIixcblx0XCJsZXNzZ3RyXCI6IFwi4om2XCIsXG5cdFwiTGVzc0xlc3NcIjogXCLiqqFcIixcblx0XCJsZXNzc2ltXCI6IFwi4omyXCIsXG5cdFwiTGVzc1NsYW50RXF1YWxcIjogXCLiqb1cIixcblx0XCJMZXNzVGlsZGVcIjogXCLiibJcIixcblx0XCJsZmlzaHRcIjogXCLipbxcIixcblx0XCJsZmxvb3JcIjogXCLijIpcIixcblx0XCJMZnJcIjogXCLwnZSPXCIsXG5cdFwibGZyXCI6IFwi8J2UqVwiLFxuXHRcImxnXCI6IFwi4om2XCIsXG5cdFwibGdFXCI6IFwi4qqRXCIsXG5cdFwibEhhclwiOiBcIuKlolwiLFxuXHRcImxoYXJkXCI6IFwi4oa9XCIsXG5cdFwibGhhcnVcIjogXCLihrxcIixcblx0XCJsaGFydWxcIjogXCLipapcIixcblx0XCJsaGJsa1wiOiBcIuKWhFwiLFxuXHRcIkxKY3lcIjogXCLQiVwiLFxuXHRcImxqY3lcIjogXCLRmVwiLFxuXHRcImxsYXJyXCI6IFwi4oeHXCIsXG5cdFwibGxcIjogXCLiiapcIixcblx0XCJMbFwiOiBcIuKLmFwiLFxuXHRcImxsY29ybmVyXCI6IFwi4oyeXCIsXG5cdFwiTGxlZnRhcnJvd1wiOiBcIuKHmlwiLFxuXHRcImxsaGFyZFwiOiBcIuKlq1wiLFxuXHRcImxsdHJpXCI6IFwi4pe6XCIsXG5cdFwiTG1pZG90XCI6IFwixL9cIixcblx0XCJsbWlkb3RcIjogXCLFgFwiLFxuXHRcImxtb3VzdGFjaGVcIjogXCLijrBcIixcblx0XCJsbW91c3RcIjogXCLijrBcIixcblx0XCJsbmFwXCI6IFwi4qqJXCIsXG5cdFwibG5hcHByb3hcIjogXCLiqolcIixcblx0XCJsbmVcIjogXCLiqodcIixcblx0XCJsbkVcIjogXCLiiahcIixcblx0XCJsbmVxXCI6IFwi4qqHXCIsXG5cdFwibG5lcXFcIjogXCLiiahcIixcblx0XCJsbnNpbVwiOiBcIuKLplwiLFxuXHRcImxvYW5nXCI6IFwi4p+sXCIsXG5cdFwibG9hcnJcIjogXCLih71cIixcblx0XCJsb2Jya1wiOiBcIuKfplwiLFxuXHRcImxvbmdsZWZ0YXJyb3dcIjogXCLin7VcIixcblx0XCJMb25nTGVmdEFycm93XCI6IFwi4p+1XCIsXG5cdFwiTG9uZ2xlZnRhcnJvd1wiOiBcIuKfuFwiLFxuXHRcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOiBcIuKft1wiLFxuXHRcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOiBcIuKft1wiLFxuXHRcIkxvbmdsZWZ0cmlnaHRhcnJvd1wiOiBcIuKfulwiLFxuXHRcImxvbmdtYXBzdG9cIjogXCLin7xcIixcblx0XCJsb25ncmlnaHRhcnJvd1wiOiBcIuKftlwiLFxuXHRcIkxvbmdSaWdodEFycm93XCI6IFwi4p+2XCIsXG5cdFwiTG9uZ3JpZ2h0YXJyb3dcIjogXCLin7lcIixcblx0XCJsb29wYXJyb3dsZWZ0XCI6IFwi4oarXCIsXG5cdFwibG9vcGFycm93cmlnaHRcIjogXCLihqxcIixcblx0XCJsb3BhclwiOiBcIuKmhVwiLFxuXHRcIkxvcGZcIjogXCLwnZWDXCIsXG5cdFwibG9wZlwiOiBcIvCdlZ1cIixcblx0XCJsb3BsdXNcIjogXCLiqK1cIixcblx0XCJsb3RpbWVzXCI6IFwi4qi0XCIsXG5cdFwibG93YXN0XCI6IFwi4oiXXCIsXG5cdFwibG93YmFyXCI6IFwiX1wiLFxuXHRcIkxvd2VyTGVmdEFycm93XCI6IFwi4oaZXCIsXG5cdFwiTG93ZXJSaWdodEFycm93XCI6IFwi4oaYXCIsXG5cdFwibG96XCI6IFwi4peKXCIsXG5cdFwibG96ZW5nZVwiOiBcIuKXilwiLFxuXHRcImxvemZcIjogXCLip6tcIixcblx0XCJscGFyXCI6IFwiKFwiLFxuXHRcImxwYXJsdFwiOiBcIuKmk1wiLFxuXHRcImxyYXJyXCI6IFwi4oeGXCIsXG5cdFwibHJjb3JuZXJcIjogXCLijJ9cIixcblx0XCJscmhhclwiOiBcIuKHi1wiLFxuXHRcImxyaGFyZFwiOiBcIuKlrVwiLFxuXHRcImxybVwiOiBcIuKAjlwiLFxuXHRcImxydHJpXCI6IFwi4oq/XCIsXG5cdFwibHNhcXVvXCI6IFwi4oC5XCIsXG5cdFwibHNjclwiOiBcIvCdk4FcIixcblx0XCJMc2NyXCI6IFwi4oSSXCIsXG5cdFwibHNoXCI6IFwi4oawXCIsXG5cdFwiTHNoXCI6IFwi4oawXCIsXG5cdFwibHNpbVwiOiBcIuKJslwiLFxuXHRcImxzaW1lXCI6IFwi4qqNXCIsXG5cdFwibHNpbWdcIjogXCLiqo9cIixcblx0XCJsc3FiXCI6IFwiW1wiLFxuXHRcImxzcXVvXCI6IFwi4oCYXCIsXG5cdFwibHNxdW9yXCI6IFwi4oCaXCIsXG5cdFwiTHN0cm9rXCI6IFwixYFcIixcblx0XCJsc3Ryb2tcIjogXCLFglwiLFxuXHRcImx0Y2NcIjogXCLiqqZcIixcblx0XCJsdGNpclwiOiBcIuKpuVwiLFxuXHRcImx0XCI6IFwiPFwiLFxuXHRcIkxUXCI6IFwiPFwiLFxuXHRcIkx0XCI6IFwi4omqXCIsXG5cdFwibHRkb3RcIjogXCLii5ZcIixcblx0XCJsdGhyZWVcIjogXCLii4tcIixcblx0XCJsdGltZXNcIjogXCLii4lcIixcblx0XCJsdGxhcnJcIjogXCLipbZcIixcblx0XCJsdHF1ZXN0XCI6IFwi4qm7XCIsXG5cdFwibHRyaVwiOiBcIuKXg1wiLFxuXHRcImx0cmllXCI6IFwi4oq0XCIsXG5cdFwibHRyaWZcIjogXCLil4JcIixcblx0XCJsdHJQYXJcIjogXCLippZcIixcblx0XCJsdXJkc2hhclwiOiBcIuKlilwiLFxuXHRcImx1cnVoYXJcIjogXCLipaZcIixcblx0XCJsdmVydG5lcXFcIjogXCLiiajvuIBcIixcblx0XCJsdm5FXCI6IFwi4omo77iAXCIsXG5cdFwibWFjclwiOiBcIsKvXCIsXG5cdFwibWFsZVwiOiBcIuKZglwiLFxuXHRcIm1hbHRcIjogXCLinKBcIixcblx0XCJtYWx0ZXNlXCI6IFwi4pygXCIsXG5cdFwiTWFwXCI6IFwi4qSFXCIsXG5cdFwibWFwXCI6IFwi4oamXCIsXG5cdFwibWFwc3RvXCI6IFwi4oamXCIsXG5cdFwibWFwc3RvZG93blwiOiBcIuKGp1wiLFxuXHRcIm1hcHN0b2xlZnRcIjogXCLihqRcIixcblx0XCJtYXBzdG91cFwiOiBcIuKGpVwiLFxuXHRcIm1hcmtlclwiOiBcIuKWrlwiLFxuXHRcIm1jb21tYVwiOiBcIuKoqVwiLFxuXHRcIk1jeVwiOiBcItCcXCIsXG5cdFwibWN5XCI6IFwi0LxcIixcblx0XCJtZGFzaFwiOiBcIuKAlFwiLFxuXHRcIm1ERG90XCI6IFwi4oi6XCIsXG5cdFwibWVhc3VyZWRhbmdsZVwiOiBcIuKIoVwiLFxuXHRcIk1lZGl1bVNwYWNlXCI6IFwi4oGfXCIsXG5cdFwiTWVsbGludHJmXCI6IFwi4oSzXCIsXG5cdFwiTWZyXCI6IFwi8J2UkFwiLFxuXHRcIm1mclwiOiBcIvCdlKpcIixcblx0XCJtaG9cIjogXCLihKdcIixcblx0XCJtaWNyb1wiOiBcIsK1XCIsXG5cdFwibWlkYXN0XCI6IFwiKlwiLFxuXHRcIm1pZGNpclwiOiBcIuKrsFwiLFxuXHRcIm1pZFwiOiBcIuKIo1wiLFxuXHRcIm1pZGRvdFwiOiBcIsK3XCIsXG5cdFwibWludXNiXCI6IFwi4oqfXCIsXG5cdFwibWludXNcIjogXCLiiJJcIixcblx0XCJtaW51c2RcIjogXCLiiLhcIixcblx0XCJtaW51c2R1XCI6IFwi4qiqXCIsXG5cdFwiTWludXNQbHVzXCI6IFwi4oiTXCIsXG5cdFwibWxjcFwiOiBcIuKrm1wiLFxuXHRcIm1sZHJcIjogXCLigKZcIixcblx0XCJtbnBsdXNcIjogXCLiiJNcIixcblx0XCJtb2RlbHNcIjogXCLiiqdcIixcblx0XCJNb3BmXCI6IFwi8J2VhFwiLFxuXHRcIm1vcGZcIjogXCLwnZWeXCIsXG5cdFwibXBcIjogXCLiiJNcIixcblx0XCJtc2NyXCI6IFwi8J2TglwiLFxuXHRcIk1zY3JcIjogXCLihLNcIixcblx0XCJtc3Rwb3NcIjogXCLiiL5cIixcblx0XCJNdVwiOiBcIs6cXCIsXG5cdFwibXVcIjogXCLOvFwiLFxuXHRcIm11bHRpbWFwXCI6IFwi4oq4XCIsXG5cdFwibXVtYXBcIjogXCLiirhcIixcblx0XCJuYWJsYVwiOiBcIuKIh1wiLFxuXHRcIk5hY3V0ZVwiOiBcIsWDXCIsXG5cdFwibmFjdXRlXCI6IFwixYRcIixcblx0XCJuYW5nXCI6IFwi4oig4oOSXCIsXG5cdFwibmFwXCI6IFwi4omJXCIsXG5cdFwibmFwRVwiOiBcIuKpsMy4XCIsXG5cdFwibmFwaWRcIjogXCLiiYvMuFwiLFxuXHRcIm5hcG9zXCI6IFwixYlcIixcblx0XCJuYXBwcm94XCI6IFwi4omJXCIsXG5cdFwibmF0dXJhbFwiOiBcIuKZrlwiLFxuXHRcIm5hdHVyYWxzXCI6IFwi4oSVXCIsXG5cdFwibmF0dXJcIjogXCLima5cIixcblx0XCJuYnNwXCI6IFwiwqBcIixcblx0XCJuYnVtcFwiOiBcIuKJjsy4XCIsXG5cdFwibmJ1bXBlXCI6IFwi4omPzLhcIixcblx0XCJuY2FwXCI6IFwi4qmDXCIsXG5cdFwiTmNhcm9uXCI6IFwixYdcIixcblx0XCJuY2Fyb25cIjogXCLFiFwiLFxuXHRcIk5jZWRpbFwiOiBcIsWFXCIsXG5cdFwibmNlZGlsXCI6IFwixYZcIixcblx0XCJuY29uZ1wiOiBcIuKJh1wiLFxuXHRcIm5jb25nZG90XCI6IFwi4qmtzLhcIixcblx0XCJuY3VwXCI6IFwi4qmCXCIsXG5cdFwiTmN5XCI6IFwi0J1cIixcblx0XCJuY3lcIjogXCLQvVwiLFxuXHRcIm5kYXNoXCI6IFwi4oCTXCIsXG5cdFwibmVhcmhrXCI6IFwi4qSkXCIsXG5cdFwibmVhcnJcIjogXCLihpdcIixcblx0XCJuZUFyclwiOiBcIuKHl1wiLFxuXHRcIm5lYXJyb3dcIjogXCLihpdcIixcblx0XCJuZVwiOiBcIuKJoFwiLFxuXHRcIm5lZG90XCI6IFwi4omQzLhcIixcblx0XCJOZWdhdGl2ZU1lZGl1bVNwYWNlXCI6IFwi4oCLXCIsXG5cdFwiTmVnYXRpdmVUaGlja1NwYWNlXCI6IFwi4oCLXCIsXG5cdFwiTmVnYXRpdmVUaGluU3BhY2VcIjogXCLigItcIixcblx0XCJOZWdhdGl2ZVZlcnlUaGluU3BhY2VcIjogXCLigItcIixcblx0XCJuZXF1aXZcIjogXCLiiaJcIixcblx0XCJuZXNlYXJcIjogXCLipKhcIixcblx0XCJuZXNpbVwiOiBcIuKJgsy4XCIsXG5cdFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjogXCLiiatcIixcblx0XCJOZXN0ZWRMZXNzTGVzc1wiOiBcIuKJqlwiLFxuXHRcIk5ld0xpbmVcIjogXCJcXG5cIixcblx0XCJuZXhpc3RcIjogXCLiiIRcIixcblx0XCJuZXhpc3RzXCI6IFwi4oiEXCIsXG5cdFwiTmZyXCI6IFwi8J2UkVwiLFxuXHRcIm5mclwiOiBcIvCdlKtcIixcblx0XCJuZ0VcIjogXCLiiafMuFwiLFxuXHRcIm5nZVwiOiBcIuKJsVwiLFxuXHRcIm5nZXFcIjogXCLiibFcIixcblx0XCJuZ2VxcVwiOiBcIuKJp8y4XCIsXG5cdFwibmdlcXNsYW50XCI6IFwi4qm+zLhcIixcblx0XCJuZ2VzXCI6IFwi4qm+zLhcIixcblx0XCJuR2dcIjogXCLii5nMuFwiLFxuXHRcIm5nc2ltXCI6IFwi4om1XCIsXG5cdFwibkd0XCI6IFwi4omr4oOSXCIsXG5cdFwibmd0XCI6IFwi4omvXCIsXG5cdFwibmd0clwiOiBcIuKJr1wiLFxuXHRcIm5HdHZcIjogXCLiiavMuFwiLFxuXHRcIm5oYXJyXCI6IFwi4oauXCIsXG5cdFwibmhBcnJcIjogXCLih45cIixcblx0XCJuaHBhclwiOiBcIuKrslwiLFxuXHRcIm5pXCI6IFwi4oiLXCIsXG5cdFwibmlzXCI6IFwi4ou8XCIsXG5cdFwibmlzZFwiOiBcIuKLulwiLFxuXHRcIm5pdlwiOiBcIuKIi1wiLFxuXHRcIk5KY3lcIjogXCLQilwiLFxuXHRcIm5qY3lcIjogXCLRmlwiLFxuXHRcIm5sYXJyXCI6IFwi4oaaXCIsXG5cdFwibmxBcnJcIjogXCLih41cIixcblx0XCJubGRyXCI6IFwi4oClXCIsXG5cdFwibmxFXCI6IFwi4ommzLhcIixcblx0XCJubGVcIjogXCLiibBcIixcblx0XCJubGVmdGFycm93XCI6IFwi4oaaXCIsXG5cdFwibkxlZnRhcnJvd1wiOiBcIuKHjVwiLFxuXHRcIm5sZWZ0cmlnaHRhcnJvd1wiOiBcIuKGrlwiLFxuXHRcIm5MZWZ0cmlnaHRhcnJvd1wiOiBcIuKHjlwiLFxuXHRcIm5sZXFcIjogXCLiibBcIixcblx0XCJubGVxcVwiOiBcIuKJpsy4XCIsXG5cdFwibmxlcXNsYW50XCI6IFwi4qm9zLhcIixcblx0XCJubGVzXCI6IFwi4qm9zLhcIixcblx0XCJubGVzc1wiOiBcIuKJrlwiLFxuXHRcIm5MbFwiOiBcIuKLmMy4XCIsXG5cdFwibmxzaW1cIjogXCLiibRcIixcblx0XCJuTHRcIjogXCLiiarig5JcIixcblx0XCJubHRcIjogXCLiia5cIixcblx0XCJubHRyaVwiOiBcIuKLqlwiLFxuXHRcIm5sdHJpZVwiOiBcIuKLrFwiLFxuXHRcIm5MdHZcIjogXCLiiarMuFwiLFxuXHRcIm5taWRcIjogXCLiiKRcIixcblx0XCJOb0JyZWFrXCI6IFwi4oGgXCIsXG5cdFwiTm9uQnJlYWtpbmdTcGFjZVwiOiBcIsKgXCIsXG5cdFwibm9wZlwiOiBcIvCdlZ9cIixcblx0XCJOb3BmXCI6IFwi4oSVXCIsXG5cdFwiTm90XCI6IFwi4qusXCIsXG5cdFwibm90XCI6IFwiwqxcIixcblx0XCJOb3RDb25ncnVlbnRcIjogXCLiiaJcIixcblx0XCJOb3RDdXBDYXBcIjogXCLiia1cIixcblx0XCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOiBcIuKIplwiLFxuXHRcIk5vdEVsZW1lbnRcIjogXCLiiIlcIixcblx0XCJOb3RFcXVhbFwiOiBcIuKJoFwiLFxuXHRcIk5vdEVxdWFsVGlsZGVcIjogXCLiiYLMuFwiLFxuXHRcIk5vdEV4aXN0c1wiOiBcIuKIhFwiLFxuXHRcIk5vdEdyZWF0ZXJcIjogXCLiia9cIixcblx0XCJOb3RHcmVhdGVyRXF1YWxcIjogXCLiibFcIixcblx0XCJOb3RHcmVhdGVyRnVsbEVxdWFsXCI6IFwi4omnzLhcIixcblx0XCJOb3RHcmVhdGVyR3JlYXRlclwiOiBcIuKJq8y4XCIsXG5cdFwiTm90R3JlYXRlckxlc3NcIjogXCLiiblcIixcblx0XCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOiBcIuKpvsy4XCIsXG5cdFwiTm90R3JlYXRlclRpbGRlXCI6IFwi4om1XCIsXG5cdFwiTm90SHVtcERvd25IdW1wXCI6IFwi4omOzLhcIixcblx0XCJOb3RIdW1wRXF1YWxcIjogXCLiiY/MuFwiLFxuXHRcIm5vdGluXCI6IFwi4oiJXCIsXG5cdFwibm90aW5kb3RcIjogXCLii7XMuFwiLFxuXHRcIm5vdGluRVwiOiBcIuKLucy4XCIsXG5cdFwibm90aW52YVwiOiBcIuKIiVwiLFxuXHRcIm5vdGludmJcIjogXCLii7dcIixcblx0XCJub3RpbnZjXCI6IFwi4ou2XCIsXG5cdFwiTm90TGVmdFRyaWFuZ2xlQmFyXCI6IFwi4qePzLhcIixcblx0XCJOb3RMZWZ0VHJpYW5nbGVcIjogXCLii6pcIixcblx0XCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOiBcIuKLrFwiLFxuXHRcIk5vdExlc3NcIjogXCLiia5cIixcblx0XCJOb3RMZXNzRXF1YWxcIjogXCLiibBcIixcblx0XCJOb3RMZXNzR3JlYXRlclwiOiBcIuKJuFwiLFxuXHRcIk5vdExlc3NMZXNzXCI6IFwi4omqzLhcIixcblx0XCJOb3RMZXNzU2xhbnRFcXVhbFwiOiBcIuKpvcy4XCIsXG5cdFwiTm90TGVzc1RpbGRlXCI6IFwi4om0XCIsXG5cdFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXJcIjogXCLiqqLMuFwiLFxuXHRcIk5vdE5lc3RlZExlc3NMZXNzXCI6IFwi4qqhzLhcIixcblx0XCJub3RuaVwiOiBcIuKIjFwiLFxuXHRcIm5vdG5pdmFcIjogXCLiiIxcIixcblx0XCJub3RuaXZiXCI6IFwi4ou+XCIsXG5cdFwibm90bml2Y1wiOiBcIuKLvVwiLFxuXHRcIk5vdFByZWNlZGVzXCI6IFwi4oqAXCIsXG5cdFwiTm90UHJlY2VkZXNFcXVhbFwiOiBcIuKqr8y4XCIsXG5cdFwiTm90UHJlY2VkZXNTbGFudEVxdWFsXCI6IFwi4ougXCIsXG5cdFwiTm90UmV2ZXJzZUVsZW1lbnRcIjogXCLiiIxcIixcblx0XCJOb3RSaWdodFRyaWFuZ2xlQmFyXCI6IFwi4qeQzLhcIixcblx0XCJOb3RSaWdodFRyaWFuZ2xlXCI6IFwi4ourXCIsXG5cdFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsXCI6IFwi4outXCIsXG5cdFwiTm90U3F1YXJlU3Vic2V0XCI6IFwi4oqPzLhcIixcblx0XCJOb3RTcXVhcmVTdWJzZXRFcXVhbFwiOiBcIuKLolwiLFxuXHRcIk5vdFNxdWFyZVN1cGVyc2V0XCI6IFwi4oqQzLhcIixcblx0XCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsXCI6IFwi4oujXCIsXG5cdFwiTm90U3Vic2V0XCI6IFwi4oqC4oOSXCIsXG5cdFwiTm90U3Vic2V0RXF1YWxcIjogXCLiiohcIixcblx0XCJOb3RTdWNjZWVkc1wiOiBcIuKKgVwiLFxuXHRcIk5vdFN1Y2NlZWRzRXF1YWxcIjogXCLiqrDMuFwiLFxuXHRcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbFwiOiBcIuKLoVwiLFxuXHRcIk5vdFN1Y2NlZWRzVGlsZGVcIjogXCLiib/MuFwiLFxuXHRcIk5vdFN1cGVyc2V0XCI6IFwi4oqD4oOSXCIsXG5cdFwiTm90U3VwZXJzZXRFcXVhbFwiOiBcIuKKiVwiLFxuXHRcIk5vdFRpbGRlXCI6IFwi4omBXCIsXG5cdFwiTm90VGlsZGVFcXVhbFwiOiBcIuKJhFwiLFxuXHRcIk5vdFRpbGRlRnVsbEVxdWFsXCI6IFwi4omHXCIsXG5cdFwiTm90VGlsZGVUaWxkZVwiOiBcIuKJiVwiLFxuXHRcIk5vdFZlcnRpY2FsQmFyXCI6IFwi4oikXCIsXG5cdFwibnBhcmFsbGVsXCI6IFwi4oimXCIsXG5cdFwibnBhclwiOiBcIuKIplwiLFxuXHRcIm5wYXJzbFwiOiBcIuKrveKDpVwiLFxuXHRcIm5wYXJ0XCI6IFwi4oiCzLhcIixcblx0XCJucG9saW50XCI6IFwi4qiUXCIsXG5cdFwibnByXCI6IFwi4oqAXCIsXG5cdFwibnByY3VlXCI6IFwi4ougXCIsXG5cdFwibnByZWNcIjogXCLiioBcIixcblx0XCJucHJlY2VxXCI6IFwi4qqvzLhcIixcblx0XCJucHJlXCI6IFwi4qqvzLhcIixcblx0XCJucmFycmNcIjogXCLipLPMuFwiLFxuXHRcIm5yYXJyXCI6IFwi4oabXCIsXG5cdFwibnJBcnJcIjogXCLih49cIixcblx0XCJucmFycndcIjogXCLihp3MuFwiLFxuXHRcIm5yaWdodGFycm93XCI6IFwi4oabXCIsXG5cdFwiblJpZ2h0YXJyb3dcIjogXCLih49cIixcblx0XCJucnRyaVwiOiBcIuKLq1wiLFxuXHRcIm5ydHJpZVwiOiBcIuKLrVwiLFxuXHRcIm5zY1wiOiBcIuKKgVwiLFxuXHRcIm5zY2N1ZVwiOiBcIuKLoVwiLFxuXHRcIm5zY2VcIjogXCLiqrDMuFwiLFxuXHRcIk5zY3JcIjogXCLwnZKpXCIsXG5cdFwibnNjclwiOiBcIvCdk4NcIixcblx0XCJuc2hvcnRtaWRcIjogXCLiiKRcIixcblx0XCJuc2hvcnRwYXJhbGxlbFwiOiBcIuKIplwiLFxuXHRcIm5zaW1cIjogXCLiiYFcIixcblx0XCJuc2ltZVwiOiBcIuKJhFwiLFxuXHRcIm5zaW1lcVwiOiBcIuKJhFwiLFxuXHRcIm5zbWlkXCI6IFwi4oikXCIsXG5cdFwibnNwYXJcIjogXCLiiKZcIixcblx0XCJuc3FzdWJlXCI6IFwi4ouiXCIsXG5cdFwibnNxc3VwZVwiOiBcIuKLo1wiLFxuXHRcIm5zdWJcIjogXCLiioRcIixcblx0XCJuc3ViRVwiOiBcIuKrhcy4XCIsXG5cdFwibnN1YmVcIjogXCLiiohcIixcblx0XCJuc3Vic2V0XCI6IFwi4oqC4oOSXCIsXG5cdFwibnN1YnNldGVxXCI6IFwi4oqIXCIsXG5cdFwibnN1YnNldGVxcVwiOiBcIuKrhcy4XCIsXG5cdFwibnN1Y2NcIjogXCLiioFcIixcblx0XCJuc3VjY2VxXCI6IFwi4qqwzLhcIixcblx0XCJuc3VwXCI6IFwi4oqFXCIsXG5cdFwibnN1cEVcIjogXCLiq4bMuFwiLFxuXHRcIm5zdXBlXCI6IFwi4oqJXCIsXG5cdFwibnN1cHNldFwiOiBcIuKKg+KDklwiLFxuXHRcIm5zdXBzZXRlcVwiOiBcIuKKiVwiLFxuXHRcIm5zdXBzZXRlcXFcIjogXCLiq4bMuFwiLFxuXHRcIm50Z2xcIjogXCLiiblcIixcblx0XCJOdGlsZGVcIjogXCLDkVwiLFxuXHRcIm50aWxkZVwiOiBcIsOxXCIsXG5cdFwibnRsZ1wiOiBcIuKJuFwiLFxuXHRcIm50cmlhbmdsZWxlZnRcIjogXCLii6pcIixcblx0XCJudHJpYW5nbGVsZWZ0ZXFcIjogXCLii6xcIixcblx0XCJudHJpYW5nbGVyaWdodFwiOiBcIuKLq1wiLFxuXHRcIm50cmlhbmdsZXJpZ2h0ZXFcIjogXCLii61cIixcblx0XCJOdVwiOiBcIs6dXCIsXG5cdFwibnVcIjogXCLOvVwiLFxuXHRcIm51bVwiOiBcIiNcIixcblx0XCJudW1lcm9cIjogXCLihJZcIixcblx0XCJudW1zcFwiOiBcIuKAh1wiLFxuXHRcIm52YXBcIjogXCLiiY3ig5JcIixcblx0XCJudmRhc2hcIjogXCLiiqxcIixcblx0XCJudkRhc2hcIjogXCLiiq1cIixcblx0XCJuVmRhc2hcIjogXCLiiq5cIixcblx0XCJuVkRhc2hcIjogXCLiiq9cIixcblx0XCJudmdlXCI6IFwi4oml4oOSXCIsXG5cdFwibnZndFwiOiBcIj7ig5JcIixcblx0XCJudkhhcnJcIjogXCLipIRcIixcblx0XCJudmluZmluXCI6IFwi4qeeXCIsXG5cdFwibnZsQXJyXCI6IFwi4qSCXCIsXG5cdFwibnZsZVwiOiBcIuKJpOKDklwiLFxuXHRcIm52bHRcIjogXCI84oOSXCIsXG5cdFwibnZsdHJpZVwiOiBcIuKKtOKDklwiLFxuXHRcIm52ckFyclwiOiBcIuKkg1wiLFxuXHRcIm52cnRyaWVcIjogXCLiirXig5JcIixcblx0XCJudnNpbVwiOiBcIuKIvOKDklwiLFxuXHRcIm53YXJoa1wiOiBcIuKko1wiLFxuXHRcIm53YXJyXCI6IFwi4oaWXCIsXG5cdFwibndBcnJcIjogXCLih5ZcIixcblx0XCJud2Fycm93XCI6IFwi4oaWXCIsXG5cdFwibnduZWFyXCI6IFwi4qSnXCIsXG5cdFwiT2FjdXRlXCI6IFwiw5NcIixcblx0XCJvYWN1dGVcIjogXCLDs1wiLFxuXHRcIm9hc3RcIjogXCLiiptcIixcblx0XCJPY2lyY1wiOiBcIsOUXCIsXG5cdFwib2NpcmNcIjogXCLDtFwiLFxuXHRcIm9jaXJcIjogXCLiippcIixcblx0XCJPY3lcIjogXCLQnlwiLFxuXHRcIm9jeVwiOiBcItC+XCIsXG5cdFwib2Rhc2hcIjogXCLiip1cIixcblx0XCJPZGJsYWNcIjogXCLFkFwiLFxuXHRcIm9kYmxhY1wiOiBcIsWRXCIsXG5cdFwib2RpdlwiOiBcIuKouFwiLFxuXHRcIm9kb3RcIjogXCLiiplcIixcblx0XCJvZHNvbGRcIjogXCLiprxcIixcblx0XCJPRWxpZ1wiOiBcIsWSXCIsXG5cdFwib2VsaWdcIjogXCLFk1wiLFxuXHRcIm9mY2lyXCI6IFwi4qa/XCIsXG5cdFwiT2ZyXCI6IFwi8J2UklwiLFxuXHRcIm9mclwiOiBcIvCdlKxcIixcblx0XCJvZ29uXCI6IFwiy5tcIixcblx0XCJPZ3JhdmVcIjogXCLDklwiLFxuXHRcIm9ncmF2ZVwiOiBcIsOyXCIsXG5cdFwib2d0XCI6IFwi4qeBXCIsXG5cdFwib2hiYXJcIjogXCLiprVcIixcblx0XCJvaG1cIjogXCLOqVwiLFxuXHRcIm9pbnRcIjogXCLiiK5cIixcblx0XCJvbGFyclwiOiBcIuKGulwiLFxuXHRcIm9sY2lyXCI6IFwi4qa+XCIsXG5cdFwib2xjcm9zc1wiOiBcIuKmu1wiLFxuXHRcIm9saW5lXCI6IFwi4oC+XCIsXG5cdFwib2x0XCI6IFwi4qeAXCIsXG5cdFwiT21hY3JcIjogXCLFjFwiLFxuXHRcIm9tYWNyXCI6IFwixY1cIixcblx0XCJPbWVnYVwiOiBcIs6pXCIsXG5cdFwib21lZ2FcIjogXCLPiVwiLFxuXHRcIk9taWNyb25cIjogXCLOn1wiLFxuXHRcIm9taWNyb25cIjogXCLOv1wiLFxuXHRcIm9taWRcIjogXCLiprZcIixcblx0XCJvbWludXNcIjogXCLiipZcIixcblx0XCJPb3BmXCI6IFwi8J2VhlwiLFxuXHRcIm9vcGZcIjogXCLwnZWgXCIsXG5cdFwib3BhclwiOiBcIuKmt1wiLFxuXHRcIk9wZW5DdXJseURvdWJsZVF1b3RlXCI6IFwi4oCcXCIsXG5cdFwiT3BlbkN1cmx5UXVvdGVcIjogXCLigJhcIixcblx0XCJvcGVycFwiOiBcIuKmuVwiLFxuXHRcIm9wbHVzXCI6IFwi4oqVXCIsXG5cdFwib3JhcnJcIjogXCLihrtcIixcblx0XCJPclwiOiBcIuKplFwiLFxuXHRcIm9yXCI6IFwi4oioXCIsXG5cdFwib3JkXCI6IFwi4qmdXCIsXG5cdFwib3JkZXJcIjogXCLihLRcIixcblx0XCJvcmRlcm9mXCI6IFwi4oS0XCIsXG5cdFwib3JkZlwiOiBcIsKqXCIsXG5cdFwib3JkbVwiOiBcIsK6XCIsXG5cdFwib3JpZ29mXCI6IFwi4oq2XCIsXG5cdFwib3JvclwiOiBcIuKpllwiLFxuXHRcIm9yc2xvcGVcIjogXCLiqZdcIixcblx0XCJvcnZcIjogXCLiqZtcIixcblx0XCJvU1wiOiBcIuKTiFwiLFxuXHRcIk9zY3JcIjogXCLwnZKqXCIsXG5cdFwib3NjclwiOiBcIuKEtFwiLFxuXHRcIk9zbGFzaFwiOiBcIsOYXCIsXG5cdFwib3NsYXNoXCI6IFwiw7hcIixcblx0XCJvc29sXCI6IFwi4oqYXCIsXG5cdFwiT3RpbGRlXCI6IFwiw5VcIixcblx0XCJvdGlsZGVcIjogXCLDtVwiLFxuXHRcIm90aW1lc2FzXCI6IFwi4qi2XCIsXG5cdFwiT3RpbWVzXCI6IFwi4qi3XCIsXG5cdFwib3RpbWVzXCI6IFwi4oqXXCIsXG5cdFwiT3VtbFwiOiBcIsOWXCIsXG5cdFwib3VtbFwiOiBcIsO2XCIsXG5cdFwib3ZiYXJcIjogXCLijL1cIixcblx0XCJPdmVyQmFyXCI6IFwi4oC+XCIsXG5cdFwiT3ZlckJyYWNlXCI6IFwi4o+eXCIsXG5cdFwiT3ZlckJyYWNrZXRcIjogXCLijrRcIixcblx0XCJPdmVyUGFyZW50aGVzaXNcIjogXCLij5xcIixcblx0XCJwYXJhXCI6IFwiwrZcIixcblx0XCJwYXJhbGxlbFwiOiBcIuKIpVwiLFxuXHRcInBhclwiOiBcIuKIpVwiLFxuXHRcInBhcnNpbVwiOiBcIuKrs1wiLFxuXHRcInBhcnNsXCI6IFwi4qu9XCIsXG5cdFwicGFydFwiOiBcIuKIglwiLFxuXHRcIlBhcnRpYWxEXCI6IFwi4oiCXCIsXG5cdFwiUGN5XCI6IFwi0J9cIixcblx0XCJwY3lcIjogXCLQv1wiLFxuXHRcInBlcmNudFwiOiBcIiVcIixcblx0XCJwZXJpb2RcIjogXCIuXCIsXG5cdFwicGVybWlsXCI6IFwi4oCwXCIsXG5cdFwicGVycFwiOiBcIuKKpVwiLFxuXHRcInBlcnRlbmtcIjogXCLigLFcIixcblx0XCJQZnJcIjogXCLwnZSTXCIsXG5cdFwicGZyXCI6IFwi8J2UrVwiLFxuXHRcIlBoaVwiOiBcIs6mXCIsXG5cdFwicGhpXCI6IFwiz4ZcIixcblx0XCJwaGl2XCI6IFwiz5VcIixcblx0XCJwaG1tYXRcIjogXCLihLNcIixcblx0XCJwaG9uZVwiOiBcIuKYjlwiLFxuXHRcIlBpXCI6IFwizqBcIixcblx0XCJwaVwiOiBcIs+AXCIsXG5cdFwicGl0Y2hmb3JrXCI6IFwi4ouUXCIsXG5cdFwicGl2XCI6IFwiz5ZcIixcblx0XCJwbGFuY2tcIjogXCLihI9cIixcblx0XCJwbGFuY2toXCI6IFwi4oSOXCIsXG5cdFwicGxhbmt2XCI6IFwi4oSPXCIsXG5cdFwicGx1c2FjaXJcIjogXCLiqKNcIixcblx0XCJwbHVzYlwiOiBcIuKKnlwiLFxuXHRcInBsdXNjaXJcIjogXCLiqKJcIixcblx0XCJwbHVzXCI6IFwiK1wiLFxuXHRcInBsdXNkb1wiOiBcIuKIlFwiLFxuXHRcInBsdXNkdVwiOiBcIuKopVwiLFxuXHRcInBsdXNlXCI6IFwi4qmyXCIsXG5cdFwiUGx1c01pbnVzXCI6IFwiwrFcIixcblx0XCJwbHVzbW5cIjogXCLCsVwiLFxuXHRcInBsdXNzaW1cIjogXCLiqKZcIixcblx0XCJwbHVzdHdvXCI6IFwi4qinXCIsXG5cdFwicG1cIjogXCLCsVwiLFxuXHRcIlBvaW5jYXJlcGxhbmVcIjogXCLihIxcIixcblx0XCJwb2ludGludFwiOiBcIuKolVwiLFxuXHRcInBvcGZcIjogXCLwnZWhXCIsXG5cdFwiUG9wZlwiOiBcIuKEmVwiLFxuXHRcInBvdW5kXCI6IFwiwqNcIixcblx0XCJwcmFwXCI6IFwi4qq3XCIsXG5cdFwiUHJcIjogXCLiqrtcIixcblx0XCJwclwiOiBcIuKJulwiLFxuXHRcInByY3VlXCI6IFwi4om8XCIsXG5cdFwicHJlY2FwcHJveFwiOiBcIuKqt1wiLFxuXHRcInByZWNcIjogXCLiibpcIixcblx0XCJwcmVjY3VybHllcVwiOiBcIuKJvFwiLFxuXHRcIlByZWNlZGVzXCI6IFwi4om6XCIsXG5cdFwiUHJlY2VkZXNFcXVhbFwiOiBcIuKqr1wiLFxuXHRcIlByZWNlZGVzU2xhbnRFcXVhbFwiOiBcIuKJvFwiLFxuXHRcIlByZWNlZGVzVGlsZGVcIjogXCLiib5cIixcblx0XCJwcmVjZXFcIjogXCLiqq9cIixcblx0XCJwcmVjbmFwcHJveFwiOiBcIuKquVwiLFxuXHRcInByZWNuZXFxXCI6IFwi4qq1XCIsXG5cdFwicHJlY25zaW1cIjogXCLii6hcIixcblx0XCJwcmVcIjogXCLiqq9cIixcblx0XCJwckVcIjogXCLiqrNcIixcblx0XCJwcmVjc2ltXCI6IFwi4om+XCIsXG5cdFwicHJpbWVcIjogXCLigLJcIixcblx0XCJQcmltZVwiOiBcIuKAs1wiLFxuXHRcInByaW1lc1wiOiBcIuKEmVwiLFxuXHRcInBybmFwXCI6IFwi4qq5XCIsXG5cdFwicHJuRVwiOiBcIuKqtVwiLFxuXHRcInBybnNpbVwiOiBcIuKLqFwiLFxuXHRcInByb2RcIjogXCLiiI9cIixcblx0XCJQcm9kdWN0XCI6IFwi4oiPXCIsXG5cdFwicHJvZmFsYXJcIjogXCLijK5cIixcblx0XCJwcm9mbGluZVwiOiBcIuKMklwiLFxuXHRcInByb2ZzdXJmXCI6IFwi4oyTXCIsXG5cdFwicHJvcFwiOiBcIuKInVwiLFxuXHRcIlByb3BvcnRpb25hbFwiOiBcIuKInVwiLFxuXHRcIlByb3BvcnRpb25cIjogXCLiiLdcIixcblx0XCJwcm9wdG9cIjogXCLiiJ1cIixcblx0XCJwcnNpbVwiOiBcIuKJvlwiLFxuXHRcInBydXJlbFwiOiBcIuKKsFwiLFxuXHRcIlBzY3JcIjogXCLwnZKrXCIsXG5cdFwicHNjclwiOiBcIvCdk4VcIixcblx0XCJQc2lcIjogXCLOqFwiLFxuXHRcInBzaVwiOiBcIs+IXCIsXG5cdFwicHVuY3NwXCI6IFwi4oCIXCIsXG5cdFwiUWZyXCI6IFwi8J2UlFwiLFxuXHRcInFmclwiOiBcIvCdlK5cIixcblx0XCJxaW50XCI6IFwi4qiMXCIsXG5cdFwicW9wZlwiOiBcIvCdlaJcIixcblx0XCJRb3BmXCI6IFwi4oSaXCIsXG5cdFwicXByaW1lXCI6IFwi4oGXXCIsXG5cdFwiUXNjclwiOiBcIvCdkqxcIixcblx0XCJxc2NyXCI6IFwi8J2ThlwiLFxuXHRcInF1YXRlcm5pb25zXCI6IFwi4oSNXCIsXG5cdFwicXVhdGludFwiOiBcIuKollwiLFxuXHRcInF1ZXN0XCI6IFwiP1wiLFxuXHRcInF1ZXN0ZXFcIjogXCLiiZ9cIixcblx0XCJxdW90XCI6IFwiXFxcIlwiLFxuXHRcIlFVT1RcIjogXCJcXFwiXCIsXG5cdFwickFhcnJcIjogXCLih5tcIixcblx0XCJyYWNlXCI6IFwi4oi9zLFcIixcblx0XCJSYWN1dGVcIjogXCLFlFwiLFxuXHRcInJhY3V0ZVwiOiBcIsWVXCIsXG5cdFwicmFkaWNcIjogXCLiiJpcIixcblx0XCJyYWVtcHR5dlwiOiBcIuKms1wiLFxuXHRcInJhbmdcIjogXCLin6lcIixcblx0XCJSYW5nXCI6IFwi4p+rXCIsXG5cdFwicmFuZ2RcIjogXCLippJcIixcblx0XCJyYW5nZVwiOiBcIuKmpVwiLFxuXHRcInJhbmdsZVwiOiBcIuKfqVwiLFxuXHRcInJhcXVvXCI6IFwiwrtcIixcblx0XCJyYXJyYXBcIjogXCLipbVcIixcblx0XCJyYXJyYlwiOiBcIuKHpVwiLFxuXHRcInJhcnJiZnNcIjogXCLipKBcIixcblx0XCJyYXJyY1wiOiBcIuKks1wiLFxuXHRcInJhcnJcIjogXCLihpJcIixcblx0XCJSYXJyXCI6IFwi4oagXCIsXG5cdFwickFyclwiOiBcIuKHklwiLFxuXHRcInJhcnJmc1wiOiBcIuKknlwiLFxuXHRcInJhcnJoa1wiOiBcIuKGqlwiLFxuXHRcInJhcnJscFwiOiBcIuKGrFwiLFxuXHRcInJhcnJwbFwiOiBcIuKlhVwiLFxuXHRcInJhcnJzaW1cIjogXCLipbRcIixcblx0XCJSYXJydGxcIjogXCLipJZcIixcblx0XCJyYXJydGxcIjogXCLihqNcIixcblx0XCJyYXJyd1wiOiBcIuKGnVwiLFxuXHRcInJhdGFpbFwiOiBcIuKkmlwiLFxuXHRcInJBdGFpbFwiOiBcIuKknFwiLFxuXHRcInJhdGlvXCI6IFwi4oi2XCIsXG5cdFwicmF0aW9uYWxzXCI6IFwi4oSaXCIsXG5cdFwicmJhcnJcIjogXCLipI1cIixcblx0XCJyQmFyclwiOiBcIuKkj1wiLFxuXHRcIlJCYXJyXCI6IFwi4qSQXCIsXG5cdFwicmJicmtcIjogXCLinbNcIixcblx0XCJyYnJhY2VcIjogXCJ9XCIsXG5cdFwicmJyYWNrXCI6IFwiXVwiLFxuXHRcInJicmtlXCI6IFwi4qaMXCIsXG5cdFwicmJya3NsZFwiOiBcIuKmjlwiLFxuXHRcInJicmtzbHVcIjogXCLippBcIixcblx0XCJSY2Fyb25cIjogXCLFmFwiLFxuXHRcInJjYXJvblwiOiBcIsWZXCIsXG5cdFwiUmNlZGlsXCI6IFwixZZcIixcblx0XCJyY2VkaWxcIjogXCLFl1wiLFxuXHRcInJjZWlsXCI6IFwi4oyJXCIsXG5cdFwicmN1YlwiOiBcIn1cIixcblx0XCJSY3lcIjogXCLQoFwiLFxuXHRcInJjeVwiOiBcItGAXCIsXG5cdFwicmRjYVwiOiBcIuKkt1wiLFxuXHRcInJkbGRoYXJcIjogXCLipalcIixcblx0XCJyZHF1b1wiOiBcIuKAnVwiLFxuXHRcInJkcXVvclwiOiBcIuKAnVwiLFxuXHRcInJkc2hcIjogXCLihrNcIixcblx0XCJyZWFsXCI6IFwi4oScXCIsXG5cdFwicmVhbGluZVwiOiBcIuKEm1wiLFxuXHRcInJlYWxwYXJ0XCI6IFwi4oScXCIsXG5cdFwicmVhbHNcIjogXCLihJ1cIixcblx0XCJSZVwiOiBcIuKEnFwiLFxuXHRcInJlY3RcIjogXCLilq1cIixcblx0XCJyZWdcIjogXCLCrlwiLFxuXHRcIlJFR1wiOiBcIsKuXCIsXG5cdFwiUmV2ZXJzZUVsZW1lbnRcIjogXCLiiItcIixcblx0XCJSZXZlcnNlRXF1aWxpYnJpdW1cIjogXCLih4tcIixcblx0XCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOiBcIuKlr1wiLFxuXHRcInJmaXNodFwiOiBcIuKlvVwiLFxuXHRcInJmbG9vclwiOiBcIuKMi1wiLFxuXHRcInJmclwiOiBcIvCdlK9cIixcblx0XCJSZnJcIjogXCLihJxcIixcblx0XCJySGFyXCI6IFwi4qWkXCIsXG5cdFwicmhhcmRcIjogXCLih4FcIixcblx0XCJyaGFydVwiOiBcIuKHgFwiLFxuXHRcInJoYXJ1bFwiOiBcIuKlrFwiLFxuXHRcIlJob1wiOiBcIs6hXCIsXG5cdFwicmhvXCI6IFwiz4FcIixcblx0XCJyaG92XCI6IFwiz7FcIixcblx0XCJSaWdodEFuZ2xlQnJhY2tldFwiOiBcIuKfqVwiLFxuXHRcIlJpZ2h0QXJyb3dCYXJcIjogXCLih6VcIixcblx0XCJyaWdodGFycm93XCI6IFwi4oaSXCIsXG5cdFwiUmlnaHRBcnJvd1wiOiBcIuKGklwiLFxuXHRcIlJpZ2h0YXJyb3dcIjogXCLih5JcIixcblx0XCJSaWdodEFycm93TGVmdEFycm93XCI6IFwi4oeEXCIsXG5cdFwicmlnaHRhcnJvd3RhaWxcIjogXCLihqNcIixcblx0XCJSaWdodENlaWxpbmdcIjogXCLijIlcIixcblx0XCJSaWdodERvdWJsZUJyYWNrZXRcIjogXCLin6dcIixcblx0XCJSaWdodERvd25UZWVWZWN0b3JcIjogXCLipZ1cIixcblx0XCJSaWdodERvd25WZWN0b3JCYXJcIjogXCLipZVcIixcblx0XCJSaWdodERvd25WZWN0b3JcIjogXCLih4JcIixcblx0XCJSaWdodEZsb29yXCI6IFwi4oyLXCIsXG5cdFwicmlnaHRoYXJwb29uZG93blwiOiBcIuKHgVwiLFxuXHRcInJpZ2h0aGFycG9vbnVwXCI6IFwi4oeAXCIsXG5cdFwicmlnaHRsZWZ0YXJyb3dzXCI6IFwi4oeEXCIsXG5cdFwicmlnaHRsZWZ0aGFycG9vbnNcIjogXCLih4xcIixcblx0XCJyaWdodHJpZ2h0YXJyb3dzXCI6IFwi4oeJXCIsXG5cdFwicmlnaHRzcXVpZ2Fycm93XCI6IFwi4oadXCIsXG5cdFwiUmlnaHRUZWVBcnJvd1wiOiBcIuKGplwiLFxuXHRcIlJpZ2h0VGVlXCI6IFwi4oqiXCIsXG5cdFwiUmlnaHRUZWVWZWN0b3JcIjogXCLipZtcIixcblx0XCJyaWdodHRocmVldGltZXNcIjogXCLii4xcIixcblx0XCJSaWdodFRyaWFuZ2xlQmFyXCI6IFwi4qeQXCIsXG5cdFwiUmlnaHRUcmlhbmdsZVwiOiBcIuKKs1wiLFxuXHRcIlJpZ2h0VHJpYW5nbGVFcXVhbFwiOiBcIuKKtVwiLFxuXHRcIlJpZ2h0VXBEb3duVmVjdG9yXCI6IFwi4qWPXCIsXG5cdFwiUmlnaHRVcFRlZVZlY3RvclwiOiBcIuKlnFwiLFxuXHRcIlJpZ2h0VXBWZWN0b3JCYXJcIjogXCLipZRcIixcblx0XCJSaWdodFVwVmVjdG9yXCI6IFwi4oa+XCIsXG5cdFwiUmlnaHRWZWN0b3JCYXJcIjogXCLipZNcIixcblx0XCJSaWdodFZlY3RvclwiOiBcIuKHgFwiLFxuXHRcInJpbmdcIjogXCLLmlwiLFxuXHRcInJpc2luZ2RvdHNlcVwiOiBcIuKJk1wiLFxuXHRcInJsYXJyXCI6IFwi4oeEXCIsXG5cdFwicmxoYXJcIjogXCLih4xcIixcblx0XCJybG1cIjogXCLigI9cIixcblx0XCJybW91c3RhY2hlXCI6IFwi4o6xXCIsXG5cdFwicm1vdXN0XCI6IFwi4o6xXCIsXG5cdFwicm5taWRcIjogXCLiq65cIixcblx0XCJyb2FuZ1wiOiBcIuKfrVwiLFxuXHRcInJvYXJyXCI6IFwi4oe+XCIsXG5cdFwicm9icmtcIjogXCLin6dcIixcblx0XCJyb3BhclwiOiBcIuKmhlwiLFxuXHRcInJvcGZcIjogXCLwnZWjXCIsXG5cdFwiUm9wZlwiOiBcIuKEnVwiLFxuXHRcInJvcGx1c1wiOiBcIuKorlwiLFxuXHRcInJvdGltZXNcIjogXCLiqLVcIixcblx0XCJSb3VuZEltcGxpZXNcIjogXCLipbBcIixcblx0XCJycGFyXCI6IFwiKVwiLFxuXHRcInJwYXJndFwiOiBcIuKmlFwiLFxuXHRcInJwcG9saW50XCI6IFwi4qiSXCIsXG5cdFwicnJhcnJcIjogXCLih4lcIixcblx0XCJScmlnaHRhcnJvd1wiOiBcIuKHm1wiLFxuXHRcInJzYXF1b1wiOiBcIuKAulwiLFxuXHRcInJzY3JcIjogXCLwnZOHXCIsXG5cdFwiUnNjclwiOiBcIuKEm1wiLFxuXHRcInJzaFwiOiBcIuKGsVwiLFxuXHRcIlJzaFwiOiBcIuKGsVwiLFxuXHRcInJzcWJcIjogXCJdXCIsXG5cdFwicnNxdW9cIjogXCLigJlcIixcblx0XCJyc3F1b3JcIjogXCLigJlcIixcblx0XCJydGhyZWVcIjogXCLii4xcIixcblx0XCJydGltZXNcIjogXCLii4pcIixcblx0XCJydHJpXCI6IFwi4pa5XCIsXG5cdFwicnRyaWVcIjogXCLiirVcIixcblx0XCJydHJpZlwiOiBcIuKWuFwiLFxuXHRcInJ0cmlsdHJpXCI6IFwi4qeOXCIsXG5cdFwiUnVsZURlbGF5ZWRcIjogXCLip7RcIixcblx0XCJydWx1aGFyXCI6IFwi4qWoXCIsXG5cdFwicnhcIjogXCLihJ5cIixcblx0XCJTYWN1dGVcIjogXCLFmlwiLFxuXHRcInNhY3V0ZVwiOiBcIsWbXCIsXG5cdFwic2JxdW9cIjogXCLigJpcIixcblx0XCJzY2FwXCI6IFwi4qq4XCIsXG5cdFwiU2Nhcm9uXCI6IFwixaBcIixcblx0XCJzY2Fyb25cIjogXCLFoVwiLFxuXHRcIlNjXCI6IFwi4qq8XCIsXG5cdFwic2NcIjogXCLiibtcIixcblx0XCJzY2N1ZVwiOiBcIuKJvVwiLFxuXHRcInNjZVwiOiBcIuKqsFwiLFxuXHRcInNjRVwiOiBcIuKqtFwiLFxuXHRcIlNjZWRpbFwiOiBcIsWeXCIsXG5cdFwic2NlZGlsXCI6IFwixZ9cIixcblx0XCJTY2lyY1wiOiBcIsWcXCIsXG5cdFwic2NpcmNcIjogXCLFnVwiLFxuXHRcInNjbmFwXCI6IFwi4qq6XCIsXG5cdFwic2NuRVwiOiBcIuKqtlwiLFxuXHRcInNjbnNpbVwiOiBcIuKLqVwiLFxuXHRcInNjcG9saW50XCI6IFwi4qiTXCIsXG5cdFwic2NzaW1cIjogXCLiib9cIixcblx0XCJTY3lcIjogXCLQoVwiLFxuXHRcInNjeVwiOiBcItGBXCIsXG5cdFwic2RvdGJcIjogXCLiiqFcIixcblx0XCJzZG90XCI6IFwi4ouFXCIsXG5cdFwic2RvdGVcIjogXCLiqaZcIixcblx0XCJzZWFyaGtcIjogXCLipKVcIixcblx0XCJzZWFyclwiOiBcIuKGmFwiLFxuXHRcInNlQXJyXCI6IFwi4oeYXCIsXG5cdFwic2VhcnJvd1wiOiBcIuKGmFwiLFxuXHRcInNlY3RcIjogXCLCp1wiLFxuXHRcInNlbWlcIjogXCI7XCIsXG5cdFwic2Vzd2FyXCI6IFwi4qSpXCIsXG5cdFwic2V0bWludXNcIjogXCLiiJZcIixcblx0XCJzZXRtblwiOiBcIuKIllwiLFxuXHRcInNleHRcIjogXCLinLZcIixcblx0XCJTZnJcIjogXCLwnZSWXCIsXG5cdFwic2ZyXCI6IFwi8J2UsFwiLFxuXHRcInNmcm93blwiOiBcIuKMolwiLFxuXHRcInNoYXJwXCI6IFwi4pmvXCIsXG5cdFwiU0hDSGN5XCI6IFwi0KlcIixcblx0XCJzaGNoY3lcIjogXCLRiVwiLFxuXHRcIlNIY3lcIjogXCLQqFwiLFxuXHRcInNoY3lcIjogXCLRiFwiLFxuXHRcIlNob3J0RG93bkFycm93XCI6IFwi4oaTXCIsXG5cdFwiU2hvcnRMZWZ0QXJyb3dcIjogXCLihpBcIixcblx0XCJzaG9ydG1pZFwiOiBcIuKIo1wiLFxuXHRcInNob3J0cGFyYWxsZWxcIjogXCLiiKVcIixcblx0XCJTaG9ydFJpZ2h0QXJyb3dcIjogXCLihpJcIixcblx0XCJTaG9ydFVwQXJyb3dcIjogXCLihpFcIixcblx0XCJzaHlcIjogXCLCrVwiLFxuXHRcIlNpZ21hXCI6IFwizqNcIixcblx0XCJzaWdtYVwiOiBcIs+DXCIsXG5cdFwic2lnbWFmXCI6IFwiz4JcIixcblx0XCJzaWdtYXZcIjogXCLPglwiLFxuXHRcInNpbVwiOiBcIuKIvFwiLFxuXHRcInNpbWRvdFwiOiBcIuKpqlwiLFxuXHRcInNpbWVcIjogXCLiiYNcIixcblx0XCJzaW1lcVwiOiBcIuKJg1wiLFxuXHRcInNpbWdcIjogXCLiqp5cIixcblx0XCJzaW1nRVwiOiBcIuKqoFwiLFxuXHRcInNpbWxcIjogXCLiqp1cIixcblx0XCJzaW1sRVwiOiBcIuKqn1wiLFxuXHRcInNpbW5lXCI6IFwi4omGXCIsXG5cdFwic2ltcGx1c1wiOiBcIuKopFwiLFxuXHRcInNpbXJhcnJcIjogXCLipbJcIixcblx0XCJzbGFyclwiOiBcIuKGkFwiLFxuXHRcIlNtYWxsQ2lyY2xlXCI6IFwi4oiYXCIsXG5cdFwic21hbGxzZXRtaW51c1wiOiBcIuKIllwiLFxuXHRcInNtYXNocFwiOiBcIuKos1wiLFxuXHRcInNtZXBhcnNsXCI6IFwi4qekXCIsXG5cdFwic21pZFwiOiBcIuKIo1wiLFxuXHRcInNtaWxlXCI6IFwi4oyjXCIsXG5cdFwic210XCI6IFwi4qqqXCIsXG5cdFwic210ZVwiOiBcIuKqrFwiLFxuXHRcInNtdGVzXCI6IFwi4qqs77iAXCIsXG5cdFwiU09GVGN5XCI6IFwi0KxcIixcblx0XCJzb2Z0Y3lcIjogXCLRjFwiLFxuXHRcInNvbGJhclwiOiBcIuKMv1wiLFxuXHRcInNvbGJcIjogXCLip4RcIixcblx0XCJzb2xcIjogXCIvXCIsXG5cdFwiU29wZlwiOiBcIvCdlYpcIixcblx0XCJzb3BmXCI6IFwi8J2VpFwiLFxuXHRcInNwYWRlc1wiOiBcIuKZoFwiLFxuXHRcInNwYWRlc3VpdFwiOiBcIuKZoFwiLFxuXHRcInNwYXJcIjogXCLiiKVcIixcblx0XCJzcWNhcFwiOiBcIuKKk1wiLFxuXHRcInNxY2Fwc1wiOiBcIuKKk++4gFwiLFxuXHRcInNxY3VwXCI6IFwi4oqUXCIsXG5cdFwic3FjdXBzXCI6IFwi4oqU77iAXCIsXG5cdFwiU3FydFwiOiBcIuKImlwiLFxuXHRcInNxc3ViXCI6IFwi4oqPXCIsXG5cdFwic3FzdWJlXCI6IFwi4oqRXCIsXG5cdFwic3FzdWJzZXRcIjogXCLiio9cIixcblx0XCJzcXN1YnNldGVxXCI6IFwi4oqRXCIsXG5cdFwic3FzdXBcIjogXCLiipBcIixcblx0XCJzcXN1cGVcIjogXCLiipJcIixcblx0XCJzcXN1cHNldFwiOiBcIuKKkFwiLFxuXHRcInNxc3Vwc2V0ZXFcIjogXCLiipJcIixcblx0XCJzcXVhcmVcIjogXCLilqFcIixcblx0XCJTcXVhcmVcIjogXCLilqFcIixcblx0XCJTcXVhcmVJbnRlcnNlY3Rpb25cIjogXCLiipNcIixcblx0XCJTcXVhcmVTdWJzZXRcIjogXCLiio9cIixcblx0XCJTcXVhcmVTdWJzZXRFcXVhbFwiOiBcIuKKkVwiLFxuXHRcIlNxdWFyZVN1cGVyc2V0XCI6IFwi4oqQXCIsXG5cdFwiU3F1YXJlU3VwZXJzZXRFcXVhbFwiOiBcIuKKklwiLFxuXHRcIlNxdWFyZVVuaW9uXCI6IFwi4oqUXCIsXG5cdFwic3F1YXJmXCI6IFwi4paqXCIsXG5cdFwic3F1XCI6IFwi4pahXCIsXG5cdFwic3F1ZlwiOiBcIuKWqlwiLFxuXHRcInNyYXJyXCI6IFwi4oaSXCIsXG5cdFwiU3NjclwiOiBcIvCdkq5cIixcblx0XCJzc2NyXCI6IFwi8J2TiFwiLFxuXHRcInNzZXRtblwiOiBcIuKIllwiLFxuXHRcInNzbWlsZVwiOiBcIuKMo1wiLFxuXHRcInNzdGFyZlwiOiBcIuKLhlwiLFxuXHRcIlN0YXJcIjogXCLii4ZcIixcblx0XCJzdGFyXCI6IFwi4piGXCIsXG5cdFwic3RhcmZcIjogXCLimIVcIixcblx0XCJzdHJhaWdodGVwc2lsb25cIjogXCLPtVwiLFxuXHRcInN0cmFpZ2h0cGhpXCI6IFwiz5VcIixcblx0XCJzdHJuc1wiOiBcIsKvXCIsXG5cdFwic3ViXCI6IFwi4oqCXCIsXG5cdFwiU3ViXCI6IFwi4ouQXCIsXG5cdFwic3ViZG90XCI6IFwi4qq9XCIsXG5cdFwic3ViRVwiOiBcIuKrhVwiLFxuXHRcInN1YmVcIjogXCLiioZcIixcblx0XCJzdWJlZG90XCI6IFwi4quDXCIsXG5cdFwic3VibXVsdFwiOiBcIuKrgVwiLFxuXHRcInN1Ym5FXCI6IFwi4quLXCIsXG5cdFwic3VibmVcIjogXCLiiopcIixcblx0XCJzdWJwbHVzXCI6IFwi4qq/XCIsXG5cdFwic3VicmFyclwiOiBcIuKluVwiLFxuXHRcInN1YnNldFwiOiBcIuKKglwiLFxuXHRcIlN1YnNldFwiOiBcIuKLkFwiLFxuXHRcInN1YnNldGVxXCI6IFwi4oqGXCIsXG5cdFwic3Vic2V0ZXFxXCI6IFwi4quFXCIsXG5cdFwiU3Vic2V0RXF1YWxcIjogXCLiioZcIixcblx0XCJzdWJzZXRuZXFcIjogXCLiiopcIixcblx0XCJzdWJzZXRuZXFxXCI6IFwi4quLXCIsXG5cdFwic3Vic2ltXCI6IFwi4quHXCIsXG5cdFwic3Vic3ViXCI6IFwi4quVXCIsXG5cdFwic3Vic3VwXCI6IFwi4quTXCIsXG5cdFwic3VjY2FwcHJveFwiOiBcIuKquFwiLFxuXHRcInN1Y2NcIjogXCLiibtcIixcblx0XCJzdWNjY3VybHllcVwiOiBcIuKJvVwiLFxuXHRcIlN1Y2NlZWRzXCI6IFwi4om7XCIsXG5cdFwiU3VjY2VlZHNFcXVhbFwiOiBcIuKqsFwiLFxuXHRcIlN1Y2NlZWRzU2xhbnRFcXVhbFwiOiBcIuKJvVwiLFxuXHRcIlN1Y2NlZWRzVGlsZGVcIjogXCLiib9cIixcblx0XCJzdWNjZXFcIjogXCLiqrBcIixcblx0XCJzdWNjbmFwcHJveFwiOiBcIuKqulwiLFxuXHRcInN1Y2NuZXFxXCI6IFwi4qq2XCIsXG5cdFwic3VjY25zaW1cIjogXCLii6lcIixcblx0XCJzdWNjc2ltXCI6IFwi4om/XCIsXG5cdFwiU3VjaFRoYXRcIjogXCLiiItcIixcblx0XCJzdW1cIjogXCLiiJFcIixcblx0XCJTdW1cIjogXCLiiJFcIixcblx0XCJzdW5nXCI6IFwi4pmqXCIsXG5cdFwic3VwMVwiOiBcIsK5XCIsXG5cdFwic3VwMlwiOiBcIsKyXCIsXG5cdFwic3VwM1wiOiBcIsKzXCIsXG5cdFwic3VwXCI6IFwi4oqDXCIsXG5cdFwiU3VwXCI6IFwi4ouRXCIsXG5cdFwic3VwZG90XCI6IFwi4qq+XCIsXG5cdFwic3VwZHN1YlwiOiBcIuKrmFwiLFxuXHRcInN1cEVcIjogXCLiq4ZcIixcblx0XCJzdXBlXCI6IFwi4oqHXCIsXG5cdFwic3VwZWRvdFwiOiBcIuKrhFwiLFxuXHRcIlN1cGVyc2V0XCI6IFwi4oqDXCIsXG5cdFwiU3VwZXJzZXRFcXVhbFwiOiBcIuKKh1wiLFxuXHRcInN1cGhzb2xcIjogXCLin4lcIixcblx0XCJzdXBoc3ViXCI6IFwi4quXXCIsXG5cdFwic3VwbGFyclwiOiBcIuKlu1wiLFxuXHRcInN1cG11bHRcIjogXCLiq4JcIixcblx0XCJzdXBuRVwiOiBcIuKrjFwiLFxuXHRcInN1cG5lXCI6IFwi4oqLXCIsXG5cdFwic3VwcGx1c1wiOiBcIuKrgFwiLFxuXHRcInN1cHNldFwiOiBcIuKKg1wiLFxuXHRcIlN1cHNldFwiOiBcIuKLkVwiLFxuXHRcInN1cHNldGVxXCI6IFwi4oqHXCIsXG5cdFwic3Vwc2V0ZXFxXCI6IFwi4quGXCIsXG5cdFwic3Vwc2V0bmVxXCI6IFwi4oqLXCIsXG5cdFwic3Vwc2V0bmVxcVwiOiBcIuKrjFwiLFxuXHRcInN1cHNpbVwiOiBcIuKriFwiLFxuXHRcInN1cHN1YlwiOiBcIuKrlFwiLFxuXHRcInN1cHN1cFwiOiBcIuKrllwiLFxuXHRcInN3YXJoa1wiOiBcIuKkplwiLFxuXHRcInN3YXJyXCI6IFwi4oaZXCIsXG5cdFwic3dBcnJcIjogXCLih5lcIixcblx0XCJzd2Fycm93XCI6IFwi4oaZXCIsXG5cdFwic3dud2FyXCI6IFwi4qSqXCIsXG5cdFwic3psaWdcIjogXCLDn1wiLFxuXHRcIlRhYlwiOiBcIlxcdFwiLFxuXHRcInRhcmdldFwiOiBcIuKMllwiLFxuXHRcIlRhdVwiOiBcIs6kXCIsXG5cdFwidGF1XCI6IFwiz4RcIixcblx0XCJ0YnJrXCI6IFwi4o60XCIsXG5cdFwiVGNhcm9uXCI6IFwixaRcIixcblx0XCJ0Y2Fyb25cIjogXCLFpVwiLFxuXHRcIlRjZWRpbFwiOiBcIsWiXCIsXG5cdFwidGNlZGlsXCI6IFwixaNcIixcblx0XCJUY3lcIjogXCLQolwiLFxuXHRcInRjeVwiOiBcItGCXCIsXG5cdFwidGRvdFwiOiBcIuKDm1wiLFxuXHRcInRlbHJlY1wiOiBcIuKMlVwiLFxuXHRcIlRmclwiOiBcIvCdlJdcIixcblx0XCJ0ZnJcIjogXCLwnZSxXCIsXG5cdFwidGhlcmU0XCI6IFwi4oi0XCIsXG5cdFwidGhlcmVmb3JlXCI6IFwi4oi0XCIsXG5cdFwiVGhlcmVmb3JlXCI6IFwi4oi0XCIsXG5cdFwiVGhldGFcIjogXCLOmFwiLFxuXHRcInRoZXRhXCI6IFwizrhcIixcblx0XCJ0aGV0YXN5bVwiOiBcIs+RXCIsXG5cdFwidGhldGF2XCI6IFwiz5FcIixcblx0XCJ0aGlja2FwcHJveFwiOiBcIuKJiFwiLFxuXHRcInRoaWNrc2ltXCI6IFwi4oi8XCIsXG5cdFwiVGhpY2tTcGFjZVwiOiBcIuKBn+KAilwiLFxuXHRcIlRoaW5TcGFjZVwiOiBcIuKAiVwiLFxuXHRcInRoaW5zcFwiOiBcIuKAiVwiLFxuXHRcInRoa2FwXCI6IFwi4omIXCIsXG5cdFwidGhrc2ltXCI6IFwi4oi8XCIsXG5cdFwiVEhPUk5cIjogXCLDnlwiLFxuXHRcInRob3JuXCI6IFwiw75cIixcblx0XCJ0aWxkZVwiOiBcIsucXCIsXG5cdFwiVGlsZGVcIjogXCLiiLxcIixcblx0XCJUaWxkZUVxdWFsXCI6IFwi4omDXCIsXG5cdFwiVGlsZGVGdWxsRXF1YWxcIjogXCLiiYVcIixcblx0XCJUaWxkZVRpbGRlXCI6IFwi4omIXCIsXG5cdFwidGltZXNiYXJcIjogXCLiqLFcIixcblx0XCJ0aW1lc2JcIjogXCLiiqBcIixcblx0XCJ0aW1lc1wiOiBcIsOXXCIsXG5cdFwidGltZXNkXCI6IFwi4qiwXCIsXG5cdFwidGludFwiOiBcIuKIrVwiLFxuXHRcInRvZWFcIjogXCLipKhcIixcblx0XCJ0b3Bib3RcIjogXCLijLZcIixcblx0XCJ0b3BjaXJcIjogXCLiq7FcIixcblx0XCJ0b3BcIjogXCLiiqRcIixcblx0XCJUb3BmXCI6IFwi8J2Vi1wiLFxuXHRcInRvcGZcIjogXCLwnZWlXCIsXG5cdFwidG9wZm9ya1wiOiBcIuKrmlwiLFxuXHRcInRvc2FcIjogXCLipKlcIixcblx0XCJ0cHJpbWVcIjogXCLigLRcIixcblx0XCJ0cmFkZVwiOiBcIuKEolwiLFxuXHRcIlRSQURFXCI6IFwi4oSiXCIsXG5cdFwidHJpYW5nbGVcIjogXCLilrVcIixcblx0XCJ0cmlhbmdsZWRvd25cIjogXCLilr9cIixcblx0XCJ0cmlhbmdsZWxlZnRcIjogXCLil4NcIixcblx0XCJ0cmlhbmdsZWxlZnRlcVwiOiBcIuKKtFwiLFxuXHRcInRyaWFuZ2xlcVwiOiBcIuKJnFwiLFxuXHRcInRyaWFuZ2xlcmlnaHRcIjogXCLilrlcIixcblx0XCJ0cmlhbmdsZXJpZ2h0ZXFcIjogXCLiirVcIixcblx0XCJ0cmlkb3RcIjogXCLil6xcIixcblx0XCJ0cmllXCI6IFwi4omcXCIsXG5cdFwidHJpbWludXNcIjogXCLiqLpcIixcblx0XCJUcmlwbGVEb3RcIjogXCLig5tcIixcblx0XCJ0cmlwbHVzXCI6IFwi4qi5XCIsXG5cdFwidHJpc2JcIjogXCLip41cIixcblx0XCJ0cml0aW1lXCI6IFwi4qi7XCIsXG5cdFwidHJwZXppdW1cIjogXCLij6JcIixcblx0XCJUc2NyXCI6IFwi8J2Sr1wiLFxuXHRcInRzY3JcIjogXCLwnZOJXCIsXG5cdFwiVFNjeVwiOiBcItCmXCIsXG5cdFwidHNjeVwiOiBcItGGXCIsXG5cdFwiVFNIY3lcIjogXCLQi1wiLFxuXHRcInRzaGN5XCI6IFwi0ZtcIixcblx0XCJUc3Ryb2tcIjogXCLFplwiLFxuXHRcInRzdHJva1wiOiBcIsWnXCIsXG5cdFwidHdpeHRcIjogXCLiiaxcIixcblx0XCJ0d29oZWFkbGVmdGFycm93XCI6IFwi4oaeXCIsXG5cdFwidHdvaGVhZHJpZ2h0YXJyb3dcIjogXCLihqBcIixcblx0XCJVYWN1dGVcIjogXCLDmlwiLFxuXHRcInVhY3V0ZVwiOiBcIsO6XCIsXG5cdFwidWFyclwiOiBcIuKGkVwiLFxuXHRcIlVhcnJcIjogXCLihp9cIixcblx0XCJ1QXJyXCI6IFwi4oeRXCIsXG5cdFwiVWFycm9jaXJcIjogXCLipYlcIixcblx0XCJVYnJjeVwiOiBcItCOXCIsXG5cdFwidWJyY3lcIjogXCLRnlwiLFxuXHRcIlVicmV2ZVwiOiBcIsWsXCIsXG5cdFwidWJyZXZlXCI6IFwixa1cIixcblx0XCJVY2lyY1wiOiBcIsObXCIsXG5cdFwidWNpcmNcIjogXCLDu1wiLFxuXHRcIlVjeVwiOiBcItCjXCIsXG5cdFwidWN5XCI6IFwi0YNcIixcblx0XCJ1ZGFyclwiOiBcIuKHhVwiLFxuXHRcIlVkYmxhY1wiOiBcIsWwXCIsXG5cdFwidWRibGFjXCI6IFwixbFcIixcblx0XCJ1ZGhhclwiOiBcIuKlrlwiLFxuXHRcInVmaXNodFwiOiBcIuKlvlwiLFxuXHRcIlVmclwiOiBcIvCdlJhcIixcblx0XCJ1ZnJcIjogXCLwnZSyXCIsXG5cdFwiVWdyYXZlXCI6IFwiw5lcIixcblx0XCJ1Z3JhdmVcIjogXCLDuVwiLFxuXHRcInVIYXJcIjogXCLipaNcIixcblx0XCJ1aGFybFwiOiBcIuKGv1wiLFxuXHRcInVoYXJyXCI6IFwi4oa+XCIsXG5cdFwidWhibGtcIjogXCLiloBcIixcblx0XCJ1bGNvcm5cIjogXCLijJxcIixcblx0XCJ1bGNvcm5lclwiOiBcIuKMnFwiLFxuXHRcInVsY3JvcFwiOiBcIuKMj1wiLFxuXHRcInVsdHJpXCI6IFwi4pe4XCIsXG5cdFwiVW1hY3JcIjogXCLFqlwiLFxuXHRcInVtYWNyXCI6IFwixatcIixcblx0XCJ1bWxcIjogXCLCqFwiLFxuXHRcIlVuZGVyQmFyXCI6IFwiX1wiLFxuXHRcIlVuZGVyQnJhY2VcIjogXCLij59cIixcblx0XCJVbmRlckJyYWNrZXRcIjogXCLijrVcIixcblx0XCJVbmRlclBhcmVudGhlc2lzXCI6IFwi4o+dXCIsXG5cdFwiVW5pb25cIjogXCLii4NcIixcblx0XCJVbmlvblBsdXNcIjogXCLiio5cIixcblx0XCJVb2dvblwiOiBcIsWyXCIsXG5cdFwidW9nb25cIjogXCLFs1wiLFxuXHRcIlVvcGZcIjogXCLwnZWMXCIsXG5cdFwidW9wZlwiOiBcIvCdlaZcIixcblx0XCJVcEFycm93QmFyXCI6IFwi4qSSXCIsXG5cdFwidXBhcnJvd1wiOiBcIuKGkVwiLFxuXHRcIlVwQXJyb3dcIjogXCLihpFcIixcblx0XCJVcGFycm93XCI6IFwi4oeRXCIsXG5cdFwiVXBBcnJvd0Rvd25BcnJvd1wiOiBcIuKHhVwiLFxuXHRcInVwZG93bmFycm93XCI6IFwi4oaVXCIsXG5cdFwiVXBEb3duQXJyb3dcIjogXCLihpVcIixcblx0XCJVcGRvd25hcnJvd1wiOiBcIuKHlVwiLFxuXHRcIlVwRXF1aWxpYnJpdW1cIjogXCLipa5cIixcblx0XCJ1cGhhcnBvb25sZWZ0XCI6IFwi4oa/XCIsXG5cdFwidXBoYXJwb29ucmlnaHRcIjogXCLihr5cIixcblx0XCJ1cGx1c1wiOiBcIuKKjlwiLFxuXHRcIlVwcGVyTGVmdEFycm93XCI6IFwi4oaWXCIsXG5cdFwiVXBwZXJSaWdodEFycm93XCI6IFwi4oaXXCIsXG5cdFwidXBzaVwiOiBcIs+FXCIsXG5cdFwiVXBzaVwiOiBcIs+SXCIsXG5cdFwidXBzaWhcIjogXCLPklwiLFxuXHRcIlVwc2lsb25cIjogXCLOpVwiLFxuXHRcInVwc2lsb25cIjogXCLPhVwiLFxuXHRcIlVwVGVlQXJyb3dcIjogXCLihqVcIixcblx0XCJVcFRlZVwiOiBcIuKKpVwiLFxuXHRcInVwdXBhcnJvd3NcIjogXCLih4hcIixcblx0XCJ1cmNvcm5cIjogXCLijJ1cIixcblx0XCJ1cmNvcm5lclwiOiBcIuKMnVwiLFxuXHRcInVyY3JvcFwiOiBcIuKMjlwiLFxuXHRcIlVyaW5nXCI6IFwixa5cIixcblx0XCJ1cmluZ1wiOiBcIsWvXCIsXG5cdFwidXJ0cmlcIjogXCLil7lcIixcblx0XCJVc2NyXCI6IFwi8J2SsFwiLFxuXHRcInVzY3JcIjogXCLwnZOKXCIsXG5cdFwidXRkb3RcIjogXCLii7BcIixcblx0XCJVdGlsZGVcIjogXCLFqFwiLFxuXHRcInV0aWxkZVwiOiBcIsWpXCIsXG5cdFwidXRyaVwiOiBcIuKWtVwiLFxuXHRcInV0cmlmXCI6IFwi4pa0XCIsXG5cdFwidXVhcnJcIjogXCLih4hcIixcblx0XCJVdW1sXCI6IFwiw5xcIixcblx0XCJ1dW1sXCI6IFwiw7xcIixcblx0XCJ1d2FuZ2xlXCI6IFwi4qanXCIsXG5cdFwidmFuZ3J0XCI6IFwi4qacXCIsXG5cdFwidmFyZXBzaWxvblwiOiBcIs+1XCIsXG5cdFwidmFya2FwcGFcIjogXCLPsFwiLFxuXHRcInZhcm5vdGhpbmdcIjogXCLiiIVcIixcblx0XCJ2YXJwaGlcIjogXCLPlVwiLFxuXHRcInZhcnBpXCI6IFwiz5ZcIixcblx0XCJ2YXJwcm9wdG9cIjogXCLiiJ1cIixcblx0XCJ2YXJyXCI6IFwi4oaVXCIsXG5cdFwidkFyclwiOiBcIuKHlVwiLFxuXHRcInZhcnJob1wiOiBcIs+xXCIsXG5cdFwidmFyc2lnbWFcIjogXCLPglwiLFxuXHRcInZhcnN1YnNldG5lcVwiOiBcIuKKiu+4gFwiLFxuXHRcInZhcnN1YnNldG5lcXFcIjogXCLiq4vvuIBcIixcblx0XCJ2YXJzdXBzZXRuZXFcIjogXCLiiovvuIBcIixcblx0XCJ2YXJzdXBzZXRuZXFxXCI6IFwi4quM77iAXCIsXG5cdFwidmFydGhldGFcIjogXCLPkVwiLFxuXHRcInZhcnRyaWFuZ2xlbGVmdFwiOiBcIuKKslwiLFxuXHRcInZhcnRyaWFuZ2xlcmlnaHRcIjogXCLiirNcIixcblx0XCJ2QmFyXCI6IFwi4quoXCIsXG5cdFwiVmJhclwiOiBcIuKrq1wiLFxuXHRcInZCYXJ2XCI6IFwi4qupXCIsXG5cdFwiVmN5XCI6IFwi0JJcIixcblx0XCJ2Y3lcIjogXCLQslwiLFxuXHRcInZkYXNoXCI6IFwi4oqiXCIsXG5cdFwidkRhc2hcIjogXCLiiqhcIixcblx0XCJWZGFzaFwiOiBcIuKKqVwiLFxuXHRcIlZEYXNoXCI6IFwi4oqrXCIsXG5cdFwiVmRhc2hsXCI6IFwi4qumXCIsXG5cdFwidmVlYmFyXCI6IFwi4oq7XCIsXG5cdFwidmVlXCI6IFwi4oioXCIsXG5cdFwiVmVlXCI6IFwi4ouBXCIsXG5cdFwidmVlZXFcIjogXCLiiZpcIixcblx0XCJ2ZWxsaXBcIjogXCLii65cIixcblx0XCJ2ZXJiYXJcIjogXCJ8XCIsXG5cdFwiVmVyYmFyXCI6IFwi4oCWXCIsXG5cdFwidmVydFwiOiBcInxcIixcblx0XCJWZXJ0XCI6IFwi4oCWXCIsXG5cdFwiVmVydGljYWxCYXJcIjogXCLiiKNcIixcblx0XCJWZXJ0aWNhbExpbmVcIjogXCJ8XCIsXG5cdFwiVmVydGljYWxTZXBhcmF0b3JcIjogXCLinZhcIixcblx0XCJWZXJ0aWNhbFRpbGRlXCI6IFwi4omAXCIsXG5cdFwiVmVyeVRoaW5TcGFjZVwiOiBcIuKAilwiLFxuXHRcIlZmclwiOiBcIvCdlJlcIixcblx0XCJ2ZnJcIjogXCLwnZSzXCIsXG5cdFwidmx0cmlcIjogXCLiirJcIixcblx0XCJ2bnN1YlwiOiBcIuKKguKDklwiLFxuXHRcInZuc3VwXCI6IFwi4oqD4oOSXCIsXG5cdFwiVm9wZlwiOiBcIvCdlY1cIixcblx0XCJ2b3BmXCI6IFwi8J2Vp1wiLFxuXHRcInZwcm9wXCI6IFwi4oidXCIsXG5cdFwidnJ0cmlcIjogXCLiirNcIixcblx0XCJWc2NyXCI6IFwi8J2SsVwiLFxuXHRcInZzY3JcIjogXCLwnZOLXCIsXG5cdFwidnN1Ym5FXCI6IFwi4quL77iAXCIsXG5cdFwidnN1Ym5lXCI6IFwi4oqK77iAXCIsXG5cdFwidnN1cG5FXCI6IFwi4quM77iAXCIsXG5cdFwidnN1cG5lXCI6IFwi4oqL77iAXCIsXG5cdFwiVnZkYXNoXCI6IFwi4oqqXCIsXG5cdFwidnppZ3phZ1wiOiBcIuKmmlwiLFxuXHRcIldjaXJjXCI6IFwixbRcIixcblx0XCJ3Y2lyY1wiOiBcIsW1XCIsXG5cdFwid2VkYmFyXCI6IFwi4qmfXCIsXG5cdFwid2VkZ2VcIjogXCLiiKdcIixcblx0XCJXZWRnZVwiOiBcIuKLgFwiLFxuXHRcIndlZGdlcVwiOiBcIuKJmVwiLFxuXHRcIndlaWVycFwiOiBcIuKEmFwiLFxuXHRcIldmclwiOiBcIvCdlJpcIixcblx0XCJ3ZnJcIjogXCLwnZS0XCIsXG5cdFwiV29wZlwiOiBcIvCdlY5cIixcblx0XCJ3b3BmXCI6IFwi8J2VqFwiLFxuXHRcIndwXCI6IFwi4oSYXCIsXG5cdFwid3JcIjogXCLiiYBcIixcblx0XCJ3cmVhdGhcIjogXCLiiYBcIixcblx0XCJXc2NyXCI6IFwi8J2SslwiLFxuXHRcIndzY3JcIjogXCLwnZOMXCIsXG5cdFwieGNhcFwiOiBcIuKLglwiLFxuXHRcInhjaXJjXCI6IFwi4pevXCIsXG5cdFwieGN1cFwiOiBcIuKLg1wiLFxuXHRcInhkdHJpXCI6IFwi4pa9XCIsXG5cdFwiWGZyXCI6IFwi8J2Um1wiLFxuXHRcInhmclwiOiBcIvCdlLVcIixcblx0XCJ4aGFyclwiOiBcIuKft1wiLFxuXHRcInhoQXJyXCI6IFwi4p+6XCIsXG5cdFwiWGlcIjogXCLOnlwiLFxuXHRcInhpXCI6IFwizr5cIixcblx0XCJ4bGFyclwiOiBcIuKftVwiLFxuXHRcInhsQXJyXCI6IFwi4p+4XCIsXG5cdFwieG1hcFwiOiBcIuKfvFwiLFxuXHRcInhuaXNcIjogXCLii7tcIixcblx0XCJ4b2RvdFwiOiBcIuKogFwiLFxuXHRcIlhvcGZcIjogXCLwnZWPXCIsXG5cdFwieG9wZlwiOiBcIvCdlalcIixcblx0XCJ4b3BsdXNcIjogXCLiqIFcIixcblx0XCJ4b3RpbWVcIjogXCLiqIJcIixcblx0XCJ4cmFyclwiOiBcIuKftlwiLFxuXHRcInhyQXJyXCI6IFwi4p+5XCIsXG5cdFwiWHNjclwiOiBcIvCdkrNcIixcblx0XCJ4c2NyXCI6IFwi8J2TjVwiLFxuXHRcInhzcWN1cFwiOiBcIuKohlwiLFxuXHRcInh1cGx1c1wiOiBcIuKohFwiLFxuXHRcInh1dHJpXCI6IFwi4pazXCIsXG5cdFwieHZlZVwiOiBcIuKLgVwiLFxuXHRcInh3ZWRnZVwiOiBcIuKLgFwiLFxuXHRcIllhY3V0ZVwiOiBcIsOdXCIsXG5cdFwieWFjdXRlXCI6IFwiw71cIixcblx0XCJZQWN5XCI6IFwi0K9cIixcblx0XCJ5YWN5XCI6IFwi0Y9cIixcblx0XCJZY2lyY1wiOiBcIsW2XCIsXG5cdFwieWNpcmNcIjogXCLFt1wiLFxuXHRcIlljeVwiOiBcItCrXCIsXG5cdFwieWN5XCI6IFwi0YtcIixcblx0XCJ5ZW5cIjogXCLCpVwiLFxuXHRcIllmclwiOiBcIvCdlJxcIixcblx0XCJ5ZnJcIjogXCLwnZS2XCIsXG5cdFwiWUljeVwiOiBcItCHXCIsXG5cdFwieWljeVwiOiBcItGXXCIsXG5cdFwiWW9wZlwiOiBcIvCdlZBcIixcblx0XCJ5b3BmXCI6IFwi8J2VqlwiLFxuXHRcIllzY3JcIjogXCLwnZK0XCIsXG5cdFwieXNjclwiOiBcIvCdk45cIixcblx0XCJZVWN5XCI6IFwi0K5cIixcblx0XCJ5dWN5XCI6IFwi0Y5cIixcblx0XCJ5dW1sXCI6IFwiw79cIixcblx0XCJZdW1sXCI6IFwixbhcIixcblx0XCJaYWN1dGVcIjogXCLFuVwiLFxuXHRcInphY3V0ZVwiOiBcIsW6XCIsXG5cdFwiWmNhcm9uXCI6IFwixb1cIixcblx0XCJ6Y2Fyb25cIjogXCLFvlwiLFxuXHRcIlpjeVwiOiBcItCXXCIsXG5cdFwiemN5XCI6IFwi0LdcIixcblx0XCJaZG90XCI6IFwixbtcIixcblx0XCJ6ZG90XCI6IFwixbxcIixcblx0XCJ6ZWV0cmZcIjogXCLihKhcIixcblx0XCJaZXJvV2lkdGhTcGFjZVwiOiBcIuKAi1wiLFxuXHRcIlpldGFcIjogXCLOllwiLFxuXHRcInpldGFcIjogXCLOtlwiLFxuXHRcInpmclwiOiBcIvCdlLdcIixcblx0XCJaZnJcIjogXCLihKhcIixcblx0XCJaSGN5XCI6IFwi0JZcIixcblx0XCJ6aGN5XCI6IFwi0LZcIixcblx0XCJ6aWdyYXJyXCI6IFwi4oedXCIsXG5cdFwiem9wZlwiOiBcIvCdlatcIixcblx0XCJab3BmXCI6IFwi4oSkXCIsXG5cdFwiWnNjclwiOiBcIvCdkrVcIixcblx0XCJ6c2NyXCI6IFwi8J2Tj1wiLFxuXHRcInp3alwiOiBcIuKAjVwiLFxuXHRcInp3bmpcIjogXCLigIxcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2Jhc2U2NC1qcy9pbmRleC5qcyIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vYnVmZmVyL2luZGV4LmpzIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXApIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIHZhciBiYXNlNjQgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9Vc2Vycy9ib2t1L3dvcmsvYmxvZy9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9pZWVlNzU0L2luZGV4LmpzIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL2Jva3Uvd29yay9ibG9nL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2lzYXJyYXkvaW5kZXguanMiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2ZpeFVybHMuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuXzFLY0U3cmgxTUtBeWV2ZDJlTV9BdGd7YmFja2dyb3VuZDojZmNmY2ZjfS5fMUtjRTdyaDFNS0F5ZXZkMmVNX0F0ZywuXzJKVnJocXd3SG84M0xlSHVaUkVlRTF7cGFkZGluZzoxMHB4O292ZXJmbG93OmF1dG87bWF4LWhlaWdodDo2MDBweH0uXzF1UHoybFQ5ZlZxVkpOQmV4RUhLU3F7d2lkdGg6MTAwJTtmb250LXNpemU6MjRwdDtwYWRkaW5nLWxlZnQ6MTBweH0uXzJuUzZtNTdwN2RKanktV3dOWXh6dmV7d2lkdGg6MTAwJTtmb250LXNpemU6MThwdDtwYWRkaW5nLWxlZnQ6MTBweH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJlZGl0b3JcIjogXCJfMUtjRTdyaDFNS0F5ZXZkMmVNX0F0Z1wiLFxuXHRcInByZXZpZXdcIjogXCJfMkpWcmhxd3dIbzgzTGVIdVpSRWVFMVwiLFxuXHRcInRpdGxlXCI6IFwiXzF1UHoybFQ5ZlZxVkpOQmV4RUhLU3FcIixcblx0XCJ0YWdzXCI6IFwiXzJuUzZtNTdwN2RKanktV3dOWXh6dmVcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vY3NzLWxvYWRlcj97XCJtb2R1bGVzXCI6dHJ1ZSxcIm1pbmltaXplXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWV9IS4vc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbztcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBtZW1vO1xuXHRcdH07XG5cdH0sXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdFx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHRcdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXIgXG5cdFx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdFx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdFx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xuXHR9KSxcblx0Z2V0RWxlbWVudCA9IChmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0XHR9O1xuXHR9KShmdW5jdGlvbiAoc3R5bGVUYXJnZXQpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzdHlsZVRhcmdldClcblx0fSksXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXSxcblx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL2ZpeFVybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEludG8gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2Vcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XG5cdHZhciBzdHlsZVRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXHRpZiAoIXN0eWxlVGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHRzdHlsZVRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBzdHlsZVRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHN0eWxlVGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGVUYXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGF0dGFjaFRhZ0F0dHJzKHN0eWxlRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YXR0YWNoVGFnQXR0cnMobGlua0VsZW1lbnQsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRhZ0F0dHJzKGVsZW1lbnQsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcblx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG5cdFx0aWYobmV3T2JqKSB7XG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlcztcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qIElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKXtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZihzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xuXG5cdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYylcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvYm9rdS93b3JrL2Jsb2cvYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEtMSEuL3N0eWxlcy5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHlsZXMuY3NzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9