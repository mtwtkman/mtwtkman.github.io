/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 19);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Utilities
//


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(8);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(5);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(12);
exports.lib.ucmicro = __webpack_require__(83);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

;(function () {
	"use strict";

	function Vnode(tag, key, attrs0, children, text, dom) {
		return { tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false };
	}
	Vnode.normalize = function (node) {
		if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined);
		if (node != null && (typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined);
		return node;
	};
	Vnode.normalizeChildren = function normalizeChildren(children) {
		for (var i = 0; i < children.length; i++) {
			children[i] = Vnode.normalize(children[i]);
		}
		return children;
	};
	var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
	var selectorCache = {};
	var hasOwn = {}.hasOwnProperty;
	function compileSelector(selector) {
		var match,
		    tag = "div",
		    classes = [],
		    attrs = {};
		while (match = selectorParser.exec(selector)) {
			var type = match[1],
			    value = match[2];
			if (type === "" && value !== "") tag = value;else if (type === "#") attrs.id = value;else if (type === ".") classes.push(value);else if (match[3][0] === "[") {
				var attrValue = match[6];
				if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
				if (match[4] === "class") classes.push(attrValue);else attrs[match[4]] = attrValue || true;
			}
		}
		if (classes.length > 0) attrs.className = classes.join(" ");
		return selectorCache[selector] = { tag: tag, attrs: attrs };
	}
	function execSelector(state, attrs, children) {
		var hasAttrs = false,
		    childList,
		    text;
		var className = attrs.className || attrs.class;
		for (var key in state.attrs) {
			if (hasOwn.call(state.attrs, key)) {
				attrs[key] = state.attrs[key];
			}
		}
		if (className !== undefined) {
			if (attrs.class !== undefined) {
				attrs.class = undefined;
				attrs.className = className;
			}
			if (state.attrs.className != null) {
				attrs.className = state.attrs.className + " " + className;
			}
		}
		for (var key in attrs) {
			if (hasOwn.call(attrs, key) && key !== "key") {
				hasAttrs = true;
				break;
			}
		}
		if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
			text = children[0].children;
		} else {
			childList = children;
		}
		return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text);
	}
	function hyperscript(selector) {
		// Because sloppy mode sucks
		var attrs = arguments[1],
		    start = 2,
		    children;
		if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
			throw Error("The selector must be either a string or a component.");
		}
		if (typeof selector === "string") {
			var cached = selectorCache[selector] || compileSelector(selector);
		}
		if (attrs == null) {
			attrs = {};
		} else if ((typeof attrs === "undefined" ? "undefined" : _typeof(attrs)) !== "object" || attrs.tag != null || Array.isArray(attrs)) {
			attrs = {};
			start = 1;
		}
		if (arguments.length === start + 1) {
			children = arguments[start];
			if (!Array.isArray(children)) children = [children];
		} else {
			children = [];
			while (start < arguments.length) {
				children.push(arguments[start++]);
			}
		}
		var normalized = Vnode.normalizeChildren(children);
		if (typeof selector === "string") {
			return execSelector(cached, attrs, normalized);
		} else {
			return Vnode(selector, attrs.key, attrs, normalized);
		}
	}
	hyperscript.trust = function (html) {
		if (html == null) html = "";
		return Vnode("<", undefined, undefined, html, undefined, undefined);
	};
	hyperscript.fragment = function (attrs1, children) {
		return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined);
	};
	var m = hyperscript;
	/** @constructor */
	var PromisePolyfill = function PromisePolyfill(executor) {
		if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`");
		if (typeof executor !== "function") throw new TypeError("executor must be a function");
		var self = this,
		    resolvers = [],
		    rejectors = [],
		    resolveCurrent = handler(resolvers, true),
		    rejectCurrent = handler(rejectors, false);
		var instance = self._instance = { resolvers: resolvers, rejectors: rejectors };
		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function handler(list, shouldAbsorb) {
			return function execute(value) {
				var then;
				try {
					if (shouldAbsorb && value != null && ((typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
						if (value === self) throw new TypeError("Promise can't be resolved w/ itself");
						executeOnce(then.bind(value));
					} else {
						callAsync(function () {
							if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value);
							for (var i = 0; i < list.length; i++) {
								list[i](value);
							}resolvers.length = 0, rejectors.length = 0;
							instance.state = shouldAbsorb;
							instance.retry = function () {
								execute(value);
							};
						});
					}
				} catch (e) {
					rejectCurrent(e);
				}
			};
		}
		function executeOnce(then) {
			var runs = 0;
			function run(fn) {
				return function (value) {
					if (runs++ > 0) return;
					fn(value);
				};
			}
			var onerror = run(rejectCurrent);
			try {
				then(run(resolveCurrent), onerror);
			} catch (e) {
				onerror(e);
			}
		}
		executeOnce(executor);
	};
	PromisePolyfill.prototype.then = function (onFulfilled, onRejection) {
		var self = this,
		    instance = self._instance;
		function handle(callback, list, next, state) {
			list.push(function (value) {
				if (typeof callback !== "function") next(value);else try {
					resolveNext(callback(value));
				} catch (e) {
					if (rejectNext) rejectNext(e);
				}
			});
			if (typeof instance.retry === "function" && state === instance.state) instance.retry();
		}
		var resolveNext, rejectNext;
		var promise = new PromisePolyfill(function (resolve, reject) {
			resolveNext = resolve, rejectNext = reject;
		});
		handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
		return promise;
	};
	PromisePolyfill.prototype.catch = function (onRejection) {
		return this.then(null, onRejection);
	};
	PromisePolyfill.resolve = function (value) {
		if (value instanceof PromisePolyfill) return value;
		return new PromisePolyfill(function (resolve) {
			resolve(value);
		});
	};
	PromisePolyfill.reject = function (value) {
		return new PromisePolyfill(function (resolve, reject) {
			reject(value);
		});
	};
	PromisePolyfill.all = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			var total = list.length,
			    count = 0,
			    values = [];
			if (list.length === 0) resolve([]);else for (var i = 0; i < list.length; i++) {
				(function (i) {
					function consume(value) {
						count++;
						values[i] = value;
						if (count === total) resolve(values);
					}
					if (list[i] != null && (_typeof(list[i]) === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
						list[i].then(consume, reject);
					} else consume(list[i]);
				})(i);
			}
		});
	};
	PromisePolyfill.race = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			for (var i = 0; i < list.length; i++) {
				list[i].then(resolve, reject);
			}
		});
	};
	if (typeof window !== "undefined") {
		if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill;
		var PromisePolyfill = window.Promise;
	} else if (typeof global !== "undefined") {
		if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill;
		var PromisePolyfill = global.Promise;
	} else {}
	var buildQueryString = function buildQueryString(object) {
		if (Object.prototype.toString.call(object) !== "[object Object]") return "";
		var args = [];
		for (var key0 in object) {
			destructure(key0, object[key0]);
		}
		return args.join("&");
		function destructure(key0, value) {
			if (Array.isArray(value)) {
				for (var i = 0; i < value.length; i++) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else if (Object.prototype.toString.call(value) === "[object Object]") {
				for (var i in value) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
		}
	};
	var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i");
	var _8 = function _8($window, Promise) {
		var callbackCount = 0;
		var oncompletion;
		function setCompletionCallback(callback) {
			oncompletion = callback;
		}
		function finalizer() {
			var count = 0;
			function complete() {
				if (--count === 0 && typeof oncompletion === "function") oncompletion();
			}
			return function finalize(promise0) {
				var then0 = promise0.then;
				promise0.then = function () {
					count++;
					var next = then0.apply(promise0, arguments);
					next.then(complete, function (e) {
						complete();
						if (count === 0) throw e;
					});
					return finalize(next);
				};
				return promise0;
			};
		}
		function normalize(args, extra) {
			if (typeof args === "string") {
				var url = args;
				args = extra || {};
				if (args.url == null) args.url = url;
			}
			return args;
		}
		function request(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				if (args.method == null) args.method = "GET";
				args.method = args.method.toUpperCase();
				var useBody = args.method === "GET" || args.method === "TRACE" ? false : typeof args.useBody === "boolean" ? args.useBody : true;
				if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function (value) {
					return value;
				} : JSON.stringify;
				if (typeof args.deserialize !== "function") args.deserialize = deserialize;
				if (typeof args.extract !== "function") args.extract = extract;
				args.url = interpolate(args.url, args.data);
				if (useBody) args.data = args.serialize(args.data);else args.url = assemble(args.url, args.data);
				var xhr = new $window.XMLHttpRequest(),
				    aborted = false,
				    _abort = xhr.abort;
				xhr.abort = function abort() {
					aborted = true;
					_abort.call(xhr);
				};
				xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);
				if (args.serialize === JSON.stringify && useBody) {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
				}
				if (args.deserialize === deserialize) {
					xhr.setRequestHeader("Accept", "application/json, text/*");
				}
				if (args.withCredentials) xhr.withCredentials = args.withCredentials;
				for (var key in args.headers) {
					if ({}.hasOwnProperty.call(args.headers, key)) {
						xhr.setRequestHeader(key, args.headers[key]);
					}
				}if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr;
				xhr.onreadystatechange = function () {
					// Don't throw errors on xhr.abort().
					if (aborted) return;
					if (xhr.readyState === 4) {
						try {
							var response = args.extract !== extract ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args));
							if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
								resolve(cast(args.type, response));
							} else {
								var error = new Error(xhr.responseText);
								for (var key in response) {
									error[key] = response[key];
								}reject(error);
							}
						} catch (e) {
							reject(e);
						}
					}
				};
				if (useBody && args.data != null) xhr.send(args.data);else xhr.send();
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function jsonp(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
				var script = $window.document.createElement("script");
				$window[callbackName] = function (data) {
					script.parentNode.removeChild(script);
					resolve(cast(args.type, data));
					delete $window[callbackName];
				};
				script.onerror = function () {
					script.parentNode.removeChild(script);
					reject(new Error("JSONP request failed"));
					delete $window[callbackName];
				};
				if (args.data == null) args.data = {};
				args.url = interpolate(args.url, args.data);
				args.data[args.callbackKey || "callback"] = callbackName;
				script.src = assemble(args.url, args.data);
				$window.document.documentElement.appendChild(script);
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function interpolate(url, data) {
			if (data == null) return url;
			var tokens = url.match(/:[^\/]+/gi) || [];
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1);
				if (data[key] != null) {
					url = url.replace(tokens[i], data[key]);
				}
			}
			return url;
		}
		function assemble(url, data) {
			var querystring = buildQueryString(data);
			if (querystring !== "") {
				var prefix = url.indexOf("?") < 0 ? "?" : "&";
				url += prefix + querystring;
			}
			return url;
		}
		function deserialize(data) {
			try {
				return data !== "" ? JSON.parse(data) : null;
			} catch (e) {
				throw new Error(data);
			}
		}
		function extract(xhr) {
			return xhr.responseText;
		}
		function cast(type0, data) {
			if (typeof type0 === "function") {
				if (Array.isArray(data)) {
					for (var i = 0; i < data.length; i++) {
						data[i] = new type0(data[i]);
					}
				} else return new type0(data);
			}
			return data;
		}
		return { request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback };
	};
	var requestService = _8(window, PromisePolyfill);
	var coreRenderer = function coreRenderer($window) {
		var $doc = $window.document;
		var $emptyFragment = $doc.createDocumentFragment();
		var onevent;
		function setEventCallback(callback) {
			return onevent = callback;
		}
		//create
		function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					createNode(parent, vnode, hooks, ns, nextSibling);
				}
			}
		}
		function createNode(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			if (typeof tag === "string") {
				vnode.state = {};
				if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
				switch (tag) {
					case "#":
						return createText(parent, vnode, nextSibling);
					case "<":
						return createHTML(parent, vnode, nextSibling);
					case "[":
						return createFragment(parent, vnode, hooks, ns, nextSibling);
					default:
						return createElement(parent, vnode, hooks, ns, nextSibling);
				}
			} else return createComponent(parent, vnode, hooks, ns, nextSibling);
		}
		function createText(parent, vnode, nextSibling) {
			vnode.dom = $doc.createTextNode(vnode.children);
			insertNode(parent, vnode.dom, nextSibling);
			return vnode.dom;
		}
		function createHTML(parent, vnode, nextSibling) {
			var match1 = vnode.children.match(/^\s*?<(\w+)/im) || [];
			var parent1 = { caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup" }[match1[1]] || "div";
			var temp = $doc.createElement(parent1);
			temp.innerHTML = vnode.children;
			vnode.dom = temp.firstChild;
			vnode.domSize = temp.childNodes.length;
			var fragment = $doc.createDocumentFragment();
			var child;
			while (child = temp.firstChild) {
				fragment.appendChild(child);
			}
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createFragment(parent, vnode, hooks, ns, nextSibling) {
			var fragment = $doc.createDocumentFragment();
			if (vnode.children != null) {
				var children = vnode.children;
				createNodes(fragment, children, 0, children.length, hooks, null, ns);
			}
			vnode.dom = fragment.firstChild;
			vnode.domSize = fragment.childNodes.length;
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createElement(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			var attrs2 = vnode.attrs;
			var is = attrs2 && attrs2.is;
			var element = ns ? is ? $doc.createElementNS(ns, tag, { is: is }) : $doc.createElementNS(ns, tag) : is ? $doc.createElement(tag, { is: is }) : $doc.createElement(tag);
			vnode.dom = element;
			if (attrs2 != null) {
				setAttrs(vnode, attrs2, ns);
			}
			insertNode(parent, element, nextSibling);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else {
				if (vnode.text != null) {
					if (vnode.text !== "") element.textContent = vnode.text;else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				}
				if (vnode.children != null) {
					var children = vnode.children;
					createNodes(element, children, 0, children.length, hooks, null, ns);
					setLateAttrs(vnode);
				}
			}
			return element;
		}
		function initComponent(vnode, hooks) {
			var sentinel;
			if (typeof vnode.tag.view === "function") {
				vnode.state = Object.create(vnode.tag);
				sentinel = vnode.state.view;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
			} else {
				vnode.state = void 0;
				sentinel = vnode.tag;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
				vnode.state = vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function" ? new vnode.tag(vnode) : vnode.tag(vnode);
			}
			vnode._state = vnode.state;
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
			initLifecycle(vnode._state, vnode, hooks);
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
			sentinel.$$reentrantLock$$ = null;
		}
		function createComponent(parent, vnode, hooks, ns, nextSibling) {
			initComponent(vnode, hooks);
			if (vnode.instance != null) {
				var element = createNode(parent, vnode.instance, hooks, ns, nextSibling);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
				insertNode(parent, element, nextSibling);
				return element;
			} else {
				vnode.domSize = 0;
				return $emptyFragment;
			}
		}
		//update
		function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
			if (old === vnodes || old == null && vnodes == null) return;else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined);else if (vnodes == null) removeNodes(old, 0, old.length, vnodes);else {
				if (old.length === vnodes.length) {
					var isUnkeyed = false;
					for (var i = 0; i < vnodes.length; i++) {
						if (vnodes[i] != null && old[i] != null) {
							isUnkeyed = vnodes[i].key == null && old[i].key == null;
							break;
						}
					}
					if (isUnkeyed) {
						for (var i = 0; i < old.length; i++) {
							if (old[i] === vnodes[i]) continue;else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling));else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes);else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns);
						}
						return;
					}
				}
				recycling = recycling || isRecyclable(old, vnodes);
				if (recycling) {
					var pool = old.pool;
					old = old.concat(old.pool);
				}
				var oldStart = 0,
				    start = 0,
				    oldEnd = old.length - 1,
				    end = vnodes.length - 1,
				    map;
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldStart],
					    v = vnodes[start];
					if (o === v && !recycling) oldStart++, start++;else if (o == null) oldStart++;else if (v == null) start++;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldStart >= old.length - pool.length || pool == null && recycling;
						oldStart++, start++;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
					} else {
						var o = old[oldEnd];
						if (o === v && !recycling) oldEnd--, start++;else if (o == null) oldEnd--;else if (v == null) start++;else if (o.key === v.key) {
							var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
							updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
							if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling));
							oldEnd--, start++;
						} else break;
					}
				}
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldEnd],
					    v = vnodes[end];
					if (o === v && !recycling) oldEnd--, end--;else if (o == null) oldEnd--;else if (v == null) end--;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
						if (o.dom != null) nextSibling = o.dom;
						oldEnd--, end--;
					} else {
						if (!map) map = getKeyMap(old, oldEnd);
						if (v != null) {
							var oldIndex = map[v.key];
							if (oldIndex != null) {
								var movable = old[oldIndex];
								var shouldRecycle = pool != null && oldIndex >= old.length - pool.length || pool == null && recycling;
								updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns);
								insertNode(parent, toFragment(movable), nextSibling);
								old[oldIndex].skip = true;
								if (movable.dom != null) nextSibling = movable.dom;
							} else {
								var dom = createNode(parent, v, hooks, undefined, nextSibling);
								nextSibling = dom;
							}
						}
						end--;
					}
					if (end < start) break;
				}
				createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
				removeNodes(old, oldStart, oldEnd + 1, vnodes);
			}
		}
		function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			var oldTag = old.tag,
			    tag = vnode.tag;
			if (oldTag === tag) {
				vnode.state = old.state;
				vnode._state = old._state;
				vnode.events = old.events;
				if (!recycling && shouldNotUpdate(vnode, old)) return;
				if (typeof oldTag === "string") {
					if (vnode.attrs != null) {
						if (recycling) {
							vnode.state = {};
							initLifecycle(vnode.attrs, vnode, hooks);
						} else updateLifecycle(vnode.attrs, vnode, hooks);
					}
					switch (oldTag) {
						case "#":
							updateText(old, vnode);break;
						case "<":
							updateHTML(parent, old, vnode, nextSibling);break;
						case "[":
							updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns);break;
						default:
							updateElement(old, vnode, recycling, hooks, ns);
					}
				} else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns);
			} else {
				removeNode(old, null);
				createNode(parent, vnode, hooks, ns, nextSibling);
			}
		}
		function updateText(old, vnode) {
			if (old.children.toString() !== vnode.children.toString()) {
				old.dom.nodeValue = vnode.children;
			}
			vnode.dom = old.dom;
		}
		function updateHTML(parent, old, vnode, nextSibling) {
			if (old.children !== vnode.children) {
				toFragment(old);
				createHTML(parent, vnode, nextSibling);
			} else vnode.dom = old.dom, vnode.domSize = old.domSize;
		}
		function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
			updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns);
			var domSize = 0,
			    children = vnode.children;
			vnode.dom = null;
			if (children != null) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i];
					if (child != null && child.dom != null) {
						if (vnode.dom == null) vnode.dom = child.dom;
						domSize += child.domSize || 1;
					}
				}
				if (domSize !== 1) vnode.domSize = domSize;
			}
		}
		function updateElement(old, vnode, recycling, hooks, ns) {
			var element = vnode.dom = old.dom;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			if (vnode.tag === "textarea") {
				if (vnode.attrs == null) vnode.attrs = {};
				if (vnode.text != null) {
					vnode.attrs.value = vnode.text; //FIXME handle0 multiple children
					vnode.text = undefined;
				}
			}
			updateAttrs(vnode, old.attrs, vnode.attrs, ns);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else if (old.text != null && vnode.text != null && vnode.text !== "") {
				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text;
			} else {
				if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)];
				if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns);
			}
		}
		function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			if (recycling) {
				initComponent(vnode, hooks);
			} else {
				vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
				if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
				if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);
				updateLifecycle(vnode._state, vnode, hooks);
			}
			if (vnode.instance != null) {
				if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.instance.domSize;
			} else if (old.instance != null) {
				removeNode(old.instance, null);
				vnode.dom = undefined;
				vnode.domSize = 0;
			} else {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
			}
		}
		function isRecyclable(old, vnodes) {
			if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
				var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0;
				var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0;
				var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0;
				if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
					return true;
				}
			}
			return false;
		}
		function getKeyMap(vnodes, end) {
			var map = {},
			    i = 0;
			for (var i = 0; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					var key2 = vnode.key;
					if (key2 != null) map[key2] = i;
				}
			}
			return map;
		}
		function toFragment(vnode) {
			var count0 = vnode.domSize;
			if (count0 != null || vnode.dom == null) {
				var fragment = $doc.createDocumentFragment();
				if (count0 > 0) {
					var dom = vnode.dom;
					while (--count0) {
						fragment.appendChild(dom.nextSibling);
					}fragment.insertBefore(dom, fragment.firstChild);
				}
				return fragment;
			} else return vnode.dom;
		}
		function getNextSibling(vnodes, i, nextSibling) {
			for (; i < vnodes.length; i++) {
				if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom;
			}
			return nextSibling;
		}
		function insertNode(parent, dom, nextSibling) {
			if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling);else parent.appendChild(dom);
		}
		function setContentEditable(vnode) {
			var children = vnode.children;
			if (children != null && children.length === 1 && children[0].tag === "<") {
				var content = children[0].children;
				if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;
			} else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted");
		}
		//remove
		function removeNodes(vnodes, start, end, context) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					if (vnode.skip) vnode.skip = false;else removeNode(vnode, context);
				}
			}
		}
		function removeNode(vnode, context) {
			var expected = 1,
			    called = 0;
			if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
				var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
				var result = vnode._state.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			continuation();
			function continuation() {
				if (++called === expected) {
					onremove(vnode);
					if (vnode.dom) {
						var count0 = vnode.domSize || 1;
						if (count0 > 1) {
							var dom = vnode.dom;
							while (--count0) {
								removeNodeFromDOM(dom.nextSibling);
							}
						}
						removeNodeFromDOM(vnode.dom);
						if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") {
							//TODO test custom elements
							if (!context.pool) context.pool = [vnode];else context.pool.push(vnode);
						}
					}
				}
			}
		}
		function removeNodeFromDOM(node) {
			var parent = node.parentNode;
			if (parent != null) parent.removeChild(node);
		}
		function onremove(vnode) {
			if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode);
			if (vnode.instance != null) onremove(vnode.instance);else {
				var children = vnode.children;
				if (Array.isArray(children)) {
					for (var i = 0; i < children.length; i++) {
						var child = children[i];
						if (child != null) onremove(child);
					}
				}
			}
		}
		//attrs2
		function setAttrs(vnode, attrs2, ns) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, null, attrs2[key2], ns);
			}
		}
		function setAttr(vnode, key2, old, value, ns) {
			var element = vnode.dom;
			if (key2 === "key" || key2 === "is" || old === value && !isFormAttribute(vnode, key2) && (typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return;
			var nsLastIndex = key2.indexOf(":");
			if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
				element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value);
			} else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value);else if (key2 === "style") updateStyle(element, old, value);else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if (vnode.tag === "input" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && key2 === "value" && vnode.dom.value == value) return;
				// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
				if (vnode.tag === "input" && key2 === "type") {
					element.setAttribute(key2, value);
					return;
				}
				element[key2] = value;
			} else {
				if (typeof value === "boolean") {
					if (value) element.setAttribute(key2, "");else element.removeAttribute(key2);
				} else element.setAttribute(key2 === "className" ? "class" : key2, value);
			}
		}
		function setLateAttrs(vnode) {
			var attrs2 = vnode.attrs;
			if (vnode.tag === "select" && attrs2 != null) {
				if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined);
				if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined);
			}
		}
		function updateAttrs(vnode, old, attrs2, ns) {
			if (attrs2 != null) {
				for (var key2 in attrs2) {
					setAttr(vnode, key2, old && old[key2], attrs2[key2], ns);
				}
			}
			if (old != null) {
				for (var key2 in old) {
					if (attrs2 == null || !(key2 in attrs2)) {
						if (key2 === "className") key2 = "class";
						if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined);else if (key2 !== "key") vnode.dom.removeAttribute(key2);
					}
				}
			}
		}
		function isFormAttribute(vnode, attr) {
			return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement;
		}
		function isLifecycleMethod(attr) {
			return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate";
		}
		function isAttribute(attr) {
			return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"; // || attr === "type"
		}
		function isCustomElement(vnode) {
			return vnode.attrs.is || vnode.tag.indexOf("-") > -1;
		}
		function hasIntegrationMethods(source) {
			return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove);
		}
		//style
		function updateStyle(element, old, style) {
			if (old === style) element.style.cssText = "", old = null;
			if (style == null) element.style.cssText = "";else if (typeof style === "string") element.style.cssText = style;else {
				if (typeof old === "string") element.style.cssText = "";
				for (var key2 in style) {
					element.style[key2] = style[key2];
				}
				if (old != null && typeof old !== "string") {
					for (var key2 in old) {
						if (!(key2 in style)) element.style[key2] = "";
					}
				}
			}
		}
		//event
		function updateEvent(vnode, key2, value) {
			var element = vnode.dom;
			var callback = typeof onevent !== "function" ? value : function (e) {
				var result = value.call(element, e);
				onevent.call(element, e);
				return result;
			};
			if (key2 in element) element[key2] = typeof value === "function" ? callback : null;else {
				var eventName = key2.slice(2);
				if (vnode.events === undefined) vnode.events = {};
				if (vnode.events[key2] === callback) return;
				if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false);
				if (typeof value === "function") {
					vnode.events[key2] = callback;
					element.addEventListener(eventName, vnode.events[key2], false);
				}
			}
		}
		//lifecycle
		function initLifecycle(source, vnode, hooks) {
			if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode);
			if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode));
		}
		function updateLifecycle(source, vnode, hooks) {
			if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode));
		}
		function shouldNotUpdate(vnode, old) {
			var forceVnodeUpdate, forceComponentUpdate;
			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old);
			if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
				vnode.instance = old.instance;
				return true;
			}
			return false;
		}
		function render(dom, vnodes) {
			if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");
			var hooks = [];
			var active = $doc.activeElement;
			// First time0 rendering into a node clears it out
			if (dom.vnodes == null) dom.textContent = "";
			if (!Array.isArray(vnodes)) vnodes = [vnodes];
			updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined);
			dom.vnodes = vnodes;
			for (var i = 0; i < hooks.length; i++) {
				hooks[i]();
			}if ($doc.activeElement !== active) active.focus();
		}
		return { render: render, setEventCallback: setEventCallback };
	};
	function throttle(callback) {
		//60fps translates to 16.6ms, round it down since setTimeout requires int
		var time = 16;
		var last = 0,
		    pending = null;
		var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout;
		return function () {
			var now = Date.now();
			if (last === 0 || now - last >= time) {
				last = now;
				callback();
			} else if (pending === null) {
				pending = timeout(function () {
					pending = null;
					callback();
					last = Date.now();
				}, time - (now - last));
			}
		};
	}
	var _11 = function _11($window) {
		var renderService = coreRenderer($window);
		renderService.setEventCallback(function (e) {
			if (e.redraw !== false) redraw();
		});
		var callbacks = [];
		function subscribe(key1, callback) {
			unsubscribe(key1);
			callbacks.push(key1, throttle(callback));
		}
		function unsubscribe(key1) {
			var index = callbacks.indexOf(key1);
			if (index > -1) callbacks.splice(index, 2);
		}
		function redraw() {
			for (var i = 1; i < callbacks.length; i += 2) {
				callbacks[i]();
			}
		}
		return { subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render };
	};
	var redrawService = _11(window);
	requestService.setCompletionCallback(redrawService.redraw);
	var _16 = function _16(redrawService0) {
		return function (root, component) {
			if (component === null) {
				redrawService0.render(root, []);
				redrawService0.unsubscribe(root);
				return;
			}

			if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode");

			var run0 = function run0() {
				redrawService0.render(root, Vnode(component));
			};
			redrawService0.subscribe(root, run0);
			redrawService0.redraw();
		};
	};
	m.mount = _16(redrawService);
	var Promise = PromisePolyfill;
	var parseQueryString = function parseQueryString(string) {
		if (string === "" || string == null) return {};
		if (string.charAt(0) === "?") string = string.slice(1);
		var entries = string.split("&"),
		    data0 = {},
		    counters = {};
		for (var i = 0; i < entries.length; i++) {
			var entry = entries[i].split("=");
			var key5 = decodeURIComponent(entry[0]);
			var value = entry.length === 2 ? decodeURIComponent(entry[1]) : "";
			if (value === "true") value = true;else if (value === "false") value = false;
			var levels = key5.split(/\]\[?|\[/);
			var cursor = data0;
			if (key5.indexOf("[") > -1) levels.pop();
			for (var j = 0; j < levels.length; j++) {
				var level = levels[j],
				    nextLevel = levels[j + 1];
				var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
				var isValue = j === levels.length - 1;
				if (level === "") {
					var key5 = levels.slice(0, j).join();
					if (counters[key5] == null) counters[key5] = 0;
					level = counters[key5]++;
				}
				if (cursor[level] == null) {
					cursor[level] = isValue ? value : isNumber ? [] : {};
				}
				cursor = cursor[level];
			}
		}
		return data0;
	};
	var coreRouter = function coreRouter($window) {
		var supportsPushState = typeof $window.history.pushState === "function";
		var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function normalize1(fragment0) {
			var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent);
			if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data;
			return data;
		}
		var asyncId;
		function debounceAsync(callback0) {
			return function () {
				if (asyncId != null) return;
				asyncId = callAsync0(function () {
					asyncId = null;
					callback0();
				});
			};
		}
		function parsePath(path, queryData, hashData) {
			var queryIndex = path.indexOf("?");
			var hashIndex = path.indexOf("#");
			var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length;
			if (queryIndex > -1) {
				var queryEnd = hashIndex > -1 ? hashIndex : path.length;
				var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd));
				for (var key4 in queryParams) {
					queryData[key4] = queryParams[key4];
				}
			}
			if (hashIndex > -1) {
				var hashParams = parseQueryString(path.slice(hashIndex + 1));
				for (var key4 in hashParams) {
					hashData[key4] = hashParams[key4];
				}
			}
			return path.slice(0, pathEnd);
		}
		var router = { prefix: "#!" };
		router.getPath = function () {
			var type2 = router.prefix.charAt(0);
			switch (type2) {
				case "#":
					return normalize1("hash").slice(router.prefix.length);
				case "?":
					return normalize1("search").slice(router.prefix.length) + normalize1("hash");
				default:
					return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash");
			}
		};
		router.setPath = function (path, data, options) {
			var queryData = {},
			    hashData = {};
			path = parsePath(path, queryData, hashData);
			if (data != null) {
				for (var key4 in data) {
					queryData[key4] = data[key4];
				}path = path.replace(/:([^\/]+)/g, function (match2, token) {
					delete queryData[token];
					return data[token];
				});
			}
			var query = buildQueryString(queryData);
			if (query) path += "?" + query;
			var hash = buildQueryString(hashData);
			if (hash) path += "#" + hash;
			if (supportsPushState) {
				var state = options ? options.state : null;
				var title = options ? options.title : null;
				$window.onpopstate();
				if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path);else $window.history.pushState(state, title, router.prefix + path);
			} else $window.location.href = router.prefix + path;
		};
		router.defineRoutes = function (routes, resolve, reject) {
			function resolveRoute() {
				var path = router.getPath();
				var params = {};
				var pathname = parsePath(path, params, params);
				var state = $window.history.state;
				if (state != null) {
					for (var k in state) {
						params[k] = state[k];
					}
				}
				for (var route0 in routes) {
					var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");
					if (matcher.test(pathname)) {
						pathname.replace(matcher, function () {
							var keys = route0.match(/:[^\/]+/g) || [];
							var values = [].slice.call(arguments, 1, -2);
							for (var i = 0; i < keys.length; i++) {
								params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i]);
							}
							resolve(routes[route0], params, path, route0);
						});
						return;
					}
				}
				reject(path, params);
			}
			if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute);else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute;
			resolveRoute();
		};
		return router;
	};
	var _20 = function _20($window, redrawService0) {
		var routeService = coreRouter($window);
		var identity = function identity(v) {
			return v;
		};
		var render1, component, attrs3, currentPath, _lastUpdate;
		var route = function route(root, defaultRoute, routes) {
			if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined");
			var run1 = function run1() {
				if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)));
			};
			var bail = function bail(path) {
				if (path !== defaultRoute) routeService.setPath(defaultRoute, null, { replace: true });else throw new Error("Could not resolve default route " + defaultRoute);
			};
			routeService.defineRoutes(routes, function (payload, params, path) {
				var update = _lastUpdate = function lastUpdate(routeResolver, comp) {
					if (update !== _lastUpdate) return;
					component = comp != null && (typeof comp.view === "function" || typeof comp === "function") ? comp : "div";
					attrs3 = params, currentPath = path, _lastUpdate = null;
					render1 = (routeResolver.render || identity).bind(routeResolver);
					run1();
				};
				if (payload.view || typeof payload === "function") update({}, payload);else {
					if (payload.onmatch) {
						Promise.resolve(payload.onmatch(params, path)).then(function (resolved) {
							update(payload, resolved);
						}, bail);
					} else update(payload, "div");
				}
			}, bail);
			redrawService0.subscribe(root, run1);
		};
		route.set = function (path, data, options) {
			if (_lastUpdate != null) options = { replace: true };
			_lastUpdate = null;
			routeService.setPath(path, data, options);
		};
		route.get = function () {
			return currentPath;
		};
		route.prefix = function (prefix0) {
			routeService.prefix = prefix0;
		};
		route.link = function (vnode1) {
			vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href);
			vnode1.dom.onclick = function (e) {
				if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return;
				e.preventDefault();
				e.redraw = false;
				var href = this.getAttribute("href");
				if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length);
				route.set(href, undefined, undefined);
			};
		};
		route.param = function (key3) {
			if (typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3];
			return attrs3;
		};
		return route;
	};
	m.route = _20(window, redrawService);
	m.withAttr = function (attrName, callback1, context) {
		return function (e) {
			callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName));
		};
	};
	var _28 = coreRenderer(window);
	m.render = _28.render;
	m.redraw = redrawService.redraw;
	m.request = requestService.request;
	m.jsonp = requestService.jsonp;
	m.parseQueryString = parseQueryString;
	m.buildQueryString = buildQueryString;
	m.version = "1.1.1";
	m.vnode = Vnode;
	if (true) module["exports"] = m;else window.m = m;
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(81).setImmediate, __webpack_require__(2)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/


/**
 * new Ruler()
 **/

function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typorgapher replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Token class



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/

function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.span = vnode.attrs.span;
    vnode.state.cls = vnode.attrs.cls;
  },
  view: function view(vnode) {
    return (0, _mithril2.default)(
      'div',
      { className: 'mdl-cell mdl-cell--' + vnode.state.span + '-col ' + vnode.state.cls },
      vnode.attrs.inner
    );
  }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23).Buffer))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML5 entities map: { name -> utf16string }
//


/*eslint quotes:0*/

module.exports = __webpack_require__(87);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = '';
      state.tokens[delimiters[startDelim.end - 1].token].content = '';
      i++;
    }
  }
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ~~strike through~~
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports.encode = __webpack_require__(74);
module.exports.decode = __webpack_require__(73);
module.exports.format = __webpack_require__(75);
module.exports.parse = __webpack_require__(76);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(80);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 17 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Save = exports.Preview = exports.Editor = undefined;

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _model = __webpack_require__(20);

var _model2 = _interopRequireDefault(_model);

var _styles = __webpack_require__(88);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(6);

var _cell2 = _interopRequireDefault(_cell);

var _title = __webpack_require__(21);

var _title2 = _interopRequireDefault(_title);

var _tags = __webpack_require__(90);

var _tags2 = _interopRequireDefault(_tags);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Editor = exports.Editor = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
  },
  view: function view(vnode) {
    var model = vnode.state.model;
    var inner = (0, _mithril2.default)(
      'textarea',
      {
        className: _styles2.default.textarea,
        oninput: _mithril2.default.withAttr('value', function (v) {
          model.data.body = v;
        }) },
      model.data.body
    );
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorLeftSide, inner: inner });
  }
};

var Preview = exports.Preview = {
  view: function view(vnode) {
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorRightSide, inner: _mithril2.default.trust(vnode.attrs.body) });
  }
};

var Save = exports.Save = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
  },
  view: function view(vnode) {
    var model = vnode.state.model;
    var inner = (0, _mithril2.default)(
      'button',
      {
        className: 'mdl-button mdl-js-button mdl-button--raised mdl-button--colored',
        onclick: model.save },
      'save'
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, cls: _styles2.default.saveButton, inner: inner });
  }
};

exports.default = {
  oninit: function oninit(vnode) {
    _model2.default.fetch();
  },
  view: function view(vnode) {
    if (_model2.default.fetched) {
      return (0, _mithril2.default)(
        'div',
        { className: 'mdl-grid' },
        (0, _mithril2.default)(_title2.default, { model: _model2.default }),
        (0, _mithril2.default)(_tags2.default, { model: _model2.default }),
        (0, _mithril2.default)(
          'div',
          { className: _styles2.default.editorWrap },
          (0, _mithril2.default)(Editor, { key: 'editor', model: _model2.default }),
          (0, _mithril2.default)(Preview, { key: 'preview', body: _model2.default.mdBody() })
        ),
        (0, _mithril2.default)(Save, { model: _model2.default })
      );
    }
    return (0, _mithril2.default)(
      'div',
      null,
      '\u30C7\u30FC\u30BF\u53D6\u5F97\u4E2D...'
    );
  }
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _component = __webpack_require__(18);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_mithril2.default.mount(document.getElementById('main'), _component2.default);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _markdownIt = __webpack_require__(28);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md = new _markdownIt2.default();
var url = '/api/articles/' + location.href.split('/').slice(4).join('/');

var Model = {
  data: {},
  fetched: false,
  fetch: function fetch() {
    return _mithril2.default.request({
      method: 'GET',
      url: url
    }).then(function (response) {
      Model.fetched = true;
      Model.data = response;
    });
  },
  save: function save() {
    return _mithril2.default.request({
      method: 'POST',
      url: url
    }).then(function (response) {
      Model.data = response;
    });
  },
  mdBody: function mdBody() {
    return md.render(Model.data.body);
  }
};

exports.default = Model;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _cell = __webpack_require__(6);

var _cell2 = _interopRequireDefault(_cell);

var _styles = __webpack_require__(89);

var _styles2 = _interopRequireDefault(_styles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.title = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.title,
      onchange: _mithril2.default.withAttr('value', vnode.state.onchange),
      value: vnode.state.model.data.title
    });
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(22);
var ieee754 = __webpack_require__(24);
var isArray = __webpack_require__(25);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//

function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(27)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(15).source;
  re.src_Cc = __webpack_require__(13).source;
  re.src_Z = __webpack_require__(14).source;
  re.src_P = __webpack_require__(5).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(34);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Just a shortcut for bulk export


exports.parseLinkLabel = __webpack_require__(32);
exports.parseLinkDestination = __webpack_require__(31);
exports.parseLinkTitle = __webpack_require__(33);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link destination
//


var isSpace = __webpack_require__(0).isSpace;
var unescapeAll = __webpack_require__(0).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
        if (level > 1) {
          break;
        }
      }

    if (code === 0x29 /* ) */) {
        level--;
        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//


module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link title
//


var unescapeAll = __webpack_require__(0).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Main parser class



var utils = __webpack_require__(0);
var helpers = __webpack_require__(30);
var Renderer = __webpack_require__(41);
var ParserCore = __webpack_require__(36);
var ParserBlock = __webpack_require__(35);
var ParserInline = __webpack_require__(37);
var LinkifyIt = __webpack_require__(26);
var mdurl = __webpack_require__(12);
var punycode = __webpack_require__(78);

var config = {
  'default': __webpack_require__(39),
  zero: __webpack_require__(40),
  commonmark: __webpack_require__(38)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/


var Ruler = __webpack_require__(3);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(53), ['paragraph', 'reference']], ['code', __webpack_require__(43)], ['fence', __webpack_require__(44), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(42), ['paragraph', 'reference', 'list']], ['hr', __webpack_require__(46), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(49), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(51)], ['heading', __webpack_require__(45), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(48)], ['html_block', __webpack_require__(47), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(50)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(52);

module.exports = ParserBlock;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/


var Ruler = __webpack_require__(3);

var _rules = [['normalize', __webpack_require__(57)], ['block', __webpack_require__(54)], ['inline', __webpack_require__(55)], ['linkify', __webpack_require__(56)], ['replacements', __webpack_require__(58)], ['smartquotes', __webpack_require__(59)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(60);

module.exports = Core;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/


var Ruler = __webpack_require__(3);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(71)], ['newline', __webpack_require__(69)], ['escape', __webpack_require__(65)], ['backticks', __webpack_require__(62)], ['strikethrough', __webpack_require__(11).tokenize], ['emphasis', __webpack_require__(10).tokenize], ['link', __webpack_require__(68)], ['image', __webpack_require__(67)], ['autolink', __webpack_require__(61)], ['html_inline', __webpack_require__(66)], ['entity', __webpack_require__(64)]];

var _rules2 = [['balance_pairs', __webpack_require__(63)], ['strikethrough', __webpack_require__(11).postProcess], ['emphasis', __webpack_require__(10).postProcess], ['text_collapse', __webpack_require__(72)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(70);

module.exports = ParserInline;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// markdown-it default options



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign = __webpack_require__(0).assign;
var unescapeAll = __webpack_require__(0).unescapeAll;
var escapeHtml = __webpack_require__(0).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without mudofying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes



var isSpace = __webpack_require__(0).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      isOutdented,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    if (isOutdented) break;

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)



var isSpace = __webpack_require__(0).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule



var isSpace = __webpack_require__(0).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block



var block_names = __webpack_require__(29);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(9).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists



var isSpace = __webpack_require__(0).isSpace;

// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finilize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class



var Token = __webpack_require__(4);
var isSpace = __webpack_require__(0).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard



var isSpace = __webpack_require__(0).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//


var arrayReplaceAt = __webpack_require__(0).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Normalize input string



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographyc replacements
//
// (c) (C) → ©
// (tm) (TM) → ™
// (r) (R) → ®
// +- → ±
// (p) (P) -> §
// ... → … (also ?.... → ?.., !.... → !..)
// ???????? → ???, !!!!! → !!!, `,,` → `,`
// -- → &ndash;, --- → &mdash;
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//


var isWhiteSpace = __webpack_require__(0).isWhiteSpace;
var isPunctChar = __webpack_require__(0).isPunctChar;
var isMdAsciiPunct = __webpack_require__(0).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Core state object
//


var Token = __webpack_require__(4);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'



/*eslint max-len:0*/

var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// For each opening emphasis-like marker find a matching closing one
//


module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities = __webpack_require__(8);
var has = __webpack_require__(0).has;
var isValidEntityCode = __webpack_require__(0).isValidEntityCode;
var fromCodePoint = __webpack_require__(0).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess escaped chars and hardbreaks



var isSpace = __webpack_require__(0).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags



var HTML_TAG_RE = __webpack_require__(9).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ![image](<src> "title")



var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [link](<to> "stuff")



var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'



var isSpace = __webpack_require__(0).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state



var Token = __webpack_require__(4);
var isWhiteSpace = __webpack_require__(0).isWhiteSpace;
var isPunctChar = __webpack_require__(0).isPunctChar;
var isMdAsciiPunct = __webpack_require__(0).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Merge adjacent text nodes into one, and re-calculate all token levels
//


module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(17)) == 'object' && __webpack_require__(17)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(84)(module), __webpack_require__(2)))

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(77)))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(79);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Any = __webpack_require__(15);
exports.Cc = __webpack_require__(13);
exports.Cf = __webpack_require__(82);
exports.P = __webpack_require__(5);
exports.Z = __webpack_require__(14);

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(7)(undefined);
// imports


// module
exports.push([module.i, "._1uPz2lT9fVqVJNBexEHKSq{width:100%;font-size:24pt;padding-left:10px}._2nS6m57p7dJjy-WwNYxzve{width:100%;font-size:18pt;padding-left:10px}._2YrKEmruSXq-LY8HT9gjcA{position:relative;width:100%;height:calc(100% - 230px)}._1KcE7rh1MKAyevd2eM_Atg{position:absolute;top:0;background:#fcfcfc;padding:10px;overflow:auto;height:100%}._2V7y6AfFLGUXuJFdleemq{left:0}._49ORhPRyX0fRDmFqS5AmZ{left:50%;background-color:#fff}._3L5NEB84KxPflxBZveysdd{text-align:right;margin-top:15px}._34UfeElUaBSa12ZpQR-aXH{width:100%;height:100%;resize:none;background-color:#fcfcfc;border:none;font-size:10pt}", ""]);

// exports
exports.locals = {
	"title": "_1uPz2lT9fVqVJNBexEHKSq",
	"tags": "_2nS6m57p7dJjy-WwNYxzve",
	"editorWrap": "_2YrKEmruSXq-LY8HT9gjcA",
	"editor": "_1KcE7rh1MKAyevd2eM_Atg",
	"editorLeftSide": "_2V7y6AfFLGUXuJFdleemq",
	"editorRightSide": "_49ORhPRyX0fRDmFqS5AmZ",
	"saveButton": "_3L5NEB84KxPflxBZveysdd",
	"textarea": "_34UfeElUaBSa12ZpQR-aXH"
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(7)(undefined);
// imports


// module
exports.push([module.i, "._1X4CyNck_1cy_XuutlaFyx{width:100%;font-size:24pt;padding-left:10px}.iJMfYsWyjdI2oWNBhyp7S{width:100%;font-size:18pt;padding-left:10px}._3THWJo1p9KnS2pCjB6ZiBz{position:relative;width:100%;height:calc(100% - 230px)}._1qWbn2cc8ew_L1JwPWUFwr{position:absolute;top:0;background:#fcfcfc;padding:10px;overflow:auto;height:100%}.CQPz0BC9iXQz81KGa0xNh{left:0}._3IxB2V68xn5MpQ7ubC1wkP{left:50%;background-color:#fff}._3uAWsMXuR08ZUpxMhtZ6Re{text-align:right;margin-top:15px}.bf86TXA2yLF158YQYu9a{width:100%;height:100%;resize:none;background-color:#fcfcfc;border:none;font-size:10pt}", ""]);

// exports
exports.locals = {
	"title": "_1X4CyNck_1cy_XuutlaFyx",
	"tags": "iJMfYsWyjdI2oWNBhyp7S",
	"editorWrap": "_3THWJo1p9KnS2pCjB6ZiBz",
	"editor": "_1qWbn2cc8ew_L1JwPWUFwr",
	"editorLeftSide": "CQPz0BC9iXQz81KGa0xNh",
	"editorRightSide": "_3IxB2V68xn5MpQ7ubC1wkP",
	"saveButton": "_3uAWsMXuR08ZUpxMhtZ6Re",
	"textarea": "bf86TXA2yLF158YQYu9a"
};

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = {
	"Aacute": "Á",
	"aacute": "á",
	"Abreve": "Ă",
	"abreve": "ă",
	"ac": "∾",
	"acd": "∿",
	"acE": "∾̳",
	"Acirc": "Â",
	"acirc": "â",
	"acute": "´",
	"Acy": "А",
	"acy": "а",
	"AElig": "Æ",
	"aelig": "æ",
	"af": "⁡",
	"Afr": "𝔄",
	"afr": "𝔞",
	"Agrave": "À",
	"agrave": "à",
	"alefsym": "ℵ",
	"aleph": "ℵ",
	"Alpha": "Α",
	"alpha": "α",
	"Amacr": "Ā",
	"amacr": "ā",
	"amalg": "⨿",
	"amp": "&",
	"AMP": "&",
	"andand": "⩕",
	"And": "⩓",
	"and": "∧",
	"andd": "⩜",
	"andslope": "⩘",
	"andv": "⩚",
	"ang": "∠",
	"ange": "⦤",
	"angle": "∠",
	"angmsdaa": "⦨",
	"angmsdab": "⦩",
	"angmsdac": "⦪",
	"angmsdad": "⦫",
	"angmsdae": "⦬",
	"angmsdaf": "⦭",
	"angmsdag": "⦮",
	"angmsdah": "⦯",
	"angmsd": "∡",
	"angrt": "∟",
	"angrtvb": "⊾",
	"angrtvbd": "⦝",
	"angsph": "∢",
	"angst": "Å",
	"angzarr": "⍼",
	"Aogon": "Ą",
	"aogon": "ą",
	"Aopf": "𝔸",
	"aopf": "𝕒",
	"apacir": "⩯",
	"ap": "≈",
	"apE": "⩰",
	"ape": "≊",
	"apid": "≋",
	"apos": "'",
	"ApplyFunction": "⁡",
	"approx": "≈",
	"approxeq": "≊",
	"Aring": "Å",
	"aring": "å",
	"Ascr": "𝒜",
	"ascr": "𝒶",
	"Assign": "≔",
	"ast": "*",
	"asymp": "≈",
	"asympeq": "≍",
	"Atilde": "Ã",
	"atilde": "ã",
	"Auml": "Ä",
	"auml": "ä",
	"awconint": "∳",
	"awint": "⨑",
	"backcong": "≌",
	"backepsilon": "϶",
	"backprime": "‵",
	"backsim": "∽",
	"backsimeq": "⋍",
	"Backslash": "∖",
	"Barv": "⫧",
	"barvee": "⊽",
	"barwed": "⌅",
	"Barwed": "⌆",
	"barwedge": "⌅",
	"bbrk": "⎵",
	"bbrktbrk": "⎶",
	"bcong": "≌",
	"Bcy": "Б",
	"bcy": "б",
	"bdquo": "„",
	"becaus": "∵",
	"because": "∵",
	"Because": "∵",
	"bemptyv": "⦰",
	"bepsi": "϶",
	"bernou": "ℬ",
	"Bernoullis": "ℬ",
	"Beta": "Β",
	"beta": "β",
	"beth": "ℶ",
	"between": "≬",
	"Bfr": "𝔅",
	"bfr": "𝔟",
	"bigcap": "⋂",
	"bigcirc": "◯",
	"bigcup": "⋃",
	"bigodot": "⨀",
	"bigoplus": "⨁",
	"bigotimes": "⨂",
	"bigsqcup": "⨆",
	"bigstar": "★",
	"bigtriangledown": "▽",
	"bigtriangleup": "△",
	"biguplus": "⨄",
	"bigvee": "⋁",
	"bigwedge": "⋀",
	"bkarow": "⤍",
	"blacklozenge": "⧫",
	"blacksquare": "▪",
	"blacktriangle": "▴",
	"blacktriangledown": "▾",
	"blacktriangleleft": "◂",
	"blacktriangleright": "▸",
	"blank": "␣",
	"blk12": "▒",
	"blk14": "░",
	"blk34": "▓",
	"block": "█",
	"bne": "=⃥",
	"bnequiv": "≡⃥",
	"bNot": "⫭",
	"bnot": "⌐",
	"Bopf": "𝔹",
	"bopf": "𝕓",
	"bot": "⊥",
	"bottom": "⊥",
	"bowtie": "⋈",
	"boxbox": "⧉",
	"boxdl": "┐",
	"boxdL": "╕",
	"boxDl": "╖",
	"boxDL": "╗",
	"boxdr": "┌",
	"boxdR": "╒",
	"boxDr": "╓",
	"boxDR": "╔",
	"boxh": "─",
	"boxH": "═",
	"boxhd": "┬",
	"boxHd": "╤",
	"boxhD": "╥",
	"boxHD": "╦",
	"boxhu": "┴",
	"boxHu": "╧",
	"boxhU": "╨",
	"boxHU": "╩",
	"boxminus": "⊟",
	"boxplus": "⊞",
	"boxtimes": "⊠",
	"boxul": "┘",
	"boxuL": "╛",
	"boxUl": "╜",
	"boxUL": "╝",
	"boxur": "└",
	"boxuR": "╘",
	"boxUr": "╙",
	"boxUR": "╚",
	"boxv": "│",
	"boxV": "║",
	"boxvh": "┼",
	"boxvH": "╪",
	"boxVh": "╫",
	"boxVH": "╬",
	"boxvl": "┤",
	"boxvL": "╡",
	"boxVl": "╢",
	"boxVL": "╣",
	"boxvr": "├",
	"boxvR": "╞",
	"boxVr": "╟",
	"boxVR": "╠",
	"bprime": "‵",
	"breve": "˘",
	"Breve": "˘",
	"brvbar": "¦",
	"bscr": "𝒷",
	"Bscr": "ℬ",
	"bsemi": "⁏",
	"bsim": "∽",
	"bsime": "⋍",
	"bsolb": "⧅",
	"bsol": "\\",
	"bsolhsub": "⟈",
	"bull": "•",
	"bullet": "•",
	"bump": "≎",
	"bumpE": "⪮",
	"bumpe": "≏",
	"Bumpeq": "≎",
	"bumpeq": "≏",
	"Cacute": "Ć",
	"cacute": "ć",
	"capand": "⩄",
	"capbrcup": "⩉",
	"capcap": "⩋",
	"cap": "∩",
	"Cap": "⋒",
	"capcup": "⩇",
	"capdot": "⩀",
	"CapitalDifferentialD": "ⅅ",
	"caps": "∩︀",
	"caret": "⁁",
	"caron": "ˇ",
	"Cayleys": "ℭ",
	"ccaps": "⩍",
	"Ccaron": "Č",
	"ccaron": "č",
	"Ccedil": "Ç",
	"ccedil": "ç",
	"Ccirc": "Ĉ",
	"ccirc": "ĉ",
	"Cconint": "∰",
	"ccups": "⩌",
	"ccupssm": "⩐",
	"Cdot": "Ċ",
	"cdot": "ċ",
	"cedil": "¸",
	"Cedilla": "¸",
	"cemptyv": "⦲",
	"cent": "¢",
	"centerdot": "·",
	"CenterDot": "·",
	"cfr": "𝔠",
	"Cfr": "ℭ",
	"CHcy": "Ч",
	"chcy": "ч",
	"check": "✓",
	"checkmark": "✓",
	"Chi": "Χ",
	"chi": "χ",
	"circ": "ˆ",
	"circeq": "≗",
	"circlearrowleft": "↺",
	"circlearrowright": "↻",
	"circledast": "⊛",
	"circledcirc": "⊚",
	"circleddash": "⊝",
	"CircleDot": "⊙",
	"circledR": "®",
	"circledS": "Ⓢ",
	"CircleMinus": "⊖",
	"CirclePlus": "⊕",
	"CircleTimes": "⊗",
	"cir": "○",
	"cirE": "⧃",
	"cire": "≗",
	"cirfnint": "⨐",
	"cirmid": "⫯",
	"cirscir": "⧂",
	"ClockwiseContourIntegral": "∲",
	"CloseCurlyDoubleQuote": "”",
	"CloseCurlyQuote": "’",
	"clubs": "♣",
	"clubsuit": "♣",
	"colon": ":",
	"Colon": "∷",
	"Colone": "⩴",
	"colone": "≔",
	"coloneq": "≔",
	"comma": ",",
	"commat": "@",
	"comp": "∁",
	"compfn": "∘",
	"complement": "∁",
	"complexes": "ℂ",
	"cong": "≅",
	"congdot": "⩭",
	"Congruent": "≡",
	"conint": "∮",
	"Conint": "∯",
	"ContourIntegral": "∮",
	"copf": "𝕔",
	"Copf": "ℂ",
	"coprod": "∐",
	"Coproduct": "∐",
	"copy": "©",
	"COPY": "©",
	"copysr": "℗",
	"CounterClockwiseContourIntegral": "∳",
	"crarr": "↵",
	"cross": "✗",
	"Cross": "⨯",
	"Cscr": "𝒞",
	"cscr": "𝒸",
	"csub": "⫏",
	"csube": "⫑",
	"csup": "⫐",
	"csupe": "⫒",
	"ctdot": "⋯",
	"cudarrl": "⤸",
	"cudarrr": "⤵",
	"cuepr": "⋞",
	"cuesc": "⋟",
	"cularr": "↶",
	"cularrp": "⤽",
	"cupbrcap": "⩈",
	"cupcap": "⩆",
	"CupCap": "≍",
	"cup": "∪",
	"Cup": "⋓",
	"cupcup": "⩊",
	"cupdot": "⊍",
	"cupor": "⩅",
	"cups": "∪︀",
	"curarr": "↷",
	"curarrm": "⤼",
	"curlyeqprec": "⋞",
	"curlyeqsucc": "⋟",
	"curlyvee": "⋎",
	"curlywedge": "⋏",
	"curren": "¤",
	"curvearrowleft": "↶",
	"curvearrowright": "↷",
	"cuvee": "⋎",
	"cuwed": "⋏",
	"cwconint": "∲",
	"cwint": "∱",
	"cylcty": "⌭",
	"dagger": "†",
	"Dagger": "‡",
	"daleth": "ℸ",
	"darr": "↓",
	"Darr": "↡",
	"dArr": "⇓",
	"dash": "‐",
	"Dashv": "⫤",
	"dashv": "⊣",
	"dbkarow": "⤏",
	"dblac": "˝",
	"Dcaron": "Ď",
	"dcaron": "ď",
	"Dcy": "Д",
	"dcy": "д",
	"ddagger": "‡",
	"ddarr": "⇊",
	"DD": "ⅅ",
	"dd": "ⅆ",
	"DDotrahd": "⤑",
	"ddotseq": "⩷",
	"deg": "°",
	"Del": "∇",
	"Delta": "Δ",
	"delta": "δ",
	"demptyv": "⦱",
	"dfisht": "⥿",
	"Dfr": "𝔇",
	"dfr": "𝔡",
	"dHar": "⥥",
	"dharl": "⇃",
	"dharr": "⇂",
	"DiacriticalAcute": "´",
	"DiacriticalDot": "˙",
	"DiacriticalDoubleAcute": "˝",
	"DiacriticalGrave": "`",
	"DiacriticalTilde": "˜",
	"diam": "⋄",
	"diamond": "⋄",
	"Diamond": "⋄",
	"diamondsuit": "♦",
	"diams": "♦",
	"die": "¨",
	"DifferentialD": "ⅆ",
	"digamma": "ϝ",
	"disin": "⋲",
	"div": "÷",
	"divide": "÷",
	"divideontimes": "⋇",
	"divonx": "⋇",
	"DJcy": "Ђ",
	"djcy": "ђ",
	"dlcorn": "⌞",
	"dlcrop": "⌍",
	"dollar": "$",
	"Dopf": "𝔻",
	"dopf": "𝕕",
	"Dot": "¨",
	"dot": "˙",
	"DotDot": "⃜",
	"doteq": "≐",
	"doteqdot": "≑",
	"DotEqual": "≐",
	"dotminus": "∸",
	"dotplus": "∔",
	"dotsquare": "⊡",
	"doublebarwedge": "⌆",
	"DoubleContourIntegral": "∯",
	"DoubleDot": "¨",
	"DoubleDownArrow": "⇓",
	"DoubleLeftArrow": "⇐",
	"DoubleLeftRightArrow": "⇔",
	"DoubleLeftTee": "⫤",
	"DoubleLongLeftArrow": "⟸",
	"DoubleLongLeftRightArrow": "⟺",
	"DoubleLongRightArrow": "⟹",
	"DoubleRightArrow": "⇒",
	"DoubleRightTee": "⊨",
	"DoubleUpArrow": "⇑",
	"DoubleUpDownArrow": "⇕",
	"DoubleVerticalBar": "∥",
	"DownArrowBar": "⤓",
	"downarrow": "↓",
	"DownArrow": "↓",
	"Downarrow": "⇓",
	"DownArrowUpArrow": "⇵",
	"DownBreve": "̑",
	"downdownarrows": "⇊",
	"downharpoonleft": "⇃",
	"downharpoonright": "⇂",
	"DownLeftRightVector": "⥐",
	"DownLeftTeeVector": "⥞",
	"DownLeftVectorBar": "⥖",
	"DownLeftVector": "↽",
	"DownRightTeeVector": "⥟",
	"DownRightVectorBar": "⥗",
	"DownRightVector": "⇁",
	"DownTeeArrow": "↧",
	"DownTee": "⊤",
	"drbkarow": "⤐",
	"drcorn": "⌟",
	"drcrop": "⌌",
	"Dscr": "𝒟",
	"dscr": "𝒹",
	"DScy": "Ѕ",
	"dscy": "ѕ",
	"dsol": "⧶",
	"Dstrok": "Đ",
	"dstrok": "đ",
	"dtdot": "⋱",
	"dtri": "▿",
	"dtrif": "▾",
	"duarr": "⇵",
	"duhar": "⥯",
	"dwangle": "⦦",
	"DZcy": "Џ",
	"dzcy": "џ",
	"dzigrarr": "⟿",
	"Eacute": "É",
	"eacute": "é",
	"easter": "⩮",
	"Ecaron": "Ě",
	"ecaron": "ě",
	"Ecirc": "Ê",
	"ecirc": "ê",
	"ecir": "≖",
	"ecolon": "≕",
	"Ecy": "Э",
	"ecy": "э",
	"eDDot": "⩷",
	"Edot": "Ė",
	"edot": "ė",
	"eDot": "≑",
	"ee": "ⅇ",
	"efDot": "≒",
	"Efr": "𝔈",
	"efr": "𝔢",
	"eg": "⪚",
	"Egrave": "È",
	"egrave": "è",
	"egs": "⪖",
	"egsdot": "⪘",
	"el": "⪙",
	"Element": "∈",
	"elinters": "⏧",
	"ell": "ℓ",
	"els": "⪕",
	"elsdot": "⪗",
	"Emacr": "Ē",
	"emacr": "ē",
	"empty": "∅",
	"emptyset": "∅",
	"EmptySmallSquare": "◻",
	"emptyv": "∅",
	"EmptyVerySmallSquare": "▫",
	"emsp13": " ",
	"emsp14": " ",
	"emsp": " ",
	"ENG": "Ŋ",
	"eng": "ŋ",
	"ensp": " ",
	"Eogon": "Ę",
	"eogon": "ę",
	"Eopf": "𝔼",
	"eopf": "𝕖",
	"epar": "⋕",
	"eparsl": "⧣",
	"eplus": "⩱",
	"epsi": "ε",
	"Epsilon": "Ε",
	"epsilon": "ε",
	"epsiv": "ϵ",
	"eqcirc": "≖",
	"eqcolon": "≕",
	"eqsim": "≂",
	"eqslantgtr": "⪖",
	"eqslantless": "⪕",
	"Equal": "⩵",
	"equals": "=",
	"EqualTilde": "≂",
	"equest": "≟",
	"Equilibrium": "⇌",
	"equiv": "≡",
	"equivDD": "⩸",
	"eqvparsl": "⧥",
	"erarr": "⥱",
	"erDot": "≓",
	"escr": "ℯ",
	"Escr": "ℰ",
	"esdot": "≐",
	"Esim": "⩳",
	"esim": "≂",
	"Eta": "Η",
	"eta": "η",
	"ETH": "Ð",
	"eth": "ð",
	"Euml": "Ë",
	"euml": "ë",
	"euro": "€",
	"excl": "!",
	"exist": "∃",
	"Exists": "∃",
	"expectation": "ℰ",
	"exponentiale": "ⅇ",
	"ExponentialE": "ⅇ",
	"fallingdotseq": "≒",
	"Fcy": "Ф",
	"fcy": "ф",
	"female": "♀",
	"ffilig": "ﬃ",
	"fflig": "ﬀ",
	"ffllig": "ﬄ",
	"Ffr": "𝔉",
	"ffr": "𝔣",
	"filig": "ﬁ",
	"FilledSmallSquare": "◼",
	"FilledVerySmallSquare": "▪",
	"fjlig": "fj",
	"flat": "♭",
	"fllig": "ﬂ",
	"fltns": "▱",
	"fnof": "ƒ",
	"Fopf": "𝔽",
	"fopf": "𝕗",
	"forall": "∀",
	"ForAll": "∀",
	"fork": "⋔",
	"forkv": "⫙",
	"Fouriertrf": "ℱ",
	"fpartint": "⨍",
	"frac12": "½",
	"frac13": "⅓",
	"frac14": "¼",
	"frac15": "⅕",
	"frac16": "⅙",
	"frac18": "⅛",
	"frac23": "⅔",
	"frac25": "⅖",
	"frac34": "¾",
	"frac35": "⅗",
	"frac38": "⅜",
	"frac45": "⅘",
	"frac56": "⅚",
	"frac58": "⅝",
	"frac78": "⅞",
	"frasl": "⁄",
	"frown": "⌢",
	"fscr": "𝒻",
	"Fscr": "ℱ",
	"gacute": "ǵ",
	"Gamma": "Γ",
	"gamma": "γ",
	"Gammad": "Ϝ",
	"gammad": "ϝ",
	"gap": "⪆",
	"Gbreve": "Ğ",
	"gbreve": "ğ",
	"Gcedil": "Ģ",
	"Gcirc": "Ĝ",
	"gcirc": "ĝ",
	"Gcy": "Г",
	"gcy": "г",
	"Gdot": "Ġ",
	"gdot": "ġ",
	"ge": "≥",
	"gE": "≧",
	"gEl": "⪌",
	"gel": "⋛",
	"geq": "≥",
	"geqq": "≧",
	"geqslant": "⩾",
	"gescc": "⪩",
	"ges": "⩾",
	"gesdot": "⪀",
	"gesdoto": "⪂",
	"gesdotol": "⪄",
	"gesl": "⋛︀",
	"gesles": "⪔",
	"Gfr": "𝔊",
	"gfr": "𝔤",
	"gg": "≫",
	"Gg": "⋙",
	"ggg": "⋙",
	"gimel": "ℷ",
	"GJcy": "Ѓ",
	"gjcy": "ѓ",
	"gla": "⪥",
	"gl": "≷",
	"glE": "⪒",
	"glj": "⪤",
	"gnap": "⪊",
	"gnapprox": "⪊",
	"gne": "⪈",
	"gnE": "≩",
	"gneq": "⪈",
	"gneqq": "≩",
	"gnsim": "⋧",
	"Gopf": "𝔾",
	"gopf": "𝕘",
	"grave": "`",
	"GreaterEqual": "≥",
	"GreaterEqualLess": "⋛",
	"GreaterFullEqual": "≧",
	"GreaterGreater": "⪢",
	"GreaterLess": "≷",
	"GreaterSlantEqual": "⩾",
	"GreaterTilde": "≳",
	"Gscr": "𝒢",
	"gscr": "ℊ",
	"gsim": "≳",
	"gsime": "⪎",
	"gsiml": "⪐",
	"gtcc": "⪧",
	"gtcir": "⩺",
	"gt": ">",
	"GT": ">",
	"Gt": "≫",
	"gtdot": "⋗",
	"gtlPar": "⦕",
	"gtquest": "⩼",
	"gtrapprox": "⪆",
	"gtrarr": "⥸",
	"gtrdot": "⋗",
	"gtreqless": "⋛",
	"gtreqqless": "⪌",
	"gtrless": "≷",
	"gtrsim": "≳",
	"gvertneqq": "≩︀",
	"gvnE": "≩︀",
	"Hacek": "ˇ",
	"hairsp": " ",
	"half": "½",
	"hamilt": "ℋ",
	"HARDcy": "Ъ",
	"hardcy": "ъ",
	"harrcir": "⥈",
	"harr": "↔",
	"hArr": "⇔",
	"harrw": "↭",
	"Hat": "^",
	"hbar": "ℏ",
	"Hcirc": "Ĥ",
	"hcirc": "ĥ",
	"hearts": "♥",
	"heartsuit": "♥",
	"hellip": "…",
	"hercon": "⊹",
	"hfr": "𝔥",
	"Hfr": "ℌ",
	"HilbertSpace": "ℋ",
	"hksearow": "⤥",
	"hkswarow": "⤦",
	"hoarr": "⇿",
	"homtht": "∻",
	"hookleftarrow": "↩",
	"hookrightarrow": "↪",
	"hopf": "𝕙",
	"Hopf": "ℍ",
	"horbar": "―",
	"HorizontalLine": "─",
	"hscr": "𝒽",
	"Hscr": "ℋ",
	"hslash": "ℏ",
	"Hstrok": "Ħ",
	"hstrok": "ħ",
	"HumpDownHump": "≎",
	"HumpEqual": "≏",
	"hybull": "⁃",
	"hyphen": "‐",
	"Iacute": "Í",
	"iacute": "í",
	"ic": "⁣",
	"Icirc": "Î",
	"icirc": "î",
	"Icy": "И",
	"icy": "и",
	"Idot": "İ",
	"IEcy": "Е",
	"iecy": "е",
	"iexcl": "¡",
	"iff": "⇔",
	"ifr": "𝔦",
	"Ifr": "ℑ",
	"Igrave": "Ì",
	"igrave": "ì",
	"ii": "ⅈ",
	"iiiint": "⨌",
	"iiint": "∭",
	"iinfin": "⧜",
	"iiota": "℩",
	"IJlig": "Ĳ",
	"ijlig": "ĳ",
	"Imacr": "Ī",
	"imacr": "ī",
	"image": "ℑ",
	"ImaginaryI": "ⅈ",
	"imagline": "ℐ",
	"imagpart": "ℑ",
	"imath": "ı",
	"Im": "ℑ",
	"imof": "⊷",
	"imped": "Ƶ",
	"Implies": "⇒",
	"incare": "℅",
	"in": "∈",
	"infin": "∞",
	"infintie": "⧝",
	"inodot": "ı",
	"intcal": "⊺",
	"int": "∫",
	"Int": "∬",
	"integers": "ℤ",
	"Integral": "∫",
	"intercal": "⊺",
	"Intersection": "⋂",
	"intlarhk": "⨗",
	"intprod": "⨼",
	"InvisibleComma": "⁣",
	"InvisibleTimes": "⁢",
	"IOcy": "Ё",
	"iocy": "ё",
	"Iogon": "Į",
	"iogon": "į",
	"Iopf": "𝕀",
	"iopf": "𝕚",
	"Iota": "Ι",
	"iota": "ι",
	"iprod": "⨼",
	"iquest": "¿",
	"iscr": "𝒾",
	"Iscr": "ℐ",
	"isin": "∈",
	"isindot": "⋵",
	"isinE": "⋹",
	"isins": "⋴",
	"isinsv": "⋳",
	"isinv": "∈",
	"it": "⁢",
	"Itilde": "Ĩ",
	"itilde": "ĩ",
	"Iukcy": "І",
	"iukcy": "і",
	"Iuml": "Ï",
	"iuml": "ï",
	"Jcirc": "Ĵ",
	"jcirc": "ĵ",
	"Jcy": "Й",
	"jcy": "й",
	"Jfr": "𝔍",
	"jfr": "𝔧",
	"jmath": "ȷ",
	"Jopf": "𝕁",
	"jopf": "𝕛",
	"Jscr": "𝒥",
	"jscr": "𝒿",
	"Jsercy": "Ј",
	"jsercy": "ј",
	"Jukcy": "Є",
	"jukcy": "є",
	"Kappa": "Κ",
	"kappa": "κ",
	"kappav": "ϰ",
	"Kcedil": "Ķ",
	"kcedil": "ķ",
	"Kcy": "К",
	"kcy": "к",
	"Kfr": "𝔎",
	"kfr": "𝔨",
	"kgreen": "ĸ",
	"KHcy": "Х",
	"khcy": "х",
	"KJcy": "Ќ",
	"kjcy": "ќ",
	"Kopf": "𝕂",
	"kopf": "𝕜",
	"Kscr": "𝒦",
	"kscr": "𝓀",
	"lAarr": "⇚",
	"Lacute": "Ĺ",
	"lacute": "ĺ",
	"laemptyv": "⦴",
	"lagran": "ℒ",
	"Lambda": "Λ",
	"lambda": "λ",
	"lang": "⟨",
	"Lang": "⟪",
	"langd": "⦑",
	"langle": "⟨",
	"lap": "⪅",
	"Laplacetrf": "ℒ",
	"laquo": "«",
	"larrb": "⇤",
	"larrbfs": "⤟",
	"larr": "←",
	"Larr": "↞",
	"lArr": "⇐",
	"larrfs": "⤝",
	"larrhk": "↩",
	"larrlp": "↫",
	"larrpl": "⤹",
	"larrsim": "⥳",
	"larrtl": "↢",
	"latail": "⤙",
	"lAtail": "⤛",
	"lat": "⪫",
	"late": "⪭",
	"lates": "⪭︀",
	"lbarr": "⤌",
	"lBarr": "⤎",
	"lbbrk": "❲",
	"lbrace": "{",
	"lbrack": "[",
	"lbrke": "⦋",
	"lbrksld": "⦏",
	"lbrkslu": "⦍",
	"Lcaron": "Ľ",
	"lcaron": "ľ",
	"Lcedil": "Ļ",
	"lcedil": "ļ",
	"lceil": "⌈",
	"lcub": "{",
	"Lcy": "Л",
	"lcy": "л",
	"ldca": "⤶",
	"ldquo": "“",
	"ldquor": "„",
	"ldrdhar": "⥧",
	"ldrushar": "⥋",
	"ldsh": "↲",
	"le": "≤",
	"lE": "≦",
	"LeftAngleBracket": "⟨",
	"LeftArrowBar": "⇤",
	"leftarrow": "←",
	"LeftArrow": "←",
	"Leftarrow": "⇐",
	"LeftArrowRightArrow": "⇆",
	"leftarrowtail": "↢",
	"LeftCeiling": "⌈",
	"LeftDoubleBracket": "⟦",
	"LeftDownTeeVector": "⥡",
	"LeftDownVectorBar": "⥙",
	"LeftDownVector": "⇃",
	"LeftFloor": "⌊",
	"leftharpoondown": "↽",
	"leftharpoonup": "↼",
	"leftleftarrows": "⇇",
	"leftrightarrow": "↔",
	"LeftRightArrow": "↔",
	"Leftrightarrow": "⇔",
	"leftrightarrows": "⇆",
	"leftrightharpoons": "⇋",
	"leftrightsquigarrow": "↭",
	"LeftRightVector": "⥎",
	"LeftTeeArrow": "↤",
	"LeftTee": "⊣",
	"LeftTeeVector": "⥚",
	"leftthreetimes": "⋋",
	"LeftTriangleBar": "⧏",
	"LeftTriangle": "⊲",
	"LeftTriangleEqual": "⊴",
	"LeftUpDownVector": "⥑",
	"LeftUpTeeVector": "⥠",
	"LeftUpVectorBar": "⥘",
	"LeftUpVector": "↿",
	"LeftVectorBar": "⥒",
	"LeftVector": "↼",
	"lEg": "⪋",
	"leg": "⋚",
	"leq": "≤",
	"leqq": "≦",
	"leqslant": "⩽",
	"lescc": "⪨",
	"les": "⩽",
	"lesdot": "⩿",
	"lesdoto": "⪁",
	"lesdotor": "⪃",
	"lesg": "⋚︀",
	"lesges": "⪓",
	"lessapprox": "⪅",
	"lessdot": "⋖",
	"lesseqgtr": "⋚",
	"lesseqqgtr": "⪋",
	"LessEqualGreater": "⋚",
	"LessFullEqual": "≦",
	"LessGreater": "≶",
	"lessgtr": "≶",
	"LessLess": "⪡",
	"lesssim": "≲",
	"LessSlantEqual": "⩽",
	"LessTilde": "≲",
	"lfisht": "⥼",
	"lfloor": "⌊",
	"Lfr": "𝔏",
	"lfr": "𝔩",
	"lg": "≶",
	"lgE": "⪑",
	"lHar": "⥢",
	"lhard": "↽",
	"lharu": "↼",
	"lharul": "⥪",
	"lhblk": "▄",
	"LJcy": "Љ",
	"ljcy": "љ",
	"llarr": "⇇",
	"ll": "≪",
	"Ll": "⋘",
	"llcorner": "⌞",
	"Lleftarrow": "⇚",
	"llhard": "⥫",
	"lltri": "◺",
	"Lmidot": "Ŀ",
	"lmidot": "ŀ",
	"lmoustache": "⎰",
	"lmoust": "⎰",
	"lnap": "⪉",
	"lnapprox": "⪉",
	"lne": "⪇",
	"lnE": "≨",
	"lneq": "⪇",
	"lneqq": "≨",
	"lnsim": "⋦",
	"loang": "⟬",
	"loarr": "⇽",
	"lobrk": "⟦",
	"longleftarrow": "⟵",
	"LongLeftArrow": "⟵",
	"Longleftarrow": "⟸",
	"longleftrightarrow": "⟷",
	"LongLeftRightArrow": "⟷",
	"Longleftrightarrow": "⟺",
	"longmapsto": "⟼",
	"longrightarrow": "⟶",
	"LongRightArrow": "⟶",
	"Longrightarrow": "⟹",
	"looparrowleft": "↫",
	"looparrowright": "↬",
	"lopar": "⦅",
	"Lopf": "𝕃",
	"lopf": "𝕝",
	"loplus": "⨭",
	"lotimes": "⨴",
	"lowast": "∗",
	"lowbar": "_",
	"LowerLeftArrow": "↙",
	"LowerRightArrow": "↘",
	"loz": "◊",
	"lozenge": "◊",
	"lozf": "⧫",
	"lpar": "(",
	"lparlt": "⦓",
	"lrarr": "⇆",
	"lrcorner": "⌟",
	"lrhar": "⇋",
	"lrhard": "⥭",
	"lrm": "‎",
	"lrtri": "⊿",
	"lsaquo": "‹",
	"lscr": "𝓁",
	"Lscr": "ℒ",
	"lsh": "↰",
	"Lsh": "↰",
	"lsim": "≲",
	"lsime": "⪍",
	"lsimg": "⪏",
	"lsqb": "[",
	"lsquo": "‘",
	"lsquor": "‚",
	"Lstrok": "Ł",
	"lstrok": "ł",
	"ltcc": "⪦",
	"ltcir": "⩹",
	"lt": "<",
	"LT": "<",
	"Lt": "≪",
	"ltdot": "⋖",
	"lthree": "⋋",
	"ltimes": "⋉",
	"ltlarr": "⥶",
	"ltquest": "⩻",
	"ltri": "◃",
	"ltrie": "⊴",
	"ltrif": "◂",
	"ltrPar": "⦖",
	"lurdshar": "⥊",
	"luruhar": "⥦",
	"lvertneqq": "≨︀",
	"lvnE": "≨︀",
	"macr": "¯",
	"male": "♂",
	"malt": "✠",
	"maltese": "✠",
	"Map": "⤅",
	"map": "↦",
	"mapsto": "↦",
	"mapstodown": "↧",
	"mapstoleft": "↤",
	"mapstoup": "↥",
	"marker": "▮",
	"mcomma": "⨩",
	"Mcy": "М",
	"mcy": "м",
	"mdash": "—",
	"mDDot": "∺",
	"measuredangle": "∡",
	"MediumSpace": " ",
	"Mellintrf": "ℳ",
	"Mfr": "𝔐",
	"mfr": "𝔪",
	"mho": "℧",
	"micro": "µ",
	"midast": "*",
	"midcir": "⫰",
	"mid": "∣",
	"middot": "·",
	"minusb": "⊟",
	"minus": "−",
	"minusd": "∸",
	"minusdu": "⨪",
	"MinusPlus": "∓",
	"mlcp": "⫛",
	"mldr": "…",
	"mnplus": "∓",
	"models": "⊧",
	"Mopf": "𝕄",
	"mopf": "𝕞",
	"mp": "∓",
	"mscr": "𝓂",
	"Mscr": "ℳ",
	"mstpos": "∾",
	"Mu": "Μ",
	"mu": "μ",
	"multimap": "⊸",
	"mumap": "⊸",
	"nabla": "∇",
	"Nacute": "Ń",
	"nacute": "ń",
	"nang": "∠⃒",
	"nap": "≉",
	"napE": "⩰̸",
	"napid": "≋̸",
	"napos": "ŉ",
	"napprox": "≉",
	"natural": "♮",
	"naturals": "ℕ",
	"natur": "♮",
	"nbsp": " ",
	"nbump": "≎̸",
	"nbumpe": "≏̸",
	"ncap": "⩃",
	"Ncaron": "Ň",
	"ncaron": "ň",
	"Ncedil": "Ņ",
	"ncedil": "ņ",
	"ncong": "≇",
	"ncongdot": "⩭̸",
	"ncup": "⩂",
	"Ncy": "Н",
	"ncy": "н",
	"ndash": "–",
	"nearhk": "⤤",
	"nearr": "↗",
	"neArr": "⇗",
	"nearrow": "↗",
	"ne": "≠",
	"nedot": "≐̸",
	"NegativeMediumSpace": "​",
	"NegativeThickSpace": "​",
	"NegativeThinSpace": "​",
	"NegativeVeryThinSpace": "​",
	"nequiv": "≢",
	"nesear": "⤨",
	"nesim": "≂̸",
	"NestedGreaterGreater": "≫",
	"NestedLessLess": "≪",
	"NewLine": "\n",
	"nexist": "∄",
	"nexists": "∄",
	"Nfr": "𝔑",
	"nfr": "𝔫",
	"ngE": "≧̸",
	"nge": "≱",
	"ngeq": "≱",
	"ngeqq": "≧̸",
	"ngeqslant": "⩾̸",
	"nges": "⩾̸",
	"nGg": "⋙̸",
	"ngsim": "≵",
	"nGt": "≫⃒",
	"ngt": "≯",
	"ngtr": "≯",
	"nGtv": "≫̸",
	"nharr": "↮",
	"nhArr": "⇎",
	"nhpar": "⫲",
	"ni": "∋",
	"nis": "⋼",
	"nisd": "⋺",
	"niv": "∋",
	"NJcy": "Њ",
	"njcy": "њ",
	"nlarr": "↚",
	"nlArr": "⇍",
	"nldr": "‥",
	"nlE": "≦̸",
	"nle": "≰",
	"nleftarrow": "↚",
	"nLeftarrow": "⇍",
	"nleftrightarrow": "↮",
	"nLeftrightarrow": "⇎",
	"nleq": "≰",
	"nleqq": "≦̸",
	"nleqslant": "⩽̸",
	"nles": "⩽̸",
	"nless": "≮",
	"nLl": "⋘̸",
	"nlsim": "≴",
	"nLt": "≪⃒",
	"nlt": "≮",
	"nltri": "⋪",
	"nltrie": "⋬",
	"nLtv": "≪̸",
	"nmid": "∤",
	"NoBreak": "⁠",
	"NonBreakingSpace": " ",
	"nopf": "𝕟",
	"Nopf": "ℕ",
	"Not": "⫬",
	"not": "¬",
	"NotCongruent": "≢",
	"NotCupCap": "≭",
	"NotDoubleVerticalBar": "∦",
	"NotElement": "∉",
	"NotEqual": "≠",
	"NotEqualTilde": "≂̸",
	"NotExists": "∄",
	"NotGreater": "≯",
	"NotGreaterEqual": "≱",
	"NotGreaterFullEqual": "≧̸",
	"NotGreaterGreater": "≫̸",
	"NotGreaterLess": "≹",
	"NotGreaterSlantEqual": "⩾̸",
	"NotGreaterTilde": "≵",
	"NotHumpDownHump": "≎̸",
	"NotHumpEqual": "≏̸",
	"notin": "∉",
	"notindot": "⋵̸",
	"notinE": "⋹̸",
	"notinva": "∉",
	"notinvb": "⋷",
	"notinvc": "⋶",
	"NotLeftTriangleBar": "⧏̸",
	"NotLeftTriangle": "⋪",
	"NotLeftTriangleEqual": "⋬",
	"NotLess": "≮",
	"NotLessEqual": "≰",
	"NotLessGreater": "≸",
	"NotLessLess": "≪̸",
	"NotLessSlantEqual": "⩽̸",
	"NotLessTilde": "≴",
	"NotNestedGreaterGreater": "⪢̸",
	"NotNestedLessLess": "⪡̸",
	"notni": "∌",
	"notniva": "∌",
	"notnivb": "⋾",
	"notnivc": "⋽",
	"NotPrecedes": "⊀",
	"NotPrecedesEqual": "⪯̸",
	"NotPrecedesSlantEqual": "⋠",
	"NotReverseElement": "∌",
	"NotRightTriangleBar": "⧐̸",
	"NotRightTriangle": "⋫",
	"NotRightTriangleEqual": "⋭",
	"NotSquareSubset": "⊏̸",
	"NotSquareSubsetEqual": "⋢",
	"NotSquareSuperset": "⊐̸",
	"NotSquareSupersetEqual": "⋣",
	"NotSubset": "⊂⃒",
	"NotSubsetEqual": "⊈",
	"NotSucceeds": "⊁",
	"NotSucceedsEqual": "⪰̸",
	"NotSucceedsSlantEqual": "⋡",
	"NotSucceedsTilde": "≿̸",
	"NotSuperset": "⊃⃒",
	"NotSupersetEqual": "⊉",
	"NotTilde": "≁",
	"NotTildeEqual": "≄",
	"NotTildeFullEqual": "≇",
	"NotTildeTilde": "≉",
	"NotVerticalBar": "∤",
	"nparallel": "∦",
	"npar": "∦",
	"nparsl": "⫽⃥",
	"npart": "∂̸",
	"npolint": "⨔",
	"npr": "⊀",
	"nprcue": "⋠",
	"nprec": "⊀",
	"npreceq": "⪯̸",
	"npre": "⪯̸",
	"nrarrc": "⤳̸",
	"nrarr": "↛",
	"nrArr": "⇏",
	"nrarrw": "↝̸",
	"nrightarrow": "↛",
	"nRightarrow": "⇏",
	"nrtri": "⋫",
	"nrtrie": "⋭",
	"nsc": "⊁",
	"nsccue": "⋡",
	"nsce": "⪰̸",
	"Nscr": "𝒩",
	"nscr": "𝓃",
	"nshortmid": "∤",
	"nshortparallel": "∦",
	"nsim": "≁",
	"nsime": "≄",
	"nsimeq": "≄",
	"nsmid": "∤",
	"nspar": "∦",
	"nsqsube": "⋢",
	"nsqsupe": "⋣",
	"nsub": "⊄",
	"nsubE": "⫅̸",
	"nsube": "⊈",
	"nsubset": "⊂⃒",
	"nsubseteq": "⊈",
	"nsubseteqq": "⫅̸",
	"nsucc": "⊁",
	"nsucceq": "⪰̸",
	"nsup": "⊅",
	"nsupE": "⫆̸",
	"nsupe": "⊉",
	"nsupset": "⊃⃒",
	"nsupseteq": "⊉",
	"nsupseteqq": "⫆̸",
	"ntgl": "≹",
	"Ntilde": "Ñ",
	"ntilde": "ñ",
	"ntlg": "≸",
	"ntriangleleft": "⋪",
	"ntrianglelefteq": "⋬",
	"ntriangleright": "⋫",
	"ntrianglerighteq": "⋭",
	"Nu": "Ν",
	"nu": "ν",
	"num": "#",
	"numero": "№",
	"numsp": " ",
	"nvap": "≍⃒",
	"nvdash": "⊬",
	"nvDash": "⊭",
	"nVdash": "⊮",
	"nVDash": "⊯",
	"nvge": "≥⃒",
	"nvgt": ">⃒",
	"nvHarr": "⤄",
	"nvinfin": "⧞",
	"nvlArr": "⤂",
	"nvle": "≤⃒",
	"nvlt": "<⃒",
	"nvltrie": "⊴⃒",
	"nvrArr": "⤃",
	"nvrtrie": "⊵⃒",
	"nvsim": "∼⃒",
	"nwarhk": "⤣",
	"nwarr": "↖",
	"nwArr": "⇖",
	"nwarrow": "↖",
	"nwnear": "⤧",
	"Oacute": "Ó",
	"oacute": "ó",
	"oast": "⊛",
	"Ocirc": "Ô",
	"ocirc": "ô",
	"ocir": "⊚",
	"Ocy": "О",
	"ocy": "о",
	"odash": "⊝",
	"Odblac": "Ő",
	"odblac": "ő",
	"odiv": "⨸",
	"odot": "⊙",
	"odsold": "⦼",
	"OElig": "Œ",
	"oelig": "œ",
	"ofcir": "⦿",
	"Ofr": "𝔒",
	"ofr": "𝔬",
	"ogon": "˛",
	"Ograve": "Ò",
	"ograve": "ò",
	"ogt": "⧁",
	"ohbar": "⦵",
	"ohm": "Ω",
	"oint": "∮",
	"olarr": "↺",
	"olcir": "⦾",
	"olcross": "⦻",
	"oline": "‾",
	"olt": "⧀",
	"Omacr": "Ō",
	"omacr": "ō",
	"Omega": "Ω",
	"omega": "ω",
	"Omicron": "Ο",
	"omicron": "ο",
	"omid": "⦶",
	"ominus": "⊖",
	"Oopf": "𝕆",
	"oopf": "𝕠",
	"opar": "⦷",
	"OpenCurlyDoubleQuote": "“",
	"OpenCurlyQuote": "‘",
	"operp": "⦹",
	"oplus": "⊕",
	"orarr": "↻",
	"Or": "⩔",
	"or": "∨",
	"ord": "⩝",
	"order": "ℴ",
	"orderof": "ℴ",
	"ordf": "ª",
	"ordm": "º",
	"origof": "⊶",
	"oror": "⩖",
	"orslope": "⩗",
	"orv": "⩛",
	"oS": "Ⓢ",
	"Oscr": "𝒪",
	"oscr": "ℴ",
	"Oslash": "Ø",
	"oslash": "ø",
	"osol": "⊘",
	"Otilde": "Õ",
	"otilde": "õ",
	"otimesas": "⨶",
	"Otimes": "⨷",
	"otimes": "⊗",
	"Ouml": "Ö",
	"ouml": "ö",
	"ovbar": "⌽",
	"OverBar": "‾",
	"OverBrace": "⏞",
	"OverBracket": "⎴",
	"OverParenthesis": "⏜",
	"para": "¶",
	"parallel": "∥",
	"par": "∥",
	"parsim": "⫳",
	"parsl": "⫽",
	"part": "∂",
	"PartialD": "∂",
	"Pcy": "П",
	"pcy": "п",
	"percnt": "%",
	"period": ".",
	"permil": "‰",
	"perp": "⊥",
	"pertenk": "‱",
	"Pfr": "𝔓",
	"pfr": "𝔭",
	"Phi": "Φ",
	"phi": "φ",
	"phiv": "ϕ",
	"phmmat": "ℳ",
	"phone": "☎",
	"Pi": "Π",
	"pi": "π",
	"pitchfork": "⋔",
	"piv": "ϖ",
	"planck": "ℏ",
	"planckh": "ℎ",
	"plankv": "ℏ",
	"plusacir": "⨣",
	"plusb": "⊞",
	"pluscir": "⨢",
	"plus": "+",
	"plusdo": "∔",
	"plusdu": "⨥",
	"pluse": "⩲",
	"PlusMinus": "±",
	"plusmn": "±",
	"plussim": "⨦",
	"plustwo": "⨧",
	"pm": "±",
	"Poincareplane": "ℌ",
	"pointint": "⨕",
	"popf": "𝕡",
	"Popf": "ℙ",
	"pound": "£",
	"prap": "⪷",
	"Pr": "⪻",
	"pr": "≺",
	"prcue": "≼",
	"precapprox": "⪷",
	"prec": "≺",
	"preccurlyeq": "≼",
	"Precedes": "≺",
	"PrecedesEqual": "⪯",
	"PrecedesSlantEqual": "≼",
	"PrecedesTilde": "≾",
	"preceq": "⪯",
	"precnapprox": "⪹",
	"precneqq": "⪵",
	"precnsim": "⋨",
	"pre": "⪯",
	"prE": "⪳",
	"precsim": "≾",
	"prime": "′",
	"Prime": "″",
	"primes": "ℙ",
	"prnap": "⪹",
	"prnE": "⪵",
	"prnsim": "⋨",
	"prod": "∏",
	"Product": "∏",
	"profalar": "⌮",
	"profline": "⌒",
	"profsurf": "⌓",
	"prop": "∝",
	"Proportional": "∝",
	"Proportion": "∷",
	"propto": "∝",
	"prsim": "≾",
	"prurel": "⊰",
	"Pscr": "𝒫",
	"pscr": "𝓅",
	"Psi": "Ψ",
	"psi": "ψ",
	"puncsp": " ",
	"Qfr": "𝔔",
	"qfr": "𝔮",
	"qint": "⨌",
	"qopf": "𝕢",
	"Qopf": "ℚ",
	"qprime": "⁗",
	"Qscr": "𝒬",
	"qscr": "𝓆",
	"quaternions": "ℍ",
	"quatint": "⨖",
	"quest": "?",
	"questeq": "≟",
	"quot": "\"",
	"QUOT": "\"",
	"rAarr": "⇛",
	"race": "∽̱",
	"Racute": "Ŕ",
	"racute": "ŕ",
	"radic": "√",
	"raemptyv": "⦳",
	"rang": "⟩",
	"Rang": "⟫",
	"rangd": "⦒",
	"range": "⦥",
	"rangle": "⟩",
	"raquo": "»",
	"rarrap": "⥵",
	"rarrb": "⇥",
	"rarrbfs": "⤠",
	"rarrc": "⤳",
	"rarr": "→",
	"Rarr": "↠",
	"rArr": "⇒",
	"rarrfs": "⤞",
	"rarrhk": "↪",
	"rarrlp": "↬",
	"rarrpl": "⥅",
	"rarrsim": "⥴",
	"Rarrtl": "⤖",
	"rarrtl": "↣",
	"rarrw": "↝",
	"ratail": "⤚",
	"rAtail": "⤜",
	"ratio": "∶",
	"rationals": "ℚ",
	"rbarr": "⤍",
	"rBarr": "⤏",
	"RBarr": "⤐",
	"rbbrk": "❳",
	"rbrace": "}",
	"rbrack": "]",
	"rbrke": "⦌",
	"rbrksld": "⦎",
	"rbrkslu": "⦐",
	"Rcaron": "Ř",
	"rcaron": "ř",
	"Rcedil": "Ŗ",
	"rcedil": "ŗ",
	"rceil": "⌉",
	"rcub": "}",
	"Rcy": "Р",
	"rcy": "р",
	"rdca": "⤷",
	"rdldhar": "⥩",
	"rdquo": "”",
	"rdquor": "”",
	"rdsh": "↳",
	"real": "ℜ",
	"realine": "ℛ",
	"realpart": "ℜ",
	"reals": "ℝ",
	"Re": "ℜ",
	"rect": "▭",
	"reg": "®",
	"REG": "®",
	"ReverseElement": "∋",
	"ReverseEquilibrium": "⇋",
	"ReverseUpEquilibrium": "⥯",
	"rfisht": "⥽",
	"rfloor": "⌋",
	"rfr": "𝔯",
	"Rfr": "ℜ",
	"rHar": "⥤",
	"rhard": "⇁",
	"rharu": "⇀",
	"rharul": "⥬",
	"Rho": "Ρ",
	"rho": "ρ",
	"rhov": "ϱ",
	"RightAngleBracket": "⟩",
	"RightArrowBar": "⇥",
	"rightarrow": "→",
	"RightArrow": "→",
	"Rightarrow": "⇒",
	"RightArrowLeftArrow": "⇄",
	"rightarrowtail": "↣",
	"RightCeiling": "⌉",
	"RightDoubleBracket": "⟧",
	"RightDownTeeVector": "⥝",
	"RightDownVectorBar": "⥕",
	"RightDownVector": "⇂",
	"RightFloor": "⌋",
	"rightharpoondown": "⇁",
	"rightharpoonup": "⇀",
	"rightleftarrows": "⇄",
	"rightleftharpoons": "⇌",
	"rightrightarrows": "⇉",
	"rightsquigarrow": "↝",
	"RightTeeArrow": "↦",
	"RightTee": "⊢",
	"RightTeeVector": "⥛",
	"rightthreetimes": "⋌",
	"RightTriangleBar": "⧐",
	"RightTriangle": "⊳",
	"RightTriangleEqual": "⊵",
	"RightUpDownVector": "⥏",
	"RightUpTeeVector": "⥜",
	"RightUpVectorBar": "⥔",
	"RightUpVector": "↾",
	"RightVectorBar": "⥓",
	"RightVector": "⇀",
	"ring": "˚",
	"risingdotseq": "≓",
	"rlarr": "⇄",
	"rlhar": "⇌",
	"rlm": "‏",
	"rmoustache": "⎱",
	"rmoust": "⎱",
	"rnmid": "⫮",
	"roang": "⟭",
	"roarr": "⇾",
	"robrk": "⟧",
	"ropar": "⦆",
	"ropf": "𝕣",
	"Ropf": "ℝ",
	"roplus": "⨮",
	"rotimes": "⨵",
	"RoundImplies": "⥰",
	"rpar": ")",
	"rpargt": "⦔",
	"rppolint": "⨒",
	"rrarr": "⇉",
	"Rrightarrow": "⇛",
	"rsaquo": "›",
	"rscr": "𝓇",
	"Rscr": "ℛ",
	"rsh": "↱",
	"Rsh": "↱",
	"rsqb": "]",
	"rsquo": "’",
	"rsquor": "’",
	"rthree": "⋌",
	"rtimes": "⋊",
	"rtri": "▹",
	"rtrie": "⊵",
	"rtrif": "▸",
	"rtriltri": "⧎",
	"RuleDelayed": "⧴",
	"ruluhar": "⥨",
	"rx": "℞",
	"Sacute": "Ś",
	"sacute": "ś",
	"sbquo": "‚",
	"scap": "⪸",
	"Scaron": "Š",
	"scaron": "š",
	"Sc": "⪼",
	"sc": "≻",
	"sccue": "≽",
	"sce": "⪰",
	"scE": "⪴",
	"Scedil": "Ş",
	"scedil": "ş",
	"Scirc": "Ŝ",
	"scirc": "ŝ",
	"scnap": "⪺",
	"scnE": "⪶",
	"scnsim": "⋩",
	"scpolint": "⨓",
	"scsim": "≿",
	"Scy": "С",
	"scy": "с",
	"sdotb": "⊡",
	"sdot": "⋅",
	"sdote": "⩦",
	"searhk": "⤥",
	"searr": "↘",
	"seArr": "⇘",
	"searrow": "↘",
	"sect": "§",
	"semi": ";",
	"seswar": "⤩",
	"setminus": "∖",
	"setmn": "∖",
	"sext": "✶",
	"Sfr": "𝔖",
	"sfr": "𝔰",
	"sfrown": "⌢",
	"sharp": "♯",
	"SHCHcy": "Щ",
	"shchcy": "щ",
	"SHcy": "Ш",
	"shcy": "ш",
	"ShortDownArrow": "↓",
	"ShortLeftArrow": "←",
	"shortmid": "∣",
	"shortparallel": "∥",
	"ShortRightArrow": "→",
	"ShortUpArrow": "↑",
	"shy": "­",
	"Sigma": "Σ",
	"sigma": "σ",
	"sigmaf": "ς",
	"sigmav": "ς",
	"sim": "∼",
	"simdot": "⩪",
	"sime": "≃",
	"simeq": "≃",
	"simg": "⪞",
	"simgE": "⪠",
	"siml": "⪝",
	"simlE": "⪟",
	"simne": "≆",
	"simplus": "⨤",
	"simrarr": "⥲",
	"slarr": "←",
	"SmallCircle": "∘",
	"smallsetminus": "∖",
	"smashp": "⨳",
	"smeparsl": "⧤",
	"smid": "∣",
	"smile": "⌣",
	"smt": "⪪",
	"smte": "⪬",
	"smtes": "⪬︀",
	"SOFTcy": "Ь",
	"softcy": "ь",
	"solbar": "⌿",
	"solb": "⧄",
	"sol": "/",
	"Sopf": "𝕊",
	"sopf": "𝕤",
	"spades": "♠",
	"spadesuit": "♠",
	"spar": "∥",
	"sqcap": "⊓",
	"sqcaps": "⊓︀",
	"sqcup": "⊔",
	"sqcups": "⊔︀",
	"Sqrt": "√",
	"sqsub": "⊏",
	"sqsube": "⊑",
	"sqsubset": "⊏",
	"sqsubseteq": "⊑",
	"sqsup": "⊐",
	"sqsupe": "⊒",
	"sqsupset": "⊐",
	"sqsupseteq": "⊒",
	"square": "□",
	"Square": "□",
	"SquareIntersection": "⊓",
	"SquareSubset": "⊏",
	"SquareSubsetEqual": "⊑",
	"SquareSuperset": "⊐",
	"SquareSupersetEqual": "⊒",
	"SquareUnion": "⊔",
	"squarf": "▪",
	"squ": "□",
	"squf": "▪",
	"srarr": "→",
	"Sscr": "𝒮",
	"sscr": "𝓈",
	"ssetmn": "∖",
	"ssmile": "⌣",
	"sstarf": "⋆",
	"Star": "⋆",
	"star": "☆",
	"starf": "★",
	"straightepsilon": "ϵ",
	"straightphi": "ϕ",
	"strns": "¯",
	"sub": "⊂",
	"Sub": "⋐",
	"subdot": "⪽",
	"subE": "⫅",
	"sube": "⊆",
	"subedot": "⫃",
	"submult": "⫁",
	"subnE": "⫋",
	"subne": "⊊",
	"subplus": "⪿",
	"subrarr": "⥹",
	"subset": "⊂",
	"Subset": "⋐",
	"subseteq": "⊆",
	"subseteqq": "⫅",
	"SubsetEqual": "⊆",
	"subsetneq": "⊊",
	"subsetneqq": "⫋",
	"subsim": "⫇",
	"subsub": "⫕",
	"subsup": "⫓",
	"succapprox": "⪸",
	"succ": "≻",
	"succcurlyeq": "≽",
	"Succeeds": "≻",
	"SucceedsEqual": "⪰",
	"SucceedsSlantEqual": "≽",
	"SucceedsTilde": "≿",
	"succeq": "⪰",
	"succnapprox": "⪺",
	"succneqq": "⪶",
	"succnsim": "⋩",
	"succsim": "≿",
	"SuchThat": "∋",
	"sum": "∑",
	"Sum": "∑",
	"sung": "♪",
	"sup1": "¹",
	"sup2": "²",
	"sup3": "³",
	"sup": "⊃",
	"Sup": "⋑",
	"supdot": "⪾",
	"supdsub": "⫘",
	"supE": "⫆",
	"supe": "⊇",
	"supedot": "⫄",
	"Superset": "⊃",
	"SupersetEqual": "⊇",
	"suphsol": "⟉",
	"suphsub": "⫗",
	"suplarr": "⥻",
	"supmult": "⫂",
	"supnE": "⫌",
	"supne": "⊋",
	"supplus": "⫀",
	"supset": "⊃",
	"Supset": "⋑",
	"supseteq": "⊇",
	"supseteqq": "⫆",
	"supsetneq": "⊋",
	"supsetneqq": "⫌",
	"supsim": "⫈",
	"supsub": "⫔",
	"supsup": "⫖",
	"swarhk": "⤦",
	"swarr": "↙",
	"swArr": "⇙",
	"swarrow": "↙",
	"swnwar": "⤪",
	"szlig": "ß",
	"Tab": "\t",
	"target": "⌖",
	"Tau": "Τ",
	"tau": "τ",
	"tbrk": "⎴",
	"Tcaron": "Ť",
	"tcaron": "ť",
	"Tcedil": "Ţ",
	"tcedil": "ţ",
	"Tcy": "Т",
	"tcy": "т",
	"tdot": "⃛",
	"telrec": "⌕",
	"Tfr": "𝔗",
	"tfr": "𝔱",
	"there4": "∴",
	"therefore": "∴",
	"Therefore": "∴",
	"Theta": "Θ",
	"theta": "θ",
	"thetasym": "ϑ",
	"thetav": "ϑ",
	"thickapprox": "≈",
	"thicksim": "∼",
	"ThickSpace": "  ",
	"ThinSpace": " ",
	"thinsp": " ",
	"thkap": "≈",
	"thksim": "∼",
	"THORN": "Þ",
	"thorn": "þ",
	"tilde": "˜",
	"Tilde": "∼",
	"TildeEqual": "≃",
	"TildeFullEqual": "≅",
	"TildeTilde": "≈",
	"timesbar": "⨱",
	"timesb": "⊠",
	"times": "×",
	"timesd": "⨰",
	"tint": "∭",
	"toea": "⤨",
	"topbot": "⌶",
	"topcir": "⫱",
	"top": "⊤",
	"Topf": "𝕋",
	"topf": "𝕥",
	"topfork": "⫚",
	"tosa": "⤩",
	"tprime": "‴",
	"trade": "™",
	"TRADE": "™",
	"triangle": "▵",
	"triangledown": "▿",
	"triangleleft": "◃",
	"trianglelefteq": "⊴",
	"triangleq": "≜",
	"triangleright": "▹",
	"trianglerighteq": "⊵",
	"tridot": "◬",
	"trie": "≜",
	"triminus": "⨺",
	"TripleDot": "⃛",
	"triplus": "⨹",
	"trisb": "⧍",
	"tritime": "⨻",
	"trpezium": "⏢",
	"Tscr": "𝒯",
	"tscr": "𝓉",
	"TScy": "Ц",
	"tscy": "ц",
	"TSHcy": "Ћ",
	"tshcy": "ћ",
	"Tstrok": "Ŧ",
	"tstrok": "ŧ",
	"twixt": "≬",
	"twoheadleftarrow": "↞",
	"twoheadrightarrow": "↠",
	"Uacute": "Ú",
	"uacute": "ú",
	"uarr": "↑",
	"Uarr": "↟",
	"uArr": "⇑",
	"Uarrocir": "⥉",
	"Ubrcy": "Ў",
	"ubrcy": "ў",
	"Ubreve": "Ŭ",
	"ubreve": "ŭ",
	"Ucirc": "Û",
	"ucirc": "û",
	"Ucy": "У",
	"ucy": "у",
	"udarr": "⇅",
	"Udblac": "Ű",
	"udblac": "ű",
	"udhar": "⥮",
	"ufisht": "⥾",
	"Ufr": "𝔘",
	"ufr": "𝔲",
	"Ugrave": "Ù",
	"ugrave": "ù",
	"uHar": "⥣",
	"uharl": "↿",
	"uharr": "↾",
	"uhblk": "▀",
	"ulcorn": "⌜",
	"ulcorner": "⌜",
	"ulcrop": "⌏",
	"ultri": "◸",
	"Umacr": "Ū",
	"umacr": "ū",
	"uml": "¨",
	"UnderBar": "_",
	"UnderBrace": "⏟",
	"UnderBracket": "⎵",
	"UnderParenthesis": "⏝",
	"Union": "⋃",
	"UnionPlus": "⊎",
	"Uogon": "Ų",
	"uogon": "ų",
	"Uopf": "𝕌",
	"uopf": "𝕦",
	"UpArrowBar": "⤒",
	"uparrow": "↑",
	"UpArrow": "↑",
	"Uparrow": "⇑",
	"UpArrowDownArrow": "⇅",
	"updownarrow": "↕",
	"UpDownArrow": "↕",
	"Updownarrow": "⇕",
	"UpEquilibrium": "⥮",
	"upharpoonleft": "↿",
	"upharpoonright": "↾",
	"uplus": "⊎",
	"UpperLeftArrow": "↖",
	"UpperRightArrow": "↗",
	"upsi": "υ",
	"Upsi": "ϒ",
	"upsih": "ϒ",
	"Upsilon": "Υ",
	"upsilon": "υ",
	"UpTeeArrow": "↥",
	"UpTee": "⊥",
	"upuparrows": "⇈",
	"urcorn": "⌝",
	"urcorner": "⌝",
	"urcrop": "⌎",
	"Uring": "Ů",
	"uring": "ů",
	"urtri": "◹",
	"Uscr": "𝒰",
	"uscr": "𝓊",
	"utdot": "⋰",
	"Utilde": "Ũ",
	"utilde": "ũ",
	"utri": "▵",
	"utrif": "▴",
	"uuarr": "⇈",
	"Uuml": "Ü",
	"uuml": "ü",
	"uwangle": "⦧",
	"vangrt": "⦜",
	"varepsilon": "ϵ",
	"varkappa": "ϰ",
	"varnothing": "∅",
	"varphi": "ϕ",
	"varpi": "ϖ",
	"varpropto": "∝",
	"varr": "↕",
	"vArr": "⇕",
	"varrho": "ϱ",
	"varsigma": "ς",
	"varsubsetneq": "⊊︀",
	"varsubsetneqq": "⫋︀",
	"varsupsetneq": "⊋︀",
	"varsupsetneqq": "⫌︀",
	"vartheta": "ϑ",
	"vartriangleleft": "⊲",
	"vartriangleright": "⊳",
	"vBar": "⫨",
	"Vbar": "⫫",
	"vBarv": "⫩",
	"Vcy": "В",
	"vcy": "в",
	"vdash": "⊢",
	"vDash": "⊨",
	"Vdash": "⊩",
	"VDash": "⊫",
	"Vdashl": "⫦",
	"veebar": "⊻",
	"vee": "∨",
	"Vee": "⋁",
	"veeeq": "≚",
	"vellip": "⋮",
	"verbar": "|",
	"Verbar": "‖",
	"vert": "|",
	"Vert": "‖",
	"VerticalBar": "∣",
	"VerticalLine": "|",
	"VerticalSeparator": "❘",
	"VerticalTilde": "≀",
	"VeryThinSpace": " ",
	"Vfr": "𝔙",
	"vfr": "𝔳",
	"vltri": "⊲",
	"vnsub": "⊂⃒",
	"vnsup": "⊃⃒",
	"Vopf": "𝕍",
	"vopf": "𝕧",
	"vprop": "∝",
	"vrtri": "⊳",
	"Vscr": "𝒱",
	"vscr": "𝓋",
	"vsubnE": "⫋︀",
	"vsubne": "⊊︀",
	"vsupnE": "⫌︀",
	"vsupne": "⊋︀",
	"Vvdash": "⊪",
	"vzigzag": "⦚",
	"Wcirc": "Ŵ",
	"wcirc": "ŵ",
	"wedbar": "⩟",
	"wedge": "∧",
	"Wedge": "⋀",
	"wedgeq": "≙",
	"weierp": "℘",
	"Wfr": "𝔚",
	"wfr": "𝔴",
	"Wopf": "𝕎",
	"wopf": "𝕨",
	"wp": "℘",
	"wr": "≀",
	"wreath": "≀",
	"Wscr": "𝒲",
	"wscr": "𝓌",
	"xcap": "⋂",
	"xcirc": "◯",
	"xcup": "⋃",
	"xdtri": "▽",
	"Xfr": "𝔛",
	"xfr": "𝔵",
	"xharr": "⟷",
	"xhArr": "⟺",
	"Xi": "Ξ",
	"xi": "ξ",
	"xlarr": "⟵",
	"xlArr": "⟸",
	"xmap": "⟼",
	"xnis": "⋻",
	"xodot": "⨀",
	"Xopf": "𝕏",
	"xopf": "𝕩",
	"xoplus": "⨁",
	"xotime": "⨂",
	"xrarr": "⟶",
	"xrArr": "⟹",
	"Xscr": "𝒳",
	"xscr": "𝓍",
	"xsqcup": "⨆",
	"xuplus": "⨄",
	"xutri": "△",
	"xvee": "⋁",
	"xwedge": "⋀",
	"Yacute": "Ý",
	"yacute": "ý",
	"YAcy": "Я",
	"yacy": "я",
	"Ycirc": "Ŷ",
	"ycirc": "ŷ",
	"Ycy": "Ы",
	"ycy": "ы",
	"yen": "¥",
	"Yfr": "𝔜",
	"yfr": "𝔶",
	"YIcy": "Ї",
	"yicy": "ї",
	"Yopf": "𝕐",
	"yopf": "𝕪",
	"Yscr": "𝒴",
	"yscr": "𝓎",
	"YUcy": "Ю",
	"yucy": "ю",
	"yuml": "ÿ",
	"Yuml": "Ÿ",
	"Zacute": "Ź",
	"zacute": "ź",
	"Zcaron": "Ž",
	"zcaron": "ž",
	"Zcy": "З",
	"zcy": "з",
	"Zdot": "Ż",
	"zdot": "ż",
	"zeetrf": "ℨ",
	"ZeroWidthSpace": "​",
	"Zeta": "Ζ",
	"zeta": "ζ",
	"zfr": "𝔷",
	"Zfr": "ℨ",
	"ZHcy": "Ж",
	"zhcy": "ж",
	"zigrarr": "⇝",
	"zopf": "𝕫",
	"Zopf": "ℤ",
	"Zscr": "𝒵",
	"zscr": "𝓏",
	"zwj": "‍",
	"zwnj": "‌"
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(85);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(16)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(86);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(16)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(89);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(6);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.tags = v.split(',');
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.tags,
      onchange: _mithril2.default.withAttr('value', vnode.state.onchanage),
      value: vnode.state.model.data.tags.join(',')
    });
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzU3YmQ4ZGU0ZWU2MzQxODcyNTUiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9taXRocmlsL21pdGhyaWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3Rva2VuLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9jZWxsLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9lbnRyeS5qcyIsIndlYnBhY2s6Ly8vLi9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy90aXRsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2xpbmtpZnktaXQvbGliL3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2xhYmVsLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9odG1sX2lubGluZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZW5jb2RlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zdHlsZXMuY3NzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uIiwid2VicGFjazovLy8uL3N0eWxlcy5jc3M/MjIzYSIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9zdHlsZXMuY3NzPzFjYTMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvdGFncy5qcyJdLCJuYW1lcyI6WyJfY2xhc3MiLCJvYmoiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1N0cmluZyIsIl9oYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiaGFzIiwib2JqZWN0Iiwia2V5IiwiYXNzaWduIiwic291cmNlcyIsIkFycmF5Iiwic2xpY2UiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwic291cmNlIiwiVHlwZUVycm9yIiwia2V5cyIsImFycmF5UmVwbGFjZUF0Iiwic3JjIiwicG9zIiwibmV3RWxlbWVudHMiLCJjb25jYXQiLCJpc1ZhbGlkRW50aXR5Q29kZSIsImMiLCJmcm9tQ29kZVBvaW50Iiwic3Vycm9nYXRlMSIsInN1cnJvZ2F0ZTIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVTkVTQ0FQRV9NRF9SRSIsIkVOVElUWV9SRSIsIlVORVNDQVBFX0FMTF9SRSIsIlJlZ0V4cCIsIkRJR0lUQUxfRU5USVRZX1RFU1RfUkUiLCJlbnRpdGllcyIsInJlcXVpcmUiLCJyZXBsYWNlRW50aXR5UGF0dGVybiIsIm1hdGNoIiwibmFtZSIsImNvZGUiLCJjaGFyQ29kZUF0IiwidGVzdCIsInRvTG93ZXJDYXNlIiwicGFyc2VJbnQiLCJ1bmVzY2FwZU1kIiwic3RyIiwiaW5kZXhPZiIsInJlcGxhY2UiLCJ1bmVzY2FwZUFsbCIsImVzY2FwZWQiLCJlbnRpdHkiLCJIVE1MX0VTQ0FQRV9URVNUX1JFIiwiSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSIsIkhUTUxfUkVQTEFDRU1FTlRTIiwicmVwbGFjZVVuc2FmZUNoYXIiLCJjaCIsImVzY2FwZUh0bWwiLCJSRUdFWFBfRVNDQVBFX1JFIiwiZXNjYXBlUkUiLCJpc1NwYWNlIiwiaXNXaGl0ZVNwYWNlIiwiVU5JQ09ERV9QVU5DVF9SRSIsImlzUHVuY3RDaGFyIiwiaXNNZEFzY2lpUHVuY3QiLCJub3JtYWxpemVSZWZlcmVuY2UiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJleHBvcnRzIiwibGliIiwibWR1cmwiLCJ1Y21pY3JvIiwiVm5vZGUiLCJ0YWciLCJhdHRyczAiLCJjaGlsZHJlbiIsInRleHQiLCJkb20iLCJhdHRycyIsImRvbVNpemUiLCJ1bmRlZmluZWQiLCJzdGF0ZSIsIl9zdGF0ZSIsImV2ZW50cyIsImluc3RhbmNlIiwic2tpcCIsIm5vcm1hbGl6ZSIsIm5vZGUiLCJpc0FycmF5Iiwibm9ybWFsaXplQ2hpbGRyZW4iLCJpIiwibGVuZ3RoIiwic2VsZWN0b3JQYXJzZXIiLCJzZWxlY3RvckNhY2hlIiwiaGFzT3duIiwiY29tcGlsZVNlbGVjdG9yIiwic2VsZWN0b3IiLCJjbGFzc2VzIiwiZXhlYyIsInR5cGUiLCJ2YWx1ZSIsImlkIiwicHVzaCIsImF0dHJWYWx1ZSIsImNsYXNzTmFtZSIsImpvaW4iLCJleGVjU2VsZWN0b3IiLCJoYXNBdHRycyIsImNoaWxkTGlzdCIsImNsYXNzIiwiaHlwZXJzY3JpcHQiLCJzdGFydCIsInZpZXciLCJFcnJvciIsImNhY2hlZCIsIm5vcm1hbGl6ZWQiLCJ0cnVzdCIsImh0bWwiLCJmcmFnbWVudCIsImF0dHJzMSIsIm0iLCJQcm9taXNlUG9seWZpbGwiLCJleGVjdXRvciIsInNlbGYiLCJyZXNvbHZlcnMiLCJyZWplY3RvcnMiLCJyZXNvbHZlQ3VycmVudCIsImhhbmRsZXIiLCJyZWplY3RDdXJyZW50IiwiX2luc3RhbmNlIiwiY2FsbEFzeW5jIiwic2V0SW1tZWRpYXRlIiwic2V0VGltZW91dCIsImxpc3QiLCJzaG91bGRBYnNvcmIiLCJleGVjdXRlIiwidGhlbiIsImV4ZWN1dGVPbmNlIiwiYmluZCIsImNvbnNvbGUiLCJlcnJvciIsInJldHJ5IiwiZSIsInJ1bnMiLCJydW4iLCJmbiIsIm9uZXJyb3IiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0aW9uIiwiaGFuZGxlIiwiY2FsbGJhY2siLCJuZXh0IiwicmVzb2x2ZU5leHQiLCJyZWplY3ROZXh0IiwicHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYXRjaCIsImFsbCIsInRvdGFsIiwiY291bnQiLCJ2YWx1ZXMiLCJjb25zdW1lIiwicmFjZSIsIndpbmRvdyIsIlByb21pc2UiLCJnbG9iYWwiLCJidWlsZFF1ZXJ5U3RyaW5nIiwiYXJncyIsImtleTAiLCJkZXN0cnVjdHVyZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkZJTEVfUFJPVE9DT0xfUkVHRVgiLCJfOCIsIiR3aW5kb3ciLCJjYWxsYmFja0NvdW50Iiwib25jb21wbGV0aW9uIiwic2V0Q29tcGxldGlvbkNhbGxiYWNrIiwiZmluYWxpemVyIiwiY29tcGxldGUiLCJmaW5hbGl6ZSIsInByb21pc2UwIiwidGhlbjAiLCJhcHBseSIsImV4dHJhIiwidXJsIiwicmVxdWVzdCIsIm1ldGhvZCIsInVzZUJvZHkiLCJzZXJpYWxpemUiLCJGb3JtRGF0YSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzZXJpYWxpemUiLCJleHRyYWN0IiwiaW50ZXJwb2xhdGUiLCJhc3NlbWJsZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiYWJvcnRlZCIsIl9hYm9ydCIsImFib3J0Iiwib3BlbiIsImFzeW5jIiwidXNlciIsInBhc3N3b3JkIiwic2V0UmVxdWVzdEhlYWRlciIsIndpdGhDcmVkZW50aWFscyIsImhlYWRlcnMiLCJjb25maWciLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJjYXN0IiwicmVzcG9uc2VUZXh0Iiwic2VuZCIsImJhY2tncm91bmQiLCJqc29ucCIsImNhbGxiYWNrTmFtZSIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsInNjcmlwdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNhbGxiYWNrS2V5IiwiZG9jdW1lbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJ0b2tlbnMiLCJxdWVyeXN0cmluZyIsInByZWZpeCIsInBhcnNlIiwidHlwZTAiLCJyZXF1ZXN0U2VydmljZSIsImNvcmVSZW5kZXJlciIsIiRkb2MiLCIkZW1wdHlGcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJvbmV2ZW50Iiwic2V0RXZlbnRDYWxsYmFjayIsImNyZWF0ZU5vZGVzIiwicGFyZW50Iiwidm5vZGVzIiwiZW5kIiwiaG9va3MiLCJuZXh0U2libGluZyIsIm5zIiwidm5vZGUiLCJjcmVhdGVOb2RlIiwiaW5pdExpZmVjeWNsZSIsImNyZWF0ZVRleHQiLCJjcmVhdGVIVE1MIiwiY3JlYXRlRnJhZ21lbnQiLCJjcmVhdGVDb21wb25lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImluc2VydE5vZGUiLCJtYXRjaDEiLCJwYXJlbnQxIiwiY2FwdGlvbiIsInRoZWFkIiwidGJvZHkiLCJ0Zm9vdCIsInRyIiwidGgiLCJ0ZCIsImNvbGdyb3VwIiwiY29sIiwidGVtcCIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwiY2hpbGQiLCJhdHRyczIiLCJpcyIsImVsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJzZXRBdHRycyIsImNvbnRlbnRlZGl0YWJsZSIsInNldENvbnRlbnRFZGl0YWJsZSIsInRleHRDb250ZW50Iiwic2V0TGF0ZUF0dHJzIiwiaW5pdENvbXBvbmVudCIsInNlbnRpbmVsIiwiY3JlYXRlIiwiJCRyZWVudHJhbnRMb2NrJCQiLCJ1cGRhdGVOb2RlcyIsIm9sZCIsInJlY3ljbGluZyIsInJlbW92ZU5vZGVzIiwiaXNVbmtleWVkIiwiZ2V0TmV4dFNpYmxpbmciLCJ1cGRhdGVOb2RlIiwiaXNSZWN5Y2xhYmxlIiwicG9vbCIsIm9sZFN0YXJ0Iiwib2xkRW5kIiwibWFwIiwibyIsInYiLCJzaG91bGRSZWN5Y2xlIiwidG9GcmFnbWVudCIsImdldEtleU1hcCIsIm9sZEluZGV4IiwibW92YWJsZSIsIm9sZFRhZyIsInNob3VsZE5vdFVwZGF0ZSIsInVwZGF0ZUxpZmVjeWNsZSIsInVwZGF0ZVRleHQiLCJ1cGRhdGVIVE1MIiwidXBkYXRlRnJhZ21lbnQiLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlQ29tcG9uZW50IiwicmVtb3ZlTm9kZSIsIm5vZGVWYWx1ZSIsInVwZGF0ZUF0dHJzIiwiYWJzIiwib2xkQ2hpbGRyZW5MZW5ndGgiLCJwb29sQ2hpbGRyZW5MZW5ndGgiLCJ2bm9kZXNDaGlsZHJlbkxlbmd0aCIsImtleTIiLCJjb3VudDAiLCJpbnNlcnRCZWZvcmUiLCJjb250ZW50IiwiY29udGV4dCIsImV4cGVjdGVkIiwiY2FsbGVkIiwib25iZWZvcmVyZW1vdmUiLCJyZXN1bHQiLCJjb250aW51YXRpb24iLCJvbnJlbW92ZSIsInJlbW92ZU5vZGVGcm9tRE9NIiwiaGFzSW50ZWdyYXRpb25NZXRob2RzIiwic2V0QXR0ciIsImlzRm9ybUF0dHJpYnV0ZSIsImlzTGlmZWN5Y2xlTWV0aG9kIiwibnNMYXN0SW5kZXgiLCJzdWJzdHIiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUV2ZW50IiwidXBkYXRlU3R5bGUiLCJpc0F0dHJpYnV0ZSIsImlzQ3VzdG9tRWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZWxlY3RlZEluZGV4IiwiYXR0ciIsIm9uY3JlYXRlIiwib251cGRhdGUiLCJzdHlsZSIsImNzc1RleHQiLCJldmVudE5hbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uaW5pdCIsImZvcmNlVm5vZGVVcGRhdGUiLCJmb3JjZUNvbXBvbmVudFVwZGF0ZSIsIm9uYmVmb3JldXBkYXRlIiwicmVuZGVyIiwiYWN0aXZlIiwiZm9jdXMiLCJ0aHJvdHRsZSIsInRpbWUiLCJsYXN0IiwicGVuZGluZyIsInRpbWVvdXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJub3ciLCJEYXRlIiwiXzExIiwicmVuZGVyU2VydmljZSIsInJlZHJhdyIsImNhbGxiYWNrcyIsInN1YnNjcmliZSIsImtleTEiLCJ1bnN1YnNjcmliZSIsImluZGV4Iiwic3BsaWNlIiwicmVkcmF3U2VydmljZSIsIl8xNiIsInJlZHJhd1NlcnZpY2UwIiwicm9vdCIsImNvbXBvbmVudCIsInJ1bjAiLCJtb3VudCIsInBhcnNlUXVlcnlTdHJpbmciLCJzdHJpbmciLCJjaGFyQXQiLCJlbnRyaWVzIiwic3BsaXQiLCJkYXRhMCIsImNvdW50ZXJzIiwiZW50cnkiLCJrZXk1IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwibGV2ZWxzIiwiY3Vyc29yIiwicG9wIiwiaiIsImxldmVsIiwibmV4dExldmVsIiwiaXNOdW1iZXIiLCJpc05hTiIsImlzVmFsdWUiLCJjb3JlUm91dGVyIiwic3VwcG9ydHNQdXNoU3RhdGUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiY2FsbEFzeW5jMCIsIm5vcm1hbGl6ZTEiLCJmcmFnbWVudDAiLCJsb2NhdGlvbiIsImFzeW5jSWQiLCJkZWJvdW5jZUFzeW5jIiwiY2FsbGJhY2swIiwicGFyc2VQYXRoIiwicGF0aCIsInF1ZXJ5RGF0YSIsImhhc2hEYXRhIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsInBhdGhFbmQiLCJxdWVyeUVuZCIsInF1ZXJ5UGFyYW1zIiwia2V5NCIsImhhc2hQYXJhbXMiLCJyb3V0ZXIiLCJnZXRQYXRoIiwidHlwZTIiLCJzZXRQYXRoIiwib3B0aW9ucyIsIm1hdGNoMiIsInRva2VuIiwicXVlcnkiLCJoYXNoIiwidGl0bGUiLCJvbnBvcHN0YXRlIiwicmVwbGFjZVN0YXRlIiwiaHJlZiIsImRlZmluZVJvdXRlcyIsInJvdXRlcyIsInJlc29sdmVSb3V0ZSIsInBhcmFtcyIsInBhdGhuYW1lIiwiayIsInJvdXRlMCIsIm1hdGNoZXIiLCJvbmhhc2hjaGFuZ2UiLCJfMjAiLCJyb3V0ZVNlcnZpY2UiLCJpZGVudGl0eSIsInJlbmRlcjEiLCJhdHRyczMiLCJjdXJyZW50UGF0aCIsImxhc3RVcGRhdGUiLCJyb3V0ZSIsImRlZmF1bHRSb3V0ZSIsInJ1bjEiLCJiYWlsIiwicGF5bG9hZCIsInVwZGF0ZSIsInJvdXRlUmVzb2x2ZXIiLCJjb21wIiwib25tYXRjaCIsInJlc29sdmVkIiwic2V0IiwiZ2V0IiwicHJlZml4MCIsImxpbmsiLCJ2bm9kZTEiLCJvbmNsaWNrIiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsIndoaWNoIiwicHJldmVudERlZmF1bHQiLCJnZXRBdHRyaWJ1dGUiLCJwYXJhbSIsImtleTMiLCJ3aXRoQXR0ciIsImF0dHJOYW1lIiwiY2FsbGJhY2sxIiwiY3VycmVudFRhcmdldCIsIl8yOCIsInZlcnNpb24iLCJtb2R1bGUiLCJnIiwiRnVuY3Rpb24iLCJldmFsIiwiUnVsZXIiLCJfX3J1bGVzX18iLCJfX2NhY2hlX18iLCJfX2ZpbmRfXyIsIl9fY29tcGlsZV9fIiwiY2hhaW5zIiwicnVsZSIsImVuYWJsZWQiLCJhbHQiLCJhbHROYW1lIiwiY2hhaW4iLCJhdCIsIm9wdCIsImJlZm9yZSIsImJlZm9yZU5hbWUiLCJydWxlTmFtZSIsImFmdGVyIiwiYWZ0ZXJOYW1lIiwiZW5hYmxlIiwiaWdub3JlSW52YWxpZCIsImlkeCIsImVuYWJsZU9ubHkiLCJkaXNhYmxlIiwiZ2V0UnVsZXMiLCJjaGFpbk5hbWUiLCJUb2tlbiIsIm5lc3RpbmciLCJtYXJrdXAiLCJpbmZvIiwibWV0YSIsImJsb2NrIiwiaGlkZGVuIiwiYXR0ckluZGV4IiwibGVuIiwiYXR0clB1c2giLCJhdHRyRGF0YSIsImF0dHJTZXQiLCJhdHRyR2V0IiwiYXR0ckpvaW4iLCJzcGFuIiwiY2xzIiwiaW5uZXIiLCJ1c2VTb3VyY2VNYXAiLCJpdGVtIiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImNzc01hcHBpbmciLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJCdWZmZXIiLCJhdHRyX25hbWUiLCJ1bnF1b3RlZCIsInNpbmdsZV9xdW90ZWQiLCJkb3VibGVfcXVvdGVkIiwiYXR0cl92YWx1ZSIsImF0dHJpYnV0ZSIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwiY29tbWVudCIsInByb2Nlc3NpbmciLCJkZWNsYXJhdGlvbiIsImNkYXRhIiwiSFRNTF9UQUdfUkUiLCJIVE1MX09QRU5fQ0xPU0VfVEFHX1JFIiwidG9rZW5pemUiLCJlbXBoYXNpcyIsInNpbGVudCIsInNjYW5uZWQiLCJtYXJrZXIiLCJzY2FuRGVsaW1zIiwiZGVsaW1pdGVycyIsImp1bXAiLCJjYW5fb3BlbiIsImNsb3NlIiwiY2FuX2Nsb3NlIiwicG9zdFByb2Nlc3MiLCJzdGFydERlbGltIiwiZW5kRGVsaW0iLCJpc1N0cm9uZyIsIm1heCIsInN0cmlrZXRocm91Z2giLCJsb25lTWFya2VycyIsImVuY29kZSIsImRlY29kZSIsImZvcm1hdCIsIkVkaXRvciIsIm1vZGVsIiwidGV4dGFyZWEiLCJib2R5IiwiZWRpdG9yIiwiZWRpdG9yTGVmdFNpZGUiLCJQcmV2aWV3IiwiZWRpdG9yUmlnaHRTaWRlIiwiU2F2ZSIsInNhdmUiLCJzYXZlQnV0dG9uIiwiZmV0Y2giLCJmZXRjaGVkIiwiZWRpdG9yV3JhcCIsIm1kQm9keSIsImdldEVsZW1lbnRCeUlkIiwibWQiLCJNb2RlbCIsIm9uY2hhbmdlIiwiYnl0ZUxlbmd0aCIsInRvQnl0ZUFycmF5IiwiZnJvbUJ5dGVBcnJheSIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsIlVpbnQ4QXJyYXkiLCJwbGFjZUhvbGRlcnNDb3VudCIsImI2NCIsImwiLCJ0bXAiLCJwbGFjZUhvbGRlcnMiLCJhcnIiLCJMIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsIm91dHB1dCIsImV4dHJhQnl0ZXMiLCJwYXJ0cyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsImllZWU3NTQiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJrTWF4TGVuZ3RoIiwiX19wcm90b19fIiwiZm9vIiwic3ViYXJyYXkiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiUmFuZ2VFcnJvciIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsIlN5bWJvbCIsInNwZWNpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93IiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwiZnJvbUFycmF5TGlrZSIsImFycmF5IiwiYnl0ZU9mZnNldCIsImlzQnVmZmVyIiwiY29weSIsImJ1ZmZlciIsImlzbmFuIiwiYiIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwieCIsInkiLCJtaW4iLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwibiIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImVxdWFscyIsImluc3BlY3QiLCJ0YXJnZXQiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJ2YWwiLCJkaXIiLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwib2Zmc2V0IiwiTnVtYmVyIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VkIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIl9hcnIiLCJyZXMiLCJmaXJzdEJ5dGUiLCJjb2RlUG9pbnQiLCJieXRlc1BlclNlcXVlbmNlIiwic2Vjb25kQnl0ZSIsInRoaXJkQnl0ZSIsImZvdXJ0aEJ5dGUiLCJ0ZW1wQ29kZVBvaW50IiwiZGVjb2RlQ29kZVBvaW50c0FycmF5IiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJjb2RlUG9pbnRzIiwicmV0Iiwib3V0IiwidG9IZXgiLCJieXRlcyIsIm5ld0J1ZiIsInNsaWNlTGVuIiwiY2hlY2tPZmZzZXQiLCJleHQiLCJyZWFkVUludExFIiwibm9Bc3NlcnQiLCJtdWwiLCJyZWFkVUludEJFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludExFIiwicG93IiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJmbG9vciIsIm9iamVjdFdyaXRlVUludDE2IiwibGl0dGxlRW5kaWFuIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVUludDE2QkUiLCJvYmplY3RXcml0ZVVJbnQzMiIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsImxpbWl0Iiwic3ViIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJJTlZBTElEX0JBU0U2NF9SRSIsImJhc2U2NGNsZWFuIiwic3RyaW5ndHJpbSIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsImRzdCIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiZCIsInMiLCJOYU4iLCJydCIsImxvZyIsIkxOMiIsImlzT2JqZWN0IiwiaXNSZWdFeHAiLCJpc0Z1bmN0aW9uIiwiZGVmYXVsdE9wdGlvbnMiLCJmdXp6eUxpbmsiLCJmdXp6eUVtYWlsIiwiZnV6enlJUCIsImlzT3B0aW9uc09iaiIsInJlZHVjZSIsImFjYyIsImRlZmF1bHRTY2hlbWFzIiwidmFsaWRhdGUiLCJ0YWlsIiwicmUiLCJodHRwIiwic3JjX2F1dGgiLCJzcmNfaG9zdF9wb3J0X3N0cmljdCIsInNyY19wYXRoIiwibm9faHR0cCIsInNyY19kb21haW4iLCJzcmNfZG9tYWluX3Jvb3QiLCJzcmNfcG9ydCIsInNyY19ob3N0X3Rlcm1pbmF0b3IiLCJtYWlsdG8iLCJzcmNfZW1haWxfbmFtZSIsInNyY19ob3N0X3N0cmljdCIsInRsZHNfMmNoX3NyY19yZSIsInRsZHNfZGVmYXVsdCIsInJlc2V0U2NhbkNhY2hlIiwiX19pbmRleF9fIiwiX190ZXh0X2NhY2hlX18iLCJjcmVhdGVWYWxpZGF0b3IiLCJjcmVhdGVOb3JtYWxpemVyIiwiY29tcGlsZSIsIl9fb3B0c19fIiwidGxkcyIsIl9fdGxkc19fIiwib25Db21waWxlIiwiX190bGRzX3JlcGxhY2VkX18iLCJzcmNfeG4iLCJzcmNfdGxkcyIsInVudHBsIiwidHBsIiwiZW1haWxfZnV6enkiLCJ0cGxfZW1haWxfZnV6enkiLCJsaW5rX2Z1enp5IiwidHBsX2xpbmtfZnV6enkiLCJsaW5rX25vX2lwX2Z1enp5IiwidHBsX2xpbmtfbm9faXBfZnV6enkiLCJob3N0X2Z1enp5X3Rlc3QiLCJ0cGxfaG9zdF9mdXp6eV90ZXN0IiwiYWxpYXNlcyIsIl9fY29tcGlsZWRfXyIsInNjaGVtYUVycm9yIiwiX19zY2hlbWFzX18iLCJjb21waWxlZCIsImFsaWFzIiwic2xpc3QiLCJmaWx0ZXIiLCJzY2hlbWFfdGVzdCIsInNyY19aUENjIiwic2NoZW1hX3NlYXJjaCIsInByZXRlc3QiLCJNYXRjaCIsInNoaWZ0IiwiX19sYXN0X2luZGV4X18iLCJzY2hlbWEiLCJfX3NjaGVtYV9fIiwibGFzdEluZGV4IiwicmF3IiwiY3JlYXRlTWF0Y2giLCJMaW5raWZ5SXQiLCJzY2hlbWFzIiwiYWRkIiwiZGVmaW5pdGlvbiIsIm1sIiwibWUiLCJ0bGRfcG9zIiwiYXRfcG9zIiwidGVzdFNjaGVtYUF0Iiwic2VhcmNoIiwia2VlcE9sZCIsInNvcnQiLCJlbCIsInJldmVyc2UiLCJvcHRzIiwic3JjX0FueSIsInNyY19DYyIsInNyY19aIiwic3JjX1AiLCJzcmNfWkNjIiwidGV4dF9zZXBhcmF0b3JzIiwic3JjX3BzZXVkb19sZXR0ZXIiLCJzcmNfaXA0Iiwic3JjX2hvc3QiLCJ0cGxfaG9zdF9mdXp6eSIsInRwbF9ob3N0X25vX2lwX2Z1enp5IiwidHBsX2hvc3RfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QiLCJ0cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCIsInBhcnNlTGlua0xhYmVsIiwicGFyc2VMaW5rRGVzdGluYXRpb24iLCJwYXJzZUxpbmtUaXRsZSIsImxpbmVzIiwib2siLCJkaXNhYmxlTmVzdGVkIiwicHJldlBvcyIsImxhYmVsRW5kIiwicG9zTWF4Iiwib2xkUG9zIiwiaW5saW5lIiwic2tpcFRva2VuIiwidXRpbHMiLCJoZWxwZXJzIiwiUmVuZGVyZXIiLCJQYXJzZXJDb3JlIiwiUGFyc2VyQmxvY2siLCJQYXJzZXJJbmxpbmUiLCJwdW55Y29kZSIsInplcm8iLCJjb21tb25tYXJrIiwiQkFEX1BST1RPX1JFIiwiR09PRF9EQVRBX1JFIiwidmFsaWRhdGVMaW5rIiwiUkVDT0RFX0hPU1ROQU1FX0ZPUiIsIm5vcm1hbGl6ZUxpbmsiLCJob3N0bmFtZSIsInByb3RvY29sIiwidG9BU0NJSSIsImVyIiwibm9ybWFsaXplTGlua1RleHQiLCJ0b1VuaWNvZGUiLCJNYXJrZG93bkl0IiwicHJlc2V0TmFtZSIsImNvcmUiLCJyZW5kZXJlciIsImxpbmtpZnkiLCJjb25maWd1cmUiLCJwcmVzZXRzIiwiY29tcG9uZW50cyIsInJ1bGVzIiwicnVsZXIiLCJydWxlczIiLCJydWxlcjIiLCJtaXNzZWQiLCJ1c2UiLCJwbHVnaW4iLCJlbnYiLCJTdGF0ZSIsInByb2Nlc3MiLCJwYXJzZUlubGluZSIsImlubGluZU1vZGUiLCJyZW5kZXJJbmxpbmUiLCJfcnVsZXMiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibGluZSIsImhhc0VtcHR5TGluZXMiLCJtYXhOZXN0aW5nIiwic2tpcEVtcHR5TGluZXMiLCJzQ291bnQiLCJibGtJbmRlbnQiLCJ0aWdodCIsImlzRW1wdHkiLCJvdXRUb2tlbnMiLCJsaW5lTWF4IiwiQ29yZSIsIl9ydWxlczIiLCJjYWNoZSIsInB1c2hQZW5kaW5nIiwieGh0bWxPdXQiLCJicmVha3MiLCJsYW5nUHJlZml4IiwidHlwb2dyYXBoZXIiLCJxdW90ZXMiLCJoaWdobGlnaHQiLCJkZWZhdWx0X3J1bGVzIiwiY29kZV9pbmxpbmUiLCJzbGYiLCJyZW5kZXJBdHRycyIsImNvZGVfYmxvY2siLCJmZW5jZSIsImxhbmdOYW1lIiwiaGlnaGxpZ2h0ZWQiLCJ0bXBBdHRycyIsInRtcFRva2VuIiwiaW1hZ2UiLCJyZW5kZXJJbmxpbmVBc1RleHQiLCJyZW5kZXJUb2tlbiIsImhhcmRicmVhayIsInNvZnRicmVhayIsImh0bWxfYmxvY2siLCJodG1sX2lubGluZSIsIm5leHRUb2tlbiIsIm5lZWRMZiIsImJsb2NrcXVvdGUiLCJhZGp1c3RUYWIiLCJpbml0aWFsIiwiaXNPdXRkZW50ZWQiLCJsYXN0TGluZUVtcHR5IiwibmV4dExpbmUiLCJvbGRCTWFya3MiLCJvbGRCU0NvdW50Iiwib2xkSW5kZW50Iiwib2xkUGFyZW50VHlwZSIsIm9sZFNDb3VudCIsIm9sZFRTaGlmdCIsInNwYWNlQWZ0ZXJNYXJrZXIiLCJ0ZXJtaW5hdGUiLCJ0ZXJtaW5hdG9yUnVsZXMiLCJvbGRMaW5lTWF4IiwiYk1hcmtzIiwidFNoaWZ0IiwiZU1hcmtzIiwiYnNDb3VudCIsInBhcmVudFR5cGUiLCJnZXRMaW5lcyIsIm1lbSIsImhhdmVFbmRNYXJrZXIiLCJza2lwQ2hhcnMiLCJza2lwU3BhY2VzIiwiaGVhZGluZyIsInNraXBTcGFjZXNCYWNrIiwic2tpcENoYXJzQmFjayIsImhyIiwiY250IiwiYmxvY2tfbmFtZXMiLCJIVE1MX1NFUVVFTkNFUyIsImxpbmVUZXh0IiwibGhlYWRpbmciLCJza2lwQnVsbGV0TGlzdE1hcmtlciIsInNraXBPcmRlcmVkTGlzdE1hcmtlciIsIm1hcmtUaWdodFBhcmFncmFwaHMiLCJjb250ZW50U3RhcnQiLCJpbmRlbnQiLCJpbmRlbnRBZnRlck1hcmtlciIsImlzT3JkZXJlZCIsIml0ZW1MaW5lcyIsImxpc3RMaW5lcyIsImxpc3RUb2tJZHgiLCJtYXJrZXJDaGFyQ29kZSIsIm1hcmtlclZhbHVlIiwib2xkTEluZGVudCIsIm9sZFRpZ2h0IiwicG9zQWZ0ZXJNYXJrZXIiLCJwcmV2RW1wdHlFbmQiLCJpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoIiwicGFyYWdyYXBoIiwicmVmZXJlbmNlIiwiX2VuZExpbmUiLCJkZXN0RW5kUG9zIiwiZGVzdEVuZExpbmVObyIsImxhYmVsIiwicmVmZXJlbmNlcyIsIlN0YXRlQmxvY2siLCJpbmRlbnRfZm91bmQiLCJkZEluZGVudCIsImJlZ2luIiwia2VlcExhc3RMRiIsImxpbmVJbmRlbnQiLCJmaXJzdCIsInF1ZXVlIiwibGluZVN0YXJ0IiwiZ2V0TGluZSIsImVzY2FwZWRTcGxpdCIsImVzY2FwZXMiLCJsYXN0UG9zIiwiYmFja1RpY2tlZCIsImxhc3RCYWNrVGljayIsInN1YnN0cmluZyIsInRhYmxlIiwiY29sdW1ucyIsImNvbHVtbkNvdW50IiwiYWxpZ25zIiwidCIsInRhYmxlTGluZXMiLCJ0Ym9keUxpbmVzIiwidG9rIiwiaXNMaW5rT3BlbiIsImlzTGlua0Nsb3NlIiwiY3VycmVudFRva2VuIiwibm9kZXMiLCJsbiIsImh0bWxMaW5rTGV2ZWwiLCJmdWxsVXJsIiwidXJsVGV4dCIsImJsb2NrVG9rZW5zIiwibGlua3MiLCJORVdMSU5FU19SRSIsIk5VTExfUkUiLCJSQVJFX1JFIiwiU0NPUEVEX0FCQlJfVEVTVF9SRSIsIlNDT1BFRF9BQkJSX1JFIiwiU0NPUEVEX0FCQlIiLCJyIiwicCIsInRtIiwicmVwbGFjZUZuIiwicmVwbGFjZV9zY29wZWQiLCJpbmxpbmVUb2tlbnMiLCJpbnNpZGVfYXV0b2xpbmsiLCJyZXBsYWNlX3JhcmUiLCJibGtJZHgiLCJRVU9URV9URVNUX1JFIiwiUVVPVEVfUkUiLCJBUE9TVFJPUEhFIiwicmVwbGFjZUF0IiwicHJvY2Vzc19pbmxpbmVzIiwidGhpc0xldmVsIiwibGFzdENoYXIiLCJuZXh0Q2hhciIsImlzTGFzdFB1bmN0Q2hhciIsImlzTmV4dFB1bmN0Q2hhciIsImlzTGFzdFdoaXRlU3BhY2UiLCJpc05leHRXaGl0ZVNwYWNlIiwiY2FuT3BlbiIsImNhbkNsb3NlIiwiaXNTaW5nbGUiLCJzdGFjayIsIm9wZW5RdW90ZSIsImNsb3NlUXVvdGUiLCJPVVRFUiIsInNpbmdsZSIsInNtYXJ0cXVvdGVzIiwiU3RhdGVDb3JlIiwiRU1BSUxfUkUiLCJBVVRPTElOS19SRSIsImF1dG9saW5rIiwibGlua01hdGNoIiwiZW1haWxNYXRjaCIsImJhY2t0aWNrIiwibWF0Y2hTdGFydCIsIm1hdGNoRW5kIiwibGlua19wYWlycyIsImxhc3REZWxpbSIsImN1cnJEZWxpbSIsIm9kZF9tYXRjaCIsIkRJR0lUQUxfUkUiLCJOQU1FRF9SRSIsIkVTQ0FQRUQiLCJlc2NhcGUiLCJpc0xldHRlciIsImxjIiwibGFiZWxTdGFydCIsInJlZiIsInBhcnNlUmVmZXJlbmNlIiwibmV3bGluZSIsInBtYXgiLCJTdGF0ZUlubGluZSIsInBlbmRpbmdMZXZlbCIsImNhblNwbGl0V29yZCIsImxlZnRfZmxhbmtpbmciLCJyaWdodF9mbGFua2luZyIsImlzVGVybWluYXRvckNoYXIiLCJ0ZXh0X2NvbGxhcHNlIiwiY3VyciIsImRlY29kZUNhY2hlIiwiZ2V0RGVjb2RlQ2FjaGUiLCJleGNsdWRlIiwiZGVmYXVsdENoYXJzIiwic2VxIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJjaHIiLCJjb21wb25lbnRDaGFycyIsImVuY29kZUNhY2hlIiwiZ2V0RW5jb2RlQ2FjaGUiLCJrZWVwRXNjYXBlZCIsIm5leHRDb2RlIiwic2xhc2hlcyIsImF1dGgiLCJwb3J0IiwiVXJsIiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsImhvc3RsZXNzUHJvdG9jb2wiLCJzbGFzaGVkUHJvdG9jb2wiLCJ1cmxQYXJzZSIsInNsYXNoZXNEZW5vdGVIb3N0IiwidSIsImxvd2VyUHJvdG8iLCJoZWMiLCJyZXN0Iiwic2ltcGxlUGF0aCIsInByb3RvIiwiaG9zdEVuZCIsImF0U2lnbiIsImhvc3QiLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwidW5zaGlmdCIsInFtIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJuZXh0VGljayIsIkl0ZW0iLCJicm93c2VyIiwiYXJndiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJtYXhJbnQiLCJiYXNlIiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJtYXBEb21haW4iLCJsYWJlbHMiLCJlbmNvZGVkIiwidWNzMmRlY29kZSIsImNvdW50ZXIiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJiaWFzIiwiYmFzaWMiLCJvbGRpIiwidyIsImJhc2VNaW51c1QiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwicSIsImN1cnJlbnRWYWx1ZSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInFNaW51c1QiLCJkZWZpbmUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJvbkdsb2JhbE1lc3NhZ2UiLCJldmVudCIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsImdldFByb3RvdHlwZU9mIiwiY3NzIiwiYmFzZVVybCIsImN1cnJlbnREaXIiLCJmaXhlZENzcyIsImZ1bGxNYXRjaCIsIm9yaWdVcmwiLCJ1bnF1b3RlZE9yaWdVcmwiLCIkMSIsIm5ld1VybCIsIlRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsImVucm9sbCIsIm1zZWNzIiwiX2lkbGVUaW1lb3V0SWQiLCJfaWRsZVRpbWVvdXQiLCJ1bmVucm9sbCIsIl91bnJlZkFjdGl2ZSIsIm9uVGltZW91dCIsIl9vblRpbWVvdXQiLCJBbnkiLCJDYyIsIkNmIiwiUCIsIloiLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsImVudW1lcmFibGUiLCJ0YWdzIiwib25jaGFuYWdlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FB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dkIsU0FBT00saUJBQWlCcEIsSUFBakIsQ0FBc0JjLEVBQXRCLENBQVA7QUFDRDs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNRLGNBQVQsQ0FBd0JSLEVBQXhCLEVBQTRCO0FBQzFCLFVBQVFBLEVBQVI7QUFDRSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUws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MkJBQTJCO0FBQzVDO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFF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QWdCLHNCQUFzQixXQUFXLFlBQVksWUFBWSx5QkFBeUIsWUFBWSxlQUFlOztBQUUxbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUM5a0VBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7QUNwQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7Ozs7Ozs7QUNwQkE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7a0JBRWU7QUFDYm5JLFVBQVEsdUJBQVM7QUFDZjNHLFVBQU0xSyxLQUFOLENBQVl3ZixLQUFaLEdBQW9COVUsTUFBTTdLLEtBQU4sQ0FBWTJmLEtBQWhDO0FBQ0E5VSxVQUFNMUssS0FBTixDQUFZeWdCLFFBQVosR0FBdUIsYUFBSztBQUMxQi9WLFlBQU0xSyxLQUFOLENBQVl3ZixLQUFaLENBQWtCMVksSUFBbEIsQ0FBdUIycEMsSUFBdkIsR0FBOEI1aUMsRUFBRTJGLEtBQUYsQ0FBUSxHQUFSLENBQTlCO0FBQ0QsS0FGRDtBQUdELEdBTlk7QUFPYnpSLFFBQU0scUJBQVM7QUFDYixRQUFNc2EsUUFBUSxrQ0FBTyxNQUFLLE1BQVosRUFBbUIsV0FBVyxpQkFBT28wQixJQUFyQztBQUNaLGdCQUFVLGtCQUFFdjNCLFFBQUYsQ0FBVyxPQUFYLEVBQW9CeE8sTUFBTTFLLEtBQU4sQ0FBWTB3QyxTQUFoQyxDQURFO0FBRVosYUFBT2htQyxNQUFNMUssS0FBTixDQUFZd2YsS0FBWixDQUFrQjFZLElBQWxCLENBQXVCMnBDLElBQXZCLENBQTRCanZDLElBQTVCLENBQWlDLEdBQWpDO0FBRkssTUFBZDtBQUlBLFdBQU8seUNBQU0sTUFBTSxFQUFaLEVBQWdCLE9BQU82YSxLQUF2QixHQUFQO0FBQ0Q7QUFiWSxDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDE5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBjNTdiZDhkZTRlZTYzNDE4NzI1NSIsIi8vIFV0aWxpdGllc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJzsgfVxuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8vIFJlbW92ZSBlbGVtZW50IGZyb20gYXJyYXkgYW5kIHB1dCBhbm90aGVyIGFycmF5IGF0IHRob3NlIHBvc2l0aW9uLlxuLy8gVXNlZnVsIGZvciBzb21lIG9wZXJhdGlvbnMgd2l0aCB0b2tlbnNcbmZ1bmN0aW9uIGFycmF5UmVwbGFjZUF0KHNyYywgcG9zLCBuZXdFbGVtZW50cykge1xuICByZXR1cm4gW10uY29uY2F0KHNyYy5zbGljZSgwLCBwb3MpLCBuZXdFbGVtZW50cywgc3JjLnNsaWNlKHBvcyArIDEpKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNWYWxpZEVudGl0eUNvZGUoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICAvLyBicm9rZW4gc2VxdWVuY2VcbiAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhERkZGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBuZXZlciB1c2VkXG4gIGlmIChjID49IDB4RkREMCAmJiBjIDw9IDB4RkRFRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKChjICYgMHhGRkZGKSA9PT0gMHhGRkZGIHx8IChjICYgMHhGRkZGKSA9PT0gMHhGRkZFKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBjb250cm9sIGNvZGVzXG4gIGlmIChjID49IDB4MDAgJiYgYyA8PSAweDA4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA9PT0gMHgwQikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPj0gMHgwRSAmJiBjIDw9IDB4MUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4N0YgJiYgYyA8PSAweDlGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBvdXQgb2YgcmFuZ2VcbiAgaWYgKGMgPiAweDEwRkZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICBpZiAoYyA+IDB4ZmZmZikge1xuICAgIGMgLT0gMHgxMDAwMDtcbiAgICB2YXIgc3Vycm9nYXRlMSA9IDB4ZDgwMCArIChjID4+IDEwKSxcbiAgICAgICAgc3Vycm9nYXRlMiA9IDB4ZGMwMCArIChjICYgMHgzZmYpO1xuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoc3Vycm9nYXRlMSwgc3Vycm9nYXRlMik7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG59XG5cblxudmFyIFVORVNDQVBFX01EX1JFICA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLlxcLzo7PD0+P0BbXFxcXFxcXV5fYHt8fX5dKS9nO1xudmFyIEVOVElUWV9SRSAgICAgICA9IC8mKFthLXojXVthLXowLTldezEsMzF9KTsvZ2k7XG52YXIgVU5FU0NBUEVfQUxMX1JFID0gbmV3IFJlZ0V4cChVTkVTQ0FQRV9NRF9SRS5zb3VyY2UgKyAnfCcgKyBFTlRJVFlfUkUuc291cmNlLCAnZ2knKTtcblxudmFyIERJR0lUQUxfRU5USVRZX1RFU1RfUkUgPSAvXiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpL2k7XG5cbnZhciBlbnRpdGllcyA9IHJlcXVpcmUoJy4vZW50aXRpZXMnKTtcblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIG5hbWUpIHtcbiAgdmFyIGNvZGUgPSAwO1xuXG4gIGlmIChoYXMoZW50aXRpZXMsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGVudGl0aWVzW25hbWVdO1xuICB9XG5cbiAgaWYgKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyMy8qICMgKi8gJiYgRElHSVRBTF9FTlRJVFlfVEVTVF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgY29kZSA9IG5hbWVbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMiksIDE2KVxuICAgIDpcbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMSksIDEwKTtcbiAgICBpZiAoaXNWYWxpZEVudGl0eUNvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuLypmdW5jdGlvbiByZXBsYWNlRW50aXRpZXMoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKEVOVElUWV9SRSwgcmVwbGFjZUVudGl0eVBhdHRlcm4pO1xufSovXG5cbmZ1bmN0aW9uIHVuZXNjYXBlTWQoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgJyQxJyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQWxsKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDAgJiYgc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9BTExfUkUsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgZW50aXR5KSB7XG4gICAgaWYgKGVzY2FwZWQpIHsgcmV0dXJuIGVzY2FwZWQ7IH1cbiAgICByZXR1cm4gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIGVudGl0eSk7XG4gIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgSFRNTF9FU0NBUEVfVEVTVF9SRSA9IC9bJjw+XCJdLztcbnZhciBIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFID0gL1smPD5cIl0vZztcbnZhciBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihjaCkge1xuICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBSRUdFWFBfRVNDQVBFX1JFID0gL1suPyorXiRbXFxdXFxcXCgpe318LV0vZztcblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzU3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6XG4gICAgY2FzZSAweDIwOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBacyAodW5pY29kZSBjbGFzcykgfHwgW1xcdFxcZlxcdlxcclxcbl1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjb2RlKSB7XG4gIGlmIChjb2RlID49IDB4MjAwMCAmJiBjb2RlIDw9IDB4MjAwQSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6IC8vIFxcdFxuICAgIGNhc2UgMHgwQTogLy8gXFxuXG4gICAgY2FzZSAweDBCOiAvLyBcXHZcbiAgICBjYXNlIDB4MEM6IC8vIFxcZlxuICAgIGNhc2UgMHgwRDogLy8gXFxyXG4gICAgY2FzZSAweDIwOlxuICAgIGNhc2UgMHhBMDpcbiAgICBjYXNlIDB4MTY4MDpcbiAgICBjYXNlIDB4MjAyRjpcbiAgICBjYXNlIDB4MjA1RjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cbnZhciBVTklDT0RFX1BVTkNUX1JFID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5cbi8vIEN1cnJlbnRseSB3aXRob3V0IGFzdHJhbCBjaGFyYWN0ZXJzIHN1cHBvcnQuXG5mdW5jdGlvbiBpc1B1bmN0Q2hhcihjaCkge1xuICByZXR1cm4gVU5JQ09ERV9QVU5DVF9SRS50ZXN0KGNoKTtcbn1cblxuXG4vLyBNYXJrZG93biBBU0NJSSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzLlxuLy9cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG4vL1xuLy8gRG9uJ3QgY29uZnVzZSB3aXRoIHVuaWNvZGUgcHVuY3R1YXRpb24gISEhIEl0IGxhY2tzIHNvbWUgY2hhcnMgaW4gYXNjaWkgcmFuZ2UuXG4vL1xuZnVuY3Rpb24gaXNNZEFzY2lpUHVuY3QoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIyLyogXCIgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MjcvKiAnICovOlxuICAgIGNhc2UgMHgyOC8qICggKi86XG4gICAgY2FzZSAweDI5LyogKSAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJDLyogLCAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgyRS8qIC4gKi86XG4gICAgY2FzZSAweDJGLyogLyAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQi8qIDsgKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDNGLyogPyAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3Qy8qIHwgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZXBsZXIgdG8gdW5pZnkgW3JlZmVyZW5jZSBsYWJlbHNdLlxuLy9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgLy8gdXNlIC50b1VwcGVyQ2FzZSgpIGluc3RlYWQgb2YgLnRvTG93ZXJDYXNlKClcbiAgLy8gaGVyZSB0byBhdm9pZCBhIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZVxuICAvLyBtZW1iZXJzIChtb3N0IG5vdGFibHksIGBfX3Byb3RvX19gKVxuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykudG9VcHBlckNhc2UoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUmUtZXhwb3J0IGxpYnJhcmllcyBjb21tb25seSB1c2VkIGluIGJvdGggbWFya2Rvd24taXQgYW5kIGl0cyBwbHVnaW5zLFxuLy8gc28gcGx1Z2lucyB3b24ndCBoYXZlIHRvIGRlcGVuZCBvbiB0aGVtIGV4cGxpY2l0bHksIHdoaWNoIHJlZHVjZXMgdGhlaXJcbi8vIGJ1bmRsZWQgc2l6ZSAoZS5nLiBhIGJyb3dzZXIgYnVpbGQpLlxuLy9cbmV4cG9ydHMubGliICAgICAgICAgICAgICAgICA9IHt9O1xuZXhwb3J0cy5saWIubWR1cmwgICAgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbmV4cG9ydHMubGliLnVjbWljcm8gICAgICAgICA9IHJlcXVpcmUoJ3VjLm1pY3JvJyk7XG5cbmV4cG9ydHMuYXNzaWduICAgICAgICAgICAgICA9IGFzc2lnbjtcbmV4cG9ydHMuaXNTdHJpbmcgICAgICAgICAgICA9IGlzU3RyaW5nO1xuZXhwb3J0cy5oYXMgICAgICAgICAgICAgICAgID0gaGFzO1xuZXhwb3J0cy51bmVzY2FwZU1kICAgICAgICAgID0gdW5lc2NhcGVNZDtcbmV4cG9ydHMudW5lc2NhcGVBbGwgICAgICAgICA9IHVuZXNjYXBlQWxsO1xuZXhwb3J0cy5pc1ZhbGlkRW50aXR5Q29kZSAgID0gaXNWYWxpZEVudGl0eUNvZGU7XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgICAgICAgPSBmcm9tQ29kZVBvaW50O1xuLy8gZXhwb3J0cy5yZXBsYWNlRW50aXRpZXMgICAgID0gcmVwbGFjZUVudGl0aWVzO1xuZXhwb3J0cy5lc2NhcGVIdG1sICAgICAgICAgID0gZXNjYXBlSHRtbDtcbmV4cG9ydHMuYXJyYXlSZXBsYWNlQXQgICAgICA9IGFycmF5UmVwbGFjZUF0O1xuZXhwb3J0cy5pc1NwYWNlICAgICAgICAgICAgID0gaXNTcGFjZTtcbmV4cG9ydHMuaXNXaGl0ZVNwYWNlICAgICAgICA9IGlzV2hpdGVTcGFjZTtcbmV4cG9ydHMuaXNNZEFzY2lpUHVuY3QgICAgICA9IGlzTWRBc2NpaVB1bmN0O1xuZXhwb3J0cy5pc1B1bmN0Q2hhciAgICAgICAgID0gaXNQdW5jdENoYXI7XG5leHBvcnRzLmVzY2FwZVJFICAgICAgICAgICAgPSBlc2NhcGVSRTtcbmV4cG9ydHMubm9ybWFsaXplUmVmZXJlbmNlICA9IG5vcm1hbGl6ZVJlZmVyZW5jZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMuanMiLCI7KGZ1bmN0aW9uKCkge1xuXCJ1c2Ugc3RyaWN0XCJcbmZ1bmN0aW9uIFZub2RlKHRhZywga2V5LCBhdHRyczAsIGNoaWxkcmVuLCB0ZXh0LCBkb20pIHtcblx0cmV0dXJuIHt0YWc6IHRhZywga2V5OiBrZXksIGF0dHJzOiBhdHRyczAsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dDogdGV4dCwgZG9tOiBkb20sIGRvbVNpemU6IHVuZGVmaW5lZCwgc3RhdGU6IHVuZGVmaW5lZCwgX3N0YXRlOiB1bmRlZmluZWQsIGV2ZW50czogdW5kZWZpbmVkLCBpbnN0YW5jZTogdW5kZWZpbmVkLCBza2lwOiBmYWxzZX1cbn1cblZub2RlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHJldHVybiBWbm9kZShcIltcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKG5vZGUpLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0aWYgKG5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIFZub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbm9kZSA9PT0gZmFsc2UgPyBcIlwiIDogbm9kZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdHJldHVybiBub2RlXG59XG5Wbm9kZS5ub3JtYWxpemVDaGlsZHJlbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZHJlbltpXSA9IFZub2RlLm5vcm1hbGl6ZShjaGlsZHJlbltpXSlcblx0fVxuXHRyZXR1cm4gY2hpbGRyZW5cbn1cbnZhciBzZWxlY3RvclBhcnNlciA9IC8oPzooXnwjfFxcLikoW14jXFwuXFxbXFxdXSspKXwoXFxbKC4rPykoPzpcXHMqPVxccyooXCJ8J3wpKCg/OlxcXFxbXCInXFxdXXwuKSo/KVxcNSk/XFxdKS9nXG52YXIgc2VsZWN0b3JDYWNoZSA9IHt9XG52YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHlcbmZ1bmN0aW9uIGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcikge1xuXHR2YXIgbWF0Y2gsIHRhZyA9IFwiZGl2XCIsIGNsYXNzZXMgPSBbXSwgYXR0cnMgPSB7fVxuXHR3aGlsZSAobWF0Y2ggPSBzZWxlY3RvclBhcnNlci5leGVjKHNlbGVjdG9yKSkge1xuXHRcdHZhciB0eXBlID0gbWF0Y2hbMV0sIHZhbHVlID0gbWF0Y2hbMl1cblx0XHRpZiAodHlwZSA9PT0gXCJcIiAmJiB2YWx1ZSAhPT0gXCJcIikgdGFnID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIiNcIikgYXR0cnMuaWQgPSB2YWx1ZVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwiLlwiKSBjbGFzc2VzLnB1c2godmFsdWUpXG5cdFx0ZWxzZSBpZiAobWF0Y2hbM11bMF0gPT09IFwiW1wiKSB7XG5cdFx0XHR2YXIgYXR0clZhbHVlID0gbWF0Y2hbNl1cblx0XHRcdGlmIChhdHRyVmFsdWUpIGF0dHJWYWx1ZSA9IGF0dHJWYWx1ZS5yZXBsYWNlKC9cXFxcKFtcIiddKS9nLCBcIiQxXCIpLnJlcGxhY2UoL1xcXFxcXFxcL2csIFwiXFxcXFwiKVxuXHRcdFx0aWYgKG1hdGNoWzRdID09PSBcImNsYXNzXCIpIGNsYXNzZXMucHVzaChhdHRyVmFsdWUpXG5cdFx0XHRlbHNlIGF0dHJzW21hdGNoWzRdXSA9IGF0dHJWYWx1ZSB8fCB0cnVlXG5cdFx0fVxuXHR9XG5cdGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcIiBcIilcblx0cmV0dXJuIHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdID0ge3RhZzogdGFnLCBhdHRyczogYXR0cnN9XG59XG5mdW5jdGlvbiBleGVjU2VsZWN0b3Ioc3RhdGUsIGF0dHJzLCBjaGlsZHJlbikge1xuXHR2YXIgaGFzQXR0cnMgPSBmYWxzZSwgY2hpbGRMaXN0LCB0ZXh0XG5cdHZhciBjbGFzc05hbWUgPSBhdHRycy5jbGFzc05hbWUgfHwgYXR0cnMuY2xhc3Ncblx0Zm9yICh2YXIga2V5IGluIHN0YXRlLmF0dHJzKSB7XG5cdFx0aWYgKGhhc093bi5jYWxsKHN0YXRlLmF0dHJzLCBrZXkpKSB7XG5cdFx0XHRhdHRyc1trZXldID0gc3RhdGUuYXR0cnNba2V5XVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoYXR0cnMuY2xhc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXR0cnMuY2xhc3MgPSB1bmRlZmluZWRcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuXHRcdH1cblx0XHRpZiAoc3RhdGUuYXR0cnMuY2xhc3NOYW1lICE9IG51bGwpIHtcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IHN0YXRlLmF0dHJzLmNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NOYW1lXG5cdFx0fVxuXHR9XG5cdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSAmJiBrZXkgIT09IFwia2V5XCIpIHtcblx0XHRcdGhhc0F0dHJzID0gdHJ1ZVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdH1cblx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXSAhPSBudWxsICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCIjXCIpIHtcblx0XHR0ZXh0ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0fSBlbHNlIHtcblx0XHRjaGlsZExpc3QgPSBjaGlsZHJlblxuXHR9XG5cdHJldHVybiBWbm9kZShzdGF0ZS50YWcsIGF0dHJzLmtleSwgaGFzQXR0cnMgPyBhdHRycyA6IHVuZGVmaW5lZCwgY2hpbGRMaXN0LCB0ZXh0KVxufVxuZnVuY3Rpb24gaHlwZXJzY3JpcHQoc2VsZWN0b3IpIHtcblx0Ly8gQmVjYXVzZSBzbG9wcHkgbW9kZSBzdWNrc1xuXHR2YXIgYXR0cnMgPSBhcmd1bWVudHNbMV0sIHN0YXJ0ID0gMiwgY2hpbGRyZW5cblx0aWYgKHNlbGVjdG9yID09IG51bGwgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzZWxlY3Rvci52aWV3ICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR0aHJvdyBFcnJvcihcIlRoZSBzZWxlY3RvciBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhIGNvbXBvbmVudC5cIik7XG5cdH1cblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHZhciBjYWNoZWQgPSBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSB8fCBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpXG5cdH1cblx0aWYgKGF0dHJzID09IG51bGwpIHtcblx0XHRhdHRycyA9IHt9XG5cdH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzICE9PSBcIm9iamVjdFwiIHx8IGF0dHJzLnRhZyAhPSBudWxsIHx8IEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHRcdHN0YXJ0ID0gMVxuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSBzdGFydCArIDEpIHtcblx0XHRjaGlsZHJlbiA9IGFyZ3VtZW50c1tzdGFydF1cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSBjaGlsZHJlbiA9IFtjaGlsZHJlbl1cblx0fSBlbHNlIHtcblx0XHRjaGlsZHJlbiA9IFtdXG5cdFx0d2hpbGUgKHN0YXJ0IDwgYXJndW1lbnRzLmxlbmd0aCkgY2hpbGRyZW4ucHVzaChhcmd1bWVudHNbc3RhcnQrK10pXG5cdH1cblx0dmFyIG5vcm1hbGl6ZWQgPSBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbilcblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBleGVjU2VsZWN0b3IoY2FjaGVkLCBhdHRycywgbm9ybWFsaXplZClcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gVm5vZGUoc2VsZWN0b3IsIGF0dHJzLmtleSwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH1cbn1cbmh5cGVyc2NyaXB0LnRydXN0ID0gZnVuY3Rpb24oaHRtbCkge1xuXHRpZiAoaHRtbCA9PSBudWxsKSBodG1sID0gXCJcIlxuXHRyZXR1cm4gVm5vZGUoXCI8XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBodG1sLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbmh5cGVyc2NyaXB0LmZyYWdtZW50ID0gZnVuY3Rpb24oYXR0cnMxLCBjaGlsZHJlbikge1xuXHRyZXR1cm4gVm5vZGUoXCJbXCIsIGF0dHJzMS5rZXksIGF0dHJzMSwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbnZhciBtID0gaHlwZXJzY3JpcHRcbi8qKiBAY29uc3RydWN0b3IgKi9cbnZhciBQcm9taXNlUG9seWZpbGwgPSBmdW5jdGlvbihleGVjdXRvcikge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGBuZXdgXCIpXG5cdGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvblwiKVxuXHR2YXIgc2VsZiA9IHRoaXMsIHJlc29sdmVycyA9IFtdLCByZWplY3RvcnMgPSBbXSwgcmVzb2x2ZUN1cnJlbnQgPSBoYW5kbGVyKHJlc29sdmVycywgdHJ1ZSksIHJlamVjdEN1cnJlbnQgPSBoYW5kbGVyKHJlamVjdG9ycywgZmFsc2UpXG5cdHZhciBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlID0ge3Jlc29sdmVyczogcmVzb2x2ZXJzLCByZWplY3RvcnM6IHJlamVjdG9yc31cblx0dmFyIGNhbGxBc3luYyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gaGFuZGxlcihsaXN0LCBzaG91bGRBYnNvcmIpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXhlY3V0ZSh2YWx1ZSkge1xuXHRcdFx0dmFyIHRoZW5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChzaG91bGRBYnNvcmIgJiYgdmFsdWUgIT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgKHRoZW4gPSB2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBzZWxmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCB3LyBpdHNlbGZcIilcblx0XHRcdFx0XHRleGVjdXRlT25jZSh0aGVuLmJpbmQodmFsdWUpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxBc3luYyhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICghc2hvdWxkQWJzb3JiICYmIGxpc3QubGVuZ3RoID09PSAwKSBjb25zb2xlLmVycm9yKFwiUG9zc2libGUgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOlwiLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgbGlzdFtpXSh2YWx1ZSlcblx0XHRcdFx0XHRcdHJlc29sdmVycy5sZW5ndGggPSAwLCByZWplY3RvcnMubGVuZ3RoID0gMFxuXHRcdFx0XHRcdFx0aW5zdGFuY2Uuc3RhdGUgPSBzaG91bGRBYnNvcmJcblx0XHRcdFx0XHRcdGluc3RhbmNlLnJldHJ5ID0gZnVuY3Rpb24oKSB7ZXhlY3V0ZSh2YWx1ZSl9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVqZWN0Q3VycmVudChlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBleGVjdXRlT25jZSh0aGVuKSB7XG5cdFx0dmFyIHJ1bnMgPSAwXG5cdFx0ZnVuY3Rpb24gcnVuKGZuKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKHJ1bnMrKyA+IDApIHJldHVyblxuXHRcdFx0XHRmbih2YWx1ZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIG9uZXJyb3IgPSBydW4ocmVqZWN0Q3VycmVudClcblx0XHR0cnkge3RoZW4ocnVuKHJlc29sdmVDdXJyZW50KSwgb25lcnJvcil9IGNhdGNoIChlKSB7b25lcnJvcihlKX1cblx0fVxuXHRleGVjdXRlT25jZShleGVjdXRvcilcbn1cblByb21pc2VQb2x5ZmlsbC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGlvbikge1xuXHR2YXIgc2VsZiA9IHRoaXMsIGluc3RhbmNlID0gc2VsZi5faW5zdGFuY2Vcblx0ZnVuY3Rpb24gaGFuZGxlKGNhbGxiYWNrLCBsaXN0LCBuZXh0LCBzdGF0ZSkge1xuXHRcdGxpc3QucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSBuZXh0KHZhbHVlKVxuXHRcdFx0ZWxzZSB0cnkge3Jlc29sdmVOZXh0KGNhbGxiYWNrKHZhbHVlKSl9IGNhdGNoIChlKSB7aWYgKHJlamVjdE5leHQpIHJlamVjdE5leHQoZSl9XG5cdFx0fSlcblx0XHRpZiAodHlwZW9mIGluc3RhbmNlLnJldHJ5ID09PSBcImZ1bmN0aW9uXCIgJiYgc3RhdGUgPT09IGluc3RhbmNlLnN0YXRlKSBpbnN0YW5jZS5yZXRyeSgpXG5cdH1cblx0dmFyIHJlc29sdmVOZXh0LCByZWplY3ROZXh0XG5cdHZhciBwcm9taXNlID0gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZXNvbHZlTmV4dCA9IHJlc29sdmUsIHJlamVjdE5leHQgPSByZWplY3R9KVxuXHRoYW5kbGUob25GdWxmaWxsZWQsIGluc3RhbmNlLnJlc29sdmVycywgcmVzb2x2ZU5leHQsIHRydWUpLCBoYW5kbGUob25SZWplY3Rpb24sIGluc3RhbmNlLnJlamVjdG9ycywgcmVqZWN0TmV4dCwgZmFsc2UpXG5cdHJldHVybiBwcm9taXNlXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcblx0cmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbilcbn1cblByb21pc2VQb2x5ZmlsbC5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSByZXR1cm4gdmFsdWVcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSkge3Jlc29sdmUodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZWplY3QodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5hbGwgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdHZhciB0b3RhbCA9IGxpc3QubGVuZ3RoLCBjb3VudCA9IDAsIHZhbHVlcyA9IFtdXG5cdFx0aWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKVxuXHRcdGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQoZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRmdW5jdGlvbiBjb25zdW1lKHZhbHVlKSB7XG5cdFx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSB0b3RhbCkgcmVzb2x2ZSh2YWx1ZXMpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxpc3RbaV0gIT0gbnVsbCAmJiAodHlwZW9mIGxpc3RbaV0gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGxpc3RbaV0gPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mIGxpc3RbaV0udGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0bGlzdFtpXS50aGVuKGNvbnN1bWUsIHJlamVjdClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGNvbnN1bWUobGlzdFtpXSlcblx0XHRcdH0pKGkpXG5cdFx0fVxuXHR9KVxufVxuUHJvbWlzZVBvbHlmaWxsLnJhY2UgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGlzdFtpXS50aGVuKHJlc29sdmUsIHJlamVjdClcblx0XHR9XG5cdH0pXG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRpZiAodHlwZW9mIHdpbmRvdy5Qcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSB3aW5kb3cuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR2YXIgUHJvbWlzZVBvbHlmaWxsID0gd2luZG93LlByb21pc2Vcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRpZiAodHlwZW9mIGdsb2JhbC5Qcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSBnbG9iYWwuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR2YXIgUHJvbWlzZVBvbHlmaWxsID0gZ2xvYmFsLlByb21pc2Vcbn0gZWxzZSB7XG59XG52YXIgYnVpbGRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHJldHVybiBcIlwiXG5cdHZhciBhcmdzID0gW11cblx0Zm9yICh2YXIga2V5MCBpbiBvYmplY3QpIHtcblx0XHRkZXN0cnVjdHVyZShrZXkwLCBvYmplY3Rba2V5MF0pXG5cdH1cblx0cmV0dXJuIGFyZ3Muam9pbihcIiZcIilcblx0ZnVuY3Rpb24gZGVzdHJ1Y3R1cmUoa2V5MCwgdmFsdWUpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRkZXN0cnVjdHVyZShrZXkwICsgXCJbXCIgKyBpICsgXCJdXCIsIHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGFyZ3MucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5MCkgKyAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gXCJcIiA/IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IFwiXCIpKVxuXHR9XG59XG52YXIgRklMRV9QUk9UT0NPTF9SRUdFWCA9IG5ldyBSZWdFeHAoXCJeZmlsZTovL1wiLCBcImlcIilcbnZhciBfOCA9IGZ1bmN0aW9uKCR3aW5kb3csIFByb21pc2UpIHtcblx0dmFyIGNhbGxiYWNrQ291bnQgPSAwXG5cdHZhciBvbmNvbXBsZXRpb25cblx0ZnVuY3Rpb24gc2V0Q29tcGxldGlvbkNhbGxiYWNrKGNhbGxiYWNrKSB7b25jb21wbGV0aW9uID0gY2FsbGJhY2t9XG5cdGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcblx0XHR2YXIgY291bnQgPSAwXG5cdFx0ZnVuY3Rpb24gY29tcGxldGUoKSB7aWYgKC0tY291bnQgPT09IDAgJiYgdHlwZW9mIG9uY29tcGxldGlvbiA9PT0gXCJmdW5jdGlvblwiKSBvbmNvbXBsZXRpb24oKX1cblx0XHRyZXR1cm4gZnVuY3Rpb24gZmluYWxpemUocHJvbWlzZTApIHtcblx0XHRcdHZhciB0aGVuMCA9IHByb21pc2UwLnRoZW5cblx0XHRcdHByb21pc2UwLnRoZW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHR2YXIgbmV4dCA9IHRoZW4wLmFwcGx5KHByb21pc2UwLCBhcmd1bWVudHMpXG5cdFx0XHRcdG5leHQudGhlbihjb21wbGV0ZSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGNvbXBsZXRlKClcblx0XHRcdFx0XHRpZiAoY291bnQgPT09IDApIHRocm93IGVcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuIGZpbmFsaXplKG5leHQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTBcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmdzID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgdXJsID0gYXJnc1xuXHRcdFx0YXJncyA9IGV4dHJhIHx8IHt9XG5cdFx0XHRpZiAoYXJncy51cmwgPT0gbnVsbCkgYXJncy51cmwgPSB1cmxcblx0XHR9XG5cdFx0cmV0dXJuIGFyZ3Ncblx0fVxuXHRmdW5jdGlvbiByZXF1ZXN0KGFyZ3MsIGV4dHJhKSB7XG5cdFx0dmFyIGZpbmFsaXplID0gZmluYWxpemVyKClcblx0XHRhcmdzID0gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKVxuXHRcdHZhciBwcm9taXNlMCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0aWYgKGFyZ3MubWV0aG9kID09IG51bGwpIGFyZ3MubWV0aG9kID0gXCJHRVRcIlxuXHRcdFx0YXJncy5tZXRob2QgPSBhcmdzLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG5cdFx0XHR2YXIgdXNlQm9keSA9IChhcmdzLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBhcmdzLm1ldGhvZCA9PT0gXCJUUkFDRVwiKSA/IGZhbHNlIDogKHR5cGVvZiBhcmdzLnVzZUJvZHkgPT09IFwiYm9vbGVhblwiID8gYXJncy51c2VCb2R5IDogdHJ1ZSlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5zZXJpYWxpemUgIT09IFwiZnVuY3Rpb25cIikgYXJncy5zZXJpYWxpemUgPSB0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJncy5kYXRhIGluc3RhbmNlb2YgRm9ybURhdGEgPyBmdW5jdGlvbih2YWx1ZSkge3JldHVybiB2YWx1ZX0gOiBKU09OLnN0cmluZ2lmeVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmRlc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmV4dHJhY3QgIT09IFwiZnVuY3Rpb25cIikgYXJncy5leHRyYWN0ID0gZXh0cmFjdFxuXHRcdFx0YXJncy51cmwgPSBpbnRlcnBvbGF0ZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0aWYgKHVzZUJvZHkpIGFyZ3MuZGF0YSA9IGFyZ3Muc2VyaWFsaXplKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgYXJncy51cmwgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0dmFyIHhociA9IG5ldyAkd2luZG93LlhNTEh0dHBSZXF1ZXN0KCksXG5cdFx0XHRcdGFib3J0ZWQgPSBmYWxzZSxcblx0XHRcdFx0X2Fib3J0ID0geGhyLmFib3J0XG5cdFx0XHR4aHIuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcblx0XHRcdFx0YWJvcnRlZCA9IHRydWVcblx0XHRcdFx0X2Fib3J0LmNhbGwoeGhyKVxuXHRcdFx0fVxuXHRcdFx0eGhyLm9wZW4oYXJncy5tZXRob2QsIGFyZ3MudXJsLCB0eXBlb2YgYXJncy5hc3luYyA9PT0gXCJib29sZWFuXCIgPyBhcmdzLmFzeW5jIDogdHJ1ZSwgdHlwZW9mIGFyZ3MudXNlciA9PT0gXCJzdHJpbmdcIiA/IGFyZ3MudXNlciA6IHVuZGVmaW5lZCwgdHlwZW9mIGFyZ3MucGFzc3dvcmQgPT09IFwic3RyaW5nXCIgPyBhcmdzLnBhc3N3b3JkIDogdW5kZWZpbmVkKVxuXHRcdFx0aWYgKGFyZ3Muc2VyaWFsaXplID09PSBKU09OLnN0cmluZ2lmeSAmJiB1c2VCb2R5KSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MuZGVzZXJpYWxpemUgPT09IGRlc2VyaWFsaXplKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC8qXCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy53aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSBhcmdzLndpdGhDcmVkZW50aWFsc1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZ3MuaGVhZGVycykgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXJncy5oZWFkZXJzLCBrZXkpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgYXJncy5oZWFkZXJzW2tleV0pXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuY29uZmlnID09PSBcImZ1bmN0aW9uXCIpIHhociA9IGFyZ3MuY29uZmlnKHhociwgYXJncykgfHwgeGhyXG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIERvbid0IHRocm93IGVycm9ycyBvbiB4aHIuYWJvcnQoKS5cblx0XHRcdFx0aWYoYWJvcnRlZCkgcmV0dXJuXG5cdFx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVzcG9uc2UgPSAoYXJncy5leHRyYWN0ICE9PSBleHRyYWN0KSA/IGFyZ3MuZXh0cmFjdCh4aHIsIGFyZ3MpIDogYXJncy5kZXNlcmlhbGl6ZShhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSlcblx0XHRcdFx0XHRcdGlmICgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PT0gMzA0IHx8IEZJTEVfUFJPVE9DT0xfUkVHRVgudGVzdChhcmdzLnVybCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShjYXN0KGFyZ3MudHlwZSwgcmVzcG9uc2UpKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcih4aHIucmVzcG9uc2VUZXh0KVxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UpIGVycm9yW2tleV0gPSByZXNwb25zZVtrZXldXG5cdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZUJvZHkgJiYgKGFyZ3MuZGF0YSAhPSBudWxsKSkgeGhyLnNlbmQoYXJncy5kYXRhKVxuXHRcdFx0ZWxzZSB4aHIuc2VuZCgpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlID8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBqc29ucChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHZhciBjYWxsYmFja05hbWUgPSBhcmdzLmNhbGxiYWNrTmFtZSB8fCBcIl9taXRocmlsX1wiICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxNikgKyBcIl9cIiArIGNhbGxiYWNrQ291bnQrK1xuXHRcdFx0dmFyIHNjcmlwdCA9ICR3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKVxuXHRcdFx0JHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIGRhdGEpKVxuXHRcdFx0XHRkZWxldGUgJHdpbmRvd1tjYWxsYmFja05hbWVdXG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJKU09OUCByZXF1ZXN0IGZhaWxlZFwiKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MuZGF0YSA9PSBudWxsKSBhcmdzLmRhdGEgPSB7fVxuXHRcdFx0YXJncy51cmwgPSBpbnRlcnBvbGF0ZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0YXJncy5kYXRhW2FyZ3MuY2FsbGJhY2tLZXkgfHwgXCJjYWxsYmFja1wiXSA9IGNhbGxiYWNrTmFtZVxuXHRcdFx0c2NyaXB0LnNyYyA9IGFzc2VtYmxlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHQkd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlPyBwcm9taXNlMCA6IGZpbmFsaXplKHByb21pc2UwKVxuXHR9XG5cdGZ1bmN0aW9uIGludGVycG9sYXRlKHVybCwgZGF0YSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHJldHVybiB1cmxcblx0XHR2YXIgdG9rZW5zID0gdXJsLm1hdGNoKC86W15cXC9dKy9naSkgfHwgW11cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IHRva2Vuc1tpXS5zbGljZSgxKVxuXHRcdFx0aWYgKGRhdGFba2V5XSAhPSBudWxsKSB7XG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHRva2Vuc1tpXSwgZGF0YVtrZXldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXJsXG5cdH1cblx0ZnVuY3Rpb24gYXNzZW1ibGUodXJsLCBkYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5c3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZyhkYXRhKVxuXHRcdGlmIChxdWVyeXN0cmluZyAhPT0gXCJcIikge1xuXHRcdFx0dmFyIHByZWZpeCA9IHVybC5pbmRleE9mKFwiP1wiKSA8IDAgPyBcIj9cIiA6IFwiJlwiXG5cdFx0XHR1cmwgKz0gcHJlZml4ICsgcXVlcnlzdHJpbmdcblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGRlc2VyaWFsaXplKGRhdGEpIHtcblx0XHR0cnkge3JldHVybiBkYXRhICE9PSBcIlwiID8gSlNPTi5wYXJzZShkYXRhKSA6IG51bGx9XG5cdFx0Y2F0Y2ggKGUpIHt0aHJvdyBuZXcgRXJyb3IoZGF0YSl9XG5cdH1cblx0ZnVuY3Rpb24gZXh0cmFjdCh4aHIpIHtyZXR1cm4geGhyLnJlc3BvbnNlVGV4dH1cblx0ZnVuY3Rpb24gY2FzdCh0eXBlMCwgZGF0YSkge1xuXHRcdGlmICh0eXBlb2YgdHlwZTAgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YVtpXSA9IG5ldyB0eXBlMChkYXRhW2ldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHJldHVybiBuZXcgdHlwZTAoZGF0YSlcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHRyZXR1cm4ge3JlcXVlc3Q6IHJlcXVlc3QsIGpzb25wOiBqc29ucCwgc2V0Q29tcGxldGlvbkNhbGxiYWNrOiBzZXRDb21wbGV0aW9uQ2FsbGJhY2t9XG59XG52YXIgcmVxdWVzdFNlcnZpY2UgPSBfOCh3aW5kb3csIFByb21pc2VQb2x5ZmlsbClcbnZhciBjb3JlUmVuZGVyZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciAkZG9jID0gJHdpbmRvdy5kb2N1bWVudFxuXHR2YXIgJGVtcHR5RnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHR2YXIgb25ldmVudFxuXHRmdW5jdGlvbiBzZXRFdmVudENhbGxiYWNrKGNhbGxiYWNrKSB7cmV0dXJuIG9uZXZlbnQgPSBjYWxsYmFja31cblx0Ly9jcmVhdGVcblx0ZnVuY3Rpb24gY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAodHlwZW9mIHRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHN3aXRjaCAodGFnKSB7XG5cdFx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiPFwiOiByZXR1cm4gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIltcIjogcmV0dXJuIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGRlZmF1bHQ6IHJldHVybiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2bm9kZS5kb20gPSAkZG9jLmNyZWF0ZVRleHROb2RlKHZub2RlLmNoaWxkcmVuKVxuXHRcdGluc2VydE5vZGUocGFyZW50LCB2bm9kZS5kb20sIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIG1hdGNoMSA9IHZub2RlLmNoaWxkcmVuLm1hdGNoKC9eXFxzKj88KFxcdyspL2ltKSB8fCBbXVxuXHRcdHZhciBwYXJlbnQxID0ge2NhcHRpb246IFwidGFibGVcIiwgdGhlYWQ6IFwidGFibGVcIiwgdGJvZHk6IFwidGFibGVcIiwgdGZvb3Q6IFwidGFibGVcIiwgdHI6IFwidGJvZHlcIiwgdGg6IFwidHJcIiwgdGQ6IFwidHJcIiwgY29sZ3JvdXA6IFwidGFibGVcIiwgY29sOiBcImNvbGdyb3VwXCJ9W21hdGNoMVsxXV0gfHwgXCJkaXZcIlxuXHRcdHZhciB0ZW1wID0gJGRvYy5jcmVhdGVFbGVtZW50KHBhcmVudDEpXG5cdFx0dGVtcC5pbm5lckhUTUwgPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IHRlbXAuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSB0ZW1wLmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHR2YXIgY2hpbGRcblx0XHR3aGlsZSAoY2hpbGQgPSB0ZW1wLmZpcnN0Q2hpbGQpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0Y3JlYXRlTm9kZXMoZnJhZ21lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gZnJhZ21lbnQuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdHN3aXRjaCAodm5vZGUudGFnKSB7XG5cdFx0XHRjYXNlIFwic3ZnXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiOyBicmVha1xuXHRcdFx0Y2FzZSBcIm1hdGhcIjogbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjsgYnJlYWtcblx0XHR9XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCB1bmRlZmluZWQpXG5cdFx0ZWxzZSBpZiAodm5vZGVzID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgMCwgb2xkLmxlbmd0aCwgdm5vZGVzKVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC5sZW5ndGggPT09IHZub2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlzVW5rZXllZCA9IGZhbHNlXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIG9sZFtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpc1Vua2V5ZWQgPSB2bm9kZXNbaV0ua2V5ID09IG51bGwgJiYgb2xkW2ldLmtleSA9PSBudWxsXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNVbmtleWVkKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChvbGRbaV0gPT09IHZub2Rlc1tpXSkgY29udGludWVcblx0XHRcdFx0XHRcdGVsc2UgaWYgKG9sZFtpXSA9PSBudWxsICYmIHZub2Rlc1tpXSAhPSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGVzW2ldLCBob29rcywgbnMsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHZub2Rlc1tpXSA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIGksIGkgKyAxLCB2bm9kZXMpXG5cdFx0XHRcdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGRbaV0sIHZub2Rlc1tpXSwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlY3ljbGluZyA9IHJlY3ljbGluZyB8fCBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpXG5cdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdHZhciBwb29sID0gb2xkLnBvb2xcblx0XHRcdFx0b2xkID0gb2xkLmNvbmNhdChvbGQucG9vbClcblx0XHRcdH1cblx0XHRcdHZhciBvbGRTdGFydCA9IDAsIHN0YXJ0ID0gMCwgb2xkRW5kID0gb2xkLmxlbmd0aCAtIDEsIGVuZCA9IHZub2Rlcy5sZW5ndGggLSAxLCBtYXBcblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZFN0YXJ0XSwgdiA9IHZub2Rlc1tzdGFydF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZFN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRTdGFydCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0b2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF1cblx0XHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0XHRpZiAocmVjeWNsaW5nIHx8IHN0YXJ0IDwgZW5kKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0b2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdLCB2ID0gdm5vZGVzW2VuZF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdGlmIChvLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG8uZG9tXG5cdFx0XHRcdFx0b2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCFtYXApIG1hcCA9IGdldEtleU1hcChvbGQsIG9sZEVuZClcblx0XHRcdFx0XHRpZiAodiAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHR2YXIgb2xkSW5kZXggPSBtYXBbdi5rZXldXG5cdFx0XHRcdFx0XHRpZiAob2xkSW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbW92YWJsZSA9IG9sZFtvbGRJbmRleF1cblx0XHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEluZGV4ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG1vdmFibGUsIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobW92YWJsZSksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRvbGRbb2xkSW5kZXhdLnNraXAgPSB0cnVlXG5cdFx0XHRcdFx0XHRcdGlmIChtb3ZhYmxlLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG1vdmFibGUuZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRvbSA9IGNyZWF0ZU5vZGUocGFyZW50LCB2LCBob29rcywgdW5kZWZpbmVkLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0bmV4dFNpYmxpbmcgPSBkb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZW5kIDwgc3RhcnQpIGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCArIDEsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHRyZW1vdmVOb2RlcyhvbGQsIG9sZFN0YXJ0LCBvbGRFbmQgKyAxLCB2bm9kZXMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHR2YXIgb2xkVGFnID0gb2xkLnRhZywgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKG9sZFRhZyA9PT0gdGFnKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IG9sZC5zdGF0ZVxuXHRcdFx0dm5vZGUuX3N0YXRlID0gb2xkLl9zdGF0ZVxuXHRcdFx0dm5vZGUuZXZlbnRzID0gb2xkLmV2ZW50c1xuXHRcdFx0aWYgKCFyZWN5Y2xpbmcgJiYgc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpKSByZXR1cm5cblx0XHRcdGlmICh0eXBlb2Ygb2xkVGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0XHRcdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAob2xkVGFnKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIiNcIjogdXBkYXRlVGV4dChvbGQsIHZub2RlKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiPFwiOiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCJbXCI6IHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKTsgYnJlYWtcblx0XHRcdFx0XHRkZWZhdWx0OiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5zKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZCwgbnVsbClcblx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlVGV4dChvbGQsIHZub2RlKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbi50b1N0cmluZygpICE9PSB2bm9kZS5jaGlsZHJlbi50b1N0cmluZygpKSB7XG5cdFx0XHRvbGQuZG9tLm5vZGVWYWx1ZSA9IHZub2RlLmNoaWxkcmVuXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuICE9PSB2bm9kZS5jaGlsZHJlbikge1xuXHRcdFx0dG9GcmFnbWVudChvbGQpXG5cdFx0XHRjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0XHRlbHNlIHZub2RlLmRvbSA9IG9sZC5kb20sIHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0dXBkYXRlTm9kZXMocGFyZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0dmFyIGRvbVNpemUgPSAwLCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gbnVsbFxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLmRvbSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHZub2RlLmRvbSA9PSBudWxsKSB2bm9kZS5kb20gPSBjaGlsZC5kb21cblx0XHRcdFx0XHRkb21TaXplICs9IGNoaWxkLmRvbVNpemUgfHwgMVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9tU2l6ZSAhPT0gMSkgdm5vZGUuZG9tU2l6ZSA9IGRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdHN3aXRjaCAodm5vZGUudGFnKSB7XG5cdFx0XHRjYXNlIFwic3ZnXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiOyBicmVha1xuXHRcdFx0Y2FzZSBcIm1hdGhcIjogbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjsgYnJlYWtcblx0XHR9XG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgPT0gbnVsbCkgdm5vZGUuYXR0cnMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5hdHRycy52YWx1ZSA9IHZub2RlLnRleHQgLy9GSVhNRSBoYW5kbGUwIG11bHRpcGxlIGNoaWxkcmVuXG5cdFx0XHRcdHZub2RlLnRleHQgPSB1bmRlZmluZWRcblx0XHRcdH1cblx0XHR9XG5cdFx0dXBkYXRlQXR0cnModm5vZGUsIG9sZC5hdHRycywgdm5vZGUuYXR0cnMsIG5zKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT09IFwiXCIpIHtcblx0XHRcdGlmIChvbGQudGV4dC50b1N0cmluZygpICE9PSB2bm9kZS50ZXh0LnRvU3RyaW5nKCkpIG9sZC5kb20uZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB2bm9kZS50ZXh0XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC50ZXh0ICE9IG51bGwpIG9sZC5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZC50ZXh0LCB1bmRlZmluZWQsIG9sZC5kb20uZmlyc3RDaGlsZCldXG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdHVwZGF0ZU5vZGVzKGVsZW1lbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR9XG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdGlmIChvbGQuaW5zdGFuY2UgPT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLmluc3RhbmNlLCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQuaW5zdGFuY2UsIG51bGwpXG5cdFx0XHR2bm9kZS5kb20gPSB1bmRlZmluZWRcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcykge1xuXHRcdGlmIChvbGQucG9vbCAhPSBudWxsICYmIE1hdGguYWJzKG9sZC5wb29sLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpIDw9IE1hdGguYWJzKG9sZC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSkge1xuXHRcdFx0dmFyIG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkWzBdICYmIG9sZFswXS5jaGlsZHJlbiAmJiBvbGRbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciBwb29sQ2hpbGRyZW5MZW5ndGggPSBvbGQucG9vbFswXSAmJiBvbGQucG9vbFswXS5jaGlsZHJlbiAmJiBvbGQucG9vbFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHZub2Rlc0NoaWxkcmVuTGVuZ3RoID0gdm5vZGVzWzBdICYmIHZub2Rlc1swXS5jaGlsZHJlbiAmJiB2bm9kZXNbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdGlmIChNYXRoLmFicyhwb29sQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkgPD0gTWF0aC5hYnMob2xkQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gZ2V0S2V5TWFwKHZub2RlcywgZW5kKSB7XG5cdFx0dmFyIG1hcCA9IHt9LCBpID0gMFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGtleTIgPSB2bm9kZS5rZXlcblx0XHRcdFx0aWYgKGtleTIgIT0gbnVsbCkgbWFwW2tleTJdID0gaVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwXG5cdH1cblx0ZnVuY3Rpb24gdG9GcmFnbWVudCh2bm9kZSkge1xuXHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplXG5cdFx0aWYgKGNvdW50MCAhPSBudWxsIHx8IHZub2RlLmRvbSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdFx0aWYgKGNvdW50MCA+IDApIHtcblx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHR3aGlsZSAoLS1jb3VudDApIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0ZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKGRvbSwgZnJhZ21lbnQuZmlyc3RDaGlsZClcblx0XHRcdH1cblx0XHRcdHJldHVybiBmcmFnbWVudFxuXHRcdH1cblx0XHRlbHNlIHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBnZXROZXh0U2libGluZyh2bm9kZXMsIGksIG5leHRTaWJsaW5nKSB7XG5cdFx0Zm9yICg7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiB2bm9kZXNbaV0uZG9tICE9IG51bGwpIHJldHVybiB2bm9kZXNbaV0uZG9tXG5cdFx0fVxuXHRcdHJldHVybiBuZXh0U2libGluZ1xuXHR9XG5cdGZ1bmN0aW9uIGluc2VydE5vZGUocGFyZW50LCBkb20sIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudE5vZGUpIHBhcmVudC5pbnNlcnRCZWZvcmUoZG9tLCBuZXh0U2libGluZylcblx0XHRlbHNlIHBhcmVudC5hcHBlbmRDaGlsZChkb20pXG5cdH1cblx0ZnVuY3Rpb24gc2V0Q29udGVudEVkaXRhYmxlKHZub2RlKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIjxcIikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHRcdFx0aWYgKHZub2RlLmRvbS5pbm5lckhUTUwgIT09IGNvbnRlbnQpIHZub2RlLmRvbS5pbm5lckhUTUwgPSBjb250ZW50XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHZub2RlLnRleHQgIT0gbnVsbCB8fCBjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgbm9kZSBvZiBhIGNvbnRlbnRlZGl0YWJsZSBtdXN0IGJlIHRydXN0ZWRcIilcblx0fVxuXHQvL3JlbW92ZVxuXHRmdW5jdGlvbiByZW1vdmVOb2Rlcyh2bm9kZXMsIHN0YXJ0LCBlbmQsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUuc2tpcCkgdm5vZGUuc2tpcCA9IGZhbHNlXG5cdFx0XHRcdGVsc2UgcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dClcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dCkge1xuXHRcdHZhciBleHBlY3RlZCA9IDEsIGNhbGxlZCA9IDBcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGludWF0aW9uKClcblx0XHRmdW5jdGlvbiBjb250aW51YXRpb24oKSB7XG5cdFx0XHRpZiAoKytjYWxsZWQgPT09IGV4cGVjdGVkKSB7XG5cdFx0XHRcdG9ucmVtb3ZlKHZub2RlKVxuXHRcdFx0XHRpZiAodm5vZGUuZG9tKSB7XG5cdFx0XHRcdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemUgfHwgMVxuXHRcdFx0XHRcdGlmIChjb3VudDAgPiAxKSB7XG5cdFx0XHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1jb3VudDApIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00oZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTSh2bm9kZS5kb20pXG5cdFx0XHRcdFx0aWYgKGNvbnRleHQgIT0gbnVsbCAmJiB2bm9kZS5kb21TaXplID09IG51bGwgJiYgIWhhc0ludGVncmF0aW9uTWV0aG9kcyh2bm9kZS5hdHRycykgJiYgdHlwZW9mIHZub2RlLnRhZyA9PT0gXCJzdHJpbmdcIikgeyAvL1RPRE8gdGVzdCBjdXN0b20gZWxlbWVudHNcblx0XHRcdFx0XHRcdGlmICghY29udGV4dC5wb29sKSBjb250ZXh0LnBvb2wgPSBbdm5vZGVdXG5cdFx0XHRcdFx0XHRlbHNlIGNvbnRleHQucG9vbC5wdXNoKHZub2RlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlRnJvbURPTShub2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZVxuXHRcdGlmIChwYXJlbnQgIT0gbnVsbCkgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpXG5cdH1cblx0ZnVuY3Rpb24gb25yZW1vdmUodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLmF0dHJzLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuX3N0YXRlLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSBvbnJlbW92ZSh2bm9kZS5pbnN0YW5jZSlcblx0XHRlbHNlIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwpIG9ucmVtb3ZlKGNoaWxkKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vYXR0cnMyXG5cdGZ1bmN0aW9uIHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKSB7XG5cdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG51bGwsIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCwgdmFsdWUsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHRpZiAoa2V5MiA9PT0gXCJrZXlcIiB8fCBrZXkyID09PSBcImlzXCIgfHwgKG9sZCA9PT0gdmFsdWUgJiYgIWlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwga2V5MikpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHJldHVyblxuXHRcdHZhciBuc0xhc3RJbmRleCA9IGtleTIuaW5kZXhPZihcIjpcIilcblx0XHRpZiAobnNMYXN0SW5kZXggPiAtMSAmJiBrZXkyLnN1YnN0cigwLCBuc0xhc3RJbmRleCkgPT09IFwieGxpbmtcIikge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwga2V5Mi5zbGljZShuc0xhc3RJbmRleCArIDEpLCB2YWx1ZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyID09PSBcInN0eWxlXCIpIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiBpbiBlbGVtZW50ICYmICFpc0F0dHJpYnV0ZShrZXkyKSAmJiBucyA9PT0gdW5kZWZpbmVkICYmICFpc0N1c3RvbUVsZW1lbnQodm5vZGUpKSB7XG5cdFx0XHQvL3NldHRpbmcgaW5wdXRbdmFsdWVdIHRvIHNhbWUgdmFsdWUgYnkgdHlwaW5nIG9uIGZvY3VzZWQgZWxlbWVudCBtb3ZlcyBjdXJzb3IgdG8gZW5kIGluIENocm9tZVxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIHNlbGVjdFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJvcHRpb25cIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlKSByZXR1cm5cblx0XHRcdC8vIElmIHlvdSBhc3NpZ24gYW4gaW5wdXQgdHlwZTEgdGhhdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFIDExIHdpdGggYW4gYXNzaWdubWVudCBleHByZXNzaW9uLCBhbiBlcnJvcjAgd2lsbCBvY2N1ci5cblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInR5cGVcIikge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50W2tleTJdID0gdmFsdWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRpZiAodmFsdWUpIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIFwiXCIpXG5cdFx0XHRcdGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdH1cblx0XHRcdGVsc2UgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiA9PT0gXCJjbGFzc05hbWVcIiA/IFwiY2xhc3NcIiA6IGtleTIsIHZhbHVlKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRMYXRlQXR0cnModm5vZGUpIHtcblx0XHR2YXIgYXR0cnMyID0gdm5vZGUuYXR0cnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXCJ2YWx1ZVwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJ2YWx1ZVwiLCBudWxsLCBhdHRyczIudmFsdWUsIHVuZGVmaW5lZClcblx0XHRcdGlmIChcInNlbGVjdGVkSW5kZXhcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsLCBhdHRyczIuc2VsZWN0ZWRJbmRleCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVBdHRycyh2bm9kZSwgb2xkLCBhdHRyczIsIG5zKSB7XG5cdFx0aWYgKGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQgJiYgb2xkW2tleTJdLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAob2xkICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gb2xkKSB7XG5cdFx0XHRcdGlmIChhdHRyczIgPT0gbnVsbCB8fCAhKGtleTIgaW4gYXR0cnMyKSkge1xuXHRcdFx0XHRcdGlmIChrZXkyID09PSBcImNsYXNzTmFtZVwiKSBrZXkyID0gXCJjbGFzc1wiXG5cdFx0XHRcdFx0aWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmICFpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHVuZGVmaW5lZClcblx0XHRcdFx0XHRlbHNlIGlmIChrZXkyICE9PSBcImtleVwiKSB2bm9kZS5kb20ucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNGb3JtQXR0cmlidXRlKHZub2RlLCBhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwidmFsdWVcIiB8fCBhdHRyID09PSBcImNoZWNrZWRcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkSW5kZXhcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkXCIgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpc0xpZmVjeWNsZU1ldGhvZChhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwib25pbml0XCIgfHwgYXR0ciA9PT0gXCJvbmNyZWF0ZVwiIHx8IGF0dHIgPT09IFwib251cGRhdGVcIiB8fCBhdHRyID09PSBcIm9ucmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmV1cGRhdGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQXR0cmlidXRlKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJocmVmXCIgfHwgYXR0ciA9PT0gXCJsaXN0XCIgfHwgYXR0ciA9PT0gXCJmb3JtXCIgfHwgYXR0ciA9PT0gXCJ3aWR0aFwiIHx8IGF0dHIgPT09IFwiaGVpZ2h0XCIvLyB8fCBhdHRyID09PSBcInR5cGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudCh2bm9kZSl7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzLmlzIHx8IHZub2RlLnRhZy5pbmRleE9mKFwiLVwiKSA+IC0xXG5cdH1cblx0ZnVuY3Rpb24gaGFzSW50ZWdyYXRpb25NZXRob2RzKHNvdXJjZSkge1xuXHRcdHJldHVybiBzb3VyY2UgIT0gbnVsbCAmJiAoc291cmNlLm9uY3JlYXRlIHx8IHNvdXJjZS5vbnVwZGF0ZSB8fCBzb3VyY2Uub25iZWZvcmVyZW1vdmUgfHwgc291cmNlLm9ucmVtb3ZlKVxuXHR9XG5cdC8vc3R5bGVcblx0ZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCBzdHlsZSkge1xuXHRcdGlmIChvbGQgPT09IHN0eWxlKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiLCBvbGQgPSBudWxsXG5cdFx0aWYgKHN0eWxlID09IG51bGwpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRlbHNlIGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZCA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBzdHlsZSkge1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlW2tleTJdID0gc3R5bGVba2V5Ml1cblx0XHRcdH1cblx0XHRcdGlmIChvbGQgIT0gbnVsbCAmJiB0eXBlb2Ygb2xkICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleTIgaW4gb2xkKSB7XG5cdFx0XHRcdFx0aWYgKCEoa2V5MiBpbiBzdHlsZSkpIGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBcIlwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9ldmVudFxuXHRmdW5jdGlvbiB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdHZhciBjYWxsYmFjayA9IHR5cGVvZiBvbmV2ZW50ICE9PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSA6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWx1ZS5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRvbmV2ZW50LmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9XG5cdFx0aWYgKGtleTIgaW4gZWxlbWVudCkgZWxlbWVudFtrZXkyXSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2FsbGJhY2sgOiBudWxsXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0ga2V5Mi5zbGljZSgyKVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50cyA9PT0gdW5kZWZpbmVkKSB2bm9kZS5ldmVudHMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXkyXSA9PT0gY2FsbGJhY2spIHJldHVyblxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXkyXSAhPSBudWxsKSBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHZub2RlLmV2ZW50c1trZXkyXSA9IGNhbGxiYWNrXG5cdFx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vbGlmZWN5Y2xlXG5cdGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmluaXQgPT09IFwiZnVuY3Rpb25cIikgc291cmNlLm9uaW5pdC5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbmNyZWF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub251cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub251cGRhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSB7XG5cdFx0dmFyIGZvcmNlVm5vZGVVcGRhdGUsIGZvcmNlQ29tcG9uZW50VXBkYXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlVm5vZGVVcGRhdGUgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VDb21wb25lbnRVcGRhdGUgPSB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAoIShmb3JjZVZub2RlVXBkYXRlID09PSB1bmRlZmluZWQgJiYgZm9yY2VDb21wb25lbnRVcGRhdGUgPT09IHVuZGVmaW5lZCkgJiYgIWZvcmNlVm5vZGVVcGRhdGUgJiYgIWZvcmNlQ29tcG9uZW50VXBkYXRlKSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHRcdHZub2RlLmluc3RhbmNlID0gb2xkLmluc3RhbmNlXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiByZW5kZXIoZG9tLCB2bm9kZXMpIHtcblx0XHRpZiAoIWRvbSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCBiZWluZyBwYXNzZWQgdG8gbS5yb3V0ZS9tLm1vdW50L20ucmVuZGVyIGlzIG5vdCB1bmRlZmluZWQuXCIpXG5cdFx0dmFyIGhvb2tzID0gW11cblx0XHR2YXIgYWN0aXZlID0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdFx0Ly8gRmlyc3QgdGltZTAgcmVuZGVyaW5nIGludG8gYSBub2RlIGNsZWFycyBpdCBvdXRcblx0XHRpZiAoZG9tLnZub2RlcyA9PSBudWxsKSBkb20udGV4dENvbnRlbnQgPSBcIlwiXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHZub2RlcykpIHZub2RlcyA9IFt2bm9kZXNdXG5cdFx0dXBkYXRlTm9kZXMoZG9tLCBkb20udm5vZGVzLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbih2bm9kZXMpLCBmYWxzZSwgaG9va3MsIG51bGwsIHVuZGVmaW5lZClcblx0XHRkb20udm5vZGVzID0gdm5vZGVzXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykgaG9va3NbaV0oKVxuXHRcdGlmICgkZG9jLmFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZSkgYWN0aXZlLmZvY3VzKClcblx0fVxuXHRyZXR1cm4ge3JlbmRlcjogcmVuZGVyLCBzZXRFdmVudENhbGxiYWNrOiBzZXRFdmVudENhbGxiYWNrfVxufVxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2spIHtcblx0Ly82MGZwcyB0cmFuc2xhdGVzIHRvIDE2LjZtcywgcm91bmQgaXQgZG93biBzaW5jZSBzZXRUaW1lb3V0IHJlcXVpcmVzIGludFxuXHR2YXIgdGltZSA9IDE2XG5cdHZhciBsYXN0ID0gMCwgcGVuZGluZyA9IG51bGxcblx0dmFyIHRpbWVvdXQgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRUaW1lb3V0XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKVxuXHRcdGlmIChsYXN0ID09PSAwIHx8IG5vdyAtIGxhc3QgPj0gdGltZSkge1xuXHRcdFx0bGFzdCA9IG5vd1xuXHRcdFx0Y2FsbGJhY2soKVxuXHRcdH1cblx0XHRlbHNlIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG5cdFx0XHRwZW5kaW5nID0gdGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0cGVuZGluZyA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2soKVxuXHRcdFx0XHRsYXN0ID0gRGF0ZS5ub3coKVxuXHRcdFx0fSwgdGltZSAtIChub3cgLSBsYXN0KSlcblx0XHR9XG5cdH1cbn1cbnZhciBfMTEgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciByZW5kZXJTZXJ2aWNlID0gY29yZVJlbmRlcmVyKCR3aW5kb3cpXG5cdHJlbmRlclNlcnZpY2Uuc2V0RXZlbnRDYWxsYmFjayhmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGUucmVkcmF3ICE9PSBmYWxzZSkgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIG9wdGlvbnMgPSB7cmVwbGFjZTogdHJ1ZX1cblx0XHRsYXN0VXBkYXRlID0gbnVsbFxuXHRcdHJvdXRlU2VydmljZS5zZXRQYXRoKHBhdGgsIGRhdGEsIG9wdGlvbnMpXG5cdH1cblx0cm91dGUuZ2V0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIGN1cnJlbnRQYXRofVxuXHRyb3V0ZS5wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgwKSB7cm91dGVTZXJ2aWNlLnByZWZpeCA9IHByZWZpeDB9XG5cdHJvdXRlLmxpbmsgPSBmdW5jdGlvbih2bm9kZTEpIHtcblx0XHR2bm9kZTEuZG9tLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgcm91dGVTZXJ2aWNlLnByZWZpeCArIHZub2RlMS5hdHRycy5ocmVmKVxuXHRcdHZub2RlMS5kb20ub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS53aGljaCA9PT0gMikgcmV0dXJuXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KClcblx0XHRcdGUucmVkcmF3ID0gZmFsc2Vcblx0XHRcdHZhciBocmVmID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpXG5cdFx0XHRpZiAoaHJlZi5pbmRleE9mKHJvdXRlU2VydmljZS5wcmVmaXgpID09PSAwKSBocmVmID0gaHJlZi5zbGljZShyb3V0ZVNlcnZpY2UucHJlZml4Lmxlbmd0aClcblx0XHRcdHJvdXRlLnNldChocmVmLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0cm91dGUucGFyYW0gPSBmdW5jdGlvbihrZXkzKSB7XG5cdFx0aWYodHlwZW9mIGF0dHJzMyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Yga2V5MyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGF0dHJzM1trZXkzXVxuXHRcdHJldHVybiBhdHRyczNcblx0fVxuXHRyZXR1cm4gcm91dGVcbn1cbm0ucm91dGUgPSBfMjAod2luZG93LCByZWRyYXdTZXJ2aWNlKVxubS53aXRoQXR0ciA9IGZ1bmN0aW9uKGF0dHJOYW1lLCBjYWxsYmFjazEsIGNvbnRleHQpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRjYWxsYmFjazEuY2FsbChjb250ZXh0IHx8IHRoaXMsIGF0dHJOYW1lIGluIGUuY3VycmVudFRhcmdldCA/IGUuY3VycmVudFRhcmdldFthdHRyTmFtZV0gOiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSlcblx0fVxufVxudmFyIF8yOCA9IGNvcmVSZW5kZXJlcih3aW5kb3cpXG5tLnJlbmRlciA9IF8yOC5yZW5kZXJcbm0ucmVkcmF3ID0gcmVkcmF3U2VydmljZS5yZWRyYXdcbm0ucmVxdWVzdCA9IHJlcXVlc3RTZXJ2aWNlLnJlcXVlc3Rcbm0uanNvbnAgPSByZXF1ZXN0U2VydmljZS5qc29ucFxubS5wYXJzZVF1ZXJ5U3RyaW5nID0gcGFyc2VRdWVyeVN0cmluZ1xubS5idWlsZFF1ZXJ5U3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZ1xubS52ZXJzaW9uID0gXCIxLjEuMVwiXG5tLnZub2RlID0gVm5vZGVcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGVbXCJleHBvcnRzXCJdID0gbVxuZWxzZSB3aW5kb3cubSA9IG1cbn0oKSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWl0aHJpbC9taXRocmlsLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIi8qKlxuICogY2xhc3MgUnVsZXJcbiAqXG4gKiBIZWxwZXIgY2xhc3MsIHVzZWQgYnkgW1tNYXJrZG93bkl0I2NvcmVdXSwgW1tNYXJrZG93bkl0I2Jsb2NrXV0gYW5kXG4gKiBbW01hcmtkb3duSXQjaW5saW5lXV0gdG8gbWFuYWdlIHNlcXVlbmNlcyBvZiBmdW5jdGlvbnMgKHJ1bGVzKTpcbiAqXG4gKiAtIGtlZXAgcnVsZXMgaW4gZGVmaW5lZCBvcmRlclxuICogLSBhc3NpZ24gdGhlIG5hbWUgdG8gZWFjaCBydWxlXG4gKiAtIGVuYWJsZS9kaXNhYmxlIHJ1bGVzXG4gKiAtIGFkZC9yZXBsYWNlIHJ1bGVzXG4gKiAtIGFsbG93IGFzc2lnbiBydWxlcyB0byBhZGRpdGlvbmFsIG5hbWVkIGNoYWlucyAoaW4gdGhlIHNhbWUpXG4gKiAtIGNhY2hlaW5nIGxpc3RzIG9mIGFjdGl2ZSBydWxlc1xuICpcbiAqIFlvdSB3aWxsIG5vdCBuZWVkIHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5IHVudGlsIHdyaXRlIHBsdWdpbnMuIEZvciBzaW1wbGVcbiAqIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0sIFtbTWFya2Rvd25JdC5lbmFibGVdXSBhbmRcbiAqIFtbTWFya2Rvd25JdC51c2VdXS5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG4vKipcbiAqIG5ldyBSdWxlcigpXG4gKiovXG5mdW5jdGlvbiBSdWxlcigpIHtcbiAgLy8gTGlzdCBvZiBhZGRlZCBydWxlcy4gRWFjaCBlbGVtZW50IGlzOlxuICAvL1xuICAvLyB7XG4gIC8vICAgbmFtZTogWFhYLFxuICAvLyAgIGVuYWJsZWQ6IEJvb2xlYW4sXG4gIC8vICAgZm46IEZ1bmN0aW9uKCksXG4gIC8vICAgYWx0OiBbIG5hbWUyLCBuYW1lMyBdXG4gIC8vIH1cbiAgLy9cbiAgdGhpcy5fX3J1bGVzX18gPSBbXTtcblxuICAvLyBDYWNoZWQgcnVsZSBjaGFpbnMuXG4gIC8vXG4gIC8vIEZpcnN0IGxldmVsIC0gY2hhaW4gbmFtZSwgJycgZm9yIGRlZmF1bHQuXG4gIC8vIFNlY29uZCBsZXZlbCAtIGRpZ2luYWwgYW5jaG9yIGZvciBmYXN0IGZpbHRlcmluZyBieSBjaGFyY29kZXMuXG4gIC8vXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlciBtZXRob2RzLCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHlcblxuXG4vLyBGaW5kIHJ1bGUgaW5kZXggYnkgbmFtZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2ZpbmRfXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fX3J1bGVzX18ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5fX3J1bGVzX19baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLy8gQnVpbGQgcnVsZXMgbG9va3VwIGNhY2hlXG4vL1xuUnVsZXIucHJvdG90eXBlLl9fY29tcGlsZV9fID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjaGFpbnMgPSBbICcnIF07XG5cbiAgLy8gY29sbGVjdCB1bmlxdWUgbmFtZXNcbiAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgIGlmICghcnVsZS5lbmFibGVkKSB7IHJldHVybjsgfVxuXG4gICAgcnVsZS5hbHQuZm9yRWFjaChmdW5jdGlvbiAoYWx0TmFtZSkge1xuICAgICAgaWYgKGNoYWlucy5pbmRleE9mKGFsdE5hbWUpIDwgMCkge1xuICAgICAgICBjaGFpbnMucHVzaChhbHROYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgc2VsZi5fX2NhY2hlX18gPSB7fTtcblxuICBjaGFpbnMuZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICBzZWxmLl9fY2FjaGVfX1tjaGFpbl0gPSBbXTtcbiAgICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgICAgaWYgKGNoYWluICYmIHJ1bGUuYWx0LmluZGV4T2YoY2hhaW4pIDwgMCkgeyByZXR1cm47IH1cblxuICAgICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dLnB1c2gocnVsZS5mbik7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmF0KG5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIG5hbWUgdG8gcmVwbGFjZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogbmV3IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IG5ldyBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIFJlcGxhY2UgcnVsZSBieSBuYW1lIHdpdGggbmV3IGZ1bmN0aW9uICYgb3B0aW9ucy4gVGhyb3dzIGVycm9yIGlmIG5hbWUgbm90XG4gKiBmb3VuZC5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIFJlcGxhY2UgZXhpc3RpbmcgdHlwb3JnYXBoZXIgcmVwbGFjZW1lbnQgcnVsZSB3aXRoIG5ldyBvbmU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmNvcmUucnVsZXIuYXQoJ3JlcGxhY2VtZW50cycsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAobmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIG5hbWUpOyB9XG5cbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmZuID0gZm47XG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5hbHQgPSBvcHQuYWx0IHx8IFtdO1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuYmVmb3JlKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gYmVmb3JlTmFtZSAoU3RyaW5nKTogbmV3IHJ1bGUgd2lsbCBiZSBhZGRlZCBiZWZvcmUgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGJlZm9yZSBvbmUgd2l0aCBnaXZlbiBuYW1lLiBTZWUgYWxzb1xuICogW1tSdWxlci5hZnRlcl1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5ibG9jay5ydWxlci5iZWZvcmUoJ3BhcmFncmFwaCcsICdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5iZWZvcmUgPSBmdW5jdGlvbiAoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18oYmVmb3JlTmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBiZWZvcmVOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCwgMCwge1xuICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm46IGZuLFxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICB9KTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuYWZ0ZXIoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGFmdGVyTmFtZSAoU3RyaW5nKTogbmV3IHJ1bGUgd2lsbCBiZSBhZGRlZCBhZnRlciB0aGlzIG9uZS5cbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgdG8gY2hhaW4gYWZ0ZXIgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYmVmb3JlXV0sIFtbUnVsZXIucHVzaF1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmlubGluZS5ydWxlci5hZnRlcigndGV4dCcsICdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5hZnRlciA9IGZ1bmN0aW9uIChhZnRlck5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGFmdGVyTmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBhZnRlck5hbWUpOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uc3BsaWNlKGluZGV4ICsgMSwgMCwge1xuICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm46IGZuLFxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICB9KTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJ1bGVyLnB1c2gocnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIFB1c2ggbmV3IHJ1bGUgdG8gdGhlIGVuZCBvZiBjaGFpbi4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYmVmb3JlXV0sIFtbUnVsZXIuYWZ0ZXJdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLnB1c2goJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAocnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuX19ydWxlc19fLnB1c2goe1xuICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm46IGZuLFxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICB9KTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZW5hYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgYW55IHJ1bGUgbmFtZSBub3QgZm91bmQgLSB0aHJvdyBFcnJvci5cbiAqIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFJldHVybnMgbGlzdCBvZiBmb3VuZCBydWxlIG5hbWVzIChpZiBubyBleGNlcHRpb24gaGFwcGVuZWQpLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZGlzYWJsZV1dLCBbW1J1bGVyLmVuYWJsZU9ubHldXS5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFNlYXJjaCBieSBuYW1lIGFuZCBlbmFibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gdHJ1ZTtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZU9ubHkobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZSAod2hpdGVsaXN0KS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLCBhbmQgZGlzYWJsZSBldmVyeXRoaW5nIGVsc2UuIElmIGFueSBydWxlIG5hbWVcbiAqIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVdXS5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5lbmFibGVPbmx5ID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHsgcnVsZS5lbmFibGVkID0gZmFsc2U7IH0pO1xuXG4gIHRoaXMuZW5hYmxlKGxpc3QsIGlnbm9yZUludmFsaWQpO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmRpc2FibGUobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSkgLT4gQXJyYXlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBEaXNhYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmVuYWJsZV1dLCBbW1J1bGVyLmVuYWJsZU9ubHldXS5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZGlzYWJsZVxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICBpZiAoaWdub3JlSW52YWxpZCkgeyByZXR1cm47IH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZXMgbWFuYWdlcjogaW52YWxpZCBydWxlIG5hbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSBmYWxzZTtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmdldFJ1bGVzKGNoYWluTmFtZSkgLT4gQXJyYXlcbiAqXG4gKiBSZXR1cm4gYXJyYXkgb2YgYWN0aXZlIGZ1bmN0aW9ucyAocnVsZXMpIGZvciBnaXZlbiBjaGFpbiBuYW1lLiBJdCBhbmFseXplc1xuICogcnVsZXMgY29uZmlndXJhdGlvbiwgY29tcGlsZXMgY2FjaGVzIGlmIG5vdCBleGlzdHMgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIERlZmF1bHQgY2hhaW4gbmFtZSBpcyBgJydgIChlbXB0eSBzdHJpbmcpLiBJdCBjYW4ndCBiZSBza2lwcGVkLiBUaGF0J3NcbiAqIGRvbmUgaW50ZW50aW9uYWxseSwgdG8ga2VlcCBzaWduYXR1cmUgbW9ub21vcnBoaWMgZm9yIGhpZ2ggc3BlZWQuXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZ2V0UnVsZXMgPSBmdW5jdGlvbiAoY2hhaW5OYW1lKSB7XG4gIGlmICh0aGlzLl9fY2FjaGVfXyA9PT0gbnVsbCkge1xuICAgIHRoaXMuX19jb21waWxlX18oKTtcbiAgfVxuXG4gIC8vIENoYWluIGNhbiBiZSBlbXB0eSwgaWYgcnVsZXMgZGlzYWJsZWQuIEJ1dCB3ZSBzdGlsbCBoYXZlIHRvIHJldHVybiBBcnJheS5cbiAgcmV0dXJuIHRoaXMuX19jYWNoZV9fW2NoYWluTmFtZV0gfHwgW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwiLy8gVG9rZW4gY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogY2xhc3MgVG9rZW5cbiAqKi9cblxuLyoqXG4gKiBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKVxuICpcbiAqIENyZWF0ZSBuZXcgdG9rZW4gYW5kIGZpbGwgcGFzc2VkIHByb3BlcnRpZXMuXG4gKiovXG5mdW5jdGlvbiBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgLyoqXG4gICAqIFRva2VuI3R5cGUgLT4gU3RyaW5nXG4gICAqXG4gICAqIFR5cGUgb2YgdGhlIHRva2VuIChzdHJpbmcsIGUuZy4gXCJwYXJhZ3JhcGhfb3BlblwiKVxuICAgKiovXG4gIHRoaXMudHlwZSAgICAgPSB0eXBlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiN0YWcgLT4gU3RyaW5nXG4gICAqXG4gICAqIGh0bWwgdGFnIG5hbWUsIGUuZy4gXCJwXCJcbiAgICoqL1xuICB0aGlzLnRhZyAgICAgID0gdGFnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNhdHRycyAtPiBBcnJheVxuICAgKlxuICAgKiBIdG1sIGF0dHJpYnV0ZXMuIEZvcm1hdDogYFsgWyBuYW1lMSwgdmFsdWUxIF0sIFsgbmFtZTIsIHZhbHVlMiBdIF1gXG4gICAqKi9cbiAgdGhpcy5hdHRycyAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcCAtPiBBcnJheVxuICAgKlxuICAgKiBTb3VyY2UgbWFwIGluZm8uIEZvcm1hdDogYFsgbGluZV9iZWdpbiwgbGluZV9lbmQgXWBcbiAgICoqL1xuICB0aGlzLm1hcCAgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbmVzdGluZyAtPiBOdW1iZXJcbiAgICpcbiAgICogTGV2ZWwgY2hhbmdlIChudW1iZXIgaW4gey0xLCAwLCAxfSBzZXQpLCB3aGVyZTpcbiAgICpcbiAgICogLSAgYDFgIG1lYW5zIHRoZSB0YWcgaXMgb3BlbmluZ1xuICAgKiAtICBgMGAgbWVhbnMgdGhlIHRhZyBpcyBzZWxmLWNsb3NpbmdcbiAgICogLSBgLTFgIG1lYW5zIHRoZSB0YWcgaXMgY2xvc2luZ1xuICAgKiovXG4gIHRoaXMubmVzdGluZyAgPSBuZXN0aW5nO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNsZXZlbCAtPiBOdW1iZXJcbiAgICpcbiAgICogbmVzdGluZyBsZXZlbCwgdGhlIHNhbWUgYXMgYHN0YXRlLmxldmVsYFxuICAgKiovXG4gIHRoaXMubGV2ZWwgICAgPSAwO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjaGlsZHJlbiAtPiBBcnJheVxuICAgKlxuICAgKiBBbiBhcnJheSBvZiBjaGlsZCBub2RlcyAoaW5saW5lIGFuZCBpbWcgdG9rZW5zKVxuICAgKiovXG4gIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjb250ZW50IC0+IFN0cmluZ1xuICAgKlxuICAgKiBJbiBhIGNhc2Ugb2Ygc2VsZi1jbG9zaW5nIHRhZyAoY29kZSwgaHRtbCwgZmVuY2UsIGV0Yy4pLFxuICAgKiBpdCBoYXMgY29udGVudHMgb2YgdGhpcyB0YWcuXG4gICAqKi9cbiAgdGhpcy5jb250ZW50ICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtYXJrdXAgLT4gU3RyaW5nXG4gICAqXG4gICAqICcqJyBvciAnXycgZm9yIGVtcGhhc2lzLCBmZW5jZSBzdHJpbmcgZm9yIGZlbmNlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5tYXJrdXAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNpbmZvIC0+IFN0cmluZ1xuICAgKlxuICAgKiBmZW5jZSBpbmZvc3RyaW5nXG4gICAqKi9cbiAgdGhpcy5pbmZvICAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtZXRhIC0+IE9iamVjdFxuICAgKlxuICAgKiBBIHBsYWNlIGZvciBwbHVnaW5zIHRvIHN0b3JlIGFuIGFyYml0cmFyeSBkYXRhXG4gICAqKi9cbiAgdGhpcy5tZXRhICAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2Jsb2NrIC0+IEJvb2xlYW5cbiAgICpcbiAgICogVHJ1ZSBmb3IgYmxvY2stbGV2ZWwgdG9rZW5zLCBmYWxzZSBmb3IgaW5saW5lIHRva2Vucy5cbiAgICogVXNlZCBpbiByZW5kZXJlciB0byBjYWxjdWxhdGUgbGluZSBicmVha3NcbiAgICoqL1xuICB0aGlzLmJsb2NrICAgID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRva2VuI2hpZGRlbiAtPiBCb29sZWFuXG4gICAqXG4gICAqIElmIGl0J3MgdHJ1ZSwgaWdub3JlIHRoaXMgZWxlbWVudCB3aGVuIHJlbmRlcmluZy4gVXNlZCBmb3IgdGlnaHQgbGlzdHNcbiAgICogdG8gaGlkZSBwYXJhZ3JhcGhzLlxuICAgKiovXG4gIHRoaXMuaGlkZGVuICAgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFRva2VuLmF0dHJJbmRleChuYW1lKSAtPiBOdW1iZXJcbiAqXG4gKiBTZWFyY2ggYXR0cmlidXRlIGluZGV4IGJ5IG5hbWUuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckluZGV4ID0gZnVuY3Rpb24gYXR0ckluZGV4KG5hbWUpIHtcbiAgdmFyIGF0dHJzLCBpLCBsZW47XG5cbiAgaWYgKCF0aGlzLmF0dHJzKSB7IHJldHVybiAtMTsgfVxuXG4gIGF0dHJzID0gdGhpcy5hdHRycztcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhdHRyc1tpXVswXSA9PT0gbmFtZSkgeyByZXR1cm4gaTsgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyUHVzaChhdHRyRGF0YSlcbiAqXG4gKiBBZGQgYFsgbmFtZSwgdmFsdWUgXWAgYXR0cmlidXRlIHRvIGxpc3QuIEluaXQgYXR0cnMgaWYgbmVjZXNzYXJ5XG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0clB1c2ggPSBmdW5jdGlvbiBhdHRyUHVzaChhdHRyRGF0YSkge1xuICBpZiAodGhpcy5hdHRycykge1xuICAgIHRoaXMuYXR0cnMucHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRycyA9IFsgYXR0ckRhdGEgXTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJTZXQobmFtZSwgdmFsdWUpXG4gKlxuICogU2V0IGBuYW1lYCBhdHRyaWJ1dGUgdG8gYHZhbHVlYC4gT3ZlcnJpZGUgb2xkIHZhbHVlIGlmIGV4aXN0cy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyU2V0ID0gZnVuY3Rpb24gYXR0clNldChuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksXG4gICAgICBhdHRyRGF0YSA9IFsgbmFtZSwgdmFsdWUgXTtcblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goYXR0ckRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XSA9IGF0dHJEYXRhO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckdldChuYW1lKVxuICpcbiAqIEdldCB0aGUgdmFsdWUgb2YgYXR0cmlidXRlIGBuYW1lYCwgb3IgbnVsbCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyR2V0ID0gZnVuY3Rpb24gYXR0ckdldChuYW1lKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSwgdmFsdWUgPSBudWxsO1xuICBpZiAoaWR4ID49IDApIHtcbiAgICB2YWx1ZSA9IHRoaXMuYXR0cnNbaWR4XVsxXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckpvaW4obmFtZSwgdmFsdWUpXG4gKlxuICogSm9pbiB2YWx1ZSB0byBleGlzdGluZyBhdHRyaWJ1dGUgdmlhIHNwYWNlLiBPciBjcmVhdGUgbmV3IGF0dHJpYnV0ZSBpZiBub3RcbiAqIGV4aXN0cy4gVXNlZnVsIHRvIG9wZXJhdGUgd2l0aCB0b2tlbiBjbGFzc2VzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJKb2luID0gZnVuY3Rpb24gYXR0ckpvaW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChbIG5hbWUsIHZhbHVlIF0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XVsxXSA9IHRoaXMuYXR0cnNbaWR4XVsxXSArICcgJyArIHZhbHVlO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVG9rZW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvdG9rZW4uanMiLCJtb2R1bGUuZXhwb3J0cz0vWyEtIyUtXFwqLC0vOjtcXD9AXFxbLVxcXV9cXHtcXH1cXHhBMVxceEE3XFx4QUJcXHhCNlxceEI3XFx4QkJcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQ0XFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgwMVxcdURENkZ8XFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1REM0Qi1cXHVEQzRGXFx1REM1QlxcdURDNURcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REU2MC1cXHVERTZDXFx1REYzQy1cXHVERjNFXXxcXHVEODA3W1xcdURDNDEtXFx1REM0NVxcdURDNzBcXHVEQzcxXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODJGXFx1REM5RnxcXHVEODM2W1xcdURFODctXFx1REU4Ql18XFx1RDgzQVtcXHVERDVFXFx1REQ1Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICB2bm9kZS5zdGF0ZS5zcGFuID0gdm5vZGUuYXR0cnMuc3BhbjtcbiAgICB2bm9kZS5zdGF0ZS5jbHMgPSB2bm9kZS5hdHRycy5jbHM7XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2BtZGwtY2VsbCBtZGwtY2VsbC0tJHt2bm9kZS5zdGF0ZS5zcGFufS1jb2wgJHt2bm9kZS5zdGF0ZS5jbHN9YH0+XG4gICAgICB7dm5vZGUuYXR0cnMuaW5uZXJ9XG4gICAgPC9kaXY+XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9jb21wb25lbnRzL2NlbGwuanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCkge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgdmFyIGJhc2U2NCA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG4gIHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8vIEhUTUw1IGVudGl0aWVzIG1hcDogeyBuYW1lIC0+IHV0ZjE2c3RyaW5nIH1cbi8vXG4ndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50IHF1b3RlczowKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzIiwiLy8gUmVnZXhwcyB0byBtYXRjaCBodG1sIGVsZW1lbnRzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dHJfbmFtZSAgICAgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xuXG52YXIgdW5xdW90ZWQgICAgICA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBzaW5nbGVfcXVvdGVkID0gXCInW14nXSonXCI7XG52YXIgZG91YmxlX3F1b3RlZCA9ICdcIlteXCJdKlwiJztcblxudmFyIGF0dHJfdmFsdWUgID0gJyg/OicgKyB1bnF1b3RlZCArICd8JyArIHNpbmdsZV9xdW90ZWQgKyAnfCcgKyBkb3VibGVfcXVvdGVkICsgJyknO1xuXG52YXIgYXR0cmlidXRlICAgPSAnKD86XFxcXHMrJyArIGF0dHJfbmFtZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJfdmFsdWUgKyAnKT8pJztcblxudmFyIG9wZW5fdGFnICAgID0gJzxbQS1aYS16XVtBLVphLXowLTlcXFxcLV0qJyArIGF0dHJpYnV0ZSArICcqXFxcXHMqXFxcXC8/Pic7XG5cbnZhciBjbG9zZV90YWcgICA9ICc8XFxcXC9bQS1aYS16XVtBLVphLXowLTlcXFxcLV0qXFxcXHMqPic7XG52YXIgY29tbWVudCAgICAgPSAnPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPic7XG52YXIgcHJvY2Vzc2luZyAgPSAnPFs/XS4qP1s/XT4nO1xudmFyIGRlY2xhcmF0aW9uID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBjZGF0YSAgICAgICA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xuXG52YXIgSFRNTF9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJ3wnICsgY29tbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBwcm9jZXNzaW5nICsgJ3wnICsgZGVjbGFyYXRpb24gKyAnfCcgKyBjZGF0YSArICcpJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpO1xuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xubW9kdWxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IEhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanMiLCIvLyBQcm9jZXNzICp0aGlzKiBhbmQgX3RoYXRfXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDVGIC8qIF8gKi8gJiYgbWFya2VyICE9PSAweDJBIC8qICogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCBtYXJrZXIgPT09IDB4MkEpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzY2FubmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICAvLyBDaGFyIGNvZGUgb2YgdGhlIHN0YXJ0aW5nIG1hcmtlciAobnVtYmVyKS5cbiAgICAgIC8vXG4gICAgICBtYXJrZXI6IG1hcmtlcixcblxuICAgICAgLy8gVG90YWwgbGVuZ3RoIG9mIHRoZXNlIHNlcmllcyBvZiBkZWxpbWl0ZXJzLlxuICAgICAgLy9cbiAgICAgIGxlbmd0aDogc2Nhbm5lZC5sZW5ndGgsXG5cbiAgICAgIC8vIEFuIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGJlZm9yZSB0aGlzIG9uZSB0aGF0J3MgZXF1aXZhbGVudCB0b1xuICAgICAgLy8gY3VycmVudCBvbmUuIEluIHBsYWluIEVuZ2xpc2g6IGlmIHRoaXMgZGVsaW1pdGVyIGRvZXMgbm90IG9wZW5cbiAgICAgIC8vIGFuIGVtcGhhc2lzLCBuZWl0aGVyIGRvIHByZXZpb3VzIGBqdW1wYCBjaGFyYWN0ZXJzLlxuICAgICAgLy9cbiAgICAgIC8vIFVzZWQgdG8gc2tpcCBzZXF1ZW5jZXMgbGlrZSBcIioqKioqXCIgaW4gb25lIHN0ZXAsIGZvciAxc3QgYXN0ZXJpc2tcbiAgICAgIC8vIHZhbHVlIHdpbGwgYmUgMCwgZm9yIDJuZCBpdCdzIDEgYW5kIHNvIG9uLlxuICAgICAgLy9cbiAgICAgIGp1bXA6ICAgaSxcblxuICAgICAgLy8gQSBwb3NpdGlvbiBvZiB0aGUgdG9rZW4gdGhpcyBkZWxpbWl0ZXIgY29ycmVzcG9uZHMgdG8uXG4gICAgICAvL1xuICAgICAgdG9rZW46ICBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMSxcblxuICAgICAgLy8gVG9rZW4gbGV2ZWwuXG4gICAgICAvL1xuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcblxuICAgICAgLy8gSWYgdGhpcyBkZWxpbWl0ZXIgaXMgbWF0Y2hlZCBhcyBhIHZhbGlkIG9wZW5lciwgYGVuZGAgd2lsbCBiZVxuICAgICAgLy8gZXF1YWwgdG8gaXRzIHBvc2l0aW9uLCBvdGhlcndpc2UgaXQncyBgLTFgLlxuICAgICAgLy9cbiAgICAgIGVuZDogICAgLTEsXG5cbiAgICAgIC8vIEJvb2xlYW4gZmxhZ3MgdGhhdCBkZXRlcm1pbmUgaWYgdGhpcyBkZWxpbWl0ZXIgY291bGQgb3BlbiBvciBjbG9zZVxuICAgICAgLy8gYW4gZW1waGFzaXMuXG4gICAgICAvL1xuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBXYWxrIHRocm91Z2ggZGVsaW1pdGVyIGxpc3QgYW5kIHJlcGxhY2UgdGV4dCB0b2tlbnMgd2l0aCB0YWdzXG4vL1xubW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBlbXBoYXNpcyhzdGF0ZSkge1xuICB2YXIgaSxcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgY2gsXG4gICAgICBpc1N0cm9uZyxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4NUYvKiBfICovICYmIHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDJBLyogKiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBvbmx5IG9wZW5pbmcgbWFya2Vyc1xuICAgIGlmIChzdGFydERlbGltLmVuZCA9PT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVuZERlbGltID0gZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZF07XG5cbiAgICAvLyBJZiB0aGUgbmV4dCBkZWxpbWl0ZXIgaGFzIHRoZSBzYW1lIG1hcmtlciBhbmQgaXMgYWRqYWNlbnQgdG8gdGhpcyBvbmUsXG4gICAgLy8gbWVyZ2UgdGhvc2UgaW50byBvbmUgc3Ryb25nIGRlbGltaXRlci5cbiAgICAvL1xuICAgIC8vIGA8ZW0+PGVtPndoYXRldmVyPC9lbT48L2VtPmAgLT4gYDxzdHJvbmc+d2hhdGV2ZXI8L3N0cm9uZz5gXG4gICAgLy9cbiAgICBpc1N0cm9uZyA9IGkgKyAxIDwgbWF4ICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS5lbmQgPT09IHN0YXJ0RGVsaW0uZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpICsgMV0udG9rZW4gPT09IHN0YXJ0RGVsaW0udG9rZW4gKyAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kIC0gMV0udG9rZW4gPT09IGVuZERlbGltLnRva2VuIC0gMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpICsgMV0ubWFya2VyID09PSBzdGFydERlbGltLm1hcmtlcjtcblxuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydERlbGltLm1hcmtlcik7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfb3BlbicgOiAnZW1fb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX2Nsb3NlJyA6ICdlbV9jbG9zZSc7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgaWYgKGlzU3Ryb25nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tpICsgMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kIC0gMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VtcGhhc2lzLmpzIiwiLy8gfn5zdHJpa2UgdGhyb3VnaH5+XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIHN0cmlrZXRocm91Z2goc3RhdGUsIHNpbGVudCkge1xuICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sIGxlbiwgY2gsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHNjYW5uZWQgPSBzdGF0ZS5zY2FuRGVsaW1zKHN0YXRlLnBvcywgdHJ1ZSk7XG4gIGxlbiA9IHNjYW5uZWQubGVuZ3RoO1xuICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICBpZiAobGVuIDwgMikgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobGVuICUgMikge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBjaDtcbiAgICBsZW4tLTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBjaCArIGNoO1xuXG4gICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgIG1hcmtlcjogbWFya2VyLFxuICAgICAganVtcDogICBpLFxuICAgICAgdG9rZW46ICBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMSxcbiAgICAgIGxldmVsOiAgc3RhdGUubGV2ZWwsXG4gICAgICBlbmQ6ICAgIC0xLFxuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBXYWxrIHRocm91Z2ggZGVsaW1pdGVyIGxpc3QgYW5kIHJlcGxhY2UgdGV4dCB0b2tlbnMgd2l0aCB0YWdzXG4vL1xubW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlKSB7XG4gIHZhciBpLCBqLFxuICAgICAgc3RhcnREZWxpbSxcbiAgICAgIGVuZERlbGltLFxuICAgICAgdG9rZW4sXG4gICAgICBsb25lTWFya2VycyA9IFtdLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBzdGFydERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdGFydERlbGltLmVuZCA9PT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVuZERlbGltID0gZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZF07XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSAnc19vcGVuJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgIHRva2VuLm1hcmt1cCAgPSAnfn4nO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSAnc19jbG9zZSc7XG4gICAgdG9rZW4udGFnICAgICA9ICdzJztcbiAgICB0b2tlbi5uZXN0aW5nID0gLTE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW4gLSAxXS5jb250ZW50ID09PSAnficpIHtcblxuICAgICAgbG9uZU1hcmtlcnMucHVzaChlbmREZWxpbS50b2tlbiAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIGEgbWFya2VyIHNlcXVlbmNlIGhhcyBhbiBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGl0J3Mgc3BsaXR0ZWRcbiAgLy8gbGlrZSB0aGlzOiBgfn5+fn5gIC0+IGB+YCArIGB+fmAgKyBgfn5gLCBsZWF2aW5nIG9uZSBtYXJrZXIgYXQgdGhlXG4gIC8vIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgLy9cbiAgLy8gU28sIHdlIGhhdmUgdG8gbW92ZSBhbGwgdGhvc2UgbWFya2VycyBhZnRlciBzdWJzZXF1ZW50IHNfY2xvc2UgdGFncy5cbiAgLy9cbiAgd2hpbGUgKGxvbmVNYXJrZXJzLmxlbmd0aCkge1xuICAgIGkgPSBsb25lTWFya2Vycy5wb3AoKTtcbiAgICBqID0gaSArIDE7XG5cbiAgICB3aGlsZSAoaiA8IHN0YXRlLnRva2Vucy5sZW5ndGggJiYgc3RhdGUudG9rZW5zW2pdLnR5cGUgPT09ICdzX2Nsb3NlJykge1xuICAgICAgaisrO1xuICAgIH1cblxuICAgIGotLTtcblxuICAgIGlmIChpICE9PSBqKSB7XG4gICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tqXTtcbiAgICAgIHN0YXRlLnRva2Vuc1tqXSA9IHN0YXRlLnRva2Vuc1tpXTtcbiAgICAgIHN0YXRlLnRva2Vuc1tpXSA9IHRva2VuO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxceDFGXFx4N0YtXFx4OUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vWyBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXguanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xudmFyIHN0eWxlc0luRG9tID0ge30sXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0fTtcblx0fSxcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0XHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdFx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlciBcblx0XHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0XHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0XHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG5cdH0pLFxuXHRnZXRFbGVtZW50ID0gKGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW8gPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHRcdH07XG5cdH0pKGZ1bmN0aW9uIChzdHlsZVRhcmdldCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN0eWxlVGFyZ2V0KVxuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdLFxuXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vZml4VXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0SW50byA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cdGlmICghc3R5bGVUYXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHN0eWxlVGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIHN0eWxlVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XG5cdHJldHVybiBsaW5rRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0LyogSWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpe1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XG5cblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKVxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgbW9kZWwgZnJvbSAnLi9tb2RlbC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICdjb21wb25lbnRzL2NlbGwnO1xuaW1wb3J0IFRpdGxlIGZyb20gJ2NvbXBvbmVudHMvdGl0bGUnO1xuaW1wb3J0IFRhZ3MgZnJvbSAnY29tcG9uZW50cy90YWdzJztcblxuZXhwb3J0IGNvbnN0IEVkaXRvciA9IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgdm5vZGUuc3RhdGUubW9kZWwgPSB2bm9kZS5hdHRycy5tb2RlbDtcbiAgfSxcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIGNvbnN0IG1vZGVsID0gdm5vZGUuc3RhdGUubW9kZWw7XG4gICAgY29uc3QgaW5uZXIgPSA8dGV4dGFyZWFcbiAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRleHRhcmVhfVxuICAgICAgb25pbnB1dD17bS53aXRoQXR0cigndmFsdWUnLCB2ID0+IHttb2RlbC5kYXRhLmJvZHkgPSB2fSl9PlxuICAgICAgICB7bW9kZWwuZGF0YS5ib2R5fVxuICAgIDwvdGV4dGFyZWE+XG4gICAgcmV0dXJuIDxDZWxsIHNwYW49ezZ9IGNscz17YCR7c3R5bGVzLmVkaXRvcn0gJHtzdHlsZXMuZWRpdG9yTGVmdFNpZGV9YH0gaW5uZXI9e2lubmVyfSAvPlxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgUHJldmlldyA9IHtcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIHJldHVybiA8Q2VsbCBzcGFuPXs2fSBjbHM9e2Ake3N0eWxlcy5lZGl0b3J9ICR7c3R5bGVzLmVkaXRvclJpZ2h0U2lkZX1gfSBpbm5lcj17bS50cnVzdCh2bm9kZS5hdHRycy5ib2R5KX0gLz5cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IFNhdmUgPSB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBjb25zdCBtb2RlbCA9IHZub2RlLnN0YXRlLm1vZGVsO1xuICAgIGNvbnN0IGlubmVyID0gPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPSdtZGwtYnV0dG9uIG1kbC1qcy1idXR0b24gbWRsLWJ1dHRvbi0tcmFpc2VkIG1kbC1idXR0b24tLWNvbG9yZWQnXG4gICAgICBvbmNsaWNrPXttb2RlbC5zYXZlfT5cbiAgICAgIHNhdmVcbiAgICA8L2J1dHRvbj5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGNscz17c3R5bGVzLnNhdmVCdXR0b259IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQ6IHZub2RlID0+IHtcbiAgICBtb2RlbC5mZXRjaCgpO1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgaWYgKG1vZGVsLmZldGNoZWQpIHtcbiAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nbWRsLWdyaWQnPlxuICAgICAgICA8VGl0bGUgbW9kZWw9e21vZGVsfSAvPlxuICAgICAgICA8VGFncyBtb2RlbD17bW9kZWx9IC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZWRpdG9yV3JhcH0+XG4gICAgICAgICAgPEVkaXRvciBrZXk9J2VkaXRvcicgbW9kZWw9e21vZGVsfSAvPlxuICAgICAgICAgIDxQcmV2aWV3IGtleT0ncHJldmlldycgYm9keT17bW9kZWwubWRCb2R5KCl9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8U2F2ZSBtb2RlbD17bW9kZWx9IC8+XG4gICAgICA8L2Rpdj5cbiAgICB9XG4gICAgcmV0dXJuIDxkaXY+44OH44O844K/5Y+W5b6X5LitLi4uPC9kaXY+XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudC5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50LmpzJ1xuXG5tLm1vdW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJyksIENvbXBvbmVudCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbnRyeS5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXG5pbXBvcnQgTWFya2Rvd25JdCBmcm9tICdtYXJrZG93bi1pdCdcblxuY29uc3QgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuY29uc3QgdXJsID0gIGAvYXBpL2FydGljbGVzLyR7bG9jYXRpb24uaHJlZi5zcGxpdCgnLycpLnNsaWNlKDQpLmpvaW4oJy8nKX1gO1xuXG5jb25zdCBNb2RlbCA9IHtcbiAgZGF0YToge30sXG4gIGZldGNoZWQ6IGZhbHNlLFxuICBmZXRjaDogKCkgPT4ge1xuICAgIHJldHVybiBtLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybDogdXJsLFxuICAgIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgTW9kZWwuZmV0Y2hlZCA9IHRydWU7XG4gICAgICBNb2RlbC5kYXRhID0gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH0sXG4gIHNhdmU6ICgpID0+IHtcbiAgICByZXR1cm4gbS5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiB1cmwsXG4gICAgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBNb2RlbC5kYXRhID0gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH0sXG4gIG1kQm9keTogKCkgPT4ge1xuICAgIHJldHVybiBtZC5yZW5kZXIoTW9kZWwuZGF0YS5ib2R5KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTW9kZWxcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21vZGVsLmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgQ2VsbCBmcm9tICdjb21wb25lbnRzL2NlbGwnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gICAgdm5vZGUuc3RhdGUub25jaGFuZ2UgPSB2ID0+IHtcbiAgICAgIHZub2RlLnN0YXRlLm1vZGVsLmRhdGEudGl0bGUgPSB2O1xuICAgIH07XG4gIH0sXG4gIHZpZXc6IHZub2RlID0+IHtcbiAgICBjb25zdCBpbm5lciA9IDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX1cbiAgICAgIG9uY2hhbmdlPXttLndpdGhBdHRyKCd2YWx1ZScsIHZub2RlLnN0YXRlLm9uY2hhbmdlKX1cbiAgICAgIHZhbHVlPXt2bm9kZS5zdGF0ZS5tb2RlbC5kYXRhLnRpdGxlfVxuICAgIC8+XG4gICAgcmV0dXJuIDxDZWxsIHNwYW49ezEyfSBpbm5lcj17aW5uZXJ9IC8+XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vY29tcG9uZW50cy90aXRsZS5qcyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2Jhc2U2NC1qcy9pbmRleC5qcyIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2J1ZmZlci9pbmRleC5qcyIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaWVlZTc1NC9pbmRleC5qcyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaXNhcnJheS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyc1xuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJzsgfVxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7IH1cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nOyB9XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7IH1cblxuXG5mdW5jdGlvbiBlc2NhcGVSRShzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKTsgfVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZnV6enlMaW5rOiB0cnVlLFxuICBmdXp6eUVtYWlsOiB0cnVlLFxuICBmdXp6eUlQOiBmYWxzZVxufTtcblxuXG5mdW5jdGlvbiBpc09wdGlvbnNPYmoob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmogfHwge30pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrKSB7XG4gICAgcmV0dXJuIGFjYyB8fCBkZWZhdWx0T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgfSwgZmFsc2UpO1xufVxuXG5cbnZhciBkZWZhdWx0U2NoZW1hcyA9IHtcbiAgJ2h0dHA6Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLmh0dHApIHtcbiAgICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ15cXFxcL1xcXFwvJyArIHNlbGYucmUuc3JjX2F1dGggKyBzZWxmLnJlLnNyY19ob3N0X3BvcnRfc3RyaWN0ICsgc2VsZi5yZS5zcmNfcGF0aCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdodHRwczonOiAgJ2h0dHA6JyxcbiAgJ2Z0cDonOiAgICAnaHR0cDonLFxuICAnLy8nOiAgICAgIHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5ub19odHRwKSB7XG4gICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLm5vX2h0dHAgPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXicgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2F1dGggK1xuICAgICAgICAgIC8vIERvbid0IGFsbG93IHNpbmdsZS1sZXZlbCBkb21haW5zLCBiZWNhdXNlIG9mIGZhbHNlIHBvc2l0aXZlcyBsaWtlICcvL3Rlc3QnXG4gICAgICAgICAgLy8gd2l0aCBjb2RlIGNvbW1lbnRzXG4gICAgICAgICAgJyg/OmxvY2FsaG9zdHwoPzooPzonICsgc2VsZi5yZS5zcmNfZG9tYWluICsgJylcXFxcLikrJyArIHNlbGYucmUuc3JjX2RvbWFpbl9yb290ICsgJyknICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wb3J0ICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19ob3N0X3Rlcm1pbmF0b3IgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BhdGgsXG5cbiAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYucmUubm9faHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIC8vIHNob3VsZCBub3QgYmUgYDovL2AgJiBgLy8vYCwgdGhhdCBwcm90ZWN0cyBmcm9tIGVycm9ycyBpbiBwcm90b2NvbCBuYW1lXG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnOicpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICcvJykgeyByZXR1cm4gMDsgfVxuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm5vX2h0dHApWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgJ21haWx0bzonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubWFpbHRvKSB7XG4gICAgICAgIHNlbGYucmUubWFpbHRvID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICsgc2VsZi5yZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHNlbGYucmUuc3JjX2hvc3Rfc3RyaWN0LCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLm1haWx0by50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubWFpbHRvKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbn07XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG5cbi8vIFJFIHBhdHRlcm4gZm9yIDItY2hhcmFjdGVyIHRsZHMgKGF1dG9nZW5lcmF0ZWQgYnkgLi9zdXBwb3J0L3RsZHNfMmNoYXJfZ2VuLmpzKVxudmFyIHRsZHNfMmNoX3NyY19yZSA9ICdhW2NkZWZnaWxtbm9xcnN0dXd4el18YlthYmRlZmdoaWptbm9yc3R2d3l6XXxjW2FjZGZnaGlrbG1ub3J1dnd4eXpdfGRbZWprbW96XXxlW2NlZ3JzdHVdfGZbaWprbW9yXXxnW2FiZGVmZ2hpbG1ucHFyc3R1d3ldfGhba21ucnR1XXxpW2RlbG1ub3Fyc3RdfGpbZW1vcF18a1tlZ2hpbW5wcnd5el18bFthYmNpa3JzdHV2eV18bVthY2RlZ2hrbG1ub3BxcnN0dXZ3eHl6XXxuW2FjZWZnaWxvcHJ1el18b218cFthZWZnaGtsbW5yc3R3eV18cWF8cltlb3N1d118c1thYmNkZWdoaWprbG1ub3J0dXZ4eXpdfHRbY2RmZ2hqa2xtbm9ydHZ3el18dVthZ2tzeXpdfHZbYWNlZ2ludV18d1tmc118eVtldF18elthbXddJztcblxuLy8gRE9OJ1QgdHJ5IHRvIG1ha2UgUFJzIHdpdGggY2hhbmdlcy4gRXh0ZW5kIFRMRHMgd2l0aCBMaW5raWZ5SXQudGxkcygpIGluc3RlYWRcbnZhciB0bGRzX2RlZmF1bHQgPSAnYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YQnLnNwbGl0KCd8Jyk7XG5cbi8qZXNsaW50LWVuYWJsZSBtYXgtbGVuKi9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gcmVzZXRTY2FuQ2FjaGUoc2VsZikge1xuICBzZWxmLl9faW5kZXhfXyA9IC0xO1xuICBzZWxmLl9fdGV4dF9jYWNoZV9fICAgPSAnJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yKHJlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGV4dCwgcG9zKSB7XG4gICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICBpZiAocmUudGVzdCh0YWlsKSkge1xuICAgICAgcmV0dXJuIHRhaWwubWF0Y2gocmUpWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vcm1hbGl6ZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIHNlbGYpIHtcbiAgICBzZWxmLm5vcm1hbGl6ZShtYXRjaCk7XG4gIH07XG59XG5cbi8vIFNjaGVtYXMgY29tcGlsZXIuIEJ1aWxkIHJlZ2V4cHMuXG4vL1xuZnVuY3Rpb24gY29tcGlsZShzZWxmKSB7XG5cbiAgLy8gTG9hZCAmIGNsb25lIFJFIHBhdHRlcm5zLlxuICB2YXIgcmUgPSBzZWxmLnJlID0gcmVxdWlyZSgnLi9saWIvcmUnKShzZWxmLl9fb3B0c19fKTtcblxuICAvLyBEZWZpbmUgZHluYW1pYyBwYXR0ZXJuc1xuICB2YXIgdGxkcyA9IHNlbGYuX190bGRzX18uc2xpY2UoKTtcblxuICBzZWxmLm9uQ29tcGlsZSgpO1xuXG4gIGlmICghc2VsZi5fX3RsZHNfcmVwbGFjZWRfXykge1xuICAgIHRsZHMucHVzaCh0bGRzXzJjaF9zcmNfcmUpO1xuICB9XG4gIHRsZHMucHVzaChyZS5zcmNfeG4pO1xuXG4gIHJlLnNyY190bGRzID0gdGxkcy5qb2luKCd8Jyk7XG5cbiAgZnVuY3Rpb24gdW50cGwodHBsKSB7IHJldHVybiB0cGwucmVwbGFjZSgnJVRMRFMlJywgcmUuc3JjX3RsZHMpOyB9XG5cbiAgcmUuZW1haWxfZnV6enkgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfZW1haWxfZnV6enkpLCAnaScpO1xuICByZS5saW5rX2Z1enp5ICAgICAgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19ub19pcF9mdXp6eSA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19ub19pcF9mdXp6eSksICdpJyk7XG4gIHJlLmhvc3RfZnV6enlfdGVzdCAgPSBSZWdFeHAodW50cGwocmUudHBsX2hvc3RfZnV6enlfdGVzdCksICdpJyk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBlYWNoIHNjaGVtYVxuICAvL1xuXG4gIHZhciBhbGlhc2VzID0gW107XG5cbiAgc2VsZi5fX2NvbXBpbGVkX18gPSB7fTsgLy8gUmVzZXQgY29tcGlsZWQgZGF0YVxuXG4gIGZ1bmN0aW9uIHNjaGVtYUVycm9yKG5hbWUsIHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignKExpbmtpZnlJdCkgSW52YWxpZCBzY2hlbWEgXCInICsgbmFtZSArICdcIjogJyArIHZhbCk7XG4gIH1cblxuICBPYmplY3Qua2V5cyhzZWxmLl9fc2NoZW1hc19fKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbCA9IHNlbGYuX19zY2hlbWFzX19bbmFtZV07XG5cbiAgICAvLyBza2lwIGRpc2FibGVkIG1ldGhvZHNcbiAgICBpZiAodmFsID09PSBudWxsKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGNvbXBpbGVkID0geyB2YWxpZGF0ZTogbnVsbCwgbGluazogbnVsbCB9O1xuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV0gPSBjb21waWxlZDtcblxuICAgIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBpZiAoaXNSZWdFeHAodmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IGNyZWF0ZVZhbGlkYXRvcih2YWwudmFsaWRhdGUpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSB2YWwudmFsaWRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWwubm9ybWFsaXplKSkge1xuICAgICAgICBjb21waWxlZC5ub3JtYWxpemUgPSB2YWwubm9ybWFsaXplO1xuICAgICAgfSBlbHNlIGlmICghdmFsLm5vcm1hbGl6ZSkge1xuICAgICAgICBjb21waWxlZC5ub3JtYWxpemUgPSBjcmVhdGVOb3JtYWxpemVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHZhbCkpIHtcbiAgICAgIGFsaWFzZXMucHVzaChuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICB9KTtcblxuICAvL1xuICAvLyBDb21waWxlIHBvc3Rwb25lZCBhbGlhc2VzXG4gIC8vXG5cbiAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgIGlmICghc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dKSB7XG4gICAgICAvLyBTaWxlbnRseSBmYWlsIG9uIG1pc3NlZCBzY2hlbWFzIHRvIGF2b2lkIGVycm9ucyBvbiBkaXNhYmxlLlxuICAgICAgLy8gc2NoZW1hRXJyb3IoYWxpYXMsIHNlbGYuX19zY2hlbWFzX19bYWxpYXNdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10udmFsaWRhdGUgPVxuICAgICAgc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dLnZhbGlkYXRlO1xuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS5ub3JtYWxpemUgPVxuICAgICAgc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dLm5vcm1hbGl6ZTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gRmFrZSByZWNvcmQgZm9yIGd1ZXNzZWQgbGlua3NcbiAgLy9cbiAgc2VsZi5fX2NvbXBpbGVkX19bJyddID0geyB2YWxpZGF0ZTogbnVsbCwgbm9ybWFsaXplOiBjcmVhdGVOb3JtYWxpemVyKCkgfTtcblxuICAvL1xuICAvLyBCdWlsZCBzY2hlbWEgY29uZGl0aW9uXG4gIC8vXG4gIHZhciBzbGlzdCA9IE9iamVjdC5rZXlzKHNlbGYuX19jb21waWxlZF9fKVxuICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBkaXNhYmxlZCAmIGZha2Ugc2NoZW1hc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUubGVuZ3RoID4gMCAmJiBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZXNjYXBlUkUpXG4gICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgLy8gKD8hXykgY2F1c2UgMS41eCBzbG93ZG93blxuICBzZWxmLnJlLnNjaGVtYV90ZXN0ICAgPSBSZWdFeHAoJyhefCg/IV8pKD86Wz48XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2knKTtcbiAgc2VsZi5yZS5zY2hlbWFfc2VhcmNoID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpZycpO1xuXG4gIHNlbGYucmUucHJldGVzdCAgICAgICA9IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzZWxmLnJlLnNjaGVtYV90ZXN0LnNvdXJjZSArICcpfCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNlbGYucmUuaG9zdF9mdXp6eV90ZXN0LnNvdXJjZSArICcpfCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaScpO1xuXG4gIC8vXG4gIC8vIENsZWFudXBcbiAgLy9cblxuICByZXNldFNjYW5DYWNoZShzZWxmKTtcbn1cblxuLyoqXG4gKiBjbGFzcyBNYXRjaFxuICpcbiAqIE1hdGNoIHJlc3VsdC4gU2luZ2xlIGVsZW1lbnQgb2YgYXJyYXksIHJldHVybmVkIGJ5IFtbTGlua2lmeUl0I21hdGNoXV1cbiAqKi9cbmZ1bmN0aW9uIE1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBzdGFydCA9IHNlbGYuX19pbmRleF9fLFxuICAgICAgZW5kICAgPSBzZWxmLl9fbGFzdF9pbmRleF9fLFxuICAgICAgdGV4dCAgPSBzZWxmLl9fdGV4dF9jYWNoZV9fLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIC8qKlxuICAgKiBNYXRjaCNzY2hlbWEgLT4gU3RyaW5nXG4gICAqXG4gICAqIFByZWZpeCAocHJvdG9jb2wpIGZvciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnNjaGVtYSAgICA9IHNlbGYuX19zY2hlbWFfXy50b0xvd2VyQ2FzZSgpO1xuICAvKipcbiAgICogTWF0Y2gjaW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIEZpcnN0IHBvc2l0aW9uIG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMuaW5kZXggICAgID0gc3RhcnQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI2xhc3RJbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogTmV4dCBwb3NpdGlvbiBhZnRlciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmxhc3RJbmRleCA9IGVuZCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjcmF3IC0+IFN0cmluZ1xuICAgKlxuICAgKiBNYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnJhdyAgICAgICA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN0ZXh0IC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3RtYWxpemVkIHRleHQgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy50ZXh0ICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdXJsIC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3JtYWxpemVkIHVybCBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnVybCAgICAgICA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBtYXRjaCA9IG5ldyBNYXRjaChzZWxmLCBzaGlmdCk7XG5cbiAgc2VsZi5fX2NvbXBpbGVkX19bbWF0Y2guc2NoZW1hXS5ub3JtYWxpemUobWF0Y2gsIHNlbGYpO1xuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuXG4vKipcbiAqIGNsYXNzIExpbmtpZnlJdFxuICoqL1xuXG4vKipcbiAqIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucylcbiAqIC0gc2NoZW1hcyAoT2JqZWN0KTogT3B0aW9uYWwuIEFkZGl0aW9uYWwgc2NoZW1hcyB0byB2YWxpZGF0ZSAocHJlZml4L3ZhbGlkYXRvcilcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogeyBmdXp6eUxpbmt8ZnV6enlFbWFpbHxmdXp6eUlQOiB0cnVlfGZhbHNlIH1cbiAqXG4gKiBDcmVhdGVzIG5ldyBsaW5raWZpZXIgaW5zdGFuY2Ugd2l0aCBvcHRpb25hbCBhZGRpdGlvbmFsIHNjaGVtYXMuXG4gKiBDYW4gYmUgY2FsbGVkIHdpdGhvdXQgYG5ld2Aga2V5d29yZCBmb3IgY29udmVuaWVuY2UuXG4gKlxuICogQnkgZGVmYXVsdCB1bmRlcnN0YW5kczpcbiAqXG4gKiAtIGBodHRwKHMpOi8vLi4uYCAsIGBmdHA6Ly8uLi5gLCBgbWFpbHRvOi4uLmAgJiBgLy8uLi5gIGxpbmtzXG4gKiAtIFwiZnV6enlcIiBsaW5rcyBhbmQgZW1haWxzIChleGFtcGxlLmNvbSwgZm9vQGJhci5jb20pLlxuICpcbiAqIGBzY2hlbWFzYCBpcyBhbiBvYmplY3QsIHdoZXJlIGVhY2gga2V5L3ZhbHVlIGRlc2NyaWJlcyBwcm90b2NvbC9ydWxlOlxuICpcbiAqIC0gX19rZXlfXyAtIGxpbmsgcHJlZml4ICh1c3VhbGx5LCBwcm90b2NvbCBuYW1lIHdpdGggYDpgIGF0IHRoZSBlbmQsIGBza3lwZTpgXG4gKiAgIGZvciBleGFtcGxlKS4gYGxpbmtpZnktaXRgIG1ha2VzIHNodXJlIHRoYXQgcHJlZml4IGlzIG5vdCBwcmVjZWVkZWQgd2l0aFxuICogICBhbHBoYW51bWVyaWMgY2hhciBhbmQgc3ltYm9scy4gT25seSB3aGl0ZXNwYWNlcyBhbmQgcHVuY3R1YXRpb24gYWxsb3dlZC5cbiAqIC0gX192YWx1ZV9fIC0gcnVsZSB0byBjaGVjayB0YWlsIGFmdGVyIGxpbmsgcHJlZml4XG4gKiAgIC0gX1N0cmluZ18gLSBqdXN0IGFsaWFzIHRvIGV4aXN0aW5nIHJ1bGVcbiAqICAgLSBfT2JqZWN0X1xuICogICAgIC0gX3ZhbGlkYXRlXyAtIHZhbGlkYXRvciBmdW5jdGlvbiAoc2hvdWxkIHJldHVybiBtYXRjaGVkIGxlbmd0aCBvbiBzdWNjZXNzKSxcbiAqICAgICAgIG9yIGBSZWdFeHBgLlxuICogICAgIC0gX25vcm1hbGl6ZV8gLSBvcHRpb25hbCBmdW5jdGlvbiB0byBub3JtYWxpemUgdGV4dCAmIHVybCBvZiBtYXRjaGVkIHJlc3VsdFxuICogICAgICAgKGZvciBleGFtcGxlLCBmb3IgQHR3aXR0ZXIgbWVudGlvbnMpLlxuICpcbiAqIGBvcHRpb25zYDpcbiAqXG4gKiAtIF9fZnV6enlMaW5rX18gLSByZWNvZ25pZ2UgVVJMLXMgd2l0aG91dCBgaHR0cChzKTpgIHByZWZpeC4gRGVmYXVsdCBgdHJ1ZWAuXG4gKiAtIF9fZnV6enlJUF9fIC0gYWxsb3cgSVBzIGluIGZ1enp5IGxpbmtzIGFib3ZlLiBDYW4gY29uZmxpY3Qgd2l0aCBzb21lIHRleHRzXG4gKiAgIGxpa2UgdmVyc2lvbiBudW1iZXJzLiBEZWZhdWx0IGBmYWxzZWAuXG4gKiAtIF9fZnV6enlFbWFpbF9fIC0gcmVjb2duaXplIGVtYWlscyB3aXRob3V0IGBtYWlsdG86YCBwcmVmaXguXG4gKlxuICoqL1xuZnVuY3Rpb24gTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmtpZnlJdCkpIHtcbiAgICByZXR1cm4gbmV3IExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmIChpc09wdGlvbnNPYmooc2NoZW1hcykpIHtcbiAgICAgIG9wdGlvbnMgPSBzY2hlbWFzO1xuICAgICAgc2NoZW1hcyA9IHt9O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX19vcHRzX18gICAgICAgICAgID0gYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgLy8gQ2FjaGUgbGFzdCB0ZXN0ZWQgcmVzdWx0LiBVc2VkIHRvIHNraXAgcmVwZWF0aW5nIHN0ZXBzIG9uIG5leHQgYG1hdGNoYCBjYWxsLlxuICB0aGlzLl9faW5kZXhfXyAgICAgICAgICA9IC0xO1xuICB0aGlzLl9fbGFzdF9pbmRleF9fICAgICA9IC0xOyAvLyBOZXh0IHNjYW4gcG9zaXRpb25cbiAgdGhpcy5fX3NjaGVtYV9fICAgICAgICAgPSAnJztcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyAgICAgPSAnJztcblxuICB0aGlzLl9fc2NoZW1hc19fICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdFNjaGVtYXMsIHNjaGVtYXMpO1xuICB0aGlzLl9fY29tcGlsZWRfXyAgICAgICA9IHt9O1xuXG4gIHRoaXMuX190bGRzX18gICAgICAgICAgID0gdGxkc19kZWZhdWx0O1xuICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fICA9IGZhbHNlO1xuXG4gIHRoaXMucmUgPSB7fTtcblxuICBjb21waWxlKHRoaXMpO1xufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNhZGQoc2NoZW1hLCBkZWZpbml0aW9uKVxuICogLSBzY2hlbWEgKFN0cmluZyk6IHJ1bGUgbmFtZSAoZml4ZWQgcGF0dGVybiBwcmVmaXgpXG4gKiAtIGRlZmluaXRpb24gKFN0cmluZ3xSZWdFeHB8T2JqZWN0KTogc2NoZW1hIGRlZmluaXRpb25cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgZGVmaW5pdGlvbi4gU2VlIGNvbnN0cnVjdG9yIGRlc2NyaXB0aW9uIGZvciBkZXRhaWxzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoc2NoZW1hLCBkZWZpbml0aW9uKSB7XG4gIHRoaXMuX19zY2hlbWFzX19bc2NoZW1hXSA9IGRlZmluaXRpb247XG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjc2V0KG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogU2V0IHJlY29nbml0aW9uIG9wdGlvbnMgZm9yIGxpbmtzIHdpdGhvdXQgc2NoZW1hLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICB0aGlzLl9fb3B0c19fID0gYXNzaWduKHRoaXMuX19vcHRzX18sIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdCh0ZXh0KSAtPiBCb29sZWFuXG4gKlxuICogU2VhcmNoZXMgbGlua2lmaWFibGUgcGF0dGVybiBhbmQgcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2VzcyBvciBgZmFsc2VgIG9uIGZhaWwuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHRleHQpIHtcbiAgLy8gUmVzZXQgc2NhbiBjYWNoZVxuICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gdGV4dDtcbiAgdGhpcy5fX2luZGV4X18gICAgICA9IC0xO1xuXG4gIGlmICghdGV4dC5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdmFyIG0sIG1sLCBtZSwgbGVuLCBzaGlmdCwgbmV4dCwgcmUsIHRsZF9wb3MsIGF0X3BvcztcblxuICAvLyB0cnkgdG8gc2NhbiBmb3IgbGluayB3aXRoIHNjaGVtYSAtIHRoYXQncyB0aGUgbW9zdCBzaW1wbGUgcnVsZVxuICBpZiAodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KHRleHQpKSB7XG4gICAgcmUgPSB0aGlzLnJlLnNjaGVtYV9zZWFyY2g7XG4gICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG0gPSByZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dCwgbVsyXSwgcmUubGFzdEluZGV4KTtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9IG1bMl07XG4gICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBtLmluZGV4ICsgbVsxXS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtLmluZGV4ICsgbVswXS5sZW5ndGggKyBsZW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5TGluayAmJiB0aGlzLl9fY29tcGlsZWRfX1snaHR0cDonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgbGlua3NcbiAgICB0bGRfcG9zID0gdGV4dC5zZWFyY2godGhpcy5yZS5ob3N0X2Z1enp5X3Rlc3QpO1xuICAgIGlmICh0bGRfcG9zID49IDApIHtcbiAgICAgIC8vIGlmIHRsZCBpcyBsb2NhdGVkIGFmdGVyIGZvdW5kIGxpbmsgLSBubyBuZWVkIHRvIGNoZWNrIGZ1enp5IHBhdHRlcm5cbiAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgdGxkX3BvcyA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgIGlmICgobWwgPSB0ZXh0Lm1hdGNoKHRoaXMuX19vcHRzX18uZnV6enlJUCA/IHRoaXMucmUubGlua19mdXp6eSA6IHRoaXMucmUubGlua19ub19pcF9mdXp6eSkpICE9PSBudWxsKSB7XG5cbiAgICAgICAgICBzaGlmdCA9IG1sLmluZGV4ICsgbWxbMV0ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJyc7XG4gICAgICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gc2hpZnQ7XG4gICAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbWwuaW5kZXggKyBtbFswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlFbWFpbCAmJiB0aGlzLl9fY29tcGlsZWRfX1snbWFpbHRvOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBlbWFpbHNcbiAgICBhdF9wb3MgPSB0ZXh0LmluZGV4T2YoJ0AnKTtcbiAgICBpZiAoYXRfcG9zID49IDApIHtcbiAgICAgIC8vIFdlIGNhbid0IHNraXAgdGhpcyBjaGVjaywgYmVjYXVzZSB0aGlzIGNhc2VzIGFyZSBwb3NzaWJsZTpcbiAgICAgIC8vIDE5Mi4xNjguMS4xQGdtYWlsLmNvbSwgbXkuaW5AZXhhbXBsZS5jb21cbiAgICAgIGlmICgobWUgPSB0ZXh0Lm1hdGNoKHRoaXMucmUuZW1haWxfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgIHNoaWZ0ID0gbWUuaW5kZXggKyBtZVsxXS5sZW5ndGg7XG4gICAgICAgIG5leHQgID0gbWUuaW5kZXggKyBtZVswXS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fIHx8XG4gICAgICAgICAgICAoc2hpZnQgPT09IHRoaXMuX19pbmRleF9fICYmIG5leHQgPiB0aGlzLl9fbGFzdF9pbmRleF9fKSkge1xuICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSAnbWFpbHRvOic7XG4gICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX19pbmRleF9fID49IDA7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3ByZXRlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFZlcnkgcXVpY2sgY2hlY2ssIHRoYXQgY2FuIGdpdmUgZmFsc2UgcG9zaXRpdmVzLiBSZXR1cm5zIHRydWUgaWYgbGluayBNQVkgQkVcbiAqIGNhbiBleGlzdHMuIENhbiBiZSB1c2VkIGZvciBzcGVlZCBvcHRpbWl6YXRpb24sIHdoZW4geW91IG5lZWQgdG8gY2hlY2sgdGhhdFxuICogbGluayBOT1QgZXhpc3RzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5wcmV0ZXN0ID0gZnVuY3Rpb24gcHJldGVzdCh0ZXh0KSB7XG4gIHJldHVybiB0aGlzLnJlLnByZXRlc3QudGVzdCh0ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdFNjaGVtYUF0KHRleHQsIG5hbWUsIHBvc2l0aW9uKSAtPiBOdW1iZXJcbiAqIC0gdGV4dCAoU3RyaW5nKTogdGV4dCB0byBzY2FuXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgKHNjaGVtYSkgbmFtZVxuICogLSBwb3NpdGlvbiAoTnVtYmVyKTogdGV4dCBvZmZzZXQgdG8gY2hlY2sgZnJvbVxuICpcbiAqIFNpbWlsYXIgdG8gW1tMaW5raWZ5SXQjdGVzdF1dIGJ1dCBjaGVja3Mgb25seSBzcGVjaWZpYyBwcm90b2NvbCB0YWlsIGV4YWN0bHlcbiAqIGF0IGdpdmVuIHBvc2l0aW9uLiBSZXR1cm5zIGxlbmd0aCBvZiBmb3VuZCBwYXR0ZXJuICgwIG9uIGZhaWwpLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0U2NoZW1hQXQgPSBmdW5jdGlvbiB0ZXN0U2NoZW1hQXQodGV4dCwgc2NoZW1hLCBwb3MpIHtcbiAgLy8gSWYgbm90IHN1cHBvcnRlZCBzY2hlbWEgY2hlY2sgcmVxdWVzdGVkIC0gdGVybWluYXRlXG4gIGlmICghdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXS52YWxpZGF0ZSh0ZXh0LCBwb3MsIHRoaXMpO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNtYXRjaCh0ZXh0KSAtPiBBcnJheXxudWxsXG4gKlxuICogUmV0dXJucyBhcnJheSBvZiBmb3VuZCBsaW5rIGRlc2NyaXB0aW9ucyBvciBgbnVsbGAgb24gZmFpbC4gV2Ugc3Ryb25nbHlcbiAqIHJlY29tbWVuZCB0byB1c2UgW1tMaW5raWZ5SXQjdGVzdF1dIGZpcnN0LCBmb3IgYmVzdCBzcGVlZC5cbiAqXG4gKiAjIyMjIyBSZXN1bHQgbWF0Y2ggZGVzY3JpcHRpb25cbiAqXG4gKiAtIF9fc2NoZW1hX18gLSBsaW5rIHNjaGVtYSwgY2FuIGJlIGVtcHR5IGZvciBmdXp6eSBsaW5rcywgb3IgYC8vYCBmb3JcbiAqICAgcHJvdG9jb2wtbmV1dHJhbCAgbGlua3MuXG4gKiAtIF9faW5kZXhfXyAtIG9mZnNldCBvZiBtYXRjaGVkIHRleHRcbiAqIC0gX19sYXN0SW5kZXhfXyAtIGluZGV4IG9mIG5leHQgY2hhciBhZnRlciBtYXRoY2ggZW5kXG4gKiAtIF9fcmF3X18gLSBtYXRjaGVkIHRleHRcbiAqIC0gX190ZXh0X18gLSBub3JtYWxpemVkIHRleHRcbiAqIC0gX191cmxfXyAtIGxpbmssIGdlbmVyYXRlZCBmcm9tIG1hdGNoZWQgdGV4dFxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHRleHQpIHtcbiAgdmFyIHNoaWZ0ID0gMCwgcmVzdWx0ID0gW107XG5cbiAgLy8gVHJ5IHRvIHRha2UgcHJldmlvdXMgZWxlbWVudCBmcm9tIGNhY2hlLCBpZiAudGVzdCgpIGNhbGxlZCBiZWZvcmVcbiAgaWYgKHRoaXMuX19pbmRleF9fID49IDAgJiYgdGhpcy5fX3RleHRfY2FjaGVfXyA9PT0gdGV4dCkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG4gICAgc2hpZnQgPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgLy8gQ3V0IGhlYWQgaWYgY2FjaGUgd2FzIHVzZWRcbiAgdmFyIHRhaWwgPSBzaGlmdCA/IHRleHQuc2xpY2Uoc2hpZnQpIDogdGV4dDtcblxuICAvLyBTY2FuIHN0cmluZyB1bnRpbCBlbmQgcmVhY2hlZFxuICB3aGlsZSAodGhpcy50ZXN0KHRhaWwpKSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcblxuICAgIHRhaWwgPSB0YWlsLnNsaWNlKHRoaXMuX19sYXN0X2luZGV4X18pO1xuICAgIHNoaWZ0ICs9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3RsZHMobGlzdCBbLCBrZWVwT2xkXSkgLT4gdGhpc1xuICogLSBsaXN0IChBcnJheSk6IGxpc3Qgb2YgdGxkc1xuICogLSBrZWVwT2xkIChCb29sZWFuKTogbWVyZ2Ugd2l0aCBjdXJyZW50IGxpc3QgaWYgYHRydWVgIChgZmFsc2VgIGJ5IGRlZmF1bHQpXG4gKlxuICogTG9hZCAob3IgbWVyZ2UpIG5ldyB0bGRzIGxpc3QuIFRob3NlIGFyZSB1c2VyIGZvciBmdXp6eSBsaW5rcyAod2l0aG91dCBwcmVmaXgpXG4gKiB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMuIEJ5IGRlZmF1bHQgdGhpcyBhbGdvcnl0aG0gdXNlZDpcbiAqXG4gKiAtIGhvc3RuYW1lIHdpdGggYW55IDItbGV0dGVyIHJvb3Qgem9uZXMgYXJlIG9rLlxuICogLSBiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhFxuICogICBhcmUgb2suXG4gKiAtIGVuY29kZWQgKGB4bi0tLi4uYCkgcm9vdCB6b25lcyBhcmUgb2suXG4gKlxuICogSWYgbGlzdCBpcyByZXBsYWNlZCwgdGhlbiBleGFjdCBtYXRjaCBmb3IgMi1jaGFycyByb290IHpvbmVzIHdpbGwgYmUgY2hlY2tlZC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGxkcyA9IGZ1bmN0aW9uIHRsZHMobGlzdCwga2VlcE9sZCkge1xuICBsaXN0ID0gQXJyYXkuaXNBcnJheShsaXN0KSA/IGxpc3QgOiBbIGxpc3QgXTtcblxuICBpZiAoIWtlZXBPbGQpIHtcbiAgICB0aGlzLl9fdGxkc19fID0gbGlzdC5zbGljZSgpO1xuICAgIHRoaXMuX190bGRzX3JlcGxhY2VkX18gPSB0cnVlO1xuICAgIGNvbXBpbGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9fdGxkc19fID0gdGhpcy5fX3RsZHNfXy5jb25jYXQobGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwsIGlkeCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwgIT09IGFycltpZHggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG5cbiAgY29tcGlsZSh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpbmtpZnlJdCNub3JtYWxpemUobWF0Y2gpXG4gKlxuICogRGVmYXVsdCBub3JtYWxpemVyIChpZiBzY2hlbWEgZG9lcyBub3QgZGVmaW5lIGl0J3Mgb3duKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1hdGNoKSB7XG5cbiAgLy8gRG8gbWluaW1hbCBwb3NzaWJsZSBjaGFuZ2VzIGJ5IGRlZmF1bHQuIE5lZWQgdG8gY29sbGVjdCBmZWVkYmFjayBwcmlvclxuICAvLyB0byBtb3ZlIGZvcndhcmQgaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQvaXNzdWVzLzFcblxuICBpZiAoIW1hdGNoLnNjaGVtYSkgeyBtYXRjaC51cmwgPSAnaHR0cDovLycgKyBtYXRjaC51cmw7IH1cblxuICBpZiAobWF0Y2guc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QobWF0Y2gudXJsKSkge1xuICAgIG1hdGNoLnVybCA9ICdtYWlsdG86JyArIG1hdGNoLnVybDtcbiAgfVxufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNvbkNvbXBpbGUoKVxuICpcbiAqIE92ZXJyaWRlIHRvIG1vZGlmeSBiYXNpYyBSZWdFeHAtcy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUub25Db21waWxlID0gZnVuY3Rpb24gb25Db21waWxlKCkge1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtpZnlJdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2xpbmtpZnktaXQvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgcmUgPSB7fTtcblxuICAvLyBVc2UgZGlyZWN0IGV4dHJhY3QgaW5zdGVhZCBvZiBgcmVnZW5lcmF0ZWAgdG8gcmVkdXNlIGJyb3dzZXJpZmllZCBzaXplXG4gIHJlLnNyY19BbnkgPSByZXF1aXJlKCd1Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX0NjICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19aICAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19QICAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXgnKS5zb3VyY2U7XG5cbiAgLy8gXFxwe1xcWlxcUFxcQ2NcXENGfSAod2hpdGUgc3BhY2VzICsgY29udHJvbCArIGZvcm1hdCArIHB1bmN0dWF0aW9uKVxuICByZS5zcmNfWlBDYyA9IFsgcmUuc3JjX1osIHJlLnNyY19QLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gXFxwe1xcWlxcQ2N9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sKVxuICByZS5zcmNfWkNjID0gWyByZS5zcmNfWiwgcmUuc3JjX0NjIF0uam9pbignfCcpO1xuXG4gIC8vIEV4cGVyaW1lbnRhbC4gTGlzdCBvZiBjaGFycywgY29tcGxldGVseSBwcm9oaWJpdGVkIGluIGxpbmtzXG4gIC8vIGJlY2F1c2UgY2FuIHNlcGFyYXRlIGl0IGZyb20gb3RoZXIgcGFydCBvZiB0ZXh0XG4gIHZhciB0ZXh0X3NlcGFyYXRvcnMgPSAnWz48XFx1ZmY1Y10nO1xuXG4gIC8vIEFsbCBwb3NzaWJsZSB3b3JkIGNoYXJhY3RlcnMgKGV2ZXJ5dGhpbmcgd2l0aG91dCBwdW5jdHVhdGlvbiwgc3BhY2VzICYgY29udHJvbHMpXG4gIC8vIERlZmluZWQgdmlhIHB1bmN0dWF0aW9uICYgc3BhY2VzIHRvIHNhdmUgc3BhY2VcbiAgLy8gU2hvdWxkIGJlIHNvbWV0aGluZyBsaWtlIFxccHtcXExcXE5cXFNcXE19IChcXHcgYnV0IHdpdGhvdXQgYF9gKVxuICByZS5zcmNfcHNldWRvX2xldHRlciAgICAgICA9ICcoPzooPyEnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKScgKyByZS5zcmNfQW55ICsgJyknO1xuICAvLyBUaGUgc2FtZSBhcyBhYm90aGUgYnV0IHdpdGhvdXQgWzAtOV1cbiAgLy8gdmFyIHNyY19wc2V1ZG9fbGV0dGVyX25vbl9kID0gJyg/Oig/IVswLTldfCcgKyBzcmNfWlBDYyArICcpJyArIHNyY19BbnkgKyAnKSc7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICByZS5zcmNfaXA0ID1cblxuICAgICcoPzooMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcXFwuKXszfSgyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pJztcblxuICAvLyBQcm9oaWJpdCBhbnkgb2YgXCJAL1tdKClcIiBpbiB1c2VyL3Bhc3MgdG8gYXZvaWQgd3JvbmcgZG9tYWluIGZldGNoLlxuICByZS5zcmNfYXV0aCAgICA9ICcoPzooPzooPyEnICsgcmUuc3JjX1pDYyArICd8W0AvXFxcXFtcXFxcXSgpXSkuKStAKT8nO1xuXG4gIHJlLnNyY19wb3J0ID1cblxuICAgICcoPzo6KD86Nig/OlswLTRdXFxcXGR7M318NSg/OlswLTRdXFxcXGR7Mn18NSg/OlswLTJdXFxcXGR8M1swLTVdKSkpfFsxLTVdP1xcXFxkezEsNH0pKT8nO1xuXG4gIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3IgPVxuXG4gICAgJyg/PSR8JyArIHRleHRfc2VwYXJhdG9ycyArICd8JyArIHJlLnNyY19aUENjICsgJykoPyEtfF98OlxcXFxkfFxcXFwuLXxcXFxcLig/ISR8JyArIHJlLnNyY19aUENjICsgJykpJztcblxuICByZS5zcmNfcGF0aCA9XG5cbiAgICAnKD86JyArXG4gICAgICAnWy8/I10nICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAgICcoPyEnICsgcmUuc3JjX1pDYyArICd8JyArIHRleHRfc2VwYXJhdG9ycyArICd8WygpW1xcXFxde30uLFwiXFwnPyFcXFxcLV0pLnwnICtcbiAgICAgICAgICAnXFxcXFsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8XFxcXF0pLikqXFxcXF18JyArXG4gICAgICAgICAgJ1xcXFwoKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFspXSkuKSpcXFxcKXwnICtcbiAgICAgICAgICAnXFxcXHsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W31dKS4pKlxcXFx9fCcgK1xuICAgICAgICAgICdcXFxcXCIoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W1wiXSkuKStcXFxcXCJ8JyArXG4gICAgICAgICAgXCJcXFxcJyg/Oig/IVwiICsgcmUuc3JjX1pDYyArIFwifFsnXSkuKStcXFxcJ3xcIiArXG4gICAgICAgICAgXCJcXFxcJyg/PVwiICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnfFstXSkufCcgKyAgLy8gYWxsb3cgYEknbV9raW5nYCBpZiBubyBwYWlyIGZvdW5kXG4gICAgICAgICAgJ1xcXFwuezIsM31bYS16QS1aMC05JS9dfCcgKyAvLyBnaXRodWIgaGFzIC4uLiBpbiBjb21taXQgcmFuZ2UgbGlua3MuIFJlc3RyaWN0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBlbmdsaXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwZXJjZW50LWVuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBhcnRzIG9mIGZpbGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIG1vcmUgZXhhbXBsZXMgZm91bmQuXG4gICAgICAgICAgJ1xcXFwuKD8hJyArIHJlLnNyY19aQ2MgKyAnfFsuXSkufCcgK1xuICAgICAgICAgIChvcHRzICYmIG9wdHNbJy0tLSddID9cbiAgICAgICAgICAgICdcXFxcLSg/IS0tKD86W14tXXwkKSkoPzotKil8JyAvLyBgLS0tYCA9PiBsb25nIGRhc2gsIHRlcm1pbmF0ZVxuICAgICAgICAgIDpcbiAgICAgICAgICAgICdcXFxcLSt8J1xuICAgICAgICAgICkgK1xuICAgICAgICAgICdcXFxcLCg/IScgKyByZS5zcmNfWkNjICsgJykufCcgKyAgICAgIC8vIGFsbG93IGAsLCxgIGluIHBhdGhzXG4gICAgICAgICAgJ1xcXFwhKD8hJyArIHJlLnNyY19aQ2MgKyAnfFshXSkufCcgK1xuICAgICAgICAgICdcXFxcPyg/IScgKyByZS5zcmNfWkNjICsgJ3xbP10pLicgK1xuICAgICAgICAnKSsnICtcbiAgICAgICd8XFxcXC8nICtcbiAgICAnKT8nO1xuXG4gIHJlLnNyY19lbWFpbF9uYW1lID1cblxuICAgICdbXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcXCJcXFxcLmEtekEtWjAtOV9dKyc7XG5cbiAgcmUuc3JjX3huID1cblxuICAgICd4bi0tW2EtejAtOVxcXFwtXXsxLDU5fSc7XG5cbiAgLy8gTW9yZSB0byByZWFkIGFib3V0IGRvbWFpbiBuYW1lc1xuICAvLyBodHRwOi8vc2VydmVyZmF1bHQuY29tL3F1ZXN0aW9ucy82MzgyNjAvXG5cbiAgcmUuc3JjX2RvbWFpbl9yb290ID1cblxuICAgIC8vIEFsbG93IGxldHRlcnMgJiBkaWdpdHMgKGh0dHA6Ly90ZXN0MSlcbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3sxLDYzfScgK1xuICAgICcpJztcblxuICByZS5zcmNfZG9tYWluID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgICAnfCcgK1xuICAgICAgLy8gZG9uJ3QgYWxsb3cgYC0tYCBpbiBkb21haW4gbmFtZXMsIGJlY2F1c2U6XG4gICAgICAvLyAtIHRoYXQgY2FuIGNvbmZsaWN0IHdpdGggbWFya2Rvd24gJm1kYXNoOyAvICZuZGFzaDtcbiAgICAgIC8vIC0gbm9ib2R5IHVzZSB0aG9zZSBhbnl3YXlcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKD86LSg/IS0pfCcgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpezAsNjF9JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2hvc3QgPVxuXG4gICAgJyg/OicgK1xuICAgIC8vIERvbid0IG5lZWQgSVAgY2hlY2ssIGJlY2F1c2UgZGlnaXRzIGFyZSBhbHJlYWR5IGFsbG93ZWQgaW4gbm9ybWFsIGRvbWFpbiBuYW1lc1xuICAgIC8vICAgc3JjX2lwNCArXG4gICAgLy8gJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKicgKyByZS5zcmNfZG9tYWluLypfcm9vdCovICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3RfZnV6enkgPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX2lwNCArXG4gICAgJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ID1cblxuICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJztcblxuICByZS5zcmNfaG9zdF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNYWluIHJ1bGVzXG5cbiAgLy8gUnVkZSB0ZXN0IGZ1enp5IGxpbmtzIGJ5IGhvc3QsIGZvciBxdWljayBkZW55XG4gIHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QgPVxuXG4gICAgJ2xvY2FsaG9zdHx3d3dcXFxcLnxcXFxcLlxcXFxkezEsM31cXFxcLnwoPzpcXFxcLig/OiVUTERTJSkoPzonICsgcmUuc3JjX1pQQ2MgKyAnfD58JCkpJztcblxuICByZS50cGxfZW1haWxfZnV6enkgPVxuXG4gICAgICAnKF58JyArIHRleHRfc2VwYXJhdG9ycyArICd8XFxcXCh8JyArIHJlLnNyY19aQ2MgKyAnKSgnICsgcmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfbm9faXBfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmV0dXJuIHJlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2xpbmtpZnktaXQvbGliL3JlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9pbmRleC5qcyIsIi8vIExpc3Qgb2YgdmFsaWQgaHRtbCBibG9ja3MgbmFtZXMsIGFjY29ydGluZyB0byBjb21tb25tYXJrIHNwZWNcbi8vIGh0dHA6Ly9qZ20uZ2l0aHViLmlvL0NvbW1vbk1hcmsvc3BlYy5odG1sI2h0bWwtYmxvY2tzXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2FkZHJlc3MnLFxuICAnYXJ0aWNsZScsXG4gICdhc2lkZScsXG4gICdiYXNlJyxcbiAgJ2Jhc2Vmb250JyxcbiAgJ2Jsb2NrcXVvdGUnLFxuICAnYm9keScsXG4gICdjYXB0aW9uJyxcbiAgJ2NlbnRlcicsXG4gICdjb2wnLFxuICAnY29sZ3JvdXAnLFxuICAnZGQnLFxuICAnZGV0YWlscycsXG4gICdkaWFsb2cnLFxuICAnZGlyJyxcbiAgJ2RpdicsXG4gICdkbCcsXG4gICdkdCcsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdmcmFtZScsXG4gICdmcmFtZXNldCcsXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICdoZWFkJyxcbiAgJ2hlYWRlcicsXG4gICdocicsXG4gICdodG1sJyxcbiAgJ2lmcmFtZScsXG4gICdsZWdlbmQnLFxuICAnbGknLFxuICAnbGluaycsXG4gICdtYWluJyxcbiAgJ21lbnUnLFxuICAnbWVudWl0ZW0nLFxuICAnbWV0YScsXG4gICduYXYnLFxuICAnbm9mcmFtZXMnLFxuICAnb2wnLFxuICAnb3B0Z3JvdXAnLFxuICAnb3B0aW9uJyxcbiAgJ3AnLFxuICAncGFyYW0nLFxuICAncHJlJyxcbiAgJ3NlY3Rpb24nLFxuICAnc291cmNlJyxcbiAgJ3RpdGxlJyxcbiAgJ3N1bW1hcnknLFxuICAndGFibGUnLFxuICAndGJvZHknLFxuICAndGQnLFxuICAndGZvb3QnLFxuICAndGgnLFxuICAndGhlYWQnLFxuICAndGl0bGUnLFxuICAndHInLFxuICAndHJhY2snLFxuICAndWwnXG5dO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qcyIsIi8vIEp1c3QgYSBzaG9ydGN1dCBmb3IgYnVsayBleHBvcnRcbid1c2Ugc3RyaWN0JztcblxuXG5leHBvcnRzLnBhcnNlTGlua0xhYmVsICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2xhYmVsJyk7XG5leHBvcnRzLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uJyk7XG5leHBvcnRzLnBhcnNlTGlua1RpdGxlICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX3RpdGxlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9pbmRleC5qcyIsIi8vIFBhcnNlIGxpbmsgZGVzdGluYXRpb25cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGlzU3BhY2UgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSwgbGV2ZWwsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6ICcnXG4gICAgICB9O1xuXG4gIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDNDIC8qIDwgKi8pIHtcbiAgICBwb3MrKztcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjb2RlID09PSAweDBBIC8qIFxcbiAqLyB8fCBpc1NwYWNlKGNvZGUpKSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICAgIGlmIChjb2RlID09PSAweDNFIC8qID4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICAvLyBubyBjbG9zaW5nICc+J1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyB0aGlzIHNob3VsZCBiZSAuLi4gfSBlbHNlIHsgLi4uIGJyYW5jaFxuXG4gIGxldmVsID0gMDtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNvZGUgPT09IDB4MjApIHsgYnJlYWs7IH1cblxuICAgIC8vIGFzY2lpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMHgyMCB8fCBjb2RlID09PSAweDdGKSB7IGJyZWFrOyB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBwb3MgKz0gMjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI4IC8qICggKi8pIHtcbiAgICAgIGxldmVsKys7XG4gICAgICBpZiAobGV2ZWwgPiAxKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjkgLyogKSAqLykge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA8IDApIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gcG9zKSB7IHJldHVybiByZXN1bHQ7IH1cblxuICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0LCBwb3MpKTtcbiAgcmVzdWx0LmxpbmVzID0gbGluZXM7XG4gIHJlc3VsdC5wb3MgPSBwb3M7XG4gIHJlc3VsdC5vayA9IHRydWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIi8vIFBhcnNlIGxpbmsgbGFiZWxcbi8vXG4vLyB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgKFwiW1wiKSBhbHJlYWR5IG1hdGNoZXM7XG4vLyByZXR1cm5zIHRoZSBlbmQgb2YgdGhlIGxhYmVsXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGFydCwgZGlzYWJsZU5lc3RlZCkge1xuICB2YXIgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsIHByZXZQb3MsXG4gICAgICBsYWJlbEVuZCA9IC0xLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zO1xuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcbiAgbGV2ZWwgPSAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBtYXgpIHtcbiAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZQb3MgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubWQuaW5saW5lLnNraXBUb2tlbihzdGF0ZSk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICBpZiAocHJldlBvcyA9PT0gc3RhdGUucG9zIC0gMSkge1xuICAgICAgICAvLyBpbmNyZWFzZSBsZXZlbCBpZiB3ZSBmaW5kIHRleHQgYFtgLCB3aGljaCBpcyBub3QgYSBwYXJ0IG9mIGFueSB0b2tlblxuICAgICAgICBsZXZlbCsrO1xuICAgICAgfSBlbHNlIGlmIChkaXNhYmxlTmVzdGVkKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZCkge1xuICAgIGxhYmVsRW5kID0gc3RhdGUucG9zO1xuICB9XG5cbiAgLy8gcmVzdG9yZSBvbGQgc3RhdGVcbiAgc3RhdGUucG9zID0gb2xkUG9zO1xuXG4gIHJldHVybiBsYWJlbEVuZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2xhYmVsLmpzIiwiLy8gUGFyc2UgbGluayB0aXRsZVxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsXG4gICAgICBtYXJrZXIsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6ICcnXG4gICAgICB9O1xuXG4gIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiByZXN1bHQ7IH1cblxuICBtYXJrZXIgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4MjIgLyogXCIgKi8gJiYgbWFya2VyICE9PSAweDI3IC8qICcgKi8gJiYgbWFya2VyICE9PSAweDI4IC8qICggKi8pIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIHBvcysrO1xuXG4gIC8vIGlmIG9wZW5pbmcgbWFya2VyIGlzIFwiKFwiLCBzd2l0Y2ggaXQgdG8gY2xvc2luZyBtYXJrZXIgXCIpXCJcbiAgaWYgKG1hcmtlciA9PT0gMHgyOCkgeyBtYXJrZXIgPSAweDI5OyB9XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgcmVzdWx0LmxpbmVzID0gbGluZXM7XG4gICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcysrO1xuICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZXMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua190aXRsZS5qcyIsIi8vIE1haW4gcGFyc2VyIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKTtcbnZhciBoZWxwZXJzICAgICAgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbnZhciBSZW5kZXJlciAgICAgPSByZXF1aXJlKCcuL3JlbmRlcmVyJyk7XG52YXIgUGFyc2VyQ29yZSAgID0gcmVxdWlyZSgnLi9wYXJzZXJfY29yZScpO1xudmFyIFBhcnNlckJsb2NrICA9IHJlcXVpcmUoJy4vcGFyc2VyX2Jsb2NrJyk7XG52YXIgUGFyc2VySW5saW5lID0gcmVxdWlyZSgnLi9wYXJzZXJfaW5saW5lJyk7XG52YXIgTGlua2lmeUl0ICAgID0gcmVxdWlyZSgnbGlua2lmeS1pdCcpO1xudmFyIG1kdXJsICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XG52YXIgcHVueWNvZGUgICAgID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxuXG52YXIgY29uZmlnID0ge1xuICAnZGVmYXVsdCc6IHJlcXVpcmUoJy4vcHJlc2V0cy9kZWZhdWx0JyksXG4gIHplcm86IHJlcXVpcmUoJy4vcHJlc2V0cy96ZXJvJyksXG4gIGNvbW1vbm1hcms6IHJlcXVpcmUoJy4vcHJlc2V0cy9jb21tb25tYXJrJylcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gVGhpcyB2YWxpZGF0b3IgY2FuIHByb2hpYml0IG1vcmUgdGhhbiByZWFsbHkgbmVlZGVkIHRvIHByZXZlbnQgWFNTLiBJdCdzIGFcbi8vIHRyYWRlb2ZmIHRvIGtlZXAgY29kZSBzaW1wbGUgYW5kIHRvIGJlIHNlY3VyZSBieSBkZWZhdWx0LlxuLy9cbi8vIElmIHlvdSBuZWVkIGRpZmZlcmVudCBzZXR1cCAtIG92ZXJyaWRlIHZhbGlkYXRvciBtZXRob2QgYXMgeW91IHdpc2guIE9yXG4vLyByZXBsYWNlIGl0IHdpdGggZHVtbXkgZnVuY3Rpb24gYW5kIHVzZSBleHRlcm5hbCBzYW5pdGl6ZXIuXG4vL1xuXG52YXIgQkFEX1BST1RPX1JFID0gL14odmJzY3JpcHR8amF2YXNjcmlwdHxmaWxlfGRhdGEpOi87XG52YXIgR09PRF9EQVRBX1JFID0gL15kYXRhOmltYWdlXFwvKGdpZnxwbmd8anBlZ3x3ZWJwKTsvO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUxpbmsodXJsKSB7XG4gIC8vIHVybCBzaG91bGQgYmUgbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50LCBhbmQgZXhpc3RpbmcgZW50aXRpZXMgYXJlIGRlY29kZWRcbiAgdmFyIHN0ciA9IHVybC50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gQkFEX1BST1RPX1JFLnRlc3Qoc3RyKSA/IChHT09EX0RBVEFfUkUudGVzdChzdHIpID8gdHJ1ZSA6IGZhbHNlKSA6IHRydWU7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIFJFQ09ERV9IT1NUTkFNRV9GT1IgPSBbICdodHRwOicsICdodHRwczonLCAnbWFpbHRvOicgXTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTGluayh1cmwpIHtcbiAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG5cbiAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXG4gICAgLy9cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHBhcnNlZC5ob3N0bmFtZSk7XG4gICAgICB9IGNhdGNoIChlcikgeyAvKiovIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWR1cmwuZW5jb2RlKG1kdXJsLmZvcm1hdChwYXJzZWQpKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTGlua1RleHQodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9Vbmljb2RlKHBhcnNlZC5ob3N0bmFtZSk7XG4gICAgICB9IGNhdGNoIChlcikgeyAvKiovIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWR1cmwuZGVjb2RlKG1kdXJsLmZvcm1hdChwYXJzZWQpKTtcbn1cblxuXG4vKipcbiAqIGNsYXNzIE1hcmtkb3duSXRcbiAqXG4gKiBNYWluIHBhcnNlci9yZW5kZXJlciBjbGFzcy5cbiAqXG4gKiAjIyMjIyBVc2FnZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIG5vZGUuanMsIFwiY2xhc3NpY1wiIHdheTpcbiAqIHZhciBNYXJrZG93bkl0ID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSxcbiAqICAgICBtZCA9IG5ldyBNYXJrZG93bkl0KCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqXG4gKiAvLyBub2RlLmpzLCB0aGUgc2FtZSwgYnV0IHdpdGggc3VnYXI6XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqXG4gKiAvLyBicm93c2VyIHdpdGhvdXQgQU1ELCBhZGRlZCB0byBcIndpbmRvd1wiIG9uIHNjcmlwdCBsb2FkXG4gKiAvLyBOb3RlLCB0aGVyZSBhcmUgbm8gZGFzaC5cbiAqIHZhciBtZCA9IHdpbmRvdy5tYXJrZG93bml0KCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqIGBgYFxuICpcbiAqIFNpbmdsZSBsaW5lIHJlbmRlcmluZywgd2l0aG91dCBwYXJhZ3JhcGggd3JhcDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKCdfX21hcmtkb3duLWl0X18gcnVsZXp6IScpO1xuICogYGBgXG4gKiovXG5cbi8qKlxuICogbmV3IE1hcmtkb3duSXQoW3ByZXNldE5hbWUsIG9wdGlvbnNdKVxuICogLSBwcmVzZXROYW1lIChTdHJpbmcpOiBvcHRpb25hbCwgYGNvbW1vbm1hcmtgIC8gYHplcm9gXG4gKiAtIG9wdGlvbnMgKE9iamVjdClcbiAqXG4gKiBDcmVhdGVzIHBhcnNlciBpbnN0YW5zZSB3aXRoIGdpdmVuIGNvbmZpZy4gQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgLlxuICpcbiAqICMjIyMjIHByZXNldE5hbWVcbiAqXG4gKiBNYXJrZG93bkl0IHByb3ZpZGVzIG5hbWVkIHByZXNldHMgYXMgYSBjb252ZW5pZW5jZSB0byBxdWlja2x5XG4gKiBlbmFibGUvZGlzYWJsZSBhY3RpdmUgc3ludGF4IHJ1bGVzIGFuZCBvcHRpb25zIGZvciBjb21tb24gdXNlIGNhc2VzLlxuICpcbiAqIC0gW1wiY29tbW9ubWFya1wiXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcykgLVxuICogICBjb25maWd1cmVzIHBhcnNlciB0byBzdHJpY3QgW0NvbW1vbk1hcmtdKGh0dHA6Ly9jb21tb25tYXJrLm9yZy8pIG1vZGUuXG4gKiAtIFtkZWZhdWx0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvZGVmYXVsdC5qcykgLVxuICogICBzaW1pbGFyIHRvIEdGTSwgdXNlZCB3aGVuIG5vIHByZXNldCBuYW1lIGdpdmVuLiBFbmFibGVzIGFsbCBhdmFpbGFibGUgcnVsZXMsXG4gKiAgIGJ1dCBzdGlsbCB3aXRob3V0IGh0bWwsIHR5cG9ncmFwaGVyICYgYXV0b2xpbmtlci5cbiAqIC0gW1wiemVyb1wiXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvemVyby5qcykgLVxuICogICBhbGwgcnVsZXMgZGlzYWJsZWQuIFVzZWZ1bCB0byBxdWlja2x5IHNldHVwIHlvdXIgY29uZmlnIHZpYSBgLmVuYWJsZSgpYC5cbiAqICAgRm9yIGV4YW1wbGUsIHdoZW4geW91IG5lZWQgb25seSBgYm9sZGAgYW5kIGBpdGFsaWNgIG1hcmt1cCBhbmQgbm90aGluZyBlbHNlLlxuICpcbiAqICMjIyMjIG9wdGlvbnM6XG4gKlxuICogLSBfX2h0bWxfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2UuIEJlIGNhcmVmdWwhXG4gKiAgIFRoYXQncyBub3Qgc2FmZSEgWW91IG1heSBuZWVkIGV4dGVybmFsIHNhbml0aXplciB0byBwcm90ZWN0IG91dHB1dCBmcm9tIFhTUy5cbiAqICAgSXQncyBiZXR0ZXIgdG8gZXh0ZW5kIGZlYXR1cmVzIHZpYSBwbHVnaW5zLCBpbnN0ZWFkIG9mIGVuYWJsaW5nIEhUTUwuXG4gKiAtIF9feGh0bWxPdXRfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYWRkICcvJyB3aGVuIGNsb3Npbmcgc2luZ2xlIHRhZ3NcbiAqICAgKGA8YnIgLz5gKS4gVGhpcyBpcyBuZWVkZWQgb25seSBmb3IgZnVsbCBDb21tb25NYXJrIGNvbXBhdGliaWxpdHkuIEluIHJlYWxcbiAqICAgd29ybGQgeW91IHdpbGwgbmVlZCBIVE1MIG91dHB1dC5cbiAqIC0gX19icmVha3NfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gY29udmVydCBgXFxuYCBpbiBwYXJhZ3JhcGhzIGludG8gYDxicj5gLlxuICogLSBfX2xhbmdQcmVmaXhfXyAtIGBsYW5ndWFnZS1gLiBDU1MgbGFuZ3VhZ2UgY2xhc3MgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzLlxuICogICBDYW4gYmUgdXNlZnVsIGZvciBleHRlcm5hbCBoaWdobGlnaHRlcnMuXG4gKiAtIF9fbGlua2lmeV9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0IHRvIGxpbmtzLlxuICogLSBfX3R5cG9ncmFwaGVyX18gIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBlbmFibGUgW3NvbWUgbGFuZ3VhZ2UtbmV1dHJhbFxuICogICByZXBsYWNlbWVudF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcykgK1xuICogICBxdW90ZXMgYmVhdXRpZmljYXRpb24gKHNtYXJ0cXVvdGVzKS5cbiAqIC0gX19xdW90ZXNfXyAtIGDigJzigJ3igJjigJlgLCBTdHJpbmcgb3IgQXJyYXkuIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnRcbiAqICAgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCBhbmQgc21hcnRxdW90ZXMgb24uIEZvciBleGFtcGxlLCB5b3UgY2FuXG4gKiAgIHVzZSBgJ8KrwrvigJ7igJwnYCBmb3IgUnVzc2lhbiwgYCfigJ7igJzigJrigJgnYCBmb3IgR2VybWFuLCBhbmRcbiAqICAgYFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J11gIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAqIC0gX19oaWdobGlnaHRfXyAtIGBudWxsYC4gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24gZm9yIGZlbmNlZCBjb2RlIGJsb2Nrcy5cbiAqICAgSGlnaGxpZ2h0ZXIgYGZ1bmN0aW9uIChzdHIsIGxhbmcpYCBzaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTC4gSXQgY2FuIGFsc29cbiAqICAgcmV0dXJuIGVtcHR5IHN0cmluZyBpZiB0aGUgc291cmNlIHdhcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWRcbiAqICAgZXh0ZXJuYWx5LiBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIGNvbW1vbm1hcmsgbW9kZVxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgnY29tbW9ubWFyaycpO1xuICpcbiAqIC8vIGRlZmF1bHQgbW9kZVxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaHRtbDogdHJ1ZSxcbiAqICAgbGlua2lmeTogdHJ1ZSxcbiAqICAgdHlwb2dyYXBoZXI6IHRydWVcbiAqIH0pO1xuICogYGBgXG4gKlxuICogIyMjIyMgU3ludGF4IGhpZ2hsaWdodGluZ1xuICpcbiAqIGBgYGpzXG4gKiB2YXIgaGxqcyA9IHJlcXVpcmUoJ2hpZ2hsaWdodC5qcycpIC8vIGh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuICpcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0Jykoe1xuICogICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzdHIsIGxhbmcpIHtcbiAqICAgICBpZiAobGFuZyAmJiBobGpzLmdldExhbmd1YWdlKGxhbmcpKSB7XG4gKiAgICAgICB0cnkge1xuICogICAgICAgICByZXR1cm4gaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZTtcbiAqICAgICAgIH0gY2F0Y2ggKF9fKSB7fVxuICogICAgIH1cbiAqXG4gKiAgICAgcmV0dXJuICcnOyAvLyB1c2UgZXh0ZXJuYWwgZGVmYXVsdCBlc2NhcGluZ1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIE9yIHdpdGggZnVsbCB3cmFwcGVyIG92ZXJyaWRlIChpZiB5b3UgbmVlZCBhc3NpZ24gY2xhc3MgdG8gYDxwcmU+YCk6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiAvLyBBY3R1YWwgZGVmYXVsdCB2YWx1ZXNcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0Jykoe1xuICogICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzdHIsIGxhbmcpIHtcbiAqICAgICBpZiAobGFuZyAmJiBobGpzLmdldExhbmd1YWdlKGxhbmcpKSB7XG4gKiAgICAgICB0cnkge1xuICogICAgICAgICByZXR1cm4gJzxwcmUgY2xhc3M9XCJobGpzXCI+PGNvZGU+JyArXG4gKiAgICAgICAgICAgICAgICBobGpzLmhpZ2hsaWdodChsYW5nLCBzdHIsIHRydWUpLnZhbHVlICtcbiAqICAgICAgICAgICAgICAgICc8L2NvZGU+PC9wcmU+JztcbiAqICAgICAgIH0gY2F0Y2ggKF9fKSB7fVxuICogICAgIH1cbiAqXG4gKiAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgKyBtZC51dGlscy5lc2NhcGVIdG1sKHN0cikgKyAnPC9jb2RlPjwvcHJlPic7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICoqL1xuZnVuY3Rpb24gTWFya2Rvd25JdChwcmVzZXROYW1lLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXJrZG93bkl0KSkge1xuICAgIHJldHVybiBuZXcgTWFya2Rvd25JdChwcmVzZXROYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmICghdXRpbHMuaXNTdHJpbmcocHJlc2V0TmFtZSkpIHtcbiAgICAgIG9wdGlvbnMgPSBwcmVzZXROYW1lIHx8IHt9O1xuICAgICAgcHJlc2V0TmFtZSA9ICdkZWZhdWx0JztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFya2Rvd25JdCNpbmxpbmUgLT4gUGFyc2VySW5saW5lXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUGFyc2VySW5saW5lXV0uIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cbiAgICogd3JpdGluZyBwbHVnaW5zLiBGb3Igc2ltcGxlIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0gYW5kXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cbiAgICoqL1xuICB0aGlzLmlubGluZSA9IG5ldyBQYXJzZXJJbmxpbmUoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNibG9jayAtPiBQYXJzZXJCbG9ja1xuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlckJsb2NrXV0uIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cbiAgICogd3JpdGluZyBwbHVnaW5zLiBGb3Igc2ltcGxlIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0gYW5kXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cbiAgICoqL1xuICB0aGlzLmJsb2NrID0gbmV3IFBhcnNlckJsb2NrKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjY29yZSAtPiBDb3JlXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbQ29yZV1dIGNoYWluIGV4ZWN1dG9yLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5jb3JlID0gbmV3IFBhcnNlckNvcmUoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNyZW5kZXJlciAtPiBSZW5kZXJlclxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1JlbmRlcmVyXV0uIFVzZSBpdCB0byBtb2RpZnkgb3V0cHV0IGxvb2suIE9yIHRvIGFkZCByZW5kZXJpbmdcbiAgICogcnVsZXMgZm9yIG5ldyB0b2tlbiB0eXBlcywgZ2VuZXJhdGVkIGJ5IHBsdWdpbnMuXG4gICAqXG4gICAqICMjIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqXG4gICAqIGZ1bmN0aW9uIG15VG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2VsZikge1xuICAgKiAgIC8vLi4uXG4gICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICogfTtcbiAgICpcbiAgICogbWQucmVuZGVyZXIucnVsZXNbJ215X3Rva2VuJ10gPSBteVRva2VuXG4gICAqIGBgYFxuICAgKlxuICAgKiBTZWUgW1tSZW5kZXJlcl1dIGRvY3MgYW5kIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5qcykuXG4gICAqKi9cbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2xpbmtpZnkgLT4gTGlua2lmeUl0XG4gICAqXG4gICAqIFtsaW5raWZ5LWl0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdCkgaW5zdGFuY2UuXG4gICAqIFVzZWQgYnkgW2xpbmtpZnldKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzKVxuICAgKiBydWxlLlxuICAgKiovXG4gIHRoaXMubGlua2lmeSA9IG5ldyBMaW5raWZ5SXQoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCN2YWxpZGF0ZUxpbmsodXJsKSAtPiBCb29sZWFuXG4gICAqXG4gICAqIExpbmsgdmFsaWRhdGlvbiBmdW5jdGlvbi4gQ29tbW9uTWFyayBhbGxvd3MgdG9vIG11Y2ggaW4gbGlua3MuIEJ5IGRlZmF1bHRcbiAgICogd2UgZGlzYWJsZSBgamF2YXNjcmlwdDpgLCBgdmJzY3JpcHQ6YCwgYGZpbGU6YCBzY2hlbWFzLCBhbmQgYWxtb3N0IGFsbCBgZGF0YTouLi5gIHNjaGVtYXNcbiAgICogZXhjZXB0IHNvbWUgZW1iZWRkZWQgaW1hZ2UgdHlwZXMuXG4gICAqXG4gICAqIFlvdSBjYW4gY2hhbmdlIHRoaXMgYmVoYXZpb3VyOlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICogLy8gZW5hYmxlIGV2ZXJ5dGhpbmdcbiAgICogbWQudmFsaWRhdGVMaW5rID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgKiBgYGBcbiAgICoqL1xuICB0aGlzLnZhbGlkYXRlTGluayA9IHZhbGlkYXRlTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rKHVybCkgLT4gU3RyaW5nXG4gICAqXG4gICAqIEZ1bmN0aW9uIHVzZWQgdG8gZW5jb2RlIGxpbmsgdXJsIHRvIGEgbWFjaGluZS1yZWFkYWJsZSBmb3JtYXQsXG4gICAqIHdoaWNoIGluY2x1ZGVzIHVybC1lbmNvZGluZywgcHVueWNvZGUsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmsgPSBub3JtYWxpemVMaW5rO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I25vcm1hbGl6ZUxpbmtUZXh0KHVybCkgLT4gU3RyaW5nXG4gICAqXG4gICAqIEZ1bmN0aW9uIHVzZWQgdG8gZGVjb2RlIGxpbmsgdXJsIHRvIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0YFxuICAgKiovXG4gIHRoaXMubm9ybWFsaXplTGlua1RleHQgPSBub3JtYWxpemVMaW5rVGV4dDtcblxuXG4gIC8vIEV4cG9zZSB1dGlscyAmIGhlbHBlcnMgZm9yIGVhc3kgYWNjZXMgZnJvbSBwbHVnaW5zXG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdXRpbHMgLT4gdXRpbHNcbiAgICpcbiAgICogQXNzb3J0ZWQgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWZ1bCB0byB3cml0ZSBwbHVnaW5zLiBTZWUgZGV0YWlsc1xuICAgKiBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9jb21tb24vdXRpbHMuanMpLlxuICAgKiovXG4gIHRoaXMudXRpbHMgPSB1dGlscztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNoZWxwZXJzIC0+IGhlbHBlcnNcbiAgICpcbiAgICogTGluayBjb21wb25lbnRzIHBhcnNlciBmdW5jdGlvbnMsIHVzZWZ1bCB0byB3cml0ZSBwbHVnaW5zLiBTZWUgZGV0YWlsc1xuICAgKiBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9oZWxwZXJzKS5cbiAgICoqL1xuICB0aGlzLmhlbHBlcnMgPSB1dGlscy5hc3NpZ24oe30sIGhlbHBlcnMpO1xuXG5cbiAgdGhpcy5vcHRpb25zID0ge307XG4gIHRoaXMuY29uZmlndXJlKHByZXNldE5hbWUpO1xuXG4gIGlmIChvcHRpb25zKSB7IHRoaXMuc2V0KG9wdGlvbnMpOyB9XG59XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5zZXQob3B0aW9ucylcbiAqXG4gKiBTZXQgcGFyc2VyIG9wdGlvbnMgKGluIHRoZSBzYW1lIGZvcm1hdCBhcyBpbiBjb25zdHJ1Y3RvcikuIFByb2JhYmx5LCB5b3VcbiAqIHdpbGwgbmV2ZXIgbmVlZCBpdCwgYnV0IHlvdSBjYW4gY2hhbmdlIG9wdGlvbnMgYWZ0ZXIgY29uc3RydWN0b3IgY2FsbC5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAuc2V0KHsgaHRtbDogdHJ1ZSwgYnJlYWtzOiB0cnVlIH0pXG4gKiAgICAgICAgICAgICAuc2V0KHsgdHlwb2dyYXBoZXIsIHRydWUgfSk7XG4gKiBgYGBcbiAqXG4gKiBfX05vdGU6X18gVG8gYWNoaWV2ZSB0aGUgYmVzdCBwb3NzaWJsZSBwZXJmb3JtYW5jZSwgZG9uJ3QgbW9kaWZ5IGFcbiAqIGBtYXJrZG93bi1pdGAgaW5zdGFuY2Ugb3B0aW9ucyBvbiB0aGUgZmx5LiBJZiB5b3UgbmVlZCBtdWx0aXBsZSBjb25maWd1cmF0aW9uc1xuICogaXQncyBiZXN0IHRvIGNyZWF0ZSBtdWx0aXBsZSBpbnN0YW5jZXMgYW5kIGluaXRpYWxpemUgZWFjaCB3aXRoIHNlcGFyYXRlXG4gKiBjb25maWcuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB1dGlscy5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGUsIGludGVybmFsXG4gKiBNYXJrZG93bkl0LmNvbmZpZ3VyZShwcmVzZXRzKVxuICpcbiAqIEJhdGNoIGxvYWQgb2YgYWxsIG9wdGlvbnMgYW5kIGNvbXBlbmVudCBzZXR0aW5ncy4gVGhpcyBpcyBpbnRlcm5hbCBtZXRob2QsXG4gKiBhbmQgeW91IHByb2JhYmx5IHdpbGwgbm90IG5lZWQgaXQuIEJ1dCBpZiB5b3Ugd2l0aCAtIHNlZSBhdmFpbGFibGUgcHJlc2V0c1xuICogYW5kIGRhdGEgc3RydWN0dXJlIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvdHJlZS9tYXN0ZXIvbGliL3ByZXNldHMpXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBwcmVzZXRzIGluc3RlYWQgb2YgZGlyZWN0IGNvbmZpZyBsb2Fkcy4gVGhhdFxuICogd2lsbCBnaXZlIGJldHRlciBjb21wYXRpYmlsaXR5IHdpdGggbmV4dCB2ZXJzaW9ucy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChwcmVzZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcywgcHJlc2V0TmFtZTtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcocHJlc2V0cykpIHtcbiAgICBwcmVzZXROYW1lID0gcHJlc2V0cztcbiAgICBwcmVzZXRzID0gY29uZmlnW3ByZXNldE5hbWVdO1xuICAgIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0IFwiJyArIHByZXNldE5hbWUgKyAnXCIsIGNoZWNrIG5hbWUnKTsgfVxuICB9XG5cbiAgaWYgKCFwcmVzZXRzKSB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQsIGNhblxcJ3QgYmUgZW1wdHknKTsgfVxuXG4gIGlmIChwcmVzZXRzLm9wdGlvbnMpIHsgc2VsZi5zZXQocHJlc2V0cy5vcHRpb25zKTsgfVxuXG4gIGlmIChwcmVzZXRzLmNvbXBvbmVudHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcmVzZXRzLmNvbXBvbmVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlci5lbmFibGVPbmx5KHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlcyk7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzMikge1xuICAgICAgICBzZWxmW25hbWVdLnJ1bGVyMi5lbmFibGVPbmx5KHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZVxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIGxpc3Qgb3IgcnVsZXMuIEl0IHdpbGwgYXV0b21hdGljYWxseSBmaW5kIGFwcHJvcHJpYXRlIGNvbXBvbmVudHMsXG4gKiBjb250YWluaW5nIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIHJ1bGUgbm90IGZvdW5kLCBhbmQgYGlnbm9yZUludmFsaWRgXG4gKiBub3Qgc2V0IC0gdGhyb3dzIGV4Y2VwdGlvbi5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAuZW5hYmxlKFsnc3ViJywgJ3N1cCddKVxuICogICAgICAgICAgICAgLmRpc2FibGUoJ3NtYXJ0cXVvdGVzJyk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgWyAnY29yZScsICdibG9jaycsICdpbmxpbmUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXNbY2hhaW5dLnJ1bGVyLmVuYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmVuYWJsZShsaXN0LCB0cnVlKSk7XG5cbiAgdmFyIG1pc3NlZCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDA7IH0pO1xuXG4gIGlmIChtaXNzZWQubGVuZ3RoICYmICFpZ25vcmVJbnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXJrZG93bkl0LiBGYWlsZWQgdG8gZW5hYmxlIHVua25vd24gcnVsZShzKTogJyArIG1pc3NlZCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5kaXNhYmxlKGxpc3QsIGlnbm9yZUludmFsaWQpXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IHJ1bGUgbmFtZSBvciBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZGlzYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbTWFya2Rvd25JdC5lbmFibGVdXSwgYnV0IHR1cm4gc3BlY2lmaWVkIHJ1bGVzIG9mZi5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5kaXNhYmxlKGxpc3QsIHRydWUpKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG5cbiAgdmFyIG1pc3NlZCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDA7IH0pO1xuXG4gIGlmIChtaXNzZWQubGVuZ3RoICYmICFpZ25vcmVJbnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXJrZG93bkl0LiBGYWlsZWQgdG8gZGlzYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LnVzZShwbHVnaW4sIHBhcmFtcylcbiAqXG4gKiBMb2FkIHNwZWNpZmllZCBwbHVnaW4gd2l0aCBnaXZlbiBwYXJhbXMgaW50byBjdXJyZW50IHBhcnNlciBpbnN0YW5jZS5cbiAqIEl0J3MganVzdCBhIHN1Z2FyIHRvIGNhbGwgYHBsdWdpbihtZCwgcGFyYW1zKWAgd2l0aCBjdXJyaW5nLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgaXRlcmF0b3IgPSByZXF1aXJlKCdtYXJrZG93bi1pdC1mb3ItaW5saW5lJyk7XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcbiAqICAgICAgICAgICAgIC51c2UoaXRlcmF0b3IsICdmb29fcmVwbGFjZScsICd0ZXh0JywgZnVuY3Rpb24gKHRva2VucywgaWR4KSB7XG4gKiAgICAgICAgICAgICAgIHRva2Vuc1tpZHhdLmNvbnRlbnQgPSB0b2tlbnNbaWR4XS5jb250ZW50LnJlcGxhY2UoL2Zvby9nLCAnYmFyJyk7XG4gKiAgICAgICAgICAgICB9KTtcbiAqIGBgYFxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKHBsdWdpbiAvKiwgcGFyYW1zLCAuLi4gKi8pIHtcbiAgdmFyIGFyZ3MgPSBbIHRoaXMgXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIHBsdWdpbi5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogUGFyc2UgaW5wdXQgc3RyaW5nIGFuZCByZXR1cm5zIGxpc3Qgb2YgYmxvY2sgdG9rZW5zIChzcGVjaWFsIHRva2VuIHR5cGVcbiAqIFwiaW5saW5lXCIgd2lsbCBjb250YWluIGxpc3Qgb2YgaW5saW5lIHRva2VucykuIFlvdSBzaG91bGQgbm90IGNhbGwgdGhpc1xuICogbWV0aG9kIGRpcmVjdGx5LCB1bnRpbCB5b3Ugd3JpdGUgY3VzdG9tIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgdG8gcHJvZHVjZVxuICogQVNUKS5cbiAqXG4gKiBgZW52YCBpcyB1c2VkIHRvIHBhc3MgZGF0YSBiZXR3ZWVuIFwiZGlzdHJpYnV0ZWRcIiBydWxlcyBhbmQgcmV0dXJuIGFkZGl0aW9uYWxcbiAqIG1ldGFkYXRhIGxpa2UgcmVmZXJlbmNlIGluZm8sIG5lZWRlZCBmb3IgdGhlIHJlbmRlcmVyLiBJdCBhbHNvIGNhbiBiZSB1c2VkIHRvXG4gKiBpbmplY3QgZGF0YSBpbiBzcGVjaWZpYyBjYXNlcy4gVXN1YWxseSwgeW91IHdpbGwgYmUgb2sgdG8gcGFzcyBge31gLFxuICogYW5kIHRoZW4gcGFzcyB1cGRhdGVkIG9iamVjdCB0byByZW5kZXJlci5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBzaG91bGQgYmUgYSBTdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHRoaXMuY29yZS5wcm9jZXNzKHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xufTtcblxuXG4vKipcbiAqIE1hcmtkb3duSXQucmVuZGVyKHNyYyBbLCBlbnZdKSAtPiBTdHJpbmdcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFJlbmRlciBtYXJrZG93biBzdHJpbmcgaW50byBodG1sLiBJdCBkb2VzIGFsbCBtYWdpYyBmb3IgeW91IDopLlxuICpcbiAqIGBlbnZgIGNhbiBiZSB1c2VkIHRvIGluamVjdCBhZGRpdGlvbmFsIG1ldGFkYXRhIChge31gIGJ5IGRlZmF1bHQpLlxuICogQnV0IHlvdSB3aWxsIG5vdCBuZWVkIGl0IHdpdGggaGlnaCBwcm9iYWJpbGl0eS4gU2VlIGFsc28gY29tbWVudFxuICogaW4gW1tNYXJrZG93bkl0LnBhcnNlXV0uXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2VJbmxpbmUoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQucGFyc2VdXSBidXQgc2tpcCBhbGwgYmxvY2sgcnVsZXMuIEl0IHJldHVybnMgdGhlXG4gKiBibG9jayB0b2tlbnMgbGlzdCB3aXRoIHRoZSBzaW5nbGUgYGlubGluZWAgZWxlbWVudCwgY29udGFpbmluZyBwYXJzZWQgaW5saW5lXG4gKiB0b2tlbnMgaW4gYGNoaWxkcmVuYCBwcm9wZXJ0eS4gQWxzbyB1cGRhdGVzIGBlbnZgIG9iamVjdC5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHN0YXRlLmlubGluZU1vZGUgPSB0cnVlO1xuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcklubGluZShzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBTaW1pbGFyIHRvIFtbTWFya2Rvd25JdC5yZW5kZXJdXSBidXQgZm9yIHNpbmdsZSBwYXJhZ3JhcGggY29udGVudC4gUmVzdWx0XG4gKiB3aWxsIE5PVCBiZSB3cmFwcGVkIGludG8gYDxwPmAgdGFncy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBlbnYgPSBlbnYgfHwge307XG5cbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2VJbmxpbmUoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFya2Rvd25JdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9pbmRleC5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VyQmxvY2tcbiAqXG4gKiBCbG9jay1sZXZlbCB0b2tlbml6ZXIuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICAvLyBGaXJzdCAyIHBhcmFtcyAtIHJ1bGUgbmFtZSAmIHNvdXJjZS4gU2Vjb25kYXJ5IGFycmF5IC0gbGlzdCBvZiBydWxlcyxcbiAgLy8gd2hpY2ggY2FuIGJlIHRlcm1pbmF0ZWQgYnkgdGhpcyBvbmUuXG4gIFsgJ3RhYmxlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3RhYmxlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScgXSBdLFxuICBbICdjb2RlJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9jb2RlJykgXSxcbiAgWyAnZmVuY2UnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZmVuY2UnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdibG9ja3F1b3RlJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ibG9ja3F1b3RlJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnbGlzdCcgXSBdLFxuICBbICdocicsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ocicpLCAgICAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2xpc3QnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xpc3QnKSwgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ3JlZmVyZW5jZScsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZScpIF0sXG4gIFsgJ2hlYWRpbmcnLCAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hlYWRpbmcnKSwgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ2xoZWFkaW5nJywgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xoZWFkaW5nJykgXSxcbiAgWyAnaHRtbF9ibG9jaycsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHRtbF9ibG9jaycpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncGFyYWdyYXBoJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcGFyYWdyYXBoJykgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBQYXJzZXJCbG9jaygpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJCbG9jaygpIHtcbiAgLyoqXG4gICAqIFBhcnNlckJsb2NrI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGJsb2NrIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSwgeyBhbHQ6IChfcnVsZXNbaV1bMl0gfHwgW10pLnNsaWNlKCkgfSk7XG4gIH1cbn1cblxuXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXG4vL1xuUGFyc2VyQmxvY2sucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGxpbmUgPSBzdGFydExpbmUsXG4gICAgICBoYXNFbXB0eUxpbmVzID0gZmFsc2UsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChsaW5lIDwgZW5kTGluZSkge1xuICAgIHN0YXRlLmxpbmUgPSBsaW5lID0gc3RhdGUuc2tpcEVtcHR5TGluZXMobGluZSk7XG4gICAgaWYgKGxpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy8gVGVybWluYXRpb24gY29uZGl0aW9uIGZvciBuZXN0ZWQgY2FsbHMuXG4gICAgLy8gTmVzdGVkIGNhbGxzIGN1cnJlbnRseSB1c2VkIGZvciBibG9ja3F1b3RlcyAmIGxpc3RzXG4gICAgaWYgKHN0YXRlLnNDb3VudFtsaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgLy8gSWYgbmVzdGluZyBsZXZlbCBleGNlZWRlZCAtIHNraXAgdGFpbCB0byB0aGUgZW5kLiBUaGF0J3Mgbm90IG9yZGluYXJ5XG4gICAgLy8gc2l0dWF0aW9uIGFuZCB3ZSBzaG91bGQgbm90IGNhcmUgYWJvdXQgY29udGVudC5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPj0gbWF4TmVzdGluZykge1xuICAgICAgc3RhdGUubGluZSA9IGVuZExpbmU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLmxpbmVgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGxpbmUsIGVuZExpbmUsIGZhbHNlKTtcbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIHNldCBzdGF0ZS50aWdodCBpZmYgd2UgaGFkIGFuIGVtcHR5IGxpbmUgYmVmb3JlIGN1cnJlbnQgdGFnXG4gICAgLy8gaS5lLiBsYXRlc3QgZW1wdHkgbGluZSBzaG91bGQgbm90IGNvdW50XG4gICAgc3RhdGUudGlnaHQgPSAhaGFzRW1wdHlMaW5lcztcblxuICAgIC8vIHBhcmFncmFwaCBtaWdodCBcImVhdFwiIG9uZSBuZXdsaW5lIGFmdGVyIGl0IGluIG5lc3RlZCBsaXN0c1xuICAgIGlmIChzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKSkge1xuICAgICAgaGFzRW1wdHlMaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgbGluZSA9IHN0YXRlLmxpbmU7XG5cbiAgICBpZiAobGluZSA8IGVuZExpbmUgJiYgc3RhdGUuaXNFbXB0eShsaW5lKSkge1xuICAgICAgaGFzRW1wdHlMaW5lcyA9IHRydWU7XG4gICAgICBsaW5lKys7XG4gICAgICBzdGF0ZS5saW5lID0gbGluZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXJzZXJCbG9jay5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBibG9jayB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VyQmxvY2sucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXNyYykgeyByZXR1cm47IH1cblxuICBzdGF0ZSA9IG5ldyB0aGlzLlN0YXRlKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKTtcblxuICB0aGlzLnRva2VuaXplKHN0YXRlLCBzdGF0ZS5saW5lLCBzdGF0ZS5saW5lTWF4KTtcbn07XG5cblxuUGFyc2VyQmxvY2sucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jaycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyQmxvY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBDb3JlXG4gKlxuICogVG9wLWxldmVsIHJ1bGVzIGV4ZWN1dG9yLiBHbHVlcyBibG9jay9pbmxpbmUgcGFyc2VycyBhbmQgZG9lcyBpbnRlcm1lZGlhdGVcbiAqIHRyYW5zZm9ybWF0aW9ucy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ25vcm1hbGl6ZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL25vcm1hbGl6ZScpICAgICAgXSxcbiAgWyAnYmxvY2snLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvYmxvY2snKSAgICAgICAgICBdLFxuICBbICdpbmxpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9pbmxpbmUnKSAgICAgICAgIF0sXG4gIFsgJ2xpbmtpZnknLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2xpbmtpZnknKSAgICAgICAgXSxcbiAgWyAncmVwbGFjZW1lbnRzJywgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzJykgICBdLFxuICBbICdzbWFydHF1b3RlcycsICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zbWFydHF1b3RlcycpICAgIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgQ29yZSgpXG4gKiovXG5mdW5jdGlvbiBDb3JlKCkge1xuICAvKipcbiAgICogQ29yZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBjb3JlIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENvcmUucHJvY2VzcyhzdGF0ZSlcbiAqXG4gKiBFeGVjdXRlcyBjb3JlIGNoYWluIHJ1bGVzLlxuICoqL1xuQ29yZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgaSwgbCwgcnVsZXM7XG5cbiAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKTtcblxuICBmb3IgKGkgPSAwLCBsID0gcnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5Db3JlLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zdGF0ZV9jb3JlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJJbmxpbmVcbiAqXG4gKiBUb2tlbml6ZXMgcGFyYWdyYXBoIGNvbnRlbnQuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUGFyc2VyIHJ1bGVzXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ3RleHQnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHQnKSBdLFxuICBbICduZXdsaW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9uZXdsaW5lJykgXSxcbiAgWyAnZXNjYXBlJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZXNjYXBlJykgXSxcbiAgWyAnYmFja3RpY2tzJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFja3RpY2tzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnRva2VuaXplIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykudG9rZW5pemUgXSxcbiAgWyAnbGluaycsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbGluaycpIF0sXG4gIFsgJ2ltYWdlJywgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2ltYWdlJykgXSxcbiAgWyAnYXV0b2xpbmsnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYXV0b2xpbmsnKSBdLFxuICBbICdodG1sX2lubGluZScsICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9odG1sX2lubGluZScpIF0sXG4gIFsgJ2VudGl0eScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VudGl0eScpIF1cbl07XG5cbnZhciBfcnVsZXMyID0gW1xuICBbICdiYWxhbmNlX3BhaXJzJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykucG9zdFByb2Nlc3MgXSxcbiAgWyAndGV4dF9jb2xsYXBzZScsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZScpIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgUGFyc2VySW5saW5lKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlcklubGluZSgpIHtcbiAgdmFyIGk7XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBpbmxpbmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlcjIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBTZWNvbmQgcnVsZXIgdXNlZCBmb3IgcG9zdC1wcm9jZXNzaW5nXG4gICAqIChlLmcuIGluIGVtcGhhc2lzLWxpa2UgcnVsZXMpLlxuICAgKiovXG4gIHRoaXMucnVsZXIyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlczIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyMi5wdXNoKF9ydWxlczJbaV1bMF0sIF9ydWxlczJbaV1bMV0pO1xuICB9XG59XG5cblxuLy8gU2tpcCBzaW5nbGUgdG9rZW4gYnkgcnVubmluZyBhbGwgcnVsZXMgaW4gdmFsaWRhdGlvbiBtb2RlO1xuLy8gcmV0dXJucyBgdHJ1ZWAgaWYgYW55IHJ1bGUgcmVwb3J0ZWQgc3VjY2Vzc1xuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUuc2tpcFRva2VuID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSwgcG9zID0gc3RhdGUucG9zLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3RpbmcsXG4gICAgICBjYWNoZSA9IHN0YXRlLmNhY2hlO1xuXG5cbiAgaWYgKHR5cGVvZiBjYWNoZVtwb3NdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLnBvcyA9IGNhY2hlW3Bvc107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gSW5jcmVtZW50IHN0YXRlLmxldmVsIGFuZCBkZWNyZW1lbnQgaXQgbGF0ZXIgdG8gbGltaXQgcmVjdXJzaW9uLlxuICAgICAgLy8gSXQncyBoYXJtbGVzcyB0byBkbyBoZXJlLCBiZWNhdXNlIG5vIHRva2VucyBhcmUgY3JlYXRlZC4gQnV0IGlkZWFsbHksXG4gICAgICAvLyB3ZSdkIG5lZWQgYSBzZXBhcmF0ZSBwcml2YXRlIHN0YXRlIHZhcmlhYmxlIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAvL1xuICAgICAgc3RhdGUubGV2ZWwrKztcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIHRydWUpO1xuICAgICAgc3RhdGUubGV2ZWwtLTtcblxuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRvbyBtdWNoIG5lc3RpbmcsIGp1c3Qgc2tpcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGguXG4gICAgLy9cbiAgICAvLyBOT1RFOiB0aGlzIHdpbGwgY2F1c2UgbGlua3MgdG8gYmVoYXZlIGluY29ycmVjdGx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZSxcbiAgICAvLyAgICAgICB3aGVuIGFuIGFtb3VudCBvZiBgW2AgaXMgZXhhY3RseSBlcXVhbCB0byBgbWF4TmVzdGluZyArIDFgOlxuICAgIC8vXG4gICAgLy8gICAgICAgW1tbW1tbW1tbW1tbW1tbW1tbW1tbZm9vXSgpXG4gICAgLy9cbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3b3JrYXJvdW5kIHdoZW4gQ00gc3RhbmRhcmQgd2lsbCBhbGxvdyBuZXN0ZWQgbGlua3NcbiAgICAvLyAgICAgICAod2UgY2FuIHJlcGxhY2UgaXQgYnkgcHJldmVudGluZyBsaW5rcyBmcm9tIGJlaW5nIHBhcnNlZCBpblxuICAgIC8vICAgICAgIHZhbGlkYXRpb24gbW9kZSlcbiAgICAvL1xuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heDtcbiAgfVxuXG4gIGlmICghb2spIHsgc3RhdGUucG9zKys7IH1cbiAgY2FjaGVbcG9zXSA9IHN0YXRlLnBvcztcbn07XG5cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGVuZCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IGVuZCkge1xuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUucG9zYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9rKSB7XG4gICAgICBpZiAoc3RhdGUucG9zID49IGVuZCkgeyBicmVhazsgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbc3RhdGUucG9zKytdO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICBzdGF0ZS5wdXNoUGVuZGluZygpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VySW5saW5lLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGlubGluZSB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgaSwgcnVsZXMsIGxlbjtcbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUpO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlcjIuZ2V0UnVsZXMoJycpO1xuICBsZW4gPSBydWxlcy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5cblBhcnNlcklubGluZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcklubGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwiLy8gQ29tbW9ubWFyayBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICB0cnVlLCAgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICB0cnVlLCAgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdibG9ja3F1b3RlJyxcbiAgICAgICAgJ2NvZGUnLFxuICAgICAgICAnZmVuY2UnLFxuICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICdocicsXG4gICAgICAgICdodG1sX2Jsb2NrJyxcbiAgICAgICAgJ2xoZWFkaW5nJyxcbiAgICAgICAgJ2xpc3QnLFxuICAgICAgICAncmVmZXJlbmNlJyxcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYXV0b2xpbmsnLFxuICAgICAgICAnYmFja3RpY2tzJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ2VudGl0eScsXG4gICAgICAgICdlc2NhcGUnLFxuICAgICAgICAnaHRtbF9pbmxpbmUnLFxuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAnbGluaycsXG4gICAgICAgICduZXdsaW5lJyxcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIi8vIG1hcmtkb3duLWl0IGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAxMDAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7fSxcbiAgICBibG9jazoge30sXG4gICAgaW5saW5lOiB7fVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcyIsIi8vIFwiWmVyb1wiIHByZXNldCwgd2l0aCBub3RoaW5nIGVuYWJsZWQuIFVzZWZ1bCBmb3IgbWFudWFsIGNvbmZpZ3VyaW5nIG9mIHNpbXBsZVxuLy8gbW9kZXMuIEZvciBleGFtcGxlLCB0byBwYXJzZSBib2xkL2l0YWxpYyBvbmx5LlxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwiLyoqXG4gKiBjbGFzcyBSZW5kZXJlclxuICpcbiAqIEdlbmVyYXRlcyBIVE1MIGZyb20gcGFyc2VkIHRva2VuIHN0cmVhbS4gRWFjaCBpbnN0YW5jZSBoYXMgaW5kZXBlbmRlbnRcbiAqIGNvcHkgb2YgcnVsZXMuIFRob3NlIGNhbiBiZSByZXdyaXR0ZW4gd2l0aCBlYXNlLiBBbHNvLCB5b3UgY2FuIGFkZCBuZXdcbiAqIHJ1bGVzIGlmIHlvdSBjcmVhdGUgcGx1Z2luIGFuZCBhZGRzIG5ldyB0b2tlbiB0eXBlcy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXNzaWduICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5hc3NpZ247XG52YXIgdW5lc2NhcGVBbGwgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcbnZhciBlc2NhcGVIdG1sICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmVzY2FwZUh0bWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmF1bHRfcnVsZXMgPSB7fTtcblxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz4nICtcbiAgICAgICAgICBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICtcbiAgICAgICAgICAnPC9jb2RlPic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9ibG9jayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgcmV0dXJuICAnPHByZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz48Y29kZT4nICtcbiAgICAgICAgICBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICtcbiAgICAgICAgICAnPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuZmVuY2UgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdLFxuICAgICAgaW5mbyA9IHRva2VuLmluZm8gPyB1bmVzY2FwZUFsbCh0b2tlbi5pbmZvKS50cmltKCkgOiAnJyxcbiAgICAgIGxhbmdOYW1lID0gJycsXG4gICAgICBoaWdobGlnaHRlZCwgaSwgdG1wQXR0cnMsIHRtcFRva2VuO1xuXG4gIGlmIChpbmZvKSB7XG4gICAgbGFuZ05hbWUgPSBpbmZvLnNwbGl0KC9cXHMrL2cpWzBdO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBvcHRpb25zLmhpZ2hsaWdodCh0b2tlbi5jb250ZW50LCBsYW5nTmFtZSkgfHwgZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBoaWdobGlnaHRlZCA9IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XG4gIH1cblxuICBpZiAoaGlnaGxpZ2h0ZWQuaW5kZXhPZignPHByZScpID09PSAwKSB7XG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkICsgJ1xcbic7XG4gIH1cblxuICAvLyBJZiBsYW5ndWFnZSBleGlzdHMsIGluamVjdCBjbGFzcyBnZW50bHksIHdpdGhvdXQgbXVkb2Z5aW5nIG9yaWdpbmFsIHRva2VuLlxuICAvLyBNYXkgYmUsIG9uZSBkYXkgd2Ugd2lsbCBhZGQgLmNsb25lKCkgZm9yIHRva2VuIGFuZCBzaW1wbGlmeSB0aGlzIHBhcnQsIGJ1dFxuICAvLyBub3cgd2UgcHJlZmVyIHRvIGtlZXAgdGhpbmdzIGxvY2FsLlxuICBpZiAoaW5mbykge1xuICAgIGkgICAgICAgID0gdG9rZW4uYXR0ckluZGV4KCdjbGFzcycpO1xuICAgIHRtcEF0dHJzID0gdG9rZW4uYXR0cnMgPyB0b2tlbi5hdHRycy5zbGljZSgpIDogW107XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRtcEF0dHJzLnB1c2goWyAnY2xhc3MnLCBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZSBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wQXR0cnNbaV1bMV0gKz0gJyAnICsgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWU7XG4gICAgfVxuXG4gICAgLy8gRmFrZSB0b2tlbiBqdXN0IHRvIHJlbmRlciBhdHRyaWJ1dGVzXG4gICAgdG1wVG9rZW4gPSB7XG4gICAgICBhdHRyczogdG1wQXR0cnNcbiAgICB9O1xuXG4gICAgcmV0dXJuICAnPHByZT48Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG1wVG9rZW4pICsgJz4nXG4gICAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICB9XG5cblxuICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPidcbiAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5pbWFnZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gXCJhbHRcIiBhdHRyIE1VU1QgYmUgc2V0LCBldmVuIGlmIGVtcHR5LiBCZWNhdXNlIGl0J3MgbWFuZGF0b3J5IGFuZFxuICAvLyBzaG91bGQgYmUgcGxhY2VkIG9uIHByb3BlciBwb3NpdGlvbiBmb3IgdGVzdHMuXG4gIC8vXG4gIC8vIFJlcGxhY2UgY29udGVudCB3aXRoIGFjdHVhbCB2YWx1ZVxuXG4gIHRva2VuLmF0dHJzW3Rva2VuLmF0dHJJbmRleCgnYWx0JyldWzFdID1cbiAgICBzbGYucmVuZGVySW5saW5lQXNUZXh0KHRva2VuLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuXG4gIHJldHVybiBzbGYucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmhhcmRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbic7XG59O1xuZGVmYXVsdF9ydWxlcy5zb2Z0YnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy5icmVha3MgPyAob3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nKSA6ICdcXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLnRleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KTtcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5odG1sX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuZGVmYXVsdF9ydWxlcy5odG1sX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xufTtcblxuXG4vKipcbiAqIG5ldyBSZW5kZXJlcigpXG4gKlxuICogQ3JlYXRlcyBuZXcgW1tSZW5kZXJlcl1dIGluc3RhbmNlIGFuZCBmaWxsIFtbUmVuZGVyZXIjcnVsZXNdXSB3aXRoIGRlZmF1bHRzLlxuICoqL1xuZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcmVyI3J1bGVzIC0+IE9iamVjdFxuICAgKlxuICAgKiBDb250YWlucyByZW5kZXIgcnVsZXMgZm9yIHRva2Vucy4gQ2FuIGJlIHVwZGF0ZWQgYW5kIGV4dGVuZGVkLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfb3BlbiAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPGI+JzsgfTtcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX2Nsb3NlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzwvYj4nOyB9O1xuICAgKlxuICAgKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKC4uLik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBFYWNoIHJ1bGUgaXMgY2FsbGVkIGFzIGluZGVwZW5kZWQgc3RhdGljIGZ1bmN0aW9uIHdpdGggZml4ZWQgc2lnbmF0dXJlOlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGZ1bmN0aW9uIG15X3Rva2VuX3JlbmRlcih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCByZW5kZXJlcikge1xuICAgKiAgIC8vIC4uLlxuICAgKiAgIHJldHVybiByZW5kZXJlZEhUTUw7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXMgPSBhc3NpZ24oe30sIGRlZmF1bHRfcnVsZXMpO1xufVxuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyQXR0cnModG9rZW4pIC0+IFN0cmluZ1xuICpcbiAqIFJlbmRlciB0b2tlbiBhdHRyaWJ1dGVzIHRvIHN0cmluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJBdHRycyA9IGZ1bmN0aW9uIHJlbmRlckF0dHJzKHRva2VuKSB7XG4gIHZhciBpLCBsLCByZXN1bHQ7XG5cbiAgaWYgKCF0b2tlbi5hdHRycykgeyByZXR1cm4gJyc7IH1cblxuICByZXN1bHQgPSAnJztcblxuICBmb3IgKGkgPSAwLCBsID0gdG9rZW4uYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMF0pICsgJz1cIicgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzFdKSArICdcIic7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb2YgdG9rZW5zXG4gKiAtIGlkeCAoTnVtYmVkKTogdG9rZW4gaW5kZXggdG8gcmVuZGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqXG4gKiBEZWZhdWx0IHRva2VuIHJlbmRlcmVyLiBDYW4gYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBmdW5jdGlvblxuICogaW4gW1tSZW5kZXJlciNydWxlc11dLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRva2VuID0gZnVuY3Rpb24gcmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIHtcbiAgdmFyIG5leHRUb2tlbixcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbmVlZExmID0gZmFsc2UsXG4gICAgICB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIC8vIFRpZ2h0IGxpc3QgcGFyYWdyYXBoc1xuICBpZiAodG9rZW4uaGlkZGVuKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gSW5zZXJ0IGEgbmV3bGluZSBiZXR3ZWVuIGhpZGRlbiBwYXJhZ3JhcGggYW5kIHN1YnNlcXVlbnQgb3BlbmluZ1xuICAvLyBibG9jay1sZXZlbCB0YWcuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlLCBoZXJlIHdlIHNob3VsZCBpbnNlcnQgYSBuZXdsaW5lIGJlZm9yZSBibG9ja3F1b3RlOlxuICAvLyAgLSBhXG4gIC8vICAgID5cbiAgLy9cbiAgaWYgKHRva2VuLmJsb2NrICYmIHRva2VuLm5lc3RpbmcgIT09IC0xICYmIGlkeCAmJiB0b2tlbnNbaWR4IC0gMV0uaGlkZGVuKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nO1xuICB9XG5cbiAgLy8gQWRkIHRva2VuIG5hbWUsIGUuZy4gYDxpbWdgXG4gIHJlc3VsdCArPSAodG9rZW4ubmVzdGluZyA9PT0gLTEgPyAnPC8nIDogJzwnKSArIHRva2VuLnRhZztcblxuICAvLyBFbmNvZGUgYXR0cmlidXRlcywgZS5nLiBgPGltZyBzcmM9XCJmb29cImBcbiAgcmVzdWx0ICs9IHRoaXMucmVuZGVyQXR0cnModG9rZW4pO1xuXG4gIC8vIEFkZCBhIHNsYXNoIGZvciBzZWxmLWNsb3NpbmcgdGFncywgZS5nLiBgPGltZyBzcmM9XCJmb29cIiAvYFxuICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMCAmJiBvcHRpb25zLnhodG1sT3V0KSB7XG4gICAgcmVzdWx0ICs9ICcgLyc7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGFkZCBhIG5ld2xpbmUgYWZ0ZXIgdGhpcyB0YWdcbiAgaWYgKHRva2VuLmJsb2NrKSB7XG4gICAgbmVlZExmID0gdHJ1ZTtcblxuICAgIGlmICh0b2tlbi5uZXN0aW5nID09PSAxKSB7XG4gICAgICBpZiAoaWR4ICsgMSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dFRva2VuID0gdG9rZW5zW2lkeCArIDFdO1xuXG4gICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSA9PT0gJ2lubGluZScgfHwgbmV4dFRva2VuLmhpZGRlbikge1xuICAgICAgICAgIC8vIEJsb2NrLWxldmVsIHRhZyBjb250YWluaW5nIGFuIGlubGluZSB0YWcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2UgaWYgKG5leHRUb2tlbi5uZXN0aW5nID09PSAtMSAmJiBuZXh0VG9rZW4udGFnID09PSB0b2tlbi50YWcpIHtcbiAgICAgICAgICAvLyBPcGVuaW5nIHRhZyArIGNsb3NpbmcgdGFnIG9mIHRoZSBzYW1lIHR5cGUuIEUuZy4gYDxsaT48L2xpPmAuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCArPSBuZWVkTGYgPyAnPlxcbicgOiAnPic7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmUodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRoZSBzYW1lIGFzIFtbUmVuZGVyZXIucmVuZGVyXV0sIGJ1dCBmb3Igc2luZ2xlIHRva2VuIG9mIGBpbmxpbmVgIHR5cGUuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHQgKz0gcnVsZXNbdHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogUmVuZGVyZXIucmVuZGVySW5saW5lQXNUZXh0KHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBTcGVjaWFsIGtsdWRnZSBmb3IgaW1hZ2UgYGFsdGAgYXR0cmlidXRlcyB0byBjb25mb3JtIENvbW1vbk1hcmsgc3BlYy5cbiAqIERvbid0IHRyeSB0byB1c2UgaXQhIFNwZWMgcmVxdWlyZXMgdG8gc2hvdyBgYWx0YCBjb250ZW50IHdpdGggc3RyaXBwZWQgbWFya3VwLFxuICogaW5zdGVhZCBvZiBzaW1wbGUgZXNjYXBpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lQXNUZXh0ID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbnNbaV0uY29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUYWtlcyB0b2tlbiBzdHJlYW0gYW5kIGdlbmVyYXRlcyBIVE1MLiBQcm9iYWJseSwgeW91IHdpbGwgbmV2ZXIgbmVlZCB0byBjYWxsXG4gKiB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIGksIGxlbiwgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnaW5saW5lJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lKHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIuanMiLCIvLyBCbG9jayBxdW90ZXNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9ja3F1b3RlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgYWRqdXN0VGFiLFxuICAgICAgY2gsXG4gICAgICBpLFxuICAgICAgaW5pdGlhbCxcbiAgICAgIGlzT3V0ZGVudGVkLFxuICAgICAgbCxcbiAgICAgIGxhc3RMaW5lRW1wdHksXG4gICAgICBsaW5lcyxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgb2xkQk1hcmtzLFxuICAgICAgb2xkQlNDb3VudCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRTQ291bnQsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBzcGFjZUFmdGVyTWFya2VyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBvbGRMaW5lTWF4ID0gc3RhdGUubGluZU1heCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjaGVjayB0aGUgYmxvY2sgcXVvdGUgbWFya2VyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgIT09IDB4M0UvKiA+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIHdlIGtub3cgdGhhdCBpdCdzIGdvaW5nIHRvIGJlIGEgdmFsaWQgYmxvY2txdW90ZSxcbiAgLy8gc28gbm8gcG9pbnQgdHJ5aW5nIHRvIGZpbmQgdGhlIGVuZCBvZiBpdCBpbiBzaWxlbnQgbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0pO1xuXG4gIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgIC8vICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZTpcbiAgICBwb3MrKztcbiAgICBpbml0aWFsKys7XG4gICAgb2Zmc2V0Kys7XG4gICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgIGlmICgoc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgcG9zKys7XG4gICAgICBpbml0aWFsKys7XG4gICAgICBvZmZzZXQrKztcbiAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gIH1cblxuICBvbGRCTWFya3MgPSBbIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdIF07XG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBvbGRCU0NvdW50ID0gWyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgb2xkU0NvdW50ID0gWyBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgb2xkVFNoaWZ0ID0gWyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdibG9ja3F1b3RlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnYmxvY2txdW90ZSc7XG5cbiAgLy8gU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGJsb2NrXG4gIC8vXG4gIC8vIEJsb2NrIGVuZHMgd2l0aCBlaXRoZXI6XG4gIC8vICAxLiBhbiBlbXB0eSBsaW5lIG91dHNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvL1xuICAvLyAgICAgYGBgXG4gIC8vICAyLiBhbiBlbXB0eSBsaW5lIGluc2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPlxuICAvLyAgICAgdGVzdFxuICAvLyAgICAgYGBgXG4gIC8vICAzLiBhbm90aGVyIHRhZzpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vICAgICAgLSAtIC1cbiAgLy8gICAgIGBgYFxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gY2hlY2sgaWYgaXQncyBvdXRkZW50ZWQsIGkuZS4gaXQncyBpbnNpZGUgbGlzdCBpdGVtIGFuZCBpbmRlbnRlZFxuICAgIC8vIGxlc3MgdGhhbiBzYWlkIGxpc3QgaXRlbTpcbiAgICAvL1xuICAgIC8vIGBgYFxuICAgIC8vIDEuIGFueXRoaW5nXG4gICAgLy8gICAgPiBjdXJyZW50IGJsb2NrcXVvdGVcbiAgICAvLyAyLiBjaGVja2luZyB0aGlzIGxpbmVcbiAgICAvLyBgYGBcbiAgICBpc091dGRlbnRlZCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQ7XG5cbiAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgIC8vIENhc2UgMTogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhpcyBsaW5lIGlzIGVtcHR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSA9PT0gMHgzRS8qID4gKi8gJiYgIWlzT3V0ZGVudGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmUgaXMgaW5zaWRlIHRoZSBibG9ja3F1b3RlLlxuXG4gICAgICAvLyBza2lwIHNwYWNlcyBhZnRlciBcIj5cIiBhbmQgcmUtY2FsY3VsYXRlIG9mZnNldFxuICAgICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyBwb3MgLSAoc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuXG4gICAgICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgICAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgICAgIHBvcysrO1xuICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgICAgIGlmICgoc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gPSBwb3M7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENhc2UgMjogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhlIGxhc3QgbGluZSB3YXMgZW1wdHkuXG4gICAgaWYgKGxhc3RMaW5lRW1wdHkpIHsgYnJlYWs7IH1cblxuICAgIC8vIENhc2UgMzogYW5vdGhlciB0YWcgZm91bmQuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAvLyBRdWlyayB0byBlbmZvcmNlIFwiaGFyZCB0ZXJtaW5hdGlvbiBtb2RlXCIgZm9yIHBhcmFncmFwaHM7XG4gICAgICAvLyBub3JtYWxseSBpZiB5b3UgY2FsbCBgdG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpYCxcbiAgICAgIC8vIHBhcmFncmFwaHMgd2lsbCBsb29rIGJlbG93IG5leHRMaW5lIGZvciBwYXJhZ3JhcGggY29udGludWF0aW9uLFxuICAgICAgLy8gYnV0IGlmIGJsb2NrcXVvdGUgaXMgdGVybWluYXRlZCBieSBhbm90aGVyIHRhZywgdGhleSBzaG91bGRuJ3RcbiAgICAgIHN0YXRlLmxpbmVNYXggPSBuZXh0TGluZTtcblxuICAgICAgaWYgKHN0YXRlLmJsa0luZGVudCAhPT0gMCkge1xuICAgICAgICAvLyBzdGF0ZS5ibGtJbmRlbnQgd2FzIG5vbi16ZXJvLCB3ZSBub3cgc2V0IGl0IHRvIHplcm8sXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGFsbCBvZmZzZXRzIHRvIGFwcGVhciBhc1xuICAgICAgICAvLyBpZiBpbmRlbnQgd2Fzbid0IGNoYW5nZWRcbiAgICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpc091dGRlbnRlZCkgYnJlYWs7XG5cbiAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuXG4gICAgLy8gQSBuZWdhdGl2ZSBpbmRlbnRhdGlvbiBtZWFucyB0aGF0IHRoaXMgaXMgYSBwYXJhZ3JhcGggY29udGludWF0aW9uXG4gICAgLy9cbiAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gLTE7XG4gIH1cblxuICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gIHN0YXRlLmJsa0luZGVudCA9IDA7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9vcGVuJywgJ2Jsb2NrcXVvdGUnLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xuICB0b2tlbi5tYXAgICAgPSBsaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfY2xvc2UnLCAnYmxvY2txdW90ZScsIC0xKTtcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xuXG4gIHN0YXRlLmxpbmVNYXggPSBvbGRMaW5lTWF4O1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgbGluZXNbMV0gPSBzdGF0ZS5saW5lO1xuXG4gIC8vIFJlc3RvcmUgb3JpZ2luYWwgdFNoaWZ0OyB0aGlzIG1pZ2h0IG5vdCBiZSBuZWNlc3Nhcnkgc2luY2UgdGhlIHBhcnNlclxuICAvLyBoYXMgYWxyZWFkeSBiZWVuIGhlcmUsIGJ1dCBqdXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gZG8gdGhhdC5cbiAgZm9yIChpID0gMDsgaSA8IG9sZFRTaGlmdC5sZW5ndGg7IGkrKykge1xuICAgIHN0YXRlLmJNYXJrc1tpICsgc3RhcnRMaW5lXSA9IG9sZEJNYXJrc1tpXTtcbiAgICBzdGF0ZS50U2hpZnRbaSArIHN0YXJ0TGluZV0gPSBvbGRUU2hpZnRbaV07XG4gICAgc3RhdGUuc0NvdW50W2kgKyBzdGFydExpbmVdID0gb2xkU0NvdW50W2ldO1xuICAgIHN0YXRlLmJzQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRCU0NvdW50W2ldO1xuICB9XG4gIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIi8vIENvZGUgYmxvY2sgKDQgc3BhY2VzIHBhZGRlZClcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29kZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBuZXh0TGluZSwgbGFzdCwgdG9rZW47XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50IDwgNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYXN0ID0gbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgbGFzdCA9IG5leHRMaW5lO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IGxhc3Q7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfYmxvY2snLCAnY29kZScsIDApO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBsYXN0LCA0ICsgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2NvZGUuanMiLCIvLyBmZW5jZXMgKGBgYCBsYW5nLCB+fn4gbGFuZylcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGxlbiwgcGFyYW1zLCBuZXh0TGluZSwgbWVtLCB0b2tlbiwgbWFya3VwLFxuICAgICAgaGF2ZUVuZE1hcmtlciA9IGZhbHNlLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAzID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8gJiYgbWFya2VyICE9PSAweDYwIC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBzY2FuIG1hcmtlciBsZW5ndGhcbiAgbWVtID0gcG9zO1xuICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gIGxlbiA9IHBvcyAtIG1lbTtcblxuICBpZiAobGVuIDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrdXAgPSBzdGF0ZS5zcmMuc2xpY2UobWVtLCBwb3MpO1xuICBwYXJhbXMgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGlmIChwYXJhbXMuaW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpID49IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2luY2Ugc3RhcnQgaXMgZm91bmQsIHdlIGNhbiByZXBvcnQgc3VjY2VzcyBoZXJlIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2VhcmNoIGVuZCBvZiBibG9ja1xuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcblxuICBmb3IgKDs7KSB7XG4gICAgbmV4dExpbmUrKztcbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkge1xuICAgICAgLy8gdW5jbG9zZWQgYmxvY2sgc2hvdWxkIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIGRvY3VtZW50LlxuICAgICAgLy8gYWxzbyBibG9jayBzZWVtcyB0byBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBwYXJlbnRcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcyA9IG1lbSA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIC8vIG5vbi1lbXB0eSBsaW5lIHdpdGggbmVnYXRpdmUgaW5kZW50IHNob3VsZCBzdG9wIHRoZSBsaXN0OlxuICAgICAgLy8gLSBgYGBcbiAgICAgIC8vICB0ZXN0XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gbWFya2VyKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAvLyBjbG9zaW5nIGZlbmNlIHNob3VsZCBiZSBpbmRlbnRlZCBsZXNzIHRoYW4gNCBzcGFjZXNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgICAvLyBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIG9uZVxuICAgIGlmIChwb3MgLSBtZW0gPCBsZW4pIHsgY29udGludWU7IH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0YWlsIGhhcyBzcGFjZXMgb25seVxuICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgIGlmIChwb3MgPCBtYXgpIHsgY29udGludWU7IH1cblxuICAgIGhhdmVFbmRNYXJrZXIgPSB0cnVlO1xuICAgIC8vIGZvdW5kIVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gSWYgYSBmZW5jZSBoYXMgaGVhZGluZyBzcGFjZXMsIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBpdHMgaW5uZXIgYmxvY2tcbiAgbGVuID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgKGhhdmVFbmRNYXJrZXIgPyAxIDogMCk7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2ZlbmNlJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uaW5mbyAgICA9IHBhcmFtcztcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSArIDEsIG5leHRMaW5lLCBsZW4sIHRydWUpO1xuICB0b2tlbi5tYXJrdXAgID0gbWFya3VwO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UuanMiLCIvLyBoZWFkaW5nICgjLCAjIywgLi4uKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGV2ZWwsIHRtcCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4MjMvKiAjICovIHx8IHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY291bnQgaGVhZGluZyBsZXZlbFxuICBsZXZlbCA9IDE7XG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB3aGlsZSAoY2ggPT09IDB4MjMvKiAjICovICYmIHBvcyA8IG1heCAmJiBsZXZlbCA8PSA2KSB7XG4gICAgbGV2ZWwrKztcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgfVxuXG4gIGlmIChsZXZlbCA+IDYgfHwgKHBvcyA8IG1heCAmJiAhaXNTcGFjZShjaCkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBMZXQncyBjdXQgdGFpbHMgbGlrZSAnICAgICMjIyAgJyBmcm9tIHRoZSBlbmQgb2Ygc3RyaW5nXG5cbiAgbWF4ID0gc3RhdGUuc2tpcFNwYWNlc0JhY2sobWF4LCBwb3MpO1xuICB0bXAgPSBzdGF0ZS5za2lwQ2hhcnNCYWNrKG1heCwgMHgyMywgcG9zKTsgLy8gI1xuICBpZiAodG1wID4gcG9zICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQodG1wIC0gMSkpKSB7XG4gICAgbWF4ID0gdG1wO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCkudHJpbSgpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCIvLyBIb3Jpem9udGFsIHJ1bGVcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBocihzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG1hcmtlciwgY250LCBjaCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIC8vIENoZWNrIGhyIG1hcmtlclxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDVGLyogXyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG1hcmtlcnMgY2FuIGJlIG1peGVkIHdpdGggc3BhY2VzLCBidXQgdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IDMgb2YgdGhlbVxuXG4gIGNudCA9IDE7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICBpZiAoY2ggIT09IG1hcmtlciAmJiAhaXNTcGFjZShjaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKGNoID09PSBtYXJrZXIpIHsgY250Kys7IH1cbiAgfVxuXG4gIGlmIChjbnQgPCAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdocicsICdocicsIDApO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5tYXJrdXAgPSBBcnJheShjbnQgKyAxKS5qb2luKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwiLy8gSFRNTCBibG9ja1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGJsb2NrX25hbWVzID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfYmxvY2tzJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcblxuLy8gQW4gYXJyYXkgb2Ygb3BlbmluZyBhbmQgY29ycmVzcG9uZGluZyBjbG9zaW5nIHNlcXVlbmNlcyBmb3IgaHRtbCB0YWdzLFxuLy8gbGFzdCBhcmd1bWVudCBkZWZpbmVzIHdoZXRoZXIgaXQgY2FuIHRlcm1pbmF0ZSBhIHBhcmFncmFwaCBvciBub3Rcbi8vXG52YXIgSFRNTF9TRVFVRU5DRVMgPSBbXG4gIFsgL148KHNjcmlwdHxwcmV8c3R5bGUpKD89KFxcc3w+fCQpKS9pLCAvPFxcLyhzY3JpcHR8cHJlfHN0eWxlKT4vaSwgdHJ1ZSBdLFxuICBbIC9ePCEtLS8sICAgICAgICAvLS0+LywgICB0cnVlIF0sXG4gIFsgL148XFw/LywgICAgICAgICAvXFw/Pi8sICAgdHJ1ZSBdLFxuICBbIC9ePCFbQS1aXS8sICAgICAvPi8sICAgICB0cnVlIF0sXG4gIFsgL148IVxcW0NEQVRBXFxbLywgL1xcXVxcXT4vLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cCgnXjwvPygnICsgYmxvY2tfbmFtZXMuam9pbignfCcpICsgJykoPz0oXFxcXHN8Lz8+fCQpKScsICdpJyksIC9eJC8sIHRydWUgXSxcbiAgWyBuZXcgUmVnRXhwKEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUuc291cmNlICsgJ1xcXFxzKiQnKSwgIC9eJC8sIGZhbHNlIF1cbl07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2Jsb2NrKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgaSwgbmV4dExpbmUsIHRva2VuLCBsaW5lVGV4dCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGluZVRleHQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBIVE1MX1NFUVVFTkNFUy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVswXS50ZXN0KGxpbmVUZXh0KSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKGkgPT09IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7XG4gICAgLy8gdHJ1ZSBpZiB0aGlzIHNlcXVlbmNlIGNhbiBiZSBhIHRlcm1pbmF0b3IsIGZhbHNlIG90aGVyd2lzZVxuICAgIHJldHVybiBIVE1MX1NFUVVFTkNFU1tpXVsyXTtcbiAgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBJZiB3ZSBhcmUgaGVyZSAtIHdlIGRldGVjdGVkIEhUTUwgYmxvY2suXG4gIC8vIExldCdzIHJvbGwgZG93biB0aWxsIGJsb2NrIGVuZC5cbiAgaWYgKCFIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgIGlmIChsaW5lVGV4dC5sZW5ndGggIT09IDApIHsgbmV4dExpbmUrKzsgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfYmxvY2snLCAnJywgMCk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgbmV4dExpbmUgXTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2suanMiLCIvLyBsaGVhZGluZyAoLS0tLCA9PT0pXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIHBvcywgbWF4LCBsZXZlbCwgbWFya2VyLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3BhcmFncmFwaCc7IC8vIHVzZSBwYXJhZ3JhcGggdG8gbWF0Y2ggdGVybWluYXRvclJ1bGVzXG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vXG4gICAgLy8gQ2hlY2sgZm9yIHVuZGVybGluZSBpbiBzZXRleHQgaGVhZGVyXG4gICAgLy9cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA+PSBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgICAgaWYgKHBvcyA8IG1heCkge1xuICAgICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4MkQvKiAtICovIHx8IG1hcmtlciA9PT0gMHgzRC8qID0gKi8pIHtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgICAgICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAgICAgICBsZXZlbCA9IChtYXJrZXIgPT09IDB4M0QvKiA9ICovID8gMSA6IDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKCFsZXZlbCkge1xuICAgIC8vIERpZG4ndCBmaW5kIHZhbGlkIHVuZGVybGluZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpO1xuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgLSAxIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCIvLyBMaXN0c1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG4vLyBTZWFyY2ggYFstKypdW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhcnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIG1hcmtlciwgcG9zLCBtYXgsIGNoO1xuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgLy8gQ2hlY2sgYnVsbGV0XG4gIGlmIChtYXJrZXIgIT09IDB4MkEvKiAqICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkQvKiAtICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkIvKiArICovKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgIC8vIFwiIC10ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvcztcbn1cblxuLy8gU2VhcmNoIGBcXGQrWy4pXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYXJ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICB2YXIgY2gsXG4gICAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBwb3MgPSBzdGFydCxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIExpc3QgbWFya2VyIHNob3VsZCBoYXZlIGF0IGxlYXN0IDIgY2hhcnMgKGRpZ2l0ICsgZG90KVxuICBpZiAocG9zICsgMSA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgaWYgKGNoIDwgMHgzMC8qIDAgKi8gfHwgY2ggPiAweDM5LyogOSAqLykgeyByZXR1cm4gLTE7IH1cblxuICBmb3IgKDs7KSB7XG4gICAgLy8gRU9MIC0+IGZhaWxcbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gICAgaWYgKGNoID49IDB4MzAvKiAwICovICYmIGNoIDw9IDB4MzkvKiA5ICovKSB7XG5cbiAgICAgIC8vIExpc3QgbWFya2VyIHNob3VsZCBoYXZlIG5vIG1vcmUgdGhhbiA5IGRpZ2l0c1xuICAgICAgLy8gKHByZXZlbnRzIGludGVnZXIgb3ZlcmZsb3cgaW4gYnJvd3NlcnMpXG4gICAgICBpZiAocG9zIC0gc3RhcnQgPj0gMTApIHsgcmV0dXJuIC0xOyB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZvdW5kIHZhbGlkIG1hcmtlclxuICAgIGlmIChjaCA9PT0gMHgyOS8qICkgKi8gfHwgY2ggPT09IDB4MmUvKiAuICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAxLnRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn1cblxuZnVuY3Rpb24gbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgaWR4KSB7XG4gIHZhciBpLCBsLFxuICAgICAgbGV2ZWwgPSBzdGF0ZS5sZXZlbCArIDI7XG5cbiAgZm9yIChpID0gaWR4ICsgMiwgbCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHN0YXRlLnRva2Vuc1tpXS5sZXZlbCA9PT0gbGV2ZWwgJiYgc3RhdGUudG9rZW5zW2ldLnR5cGUgPT09ICdwYXJhZ3JhcGhfb3BlbicpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tpICsgMl0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnRva2Vuc1tpXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgaSArPSAyO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgY29udGVudFN0YXJ0LFxuICAgICAgaSxcbiAgICAgIGluZGVudCxcbiAgICAgIGluZGVudEFmdGVyTWFya2VyLFxuICAgICAgaW5pdGlhbCxcbiAgICAgIGlzT3JkZXJlZCxcbiAgICAgIGl0ZW1MaW5lcyxcbiAgICAgIGwsXG4gICAgICBsaXN0TGluZXMsXG4gICAgICBsaXN0VG9rSWR4LFxuICAgICAgbWFya2VyQ2hhckNvZGUsXG4gICAgICBtYXJrZXJWYWx1ZSxcbiAgICAgIG1heCxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkTEluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBvbGRUaWdodCxcbiAgICAgIHBvcyxcbiAgICAgIHBvc0FmdGVyTWFya2VyLFxuICAgICAgcHJldkVtcHR5RW5kLFxuICAgICAgc3RhcnQsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0b2tlbixcbiAgICAgIGlzVGVybWluYXRpbmdQYXJhZ3JhcGggPSBmYWxzZSxcbiAgICAgIHRpZ2h0ID0gdHJ1ZTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBsaW1pdCBjb25kaXRpb25zIHdoZW4gbGlzdCBjYW4gaW50ZXJydXB0XG4gIC8vIGEgcGFyYWdyYXBoICh2YWxpZGF0aW9uIG1vZGUgb25seSlcbiAgaWYgKHNpbGVudCAmJiBzdGF0ZS5wYXJlbnRUeXBlID09PSAncGFyYWdyYXBoJykge1xuICAgIC8vIE5leHQgbGlzdCBpdGVtIHNob3VsZCBzdGlsbCB0ZXJtaW5hdGUgcHJldmlvdXMgbGlzdCBpdGVtO1xuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGNhbiBmYWlsIGlmIHBsdWdpbnMgdXNlIGJsa0luZGVudCBhcyB3ZWxsIGFzIGxpc3RzLFxuICAgIC8vIGJ1dCBJIGhvcGUgdGhlIHNwZWMgZ2V0cyBmaXhlZCBsb25nIGJlZm9yZSB0aGF0IGhhcHBlbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBEZXRlY3QgbGlzdCB0eXBlIGFuZCBwb3NpdGlvbiBhZnRlciBtYXJrZXJcbiAgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSkgPj0gMCkge1xuICAgIGlzT3JkZXJlZCA9IHRydWU7XG4gICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG1hcmtlclZhbHVlID0gTnVtYmVyKHN0YXRlLnNyYy5zdWJzdHIoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gc3RhcnQgLSAxKSk7XG5cbiAgICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyBvcmRlcmVkIGxpc3QgcmlnaHQgYWZ0ZXJcbiAgICAvLyBhIHBhcmFncmFwaCwgaXQgc2hvdWxkIHN0YXJ0IHdpdGggMS5cbiAgICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCAmJiBtYXJrZXJWYWx1ZSAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gIH0gZWxzZSBpZiAoKHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSBmYWxzZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIHN0YXJ0aW5nIGEgbmV3IHVub3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gIC8vIGEgcGFyYWdyYXBoLCBmaXJzdCBsaW5lIHNob3VsZCBub3QgYmUgZW1wdHkuXG4gIGlmIChpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoKSB7XG4gICAgaWYgKHN0YXRlLnNraXBTcGFjZXMocG9zQWZ0ZXJNYXJrZXIpID49IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBXZSBzaG91bGQgdGVybWluYXRlIGxpc3Qgb24gc3R5bGUgY2hhbmdlLiBSZW1lbWJlciBmaXJzdCBvbmUgdG8gY29tcGFyZS5cbiAgbWFya2VyQ2hhckNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpO1xuXG4gIC8vIEZvciB2YWxpZGF0aW9uIG1vZGUgd2UgY2FuIHRlcm1pbmF0ZSBpbW1lZGlhdGVseVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gU3RhcnQgbGlzdFxuICBsaXN0VG9rSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgdG9rZW4gICAgICAgPSBzdGF0ZS5wdXNoKCdvcmRlcmVkX2xpc3Rfb3BlbicsICdvbCcsIDEpO1xuICAgIGlmIChtYXJrZXJWYWx1ZSAhPT0gMSkge1xuICAgICAgdG9rZW4uYXR0cnMgPSBbIFsgJ3N0YXJ0JywgbWFya2VyVmFsdWUgXSBdO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3Rfb3BlbicsICd1bCcsIDEpO1xuICB9XG5cbiAgdG9rZW4ubWFwICAgID0gbGlzdExpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcbiAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgLy9cbiAgLy8gSXRlcmF0ZSBsaXN0IGl0ZW1zXG4gIC8vXG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmU7XG4gIHByZXZFbXB0eUVuZCA9IGZhbHNlO1xuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnbGlzdCcpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2xpc3QnO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBwb3MgPSBwb3NBZnRlck1hcmtlcjtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyBwb3NBZnRlck1hcmtlciAtIChzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdKTtcblxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKSAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBjb250ZW50U3RhcnQgPSBwb3M7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCkge1xuICAgICAgLy8gdHJpbW1pbmcgc3BhY2UgaW4gXCItICAgIFxcbiAgM1wiIGNhc2UsIGluZGVudCBpcyAxIGhlcmVcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBcIiAgLSAgdGVzdFwiXG4gICAgLy8gIF5eXl5eIC0gY2FsY3VsYXRpbmcgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdGhpbmdcbiAgICBpbmRlbnQgPSBpbml0aWFsICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG5cbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX29wZW4nLCAnbGknLCAxKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gICAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XG4gICAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgb2xkTEluZGVudCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuICAgIHN0YXRlLmJsa0luZGVudCA9IGluZGVudDtcbiAgICBzdGF0ZS50aWdodCA9IHRydWU7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBjb250ZW50U3RhcnQgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldDtcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4ICYmIHN0YXRlLmlzRW1wdHkoc3RhcnRMaW5lICsgMSkpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIHRoaXMgY2FzZVxuICAgICAgLy8gKGxpc3QgaXRlbSBpcyBlbXB0eSwgbGlzdCB0ZXJtaW5hdGVzIGJlZm9yZSBcImZvb1wiKTpcbiAgICAgIC8vIH5+fn5+fn5+XG4gICAgICAvLyAgIC1cbiAgICAgIC8vXG4gICAgICAvLyAgICAgZm9vXG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgc3RhdGUubGluZSA9IE1hdGgubWluKHN0YXRlLmxpbmUgKyAyLCBlbmRMaW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG9mIGxpc3QgaXRlbSBpcyB0aWdodCwgbWFyayBsaXN0IGFzIHRpZ2h0XG4gICAgaWYgKCFzdGF0ZS50aWdodCB8fCBwcmV2RW1wdHlFbmQpIHtcbiAgICAgIHRpZ2h0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEl0ZW0gYmVjb21lIGxvb3NlIGlmIGZpbmlzaCB3aXRoIGVtcHR5IGxpbmUsXG4gICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgcHJldkVtcHR5RW5kID0gKHN0YXRlLmxpbmUgLSBzdGFydExpbmUpID4gMSAmJiBzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKTtcblxuICAgIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IG9sZFRTaGlmdDtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9sZExJbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSBvbGRUaWdodDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9jbG9zZScsICdsaScsIC0xKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICAgIG5leHRMaW5lID0gc3RhcnRMaW5lID0gc3RhdGUubGluZTtcbiAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvL1xuICAgIC8vIFRyeSB0byBjaGVjayBpZiBsaXN0IGlzIHRlcm1pbmF0ZWQgb3IgY29udGludWVkLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIC8vIGZhaWwgaWYgdGVybWluYXRpbmcgYmxvY2sgZm91bmRcbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIGxpc3QgaGFzIGFub3RoZXIgdHlwZVxuICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAobWFya2VyQ2hhckNvZGUgIT09IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIC8vIEZpbmlsaXplIGxpc3RcbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X2Nsb3NlJywgJ29sJywgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3RfY2xvc2UnLCAndWwnLCAtMSk7XG4gIH1cbiAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgbGlzdExpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICAvLyBtYXJrIHBhcmFncmFwaHMgdGlnaHQgaWYgbmVlZGVkXG4gIGlmICh0aWdodCkge1xuICAgIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGxpc3RUb2tJZHgpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xpc3QuanMiLCIvLyBQYXJhZ3JhcGhcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyYWdyYXBoKHN0YXRlLCBzdGFydExpbmUvKiwgZW5kTGluZSovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpLFxuICAgICAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJztcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfb3BlbicsICdwJywgMSk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfY2xvc2UnLCAncCcsIC0xKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWZlcmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgX2VuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBkZXN0RW5kUG9zLFxuICAgICAgZGVzdEVuZExpbmVObyxcbiAgICAgIGVuZExpbmUsXG4gICAgICBocmVmLFxuICAgICAgaSxcbiAgICAgIGwsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIHJlcyxcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdGl0bGUsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0sXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbXBsZSBjaGVjayB0byBxdWlja2x5IGludGVycnVwdCBzY2FuIG9uIFtsaW5rXSh1cmwpIGF0IHRoZSBzdGFydCBvZiBsaW5lLlxuICAvLyBDYW4gYmUgdXNlZnVsIG9uIHByYWN0aWNlOiBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvaXNzdWVzLzU0XG4gIHdoaWxlICgrK3BvcyA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVEIC8qIF0gKi8gJiZcbiAgICAgICAgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zIC0gMSkgIT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgaWYgKHBvcyArIDEgPT09IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdyZWZlcmVuY2UnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdyZWZlcmVuY2UnO1xuXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgc3RyID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuICBtYXggPSBzdHIubGVuZ3RoO1xuXG4gIGZvciAocG9zID0gMTsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGFiZWxFbmQgPSBwb3M7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDBBIC8qIFxcbiAqLykge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDIC8qIFxcICovKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsYWJlbEVuZCA8IDAgfHwgc3RyLmNoYXJDb2RlQXQobGFiZWxFbmQgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICBeXl4gc2tpcCBvcHRpb25hbCB3aGl0ZXNwYWNlIGhlcmVcbiAgZm9yIChwb3MgPSBsYWJlbEVuZCArIDI7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgIF5eXl5eXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KTtcbiAgaWYgKCFyZXMub2spIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHJlcy5wb3M7XG4gIGxpbmVzICs9IHJlcy5saW5lcztcblxuICAvLyBzYXZlIGN1cnNvciBzdGF0ZSwgd2UgY291bGQgcmVxdWlyZSB0byByb2xsYmFjayBsYXRlclxuICBkZXN0RW5kUG9zID0gcG9zO1xuICBkZXN0RW5kTGluZU5vID0gbGluZXM7XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIF5eXiBza2lwcGluZyB0aG9zZSBzcGFjZXNcbiAgc3RhcnQgPSBwb3M7XG4gIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgdGl0bGUgPSByZXMuc3RyO1xuICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgbGluZXMgKz0gcmVzLmxpbmVzO1xuICB9IGVsc2Uge1xuICAgIHRpdGxlID0gJyc7XG4gICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gIH1cblxuICAvLyBza2lwIHRyYWlsaW5nIHNwYWNlcyB1bnRpbCB0aGUgcmVzdCBvZiB0aGUgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIGFmdGVyIHRpdGxlLFxuICAgICAgLy8gYnV0IGl0IGNvdWxkIHN0aWxsIGJlIGEgdmFsaWQgcmVmZXJlbmNlIGlmIHdlIHJvbGwgYmFja1xuICAgICAgdGl0bGUgPSAnJztcbiAgICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIuc2xpY2UoMSwgbGFiZWxFbmQpKTtcbiAgaWYgKCFsYWJlbCkge1xuICAgIC8vIENvbW1vbk1hcmsgMC4yMCBkaXNhbGxvd3MgZW1wdHkgbGFiZWxzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUmVmZXJlbmNlIGNhbiBub3QgdGVybWluYXRlIGFueXRoaW5nLiBUaGlzIGNoZWNrIGlzIGZvciBzYWZldHkgb25seS5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgaWYqL1xuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9IHsgdGl0bGU6IHRpdGxlLCBocmVmOiBocmVmIH07XG4gIH1cblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgbGluZXMgKyAxO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzIiwiLy8gUGFyc2VyIHN0YXRlIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBTdGF0ZUJsb2NrKHNyYywgbWQsIGVudiwgdG9rZW5zKSB7XG4gIHZhciBjaCwgcywgc3RhcnQsIHBvcywgbGVuLCBpbmRlbnQsIG9mZnNldCwgaW5kZW50X2ZvdW5kO1xuXG4gIHRoaXMuc3JjID0gc3JjO1xuXG4gIC8vIGxpbmsgdG8gcGFyc2VyIGluc3RhbmNlXG4gIHRoaXMubWQgICAgID0gbWQ7XG5cbiAgdGhpcy5lbnYgPSBlbnY7XG5cbiAgLy9cbiAgLy8gSW50ZXJuYWwgc3RhdGUgdmFydGlhYmxlc1xuICAvL1xuXG4gIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuXG4gIHRoaXMuYk1hcmtzID0gW107ICAvLyBsaW5lIGJlZ2luIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy5lTWFya3MgPSBbXTsgIC8vIGxpbmUgZW5kIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy50U2hpZnQgPSBbXTsgIC8vIG9mZnNldHMgb2YgdGhlIGZpcnN0IG5vbi1zcGFjZSBjaGFyYWN0ZXJzICh0YWJzIG5vdCBleHBhbmRlZClcbiAgdGhpcy5zQ291bnQgPSBbXTsgIC8vIGluZGVudHMgZm9yIGVhY2ggbGluZSAodGFicyBleHBhbmRlZClcblxuICAvLyBBbiBhbW91bnQgb2YgdmlydHVhbCBzcGFjZXMgKHRhYnMgZXhwYW5kZWQpIGJldHdlZW4gYmVnaW5uaW5nXG4gIC8vIG9mIGVhY2ggbGluZSAoYk1hcmtzKSBhbmQgcmVhbCBiZWdpbm5pbmcgb2YgdGhhdCBsaW5lLlxuICAvL1xuICAvLyBJdCBleGlzdHMgb25seSBhcyBhIGhhY2sgYmVjYXVzZSBibG9ja3F1b3RlcyBvdmVycmlkZSBiTWFya3NcbiAgLy8gbG9zaW5nIGluZm9ybWF0aW9uIGluIHRoZSBwcm9jZXNzLlxuICAvL1xuICAvLyBJdCdzIHVzZWQgb25seSB3aGVuIGV4cGFuZGluZyB0YWJzLCB5b3UgY2FuIHRoaW5rIGFib3V0IGl0IGFzXG4gIC8vIGFuIGluaXRpYWwgdGFiIGxlbmd0aCwgZS5nLiBic0NvdW50PTIxIGFwcGxpZWQgdG8gc3RyaW5nIGBcXHQxMjNgXG4gIC8vIG1lYW5zIGZpcnN0IHRhYiBzaG91bGQgYmUgZXhwYW5kZWQgdG8gNC0yMSU0ID09PSAzIHNwYWNlcy5cbiAgLy9cbiAgdGhpcy5ic0NvdW50ID0gW107XG5cbiAgLy8gYmxvY2sgcGFyc2VyIHZhcmlhYmxlc1xuICB0aGlzLmJsa0luZGVudCAgPSAwOyAvLyByZXF1aXJlZCBibG9jayBjb250ZW50IGluZGVudFxuICAgICAgICAgICAgICAgICAgICAgICAvLyAoZm9yIGV4YW1wbGUsIGlmIHdlIGFyZSBpbiBsaXN0KVxuICB0aGlzLmxpbmUgICAgICAgPSAwOyAvLyBsaW5lIGluZGV4IGluIHNyY1xuICB0aGlzLmxpbmVNYXggICAgPSAwOyAvLyBsaW5lcyBjb3VudFxuICB0aGlzLnRpZ2h0ICAgICAgPSBmYWxzZTsgIC8vIGxvb3NlL3RpZ2h0IG1vZGUgZm9yIGxpc3RzXG4gIHRoaXMuZGRJbmRlbnQgICA9IC0xOyAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgZGQgYmxvY2sgKC0xIGlmIHRoZXJlIGlzbid0IGFueSlcblxuICAvLyBjYW4gYmUgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdyb290JywgJ3BhcmFncmFwaCcgb3IgJ3JlZmVyZW5jZSdcbiAgLy8gdXNlZCBpbiBsaXN0cyB0byBkZXRlcm1pbmUgaWYgdGhleSBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGhcbiAgdGhpcy5wYXJlbnRUeXBlID0gJ3Jvb3QnO1xuXG4gIHRoaXMubGV2ZWwgPSAwO1xuXG4gIC8vIHJlbmRlcmVyXG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgLy8gQ3JlYXRlIGNhY2hlc1xuICAvLyBHZW5lcmF0ZSBtYXJrZXJzLlxuICBzID0gdGhpcy5zcmM7XG4gIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuXG4gIGZvciAoc3RhcnQgPSBwb3MgPSBpbmRlbnQgPSBvZmZzZXQgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgIGNoID0gcy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWluZGVudF9mb3VuZCkge1xuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGluZGVudCsrO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIG9mZnNldCArPSA0IC0gb2Zmc2V0ICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudF9mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBIHx8IHBvcyA9PT0gbGVuIC0gMSkge1xuICAgICAgaWYgKGNoICE9PSAweDBBKSB7IHBvcysrOyB9XG4gICAgICB0aGlzLmJNYXJrcy5wdXNoKHN0YXJ0KTtcbiAgICAgIHRoaXMuZU1hcmtzLnB1c2gocG9zKTtcbiAgICAgIHRoaXMudFNoaWZ0LnB1c2goaW5kZW50KTtcbiAgICAgIHRoaXMuc0NvdW50LnB1c2gob2Zmc2V0KTtcbiAgICAgIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gICAgICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggZmFrZSBlbnRyeSB0byBzaW1wbGlmeSBjYWNoZSBib3VuZHMgY2hlY2tzXG4gIHRoaXMuYk1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLmVNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy50U2hpZnQucHVzaCgwKTtcbiAgdGhpcy5zQ291bnQucHVzaCgwKTtcbiAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgdGhpcy5saW5lTWF4ID0gdGhpcy5iTWFya3MubGVuZ3RoIC0gMTsgLy8gZG9uJ3QgY291bnQgbGFzdCBmYWtlIGxpbmVcbn1cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcbiAgdG9rZW4uYmxvY2sgPSB0cnVlO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XG5cbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgcmV0dXJuIHRoaXMuYk1hcmtzW2xpbmVdICsgdGhpcy50U2hpZnRbbGluZV0gPj0gdGhpcy5lTWFya3NbbGluZV07XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIHNraXBFbXB0eUxpbmVzKGZyb20pIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4OyBmcm9tKyspIHtcbiAgICBpZiAodGhpcy5iTWFya3NbZnJvbV0gKyB0aGlzLnRTaGlmdFtmcm9tXSA8IHRoaXMuZU1hcmtzW2Zyb21dKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb207XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlcyA9IGZ1bmN0aW9uIHNraXBTcGFjZXMocG9zKSB7XG4gIHZhciBjaDtcblxuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24gaW4gcmV2ZXJzZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXNCYWNrID0gZnVuY3Rpb24gc2tpcFNwYWNlc0JhY2socG9zLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoIWlzU3BhY2UodGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyBmcm9tIGdpdmVuIHBvc2l0aW9uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmICh0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IGNvZGUpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIHJldmVyc2UgZnJvbSBnaXZlbiBwb3NpdGlvbiAtIDFcblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFyc0JhY2sgPSBmdW5jdGlvbiBza2lwQ2hhcnNCYWNrKHBvcywgY29kZSwgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKGNvZGUgIT09IHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIGN1dCBsaW5lcyByYW5nZSBmcm9tIHNvdXJjZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmVnaW4sIGVuZCwgaW5kZW50LCBrZWVwTGFzdExGKSB7XG4gIHZhciBpLCBsaW5lSW5kZW50LCBjaCwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBsaW5lU3RhcnQsXG4gICAgICBsaW5lID0gYmVnaW47XG5cbiAgaWYgKGJlZ2luID49IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcblxuICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgIGxpbmVJbmRlbnQgPSAwO1xuICAgIGxpbmVTdGFydCA9IGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV07XG5cbiAgICBpZiAobGluZSArIDEgPCBlbmQgfHwga2VlcExhc3RMRikge1xuICAgICAgLy8gTm8gbmVlZCBmb3IgYm91bmRzIGNoZWNrIGJlY2F1c2Ugd2UgaGF2ZSBmYWtlIGVudHJ5IG9uIHRhaWwuXG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV07XG4gICAgfVxuXG4gICAgd2hpbGUgKGZpcnN0IDwgbGFzdCAmJiBsaW5lSW5kZW50IDwgaW5kZW50KSB7XG4gICAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoZmlyc3QpO1xuXG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgbGluZUluZGVudCArPSA0IC0gKGxpbmVJbmRlbnQgKyB0aGlzLmJzQ291bnRbbGluZV0pICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3QgLSBsaW5lU3RhcnQgPCB0aGlzLnRTaGlmdFtsaW5lXSkge1xuICAgICAgICAvLyBwYXRjaGVkIHRTaGlmdCBtYXNrZWQgY2hhcmFjdGVycyB0byBsb29rIGxpa2Ugc3BhY2VzIChibG9ja3F1b3RlcywgbGlzdCBtYXJrZXJzKVxuICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZmlyc3QrKztcbiAgICB9XG5cbiAgICBpZiAobGluZUluZGVudCA+IGluZGVudCkge1xuICAgICAgLy8gcGFydGlhbGx5IGV4cGFuZGluZyB0YWJzIGluIGNvZGUgYmxvY2tzLCBlLmcgJ1xcdFxcdGZvb2JhcidcbiAgICAgIC8vIHdpdGggaW5kZW50PTIgYmVjb21lcyAnICBcXHRmb29iYXInXG4gICAgICBxdWV1ZVtpXSA9IG5ldyBBcnJheShsaW5lSW5kZW50IC0gaW5kZW50ICsgMSkuam9pbignICcpICsgdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZVtpXSA9IHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVldWUuam9pbignJyk7XG59O1xuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jay5qcyIsIi8vIEdGTSB0YWJsZSwgbm9uLXN0YW5kYXJkXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbmZ1bmN0aW9uIGdldExpbmUoc3RhdGUsIGxpbmUpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLmJNYXJrc1tsaW5lXSArIHN0YXRlLmJsa0luZGVudCxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tsaW5lXTtcblxuICByZXR1cm4gc3RhdGUuc3JjLnN1YnN0cihwb3MsIG1heCAtIHBvcyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRTcGxpdChzdHIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgcG9zID0gMCxcbiAgICAgIG1heCA9IHN0ci5sZW5ndGgsXG4gICAgICBjaCxcbiAgICAgIGVzY2FwZXMgPSAwLFxuICAgICAgbGFzdFBvcyA9IDAsXG4gICAgICBiYWNrVGlja2VkID0gZmFsc2UsXG4gICAgICBsYXN0QmFja1RpY2sgPSAwO1xuXG4gIGNoICA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGlmIChjaCA9PT0gMHg2MC8qIGAgKi8pIHtcbiAgICAgIGlmIChiYWNrVGlja2VkKSB7XG4gICAgICAgIC8vIG1ha2UgXFxgIGNsb3NlIGNvZGUgc2VxdWVuY2UsIGJ1dCBub3Qgb3BlbiBpdDtcbiAgICAgICAgLy8gdGhlIHJlYXNvbiBpczogYFxcYCBpcyBjb3JyZWN0IGNvZGUgYmxvY2tcbiAgICAgICAgYmFja1RpY2tlZCA9IGZhbHNlO1xuICAgICAgICBsYXN0QmFja1RpY2sgPSBwb3M7XG4gICAgICB9IGVsc2UgaWYgKGVzY2FwZXMgJSAyID09PSAwKSB7XG4gICAgICAgIGJhY2tUaWNrZWQgPSB0cnVlO1xuICAgICAgICBsYXN0QmFja1RpY2sgPSBwb3M7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Yy8qIHwgKi8gJiYgKGVzY2FwZXMgJSAyID09PSAwKSAmJiAhYmFja1RpY2tlZCkge1xuICAgICAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhsYXN0UG9zLCBwb3MpKTtcbiAgICAgIGxhc3RQb3MgPSBwb3MgKyAxO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHg1Yy8qIFxcICovKSB7XG4gICAgICBlc2NhcGVzKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVzY2FwZXMgPSAwO1xuICAgIH1cblxuICAgIHBvcysrO1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIGFuIHVuLWNsb3NlZCBiYWNrdGljaywgZ28gYmFjayB0byBqdXN0IGFmdGVyXG4gICAgLy8gdGhlIGxhc3QgYmFja3RpY2ssIGJ1dCBhcyBpZiBpdCB3YXMgYSBub3JtYWwgY2hhcmFjdGVyXG4gICAgaWYgKHBvcyA9PT0gbWF4ICYmIGJhY2tUaWNrZWQpIHtcbiAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZTtcbiAgICAgIHBvcyA9IGxhc3RCYWNrVGljayArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICB9XG5cbiAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhsYXN0UG9zKSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRhYmxlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxpbmVUZXh0LCBwb3MsIGksIG5leHRMaW5lLCBjb2x1bW5zLCBjb2x1bW5Db3VudCwgdG9rZW4sXG4gICAgICBhbGlnbnMsIHQsIHRhYmxlTGluZXMsIHRib2R5TGluZXM7XG5cbiAgLy8gc2hvdWxkIGhhdmUgYXQgbGVhc3QgdHdvIGxpbmVzXG4gIGlmIChzdGFydExpbmUgKyAyID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlY29uZCBsaW5lIHNob3VsZCBiZSAnfCcsICctJywgJzonLFxuICAvLyBhbmQgbm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCBidXQgc3BhY2VzO1xuICAvLyBiYXNpY2FsbHksIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgL15bLTp8XVstOnxcXHNdKiQvIHJlZ2V4cFxuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICBpZiAocG9zID49IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIGlmIChjaCAhPT0gMHg3Qy8qIHwgKi8gJiYgY2ggIT09IDB4MkQvKiAtICovICYmIGNoICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICB3aGlsZSAocG9zIDwgc3RhdGUuZU1hcmtzW25leHRMaW5lXSkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCAhPT0gMHg3Qy8qIHwgKi8gJiYgY2ggIT09IDB4MkQvKiAtICovICYmIGNoICE9PSAweDNBLyogOiAqLyAmJiAhaXNTcGFjZShjaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lICsgMSk7XG5cbiAgY29sdW1ucyA9IGxpbmVUZXh0LnNwbGl0KCd8Jyk7XG4gIGFsaWducyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHQgPSBjb2x1bW5zW2ldLnRyaW0oKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIC8vIGFsbG93IGVtcHR5IGNvbHVtbnMgYmVmb3JlIGFuZCBhZnRlciB0YWJsZSwgYnV0IG5vdCBpbiBiZXR3ZWVuIGNvbHVtbnM7XG4gICAgICAvLyBlLmcuIGFsbG93IGAgfC0tLXwgYCwgZGlzYWxsb3cgYCAtLS18fC0tLSBgXG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBjb2x1bW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXjo/LSs6PyQvLnRlc3QodCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHQuY2hhckNvZGVBdCh0Lmxlbmd0aCAtIDEpID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2godC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLyA/ICdjZW50ZXInIDogJ3JpZ2h0Jyk7XG4gICAgfSBlbHNlIGlmICh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBhbGlnbnMucHVzaCgnbGVmdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGlnbnMucHVzaCgnJyk7XG4gICAgfVxuICB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUpLnRyaW0oKTtcbiAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ3wnKSA9PT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuICBjb2x1bW5zID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0LnJlcGxhY2UoL15cXHx8XFx8JC9nLCAnJykpO1xuXG4gIC8vIGhlYWRlciByb3cgd2lsbCBkZWZpbmUgYW4gYW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIGVudGlyZSB0YWJsZSxcbiAgLy8gYW5kIGFsaWduIHJvdyBzaG91bGRuJ3QgYmUgc21hbGxlciB0aGFuIHRoYXQgKHRoZSByZXN0IG9mIHRoZSByb3dzIGNhbilcbiAgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgaWYgKGNvbHVtbkNvdW50ID4gYWxpZ25zLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGFibGVfb3BlbicsICd0YWJsZScsIDEpO1xuICB0b2tlbi5tYXAgPSB0YWJsZUxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0aGVhZF9vcGVuJywgJ3RoZWFkJywgMSk7XG4gIHRva2VuLm1hcCA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfb3BlbicsICd0cicsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0aF9vcGVuJywgJ3RoJywgMSk7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICB9XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0aF9jbG9zZScsICd0aCcsIC0xKTtcbiAgfVxuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX2Nsb3NlJywgJ3RyJywgLTEpO1xuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0aGVhZF9jbG9zZScsICd0aGVhZCcsIC0xKTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0Ym9keV9vcGVuJywgJ3Rib2R5JywgMSk7XG4gIHRva2VuLm1hcCA9IHRib2R5TGluZXMgPSBbIHN0YXJ0TGluZSArIDIsIDAgXTtcblxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMjsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgbmV4dExpbmUpLnRyaW0oKTtcbiAgICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyBicmVhazsgfVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgYnJlYWs7IH1cbiAgICBjb2x1bW5zID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0LnJlcGxhY2UoL15cXHx8XFx8JC9nLCAnJykpO1xuXG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGRfb3BlbicsICd0ZCcsIDEpO1xuICAgICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgICB0b2tlbi5hdHRycyAgPSBbIFsgJ3N0eWxlJywgJ3RleHQtYWxpZ246JyArIGFsaWduc1tpXSBdIF07XG4gICAgICB9XG5cbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCAgPSBjb2x1bW5zW2ldID8gY29sdW1uc1tpXS50cmltKCkgOiAnJztcbiAgICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGRfY2xvc2UnLCAndGQnLCAtMSk7XG4gICAgfVxuICAgIHRva2VuID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIH1cbiAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0Ym9keV9jbG9zZScsICd0Ym9keScsIC0xKTtcbiAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0YWJsZV9jbG9zZScsICd0YWJsZScsIC0xKTtcblxuICB0YWJsZUxpbmVzWzFdID0gdGJvZHlMaW5lc1sxXSA9IG5leHRMaW5lO1xuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrKHN0YXRlKSB7XG4gIHZhciB0b2tlbjtcblxuICBpZiAoc3RhdGUuaW5saW5lTW9kZSkge1xuICAgIHRva2VuICAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCAgPSBzdGF0ZS5zcmM7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIDAsIDEgXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5tZC5ibG9jay5wYXJzZShzdGF0ZS5zcmMsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHN0YXRlLnRva2Vucyk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucywgdG9rLCBpLCBsO1xuXG4gIC8vIFBhcnNlIGlubGluZXNcbiAgZm9yIChpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2sgPSB0b2tlbnNbaV07XG4gICAgaWYgKHRvay50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKHRvay5jb250ZW50LCBzdGF0ZS5tZCwgc3RhdGUuZW52LCB0b2suY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2lubGluZS5qcyIsIi8vIFJlcGxhY2UgbGluay1saWtlIHRleHRzIHdpdGggbGluayBub2Rlcy5cbi8vXG4vLyBDdXJyZW50bHkgcmVzdHJpY3RlZCBieSBgbWQudmFsaWRhdGVMaW5rKClgIHRvIGh0dHAvaHR0cHMvZnRwXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhcnJheVJlcGxhY2VBdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmFycmF5UmVwbGFjZUF0O1xuXG5cbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5raWZ5KHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dCwgcG9zLCBsYXN0UG9zLFxuICAgICAgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsIHVybCwgZnVsbFVybCwgdXJsVGV4dCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbGlua3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmxpbmtpZnkpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjdXJyZW50VG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBtYXJrZG93biBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSBjdXJyZW50VG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09ICdsaW5rX29wZW4nKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2h0bWxfaW5saW5lJykge1xuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh0bWxMaW5rTGV2ZWwgPiAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcblxuICAgICAgICB0ZXh0ID0gY3VycmVudFRva2VuLmNvbnRlbnQ7XG4gICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0KTtcblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxldmVsID0gY3VycmVudFRva2VuLmxldmVsO1xuICAgICAgICBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcblxuICAgICAgICAgIHVybCA9IGxpbmtzW2xuXS51cmw7XG4gICAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdXJsVGV4dCA9IGxpbmtzW2xuXS50ZXh0O1xuXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggZG9tYWluIG5hbWUuIFNvIHdlIHByZXBlbmQgaHR0cDovLyBpbiB0aG9zZSBjYXNlcyxcbiAgICAgICAgICAvLyBhbmQgcmVtb3ZlIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIWxpbmtzW2xuXS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnaHR0cDovLycgKyB1cmxUZXh0KS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5rc1tsbl0uc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnbWFpbHRvOicgKyB1cmxUZXh0KS5yZXBsYWNlKC9ebWFpbHRvOi8sICcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyA9IGxpbmtzW2xuXS5pbmRleDtcblxuICAgICAgICAgIGlmIChwb3MgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbCsrO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHVybFRleHQ7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSAtLWxldmVsO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXG4gICAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gYXJyYXlSZXBsYWNlQXQodG9rZW5zLCBpLCBub2Rlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIi8vIE5vcm1hbGl6ZSBpbnB1dCBzdHJpbmdcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBORVdMSU5FU19SRSAgPSAvXFxyW1xcblxcdTAwODVdP3xbXFx1MjQyNFxcdTIwMjhcXHUwMDg1XS9nO1xudmFyIE5VTExfUkUgICAgICA9IC9cXHUwMDAwL2c7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHN0cjtcblxuICAvLyBOb3JtYWxpemUgbmV3bGluZXNcbiAgc3RyID0gc3RhdGUuc3JjLnJlcGxhY2UoTkVXTElORVNfUkUsICdcXG4nKTtcblxuICAvLyBSZXBsYWNlIE5VTEwgY2hhcmFjdGVyc1xuICBzdHIgPSBzdHIucmVwbGFjZShOVUxMX1JFLCAnXFx1RkZGRCcpO1xuXG4gIHN0YXRlLnNyYyA9IHN0cjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCIvLyBTaW1wbGUgdHlwb2dyYXBoeWMgcmVwbGFjZW1lbnRzXG4vL1xuLy8gKGMpIChDKSDihpIgwqlcbi8vICh0bSkgKFRNKSDihpIg4oSiXG4vLyAocikgKFIpIOKGkiDCrlxuLy8gKy0g4oaSIMKxXG4vLyAocCkgKFApIC0+IMKnXG4vLyAuLi4g4oaSIOKApiAoYWxzbyA/Li4uLiDihpIgPy4uLCAhLi4uLiDihpIgIS4uKVxuLy8gPz8/Pz8/Pz8g4oaSID8/PywgISEhISEg4oaSICEhISwgYCwsYCDihpIgYCxgXG4vLyAtLSDihpIgJm5kYXNoOywgLS0tIOKGkiAmbWRhc2g7XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOlxuLy8gLSBmcmFjdGlvbmFscyAxLzIsIDEvNCwgMy80IC0+IMK9LCDCvCwgwr5cbi8vIC0gbWlsdGlwbGljYXRpb24gMiB4IDQgLT4gMiDDlyA0XG5cbnZhciBSQVJFX1JFID0gL1xcKy18XFwuXFwufFxcP1xcP1xcP1xcP3whISEhfCwsfC0tLztcblxuLy8gV29ya2Fyb3VuZCBmb3IgcGhhbnRvbWpzIC0gbmVlZCByZWdleCB3aXRob3V0IC9nIGZsYWcsXG4vLyBvciByb290IGNoZWNrIHdpbGwgZmFpbCBldmVyeSBzZWNvbmQgdGltZVxudmFyIFNDT1BFRF9BQkJSX1RFU1RfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pO1xuXG52YXIgU0NPUEVEX0FCQlJfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pZztcbnZhciBTQ09QRURfQUJCUiA9IHtcbiAgYzogJ8KpJyxcbiAgcjogJ8KuJyxcbiAgcDogJ8KnJyxcbiAgdG06ICfihKInXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlRm4obWF0Y2gsIG5hbWUpIHtcbiAgcmV0dXJuIFNDT1BFRF9BQkJSW25hbWUudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2Vfc2NvcGVkKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50LnJlcGxhY2UoU0NPUEVEX0FCQlJfUkUsIHJlcGxhY2VGbik7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlX3JhcmUoaW5saW5lVG9rZW5zKSB7XG4gIHZhciBpLCB0b2tlbiwgaW5zaWRlX2F1dG9saW5rID0gMDtcblxuICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgaWYgKFJBUkVfUkUudGVzdCh0b2tlbi5jb250ZW50KSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwrLS9nLCAnwrEnKVxuICAgICAgICAgICAgICAgICAgICAvLyAuLiwgLi4uLCAuLi4uLi4uIC0+IOKAplxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgPy4uLi4uICYgIS4uLi4uIC0+ID8uLiAmICEuLlxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuezIsfS9nLCAn4oCmJykucmVwbGFjZSgvKFs/IV0p4oCmL2csICckMS4uJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbPyFdKXs0LH0vZywgJyQxJDEkMScpLnJlcGxhY2UoLyx7Mix9L2csICcsJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW0tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXSktLS0oW14tXXwkKS9tZywgJyQxXFx1MjAxNCQyJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW4tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58XFxzKS0tKFxcc3wkKS9tZywgJyQxXFx1MjAxMyQyJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLVxcc10pLS0oW14tXFxzXXwkKS9tZywgJyQxXFx1MjAxMyQyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKFNDT1BFRF9BQkJSX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChSQVJFX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2VfcmFyZShzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMiLCIvLyBDb252ZXJ0IHN0cmFpZ2h0IHF1b3RhdGlvbiBtYXJrcyB0byB0eXBvZ3JhcGhpYyBvbmVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XG5cbnZhciBRVU9URV9URVNUX1JFID0gL1snXCJdLztcbnZhciBRVU9URV9SRSA9IC9bJ1wiXS9nO1xudmFyIEFQT1NUUk9QSEUgPSAnXFx1MjAxOSc7IC8qIOKAmSAqL1xuXG5cbmZ1bmN0aW9uIHJlcGxhY2VBdChzdHIsIGluZGV4LCBjaCkge1xuICByZXR1cm4gc3RyLnN1YnN0cigwLCBpbmRleCkgKyBjaCArIHN0ci5zdWJzdHIoaW5kZXggKyAxKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc19pbmxpbmVzKHRva2Vucywgc3RhdGUpIHtcbiAgdmFyIGksIHRva2VuLCB0ZXh0LCB0LCBwb3MsIG1heCwgdGhpc0xldmVsLCBpdGVtLCBsYXN0Q2hhciwgbmV4dENoYXIsXG4gICAgICBpc0xhc3RQdW5jdENoYXIsIGlzTmV4dFB1bmN0Q2hhciwgaXNMYXN0V2hpdGVTcGFjZSwgaXNOZXh0V2hpdGVTcGFjZSxcbiAgICAgIGNhbk9wZW4sIGNhbkNsb3NlLCBqLCBpc1NpbmdsZSwgc3RhY2ssIG9wZW5RdW90ZSwgY2xvc2VRdW90ZTtcblxuICBzdGFjayA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIHRoaXNMZXZlbCA9IHRva2Vuc1tpXS5sZXZlbDtcblxuICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPD0gdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIHN0YWNrLmxlbmd0aCA9IGogKyAxO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgcG9zID0gMDtcbiAgICBtYXggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIC8qZXNsaW50IG5vLWxhYmVsczowLGJsb2NrLXNjb3BlZC12YXI6MCovXG4gICAgT1VURVI6XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgUVVPVEVfUkUubGFzdEluZGV4ID0gcG9zO1xuICAgICAgdCA9IFFVT1RFX1JFLmV4ZWModGV4dCk7XG4gICAgICBpZiAoIXQpIHsgYnJlYWs7IH1cblxuICAgICAgY2FuT3BlbiA9IGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIHBvcyA9IHQuaW5kZXggKyAxO1xuICAgICAgaXNTaW5nbGUgPSAodFswXSA9PT0gXCInXCIpO1xuXG4gICAgICAvLyBGaW5kIHByZXZpb3VzIGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbGFzdENoYXIgPSAweDIwO1xuXG4gICAgICBpZiAodC5pbmRleCAtIDEgPj0gMCkge1xuICAgICAgICBsYXN0Q2hhciA9IHRleHQuY2hhckNvZGVBdCh0LmluZGV4IC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgbGFzdENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KHRva2Vuc1tqXS5jb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgbmV4dCBjaGFyYWN0ZXIsXG4gICAgICAvLyBkZWZhdWx0IHRvIHNwYWNlIGlmIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgLy9cbiAgICAgIG5leHRDaGFyID0gMHgyMDtcblxuICAgICAgaWYgKHBvcyA8IG1heCkge1xuICAgICAgICBuZXh0Q2hhciA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgbmV4dENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XG4gICAgICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xuXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgICAgIGlzTmV4dFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuXG4gICAgICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRDaGFyID09PSAweDIyIC8qIFwiICovICYmIHRbMF0gPT09ICdcIicpIHtcbiAgICAgICAgaWYgKGxhc3RDaGFyID49IDB4MzAgLyogMCAqLyAmJiBsYXN0Q2hhciA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IDFcIlwiIC0gY291bnQgZmlyc3QgcXVvdGUgYXMgYW4gaW5jaFxuICAgICAgICAgIGNhbkNsb3NlID0gY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5PcGVuICYmIGNhbkNsb3NlKSB7XG4gICAgICAgIC8vIHRyZWF0IHRoaXMgYXMgdGhlIG1pZGRsZSBvZiB0aGUgd29yZFxuICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIGNhbkNsb3NlID0gaXNOZXh0UHVuY3RDaGFyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbk9wZW4gJiYgIWNhbkNsb3NlKSB7XG4gICAgICAgIC8vIG1pZGRsZSBvZiB3b3JkXG4gICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5DbG9zZSkge1xuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGEgY2xvc2luZyBxdW90ZSwgcmV3aW5kIHRoZSBzdGFjayB0byBnZXQgYSBtYXRjaFxuICAgICAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcbiAgICAgICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPCB0aGlzTGV2ZWwpIHsgYnJlYWs7IH1cbiAgICAgICAgICBpZiAoaXRlbS5zaW5nbGUgPT09IGlzU2luZ2xlICYmIHN0YWNrW2pdLmxldmVsID09PSB0aGlzTGV2ZWwpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcblxuICAgICAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzJdO1xuICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbM107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1swXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRva2VuLmNvbnRlbnQgKmJlZm9yZSogdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlLCBpZiB0aGV5IGFyZSBwb2ludGluZyBhdCB0aGUgc2FtZSB0b2tlbiwgcmVwbGFjZUF0XG4gICAgICAgICAgICAvLyBjb3VsZCBtZXNzIHVwIGluZGljZXMgd2hlbiBxdW90ZSBsZW5ndGggIT0gMVxuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBjbG9zZVF1b3RlKTtcbiAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50ID0gcmVwbGFjZUF0KFxuICAgICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCwgaXRlbS5wb3MsIG9wZW5RdW90ZSk7XG5cbiAgICAgICAgICAgIHBvcyArPSBjbG9zZVF1b3RlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAoaXRlbS50b2tlbiA9PT0gaSkgeyBwb3MgKz0gb3BlblF1b3RlLmxlbmd0aCAtIDE7IH1cblxuICAgICAgICAgICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICBtYXggPSB0ZXh0Lmxlbmd0aDtcblxuICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlIE9VVEVSO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3Blbikge1xuICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICB0b2tlbjogaSxcbiAgICAgICAgICBwb3M6IHQuaW5kZXgsXG4gICAgICAgICAgc2luZ2xlOiBpc1NpbmdsZSxcbiAgICAgICAgICBsZXZlbDogdGhpc0xldmVsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChjYW5DbG9zZSAmJiBpc1NpbmdsZSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc21hcnRxdW90ZXMoc3RhdGUpIHtcbiAgLyplc2xpbnQgbWF4LWRlcHRoOjAqL1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhUVVPVEVfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwcm9jZXNzX2lubGluZXMoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4sIHN0YXRlKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzLmpzIiwiLy8gQ29yZSBzdGF0ZSBvYmplY3Rcbi8vXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG5cblxuZnVuY3Rpb24gU3RhdGVDb3JlKHNyYywgbWQsIGVudikge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMuaW5saW5lTW9kZSA9IGZhbHNlO1xuICB0aGlzLm1kID0gbWQ7IC8vIGxpbmsgdG8gcGFyc2VyIGluc3RhbmNlXG59XG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gY29yZSBydWxlc1xuU3RhdGVDb3JlLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVDb3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5qcyIsIi8vIFByb2Nlc3MgYXV0b2xpbmtzICc8cHJvdG9jb2w6Li4uPidcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qZXNsaW50IG1heC1sZW46MCovXG52YXIgRU1BSUxfUkUgICAgPSAvXjwoW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKik+LztcbnZhciBBVVRPTElOS19SRSA9IC9ePChbYS16QS1aXVthLXpBLVowLTkrLlxcLV17MSwzMX0pOihbXjw+XFx4MDAtXFx4MjBdKik+LztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF1dG9saW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHRhaWwsIGxpbmtNYXRjaCwgZW1haWxNYXRjaCwgdXJsLCBmdWxsVXJsLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdGFpbCA9IHN0YXRlLnNyYy5zbGljZShwb3MpO1xuXG4gIGlmICh0YWlsLmluZGV4T2YoJz4nKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKEFVVE9MSU5LX1JFLnRlc3QodGFpbCkpIHtcbiAgICBsaW5rTWF0Y2ggPSB0YWlsLm1hdGNoKEFVVE9MSU5LX1JFKTtcblxuICAgIHVybCA9IGxpbmtNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gbGlua01hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFTUFJTF9SRS50ZXN0KHRhaWwpKSB7XG4gICAgZW1haWxNYXRjaCA9IHRhaWwubWF0Y2goRU1BSUxfUkUpO1xuXG4gICAgdXJsID0gZW1haWxNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gZW1haWxNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIi8vIFBhcnNlIGJhY2t0aWNrc1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFja3RpY2soc3RhdGUsIHNpbGVudCkge1xuICB2YXIgc3RhcnQsIG1heCwgbWFya2VyLCBtYXRjaFN0YXJ0LCBtYXRjaEVuZCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKGNoICE9PSAweDYwLyogYCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzdGFydCA9IHBvcztcbiAgcG9zKys7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NjAvKiBgICovKSB7IHBvcysrOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpO1xuXG4gIG1hdGNoU3RhcnQgPSBtYXRjaEVuZCA9IHBvcztcblxuICB3aGlsZSAoKG1hdGNoU3RhcnQgPSBzdGF0ZS5zcmMuaW5kZXhPZignYCcsIG1hdGNoRW5kKSkgIT09IC0xKSB7XG4gICAgbWF0Y2hFbmQgPSBtYXRjaFN0YXJ0ICsgMTtcblxuICAgIHdoaWxlIChtYXRjaEVuZCA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChtYXRjaEVuZCkgPT09IDB4NjAvKiBgICovKSB7IG1hdGNoRW5kKys7IH1cblxuICAgIGlmIChtYXRjaEVuZCAtIG1hdGNoU3RhcnQgPT09IG1hcmtlci5sZW5ndGgpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2lubGluZScsICdjb2RlJywgMCk7XG4gICAgICAgIHRva2VuLm1hcmt1cCAgPSBtYXJrZXI7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXRjaFN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1sgXFxuXSsvZywgJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IG1hdGNoRW5kO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBtYXJrZXI7IH1cbiAgc3RhdGUucG9zICs9IG1hcmtlci5sZW5ndGg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwiLy8gRm9yIGVhY2ggb3BlbmluZyBlbXBoYXNpcy1saWtlIG1hcmtlciBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyBvbmVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rX3BhaXJzKHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsYXN0RGVsaW0sIGN1cnJEZWxpbSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgbGFzdERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmICghbGFzdERlbGltLmNsb3NlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBqID0gaSAtIGxhc3REZWxpbS5qdW1wIC0gMTtcblxuICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgIGN1cnJEZWxpbSA9IGRlbGltaXRlcnNbal07XG5cbiAgICAgIGlmIChjdXJyRGVsaW0ub3BlbiAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5tYXJrZXIgPT09IGxhc3REZWxpbS5tYXJrZXIgJiZcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kIDwgMCAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5sZXZlbCA9PT0gbGFzdERlbGltLmxldmVsKSB7XG5cbiAgICAgICAgLy8gdHlwZW9mcyBhcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBwbHVnaW5zXG4gICAgICAgIHZhciBvZGRfbWF0Y2ggPSAoY3VyckRlbGltLmNsb3NlIHx8IGxhc3REZWxpbS5vcGVuKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJEZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdERlbGltLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyRGVsaW0ubGVuZ3RoICsgbGFzdERlbGltLmxlbmd0aCkgJSAzID09PSAwO1xuXG4gICAgICAgIGlmICghb2RkX21hdGNoKSB7XG4gICAgICAgICAgbGFzdERlbGltLmp1bXAgPSBpIC0gajtcbiAgICAgICAgICBsYXN0RGVsaW0ub3BlbiA9IGZhbHNlO1xuICAgICAgICAgIGN1cnJEZWxpbS5lbmQgID0gaTtcbiAgICAgICAgICBjdXJyRGVsaW0uanVtcCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaiAtPSBjdXJyRGVsaW0uanVtcCArIDE7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzLmpzIiwiLy8gUHJvY2VzcyBodG1sIGVudGl0eSAtICYjMTIzOywgJiN4QUY7LCAmcXVvdDssIC4uLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbnRpdGllcyAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lbnRpdGllcycpO1xudmFyIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaGFzO1xudmFyIGlzVmFsaWRFbnRpdHlDb2RlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNWYWxpZEVudGl0eUNvZGU7XG52YXIgZnJvbUNvZGVQb2ludCAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5mcm9tQ29kZVBvaW50O1xuXG5cbnZhciBESUdJVEFMX1JFID0gL14mIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSk7L2k7XG52YXIgTkFNRURfUkUgICA9IC9eJihbYS16XVthLXowLTldezEsMzF9KTsvaTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVudGl0eShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgY29kZSwgbWF0Y2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI2LyogJiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMSA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjMgLyogIyAqLykge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChESUdJVEFMX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIGNvZGUgPSBtYXRjaFsxXVswXS50b0xvd2VyQ2FzZSgpID09PSAneCcgPyBwYXJzZUludChtYXRjaFsxXS5zbGljZSgxKSwgMTYpIDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpID8gZnJvbUNvZGVQb2ludChjb2RlKSA6IGZyb21Db2RlUG9pbnQoMHhGRkZEKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChOQU1FRF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKGhhcyhlbnRpdGllcywgbWF0Y2hbMV0pKSB7XG4gICAgICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBlbnRpdGllc1ttYXRjaFsxXV07IH1cbiAgICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnJic7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwiLy8gUHJvY2Vlc3MgZXNjYXBlZCBjaGFycyBhbmQgaGFyZGJyZWFrc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxudmFyIEVTQ0FQRUQgPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykgeyBFU0NBUEVELnB1c2goMCk7IH1cblxuJ1xcXFwhXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXV5fYHt8fX4tJ1xuICAuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7IEVTQ0FQRURbY2guY2hhckNvZGVBdCgwKV0gPSAxOyB9KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUMvKiBcXCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MrKztcblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoIDwgMjU2ICYmIEVTQ0FQRURbY2hdICE9PSAwKSB7XG4gICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1twb3NdOyB9XG4gICAgICBzdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgICAgLy8gc2tpcCBsZWFkaW5nIHdoaXRlc3BhY2VzIGZyb20gbmV4dCBsaW5lXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zID0gcG9zO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnXFxcXCc7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLmpzIiwiLy8gUHJvY2VzcyBodG1sIHRhZ3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBIVE1MX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9UQUdfUkU7XG5cblxuZnVuY3Rpb24gaXNMZXR0ZXIoY2gpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgdmFyIGxjID0gY2ggfCAweDIwOyAvLyB0byBsb3dlciBjYXNlXG4gIHJldHVybiAobGMgPj0gMHg2MS8qIGEgKi8pICYmIChsYyA8PSAweDdhLyogeiAqLyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2lubGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbWF0Y2gsIG1heCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gQ2hlY2sgc3RhcnRcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8gfHxcbiAgICAgIHBvcyArIDIgPj0gbWF4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUXVpY2sgZmFpbCBvbiBzZWNvbmQgY2hhclxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICBpZiAoY2ggIT09IDB4MjEvKiAhICovICYmXG4gICAgICBjaCAhPT0gMHgzRi8qID8gKi8gJiZcbiAgICAgIGNoICE9PSAweDJGLyogLyAqLyAmJlxuICAgICAgIWlzTGV0dGVyKGNoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goSFRNTF9UQUdfUkUpO1xuICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc2lsZW50KSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBwb3MgKyBtYXRjaFswXS5sZW5ndGgpO1xuICB9XG4gIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCIvLyBQcm9jZXNzICFbaW1hZ2VdKDxzcmM+IFwidGl0bGVcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW1hZ2Uoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgY29udGVudCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVmLFxuICAgICAgcmVzLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIHRva2VucyxcbiAgICAgIHN0YXJ0LFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDIxLyogISAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMjtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MgKyAxLCBmYWxzZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH0gZWxzZSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UoXG4gICAgICBjb250ZW50LFxuICAgICAgc3RhdGUubWQsXG4gICAgICBzdGF0ZS5lbnYsXG4gICAgICB0b2tlbnMgPSBbXVxuICAgICk7XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2ltYWdlJywgJ2ltZycsIDApO1xuICAgIHRva2VuLmF0dHJzICAgID0gYXR0cnMgPSBbIFsgJ3NyYycsIGhyZWYgXSwgWyAnYWx0JywgJycgXSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gdG9rZW5zO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwiLy8gUHJvY2VzcyBbbGlua10oPHRvPiBcInN0dWZmXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIGxhYmVsU3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZXMsXG4gICAgICByZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHRva2VuLFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAxO1xuICBsYWJlbEVuZCA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXRlLnBvcywgdHJ1ZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBtaWdodCBoYXZlIGZvdW5kIGEgdmFsaWQgc2hvcnRjdXQgbGluaywgZGlzYWJsZSByZWZlcmVuY2UgcGFyc2luZ1xuICAgIHBhcnNlUmVmZXJlbmNlID0gZmFsc2U7XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIC8vIHBhcnNpbmcgYSB2YWxpZCBzaG9ydGN1dCBsaW5rIGZhaWxlZCwgZmFsbGJhY2sgdG8gcmVmZXJlbmNlXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBhcnNlUmVmZXJlbmNlKSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucG9zID0gbGFiZWxTdGFydDtcbiAgICBzdGF0ZS5wb3NNYXggPSBsYWJlbEVuZDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgdG9rZW4uYXR0cnMgID0gYXR0cnMgPSBbIFsgJ2hyZWYnLCBocmVmIF0gXTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qcyIsIi8vIFByb2NlZXNzICdcXG4nXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3bGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwbWF4LCBtYXgsIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQS8qIFxcbiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwbWF4ID0gc3RhdGUucGVuZGluZy5sZW5ndGggLSAxO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgLy8gJyAgXFxuJyAtPiBoYXJkYnJlYWtcbiAgLy8gTG9va3VwIGluIHBlbmRpbmcgY2hhcnMgaXMgYmFkIHByYWN0aWNlISBEb24ndCBjb3B5IHRvIG90aGVyIHJ1bGVzIVxuICAvLyBQZW5kaW5nIHN0cmluZyBpcyBzdG9yZWQgaW4gY29uY2F0IG1vZGUsIGluZGV4ZWQgbG9va3VwcyB3aWxsIGNhdXNlXG4gIC8vIGNvbnZlcnRpb24gdG8gZmxhdCBtb2RlLlxuICBpZiAoIXNpbGVudCkge1xuICAgIGlmIChwbWF4ID49IDAgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXgpID09PSAweDIwKSB7XG4gICAgICBpZiAocG1heCA+PSAxICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4IC0gMSkgPT09IDB4MjApIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcucmVwbGFjZSgvICskLywgJycpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdoYXJkYnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgc3RhdGUucHVzaCgnc29mdGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHVzaCgnc29mdGJyZWFrJywgJ2JyJywgMCk7XG4gICAgfVxuICB9XG5cbiAgcG9zKys7XG5cbiAgLy8gc2tpcCBoZWFkaW5nIHNwYWNlcyBmb3IgbmV4dCBsaW5lXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkgeyBwb3MrKzsgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwiLy8gSW5saW5lIHBhcnNlciBzdGF0ZVxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFRva2VuICAgICAgICAgID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XG5cblxuZnVuY3Rpb24gU3RhdGVJbmxpbmUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLm1kID0gbWQ7XG4gIHRoaXMudG9rZW5zID0gb3V0VG9rZW5zO1xuXG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5wb3NNYXggPSB0aGlzLnNyYy5sZW5ndGg7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLnBlbmRpbmcgPSAnJztcbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSAwO1xuXG4gIHRoaXMuY2FjaGUgPSB7fTsgICAgICAgIC8vIFN0b3JlcyB7IHN0YXJ0OiBlbmQgfSBwYWlycy4gVXNlZnVsIGZvciBiYWNrdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uIG9mIHBhaXJzIHBhcnNlIChlbXBoYXNpcywgc3RyaWtlcykuXG5cbiAgdGhpcy5kZWxpbWl0ZXJzID0gW107ICAgLy8gRW1waGFzaXMtbGlrZSBkZWxpbWl0ZXJzXG59XG5cblxuLy8gRmx1c2ggcGVuZGluZyB0ZXh0XG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2hQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgPSB0aGlzLnBlbmRpbmc7XG4gIHRva2VuLmxldmVsID0gdGhpcy5wZW5kaW5nTGV2ZWw7XG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLnBlbmRpbmcgPSAnJztcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy8gSWYgcGVuZGluZyB0ZXh0IGV4aXN0cyAtIGZsdXNoIGl0IGFzIHRleHQgdG9rZW5cbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgaWYgKHRoaXMucGVuZGluZykge1xuICAgIHRoaXMucHVzaFBlbmRpbmcoKTtcbiAgfVxuXG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XG5cbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSB0aGlzLmxldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuXG4vLyBTY2FuIGEgc2VxdWVuY2Ugb2YgZW1waGFzaXMtbGlrZSBtYXJrZXJzLCBhbmQgZGV0ZXJtaW5lIHdoZXRoZXJcbi8vIGl0IGNhbiBzdGFydCBhbiBlbXBoYXNpcyBzZXF1ZW5jZSBvciBlbmQgYW4gZW1waGFzaXMgc2VxdWVuY2UuXG4vL1xuLy8gIC0gc3RhcnQgLSBwb3NpdGlvbiB0byBzY2FuIGZyb20gKGl0IHNob3VsZCBwb2ludCBhdCBhIHZhbGlkIG1hcmtlcik7XG4vLyAgLSBjYW5TcGxpdFdvcmQgLSBkZXRlcm1pbmUgaWYgdGhlc2UgbWFya2VycyBjYW4gYmUgZm91bmQgaW5zaWRlIGEgd29yZFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5zY2FuRGVsaW1zID0gZnVuY3Rpb24gKHN0YXJ0LCBjYW5TcGxpdFdvcmQpIHtcbiAgdmFyIHBvcyA9IHN0YXJ0LCBsYXN0Q2hhciwgbmV4dENoYXIsIGNvdW50LCBjYW5fb3BlbiwgY2FuX2Nsb3NlLFxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSwgaXNMYXN0UHVuY3RDaGFyLFxuICAgICAgaXNOZXh0V2hpdGVTcGFjZSwgaXNOZXh0UHVuY3RDaGFyLFxuICAgICAgbGVmdF9mbGFua2luZyA9IHRydWUsXG4gICAgICByaWdodF9mbGFua2luZyA9IHRydWUsXG4gICAgICBtYXggPSB0aGlzLnBvc01heCxcbiAgICAgIG1hcmtlciA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIC8vIHRyZWF0IGJlZ2lubmluZyBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcbiAgbGFzdENoYXIgPSBzdGFydCA+IDAgPyB0aGlzLnNyYy5jaGFyQ29kZUF0KHN0YXJ0IC0gMSkgOiAweDIwO1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpID09PSBtYXJrZXIpIHsgcG9zKys7IH1cblxuICBjb3VudCA9IHBvcyAtIHN0YXJ0O1xuXG4gIC8vIHRyZWF0IGVuZCBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcbiAgbmV4dENoYXIgPSBwb3MgPCBtYXggPyB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgOiAweDIwO1xuXG4gIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XG4gIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gIGlzTmV4dFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuXG4gIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgbGVmdF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgbGVmdF9mbGFua2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjYW5TcGxpdFdvcmQpIHtcbiAgICBjYW5fb3BlbiAgPSBsZWZ0X2ZsYW5raW5nICAmJiAoIXJpZ2h0X2ZsYW5raW5nIHx8IGlzTGFzdFB1bmN0Q2hhcik7XG4gICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmcgJiYgKCFsZWZ0X2ZsYW5raW5nICB8fCBpc05leHRQdW5jdENoYXIpO1xuICB9IGVsc2Uge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmc7XG4gICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNhbl9vcGVuOiAgY2FuX29wZW4sXG4gICAgY2FuX2Nsb3NlOiBjYW5fY2xvc2UsXG4gICAgbGVuZ3RoOiAgICBjb3VudFxuICB9O1xufTtcblxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlSW5saW5lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCIvLyBTa2lwIHRleHQgY2hhcmFjdGVycyBmb3IgdGV4dCB0b2tlbiwgcGxhY2UgdGhvc2UgdG8gcGVuZGluZyBidWZmZXJcbi8vIGFuZCBpbmNyZW1lbnQgY3VycmVudCBwb3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIFJ1bGUgdG8gc2tpcCBwdXJlIHRleHRcbi8vICd7fSQlQH4rPTonIHJlc2VydmVkIGZvciBleHRlbnRpb25zXG5cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuXG4vLyAhISEhIERvbid0IGNvbmZ1c2Ugd2l0aCBcIk1hcmtkb3duIEFTQ0lJIFB1bmN0dWF0aW9uXCIgY2hhcnNcbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuZnVuY3Rpb24gaXNUZXJtaW5hdG9yQ2hhcihjaCkge1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAweDBBLyogXFxuICovOlxuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHg0MC8qIEAgKi86XG4gICAgY2FzZSAweDVCLyogWyAqLzpcbiAgICBjYXNlIDB4NUMvKiBcXCAqLzpcbiAgICBjYXNlIDB4NUQvKiBdICovOlxuICAgIGNhc2UgMHg1RS8qIF4gKi86XG4gICAgY2FzZSAweDVGLyogXyAqLzpcbiAgICBjYXNlIDB4NjAvKiBgICovOlxuICAgIGNhc2UgMHg3Qi8qIHsgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHQoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG9zID0gc3RhdGUucG9zO1xuXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5wb3NNYXggJiYgIWlzVGVybWluYXRvckNoYXIoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwb3MgPT09IHN0YXRlLnBvcykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5wb3MsIHBvcyk7IH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBBbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgZm9yIG1lbW9yeS5cbi8vXG4vLyBJdCBjb3N0cyAxMCUgb2YgcGVyZm9ybWFuY2UsIGJ1dCBhbGxvd3MgZXh0ZW5kIHRlcm1pbmF0b3JzIGxpc3QsIGlmIHBsYWNlIGl0XG4vLyB0byBgUGFyY2VySW5saW5lYCBwcm9wZXJ0eS4gUHJvYmFibHksIHdpbGwgc3dpdGNoIHRvIGl0IHNvbWV0aW1lLCBzdWNoXG4vLyBmbGV4aWJpbGl0eSByZXF1aXJlZC5cblxuLypcbnZhciBURVJNSU5BVE9SX1JFID0gL1tcXG4hIyQlJiorXFwtOjw9PkBbXFxcXFxcXV5fYHt9fl0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHQoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG9zID0gc3RhdGUucG9zLFxuICAgICAgaWR4ID0gc3RhdGUuc3JjLnNsaWNlKHBvcykuc2VhcmNoKFRFUk1JTkFUT1JfUkUpO1xuXG4gIC8vIGZpcnN0IGNoYXIgaXMgdGVybWluYXRvciAtPiBlbXB0eSB0ZXh0XG4gIGlmIChpZHggPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbm8gdGVybWluYXRvciAtPiB0ZXh0IHRpbGwgZW5kIG9mIHN0cmluZ1xuICBpZiAoaWR4IDwgMCkge1xuICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcyk7IH1cbiAgICBzdGF0ZS5wb3MgPSBzdGF0ZS5zcmMubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBwb3MgKyBpZHgpOyB9XG5cbiAgc3RhdGUucG9zICs9IGlkeDtcblxuICByZXR1cm4gdHJ1ZTtcbn07Ki9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dC5qcyIsIi8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgaW50byBvbmUsIGFuZCByZS1jYWxjdWxhdGUgYWxsIHRva2VuIGxldmVsc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHRfY29sbGFwc2Uoc3RhdGUpIHtcbiAgdmFyIGN1cnIsIGxhc3QsXG4gICAgICBsZXZlbCA9IDAsXG4gICAgICB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsXG4gICAgICBtYXggPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuXG4gIGZvciAoY3VyciA9IGxhc3QgPSAwOyBjdXJyIDwgbWF4OyBjdXJyKyspIHtcbiAgICAvLyByZS1jYWxjdWxhdGUgbGV2ZWxzXG4gICAgbGV2ZWwgKz0gdG9rZW5zW2N1cnJdLm5lc3Rpbmc7XG4gICAgdG9rZW5zW2N1cnJdLmxldmVsID0gbGV2ZWw7XG5cbiAgICBpZiAodG9rZW5zW2N1cnJdLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICBjdXJyICsgMSA8IG1heCAmJlxuICAgICAgICB0b2tlbnNbY3VyciArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuXG4gICAgICAvLyBjb2xsYXBzZSB0d28gYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50ID0gdG9rZW5zW2N1cnJdLmNvbnRlbnQgKyB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyICE9PSBsYXN0KSB7IHRva2Vuc1tsYXN0XSA9IHRva2Vuc1tjdXJyXTsgfVxuXG4gICAgICBsYXN0Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnIgIT09IGxhc3QpIHtcbiAgICB0b2tlbnMubGVuZ3RoID0gbGFzdDtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxudmFyIGRlY29kZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBjYWNoZS5wdXNoKGNoKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgY2ggPSBleGNsdWRlLmNoYXJDb2RlQXQoaSk7XG4gICAgY2FjaGVbY2hdID0gJyUnICsgKCcwJyArIGNoLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59XG5cblxuLy8gRGVjb2RlIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcuXG4vL1xuZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgZXhjbHVkZSkge1xuICB2YXIgY2FjaGU7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIGV4Y2x1ZGUgPSBkZWNvZGUuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgY2FjaGUgPSBnZXREZWNvZGVDYWNoZShleGNsdWRlKTtcblxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyglW2EtZjAtOV17Mn0pKy9naSwgZnVuY3Rpb24oc2VxKSB7XG4gICAgdmFyIGksIGwsIGIxLCBiMiwgYjMsIGI0LCBjaHIsXG4gICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHNlcS5sZW5ndGg7IGkgPCBsOyBpICs9IDMpIHtcbiAgICAgIGIxID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxLCBpICsgMyksIDE2KTtcblxuICAgICAgaWYgKGIxIDwgMHg4MCkge1xuICAgICAgICByZXN1bHQgKz0gY2FjaGVbYjFdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RTApID09PSAweEMwICYmIChpICsgMyA8IGwpKSB7XG4gICAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDYpICYgMHg3QzApIHwgKGIyICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAzO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEYwKSA9PT0gMHhFMCAmJiAoaSArIDYgPCBsKSkge1xuICAgICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDEyKSAmIDB4RjAwMCkgfCAoKGIyIDw8IDYpICYgMHhGQzApIHwgKGIzICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHg4MDAgfHwgKGNociA+PSAweEQ4MDAgJiYgY2hyIDw9IDB4REZGRikpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDY7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjgpID09PSAweEYwICYmIChpICsgOSA8IGwpKSB7XG4gICAgICAgIC8vIDExMTExMHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuICAgICAgICBiNCA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMTAsIGkgKyAxMiksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODAgJiYgKGI0ICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDE4KSAmIDB4MUMwMDAwKSB8ICgoYjIgPDwgMTIpICYgMHgzRjAwMCkgfCAoKGIzIDw8IDYpICYgMHhGQzApIHwgKGI0ICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHgxMDAwMCB8fCBjaHIgPiAweDEwRkZGRikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyIC09IDB4MTAwMDA7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoY2hyID4+IDEwKSwgMHhEQzAwICsgKGNociAmIDB4M0ZGKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA5O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG5cblxuZGVjb2RlLmRlZmF1bHRDaGFycyAgID0gJzsvPzpAJj0rJCwjJztcbmRlY29kZS5jb21wb25lbnRDaGFycyA9ICcnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZGVjb2RlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGVuY29kZUNhY2hlID0ge307XG5cblxuLy8gQ3JlYXRlIGEgbG9va3VwIGFycmF5IHdoZXJlIGFueXRoaW5nIGJ1dCBjaGFyYWN0ZXJzIGluIGBjaGFyc2Agc3RyaW5nXG4vLyBhbmQgYWxwaGFudW1lcmljIGNoYXJzIGlzIHBlcmNlbnQtZW5jb2RlZC5cbi8vXG5mdW5jdGlvbiBnZXRFbmNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG5cbiAgICBpZiAoL15bMC05YS16XSQvaS50ZXN0KGNoKSkge1xuICAgICAgLy8gYWx3YXlzIGFsbG93IHVuZW5jb2RlZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgY2FjaGUucHVzaChjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLnB1c2goJyUnICsgKCcwJyArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZVtleGNsdWRlLmNoYXJDb2RlQXQoaSldID0gZXhjbHVkZVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBFbmNvZGUgdW5zYWZlIGNoYXJhY3RlcnMgd2l0aCBwZXJjZW50LWVuY29kaW5nLCBza2lwcGluZyBhbHJlYWR5XG4vLyBlbmNvZGVkIHNlcXVlbmNlcy5cbi8vXG4vLyAgLSBzdHJpbmcgICAgICAgLSBzdHJpbmcgdG8gZW5jb2RlXG4vLyAgLSBleGNsdWRlICAgICAgLSBsaXN0IG9mIGNoYXJhY3RlcnMgdG8gaWdub3JlIChpbiBhZGRpdGlvbiB0byBhLXpBLVowLTkpXG4vLyAgLSBrZWVwRXNjYXBlZCAgLSBkb24ndCBlbmNvZGUgJyUnIGluIGEgY29ycmVjdCBlc2NhcGUgc2VxdWVuY2UgKGRlZmF1bHQ6IHRydWUpXG4vL1xuZnVuY3Rpb24gZW5jb2RlKHN0cmluZywgZXhjbHVkZSwga2VlcEVzY2FwZWQpIHtcbiAgdmFyIGksIGwsIGNvZGUsIG5leHRDb2RlLCBjYWNoZSxcbiAgICAgIHJlc3VsdCA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBlbmNvZGUoc3RyaW5nLCBrZWVwRXNjYXBlZClcbiAgICBrZWVwRXNjYXBlZCAgPSBleGNsdWRlO1xuICAgIGV4Y2x1ZGUgPSBlbmNvZGUuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBrZWVwRXNjYXBlZCA9IHRydWU7XG4gIH1cblxuICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUgPT09IDB4MjUgLyogJSAqLyAmJiBpICsgMiA8IGwpIHtcbiAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoaSwgaSArIDMpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICByZXN1bHQgKz0gY2FjaGVbY29kZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcbiAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REJGRiAmJiBpICsgMSA8IGwpIHtcbiAgICAgICAgbmV4dENvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgIGlmIChuZXh0Q29kZSA+PSAweERDMDAgJiYgbmV4dENvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0gKyBzdHJpbmdbaSArIDFdKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmVuY29kZS5kZWZhdWx0Q2hhcnMgICA9IFwiOy8/OkAmPSskLC1fLiF+KicoKSNcIjtcbmVuY29kZS5jb21wb25lbnRDaGFycyA9IFwiLV8uIX4qJygpXCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9lbmNvZGUuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvcm1hdCh1cmwpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIHJlc3VsdCArPSB1cmwucHJvdG9jb2wgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2xhc2hlcyA/ICcvLycgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5hdXRoID8gdXJsLmF1dGggKyAnQCcgOiAnJztcblxuICBpZiAodXJsLmhvc3RuYW1lICYmIHVybC5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgLy8gaXB2NiBhZGRyZXNzXG4gICAgcmVzdWx0ICs9ICdbJyArIHVybC5ob3N0bmFtZSArICddJztcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gdXJsLmhvc3RuYW1lIHx8ICcnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5wb3J0ID8gJzonICsgdXJsLnBvcnQgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5wYXRobmFtZSB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zZWFyY2ggfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuaGFzaCB8fCAnJztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2Zvcm1hdC5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBDaGFuZ2VzIGZyb20gam95ZW50L25vZGU6XG4vL1xuLy8gMS4gTm8gbGVhZGluZyBzbGFzaCBpbiBwYXRocyxcbi8vICAgIGUuZy4gaW4gYHVybC5wYXJzZSgnaHR0cDovL2Zvbz9iYXInKWAgcGF0aG5hbWUgaXMgYGAsIG5vdCBgL2Bcbi8vXG4vLyAyLiBCYWNrc2xhc2hlcyBhcmUgbm90IHJlcGxhY2VkIHdpdGggc2xhc2hlcyxcbi8vICAgIHNvIGBodHRwOlxcXFxleGFtcGxlLm9yZ1xcYCBpcyB0cmVhdGVkIGxpa2UgYSByZWxhdGl2ZSBwYXRoXG4vL1xuLy8gMy4gVHJhaWxpbmcgY29sb24gaXMgdHJlYXRlZCBsaWtlIGEgcGFydCBvZiB0aGUgcGF0aCxcbi8vICAgIGkuZS4gaW4gYGh0dHA6Ly9leGFtcGxlLm9yZzpmb29gIHBhdGhuYW1lIGlzIGA6Zm9vYFxuLy9cbi8vIDQuIE5vdGhpbmcgaXMgVVJMLWVuY29kZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsXG4vLyAgICAoaW4gam95ZW50L25vZGUgc29tZSBjaGFycyBpbiBhdXRoIGFuZCBwYXRocyBhcmUgZW5jb2RlZClcbi8vXG4vLyA1LiBgdXJsLnBhcnNlKClgIGRvZXMgbm90IGhhdmUgYHBhcnNlUXVlcnlTdHJpbmdgIGFyZ3VtZW50XG4vL1xuLy8gNi4gUmVtb3ZlZCBleHRyYW5lb3VzIHJlc3VsdCBwcm9wZXJ0aWVzOiBgaG9zdGAsIGBwYXRoYCwgYHF1ZXJ5YCwgZXRjLixcbi8vICAgIHdoaWNoIGNhbiBiZSBjb25zdHJ1Y3RlZCB1c2luZyBvdGhlciBwYXJ0cyBvZiB0aGUgdXJsLlxuLy9cblxuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyAnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCcgXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyAneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnIF0uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsgJ1xcJycgXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsgJyUnLCAnLycsICc/JywgJzsnLCAnIycgXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWyAnLycsICc/JywgJyMnIF0sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zY3JpcHQtdXJsICovXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2NyaXB0LXVybCAqL1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSB7IHJldHVybiB1cmw7IH1cblxuICB2YXIgdSA9IG5ldyBVcmwoKTtcbiAgdS5wYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIHZhciBpLCBsLCBsb3dlclByb3RvLCBoZWMsIHNsYXNoZXMsXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IHByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChyZXN0W2hvc3RFbmQgLSAxXSA9PT0gJzonKSB7IGhvc3RFbmQtLTsgfVxuICAgIHZhciBob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoaG9zdCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH1cbiAgaWYgKHJlc3QpIHsgdGhpcy5wYXRobmFtZSA9IHJlc3Q7IH1cbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnJztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbihob3N0KSB7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB7IHRoaXMuaG9zdG5hbWUgPSBob3N0OyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybFBhcnNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvcGFyc2UuanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vcHJvY2Vzcy9icm93c2VyLmpzIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2ZpeFVybHMuanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xceEFEXFx1MDYwMC1cXHUwNjA1XFx1MDYxQ1xcdTA2RERcXHUwNzBGXFx1MDhFMlxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNjRcXHUyMDY2LVxcdTIwNkZcXHVGRUZGXFx1RkZGOS1cXHVGRkZCXXxcXHVEODA0XFx1RENCRHxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdURCNDBbXFx1REMwMVxcdURDMjAtXFx1REM3Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5BbnkgPSByZXF1aXJlKCcuL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jyk7XG5leHBvcnRzLkNjICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DYy9yZWdleCcpO1xuZXhwb3J0cy5DZiAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2YvcmVnZXgnKTtcbmV4cG9ydHMuUCAgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL1AvcmVnZXgnKTtcbmV4cG9ydHMuWiAgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL1ovcmVnZXgnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5fMXVQejJsVDlmVnFWSk5CZXhFSEtTcXt3aWR0aDoxMDAlO2ZvbnQtc2l6ZToyNHB0O3BhZGRpbmctbGVmdDoxMHB4fS5fMm5TNm01N3A3ZEpqeS1Xd05ZeHp2ZXt3aWR0aDoxMDAlO2ZvbnQtc2l6ZToxOHB0O3BhZGRpbmctbGVmdDoxMHB4fS5fMllyS0VtcnVTWHEtTFk4SFQ5Z2pjQXtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlO2hlaWdodDpjYWxjKDEwMCUgLSAyMzBweCl9Ll8xS2NFN3JoMU1LQXlldmQyZU1fQXRne3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JhY2tncm91bmQ6I2ZjZmNmYztwYWRkaW5nOjEwcHg7b3ZlcmZsb3c6YXV0bztoZWlnaHQ6MTAwJX0uXzJWN3k2QWZGTEdVWHVKRmRsZWVtcXtsZWZ0OjB9Ll80OU9SaFBSeVgwZlJEbUZxUzVBbVp7bGVmdDo1MCU7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5fM0w1TkVCODRLeFBmbHhCWnZleXNkZHt0ZXh0LWFsaWduOnJpZ2h0O21hcmdpbi10b3A6MTVweH0uXzM0VWZlRWxVYUJTYTEyWnBRUi1hWEh7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtyZXNpemU6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiNmY2ZjZmM7Ym9yZGVyOm5vbmU7Zm9udC1zaXplOjEwcHR9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwidGl0bGVcIjogXCJfMXVQejJsVDlmVnFWSk5CZXhFSEtTcVwiLFxuXHRcInRhZ3NcIjogXCJfMm5TNm01N3A3ZEpqeS1Xd05ZeHp2ZVwiLFxuXHRcImVkaXRvcldyYXBcIjogXCJfMllyS0VtcnVTWHEtTFk4SFQ5Z2pjQVwiLFxuXHRcImVkaXRvclwiOiBcIl8xS2NFN3JoMU1LQXlldmQyZU1fQXRnXCIsXG5cdFwiZWRpdG9yTGVmdFNpZGVcIjogXCJfMlY3eTZBZkZMR1VYdUpGZGxlZW1xXCIsXG5cdFwiZWRpdG9yUmlnaHRTaWRlXCI6IFwiXzQ5T1JoUFJ5WDBmUkRtRnFTNUFtWlwiLFxuXHRcInNhdmVCdXR0b25cIjogXCJfM0w1TkVCODRLeFBmbHhCWnZleXNkZFwiLFxuXHRcInRleHRhcmVhXCI6IFwiXzM0VWZlRWxVYUJTYTEyWnBRUi1hWEhcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2Nzcy1sb2FkZXI/e1wibW9kdWxlc1wiOnRydWUsXCJtaW5pbWl6ZVwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlfSEuL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5fMVg0Q3lOY2tfMWN5X1h1dXRsYUZ5eHt3aWR0aDoxMDAlO2ZvbnQtc2l6ZToyNHB0O3BhZGRpbmctbGVmdDoxMHB4fS5pSk1mWXNXeWpkSTJvV05CaHlwN1N7d2lkdGg6MTAwJTtmb250LXNpemU6MThwdDtwYWRkaW5nLWxlZnQ6MTBweH0uXzNUSFdKbzFwOUtuUzJwQ2pCNlppQnp7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtoZWlnaHQ6Y2FsYygxMDAlIC0gMjMwcHgpfS5fMXFXYm4yY2M4ZXdfTDFKd1BXVUZ3cntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtiYWNrZ3JvdW5kOiNmY2ZjZmM7cGFkZGluZzoxMHB4O292ZXJmbG93OmF1dG87aGVpZ2h0OjEwMCV9LkNRUHowQkM5aVhRejgxS0dhMHhOaHtsZWZ0OjB9Ll8zSXhCMlY2OHhuNU1wUTd1YkMxd2tQe2xlZnQ6NTAlO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uXzN1QVdzTVh1UjA4WlVweE1odFo2UmV7dGV4dC1hbGlnbjpyaWdodDttYXJnaW4tdG9wOjE1cHh9LmJmODZUWEEyeUxGMTU4WVFZdTlhe3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7cmVzaXplOm5vbmU7YmFja2dyb3VuZC1jb2xvcjojZmNmY2ZjO2JvcmRlcjpub25lO2ZvbnQtc2l6ZToxMHB0fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInRpdGxlXCI6IFwiXzFYNEN5TmNrXzFjeV9YdXV0bGFGeXhcIixcblx0XCJ0YWdzXCI6IFwiaUpNZllzV3lqZEkyb1dOQmh5cDdTXCIsXG5cdFwiZWRpdG9yV3JhcFwiOiBcIl8zVEhXSm8xcDlLblMycENqQjZaaUJ6XCIsXG5cdFwiZWRpdG9yXCI6IFwiXzFxV2JuMmNjOGV3X0wxSndQV1VGd3JcIixcblx0XCJlZGl0b3JMZWZ0U2lkZVwiOiBcIkNRUHowQkM5aVhRejgxS0dhMHhOaFwiLFxuXHRcImVkaXRvclJpZ2h0U2lkZVwiOiBcIl8zSXhCMlY2OHhuNU1wUTd1YkMxd2tQXCIsXG5cdFwic2F2ZUJ1dHRvblwiOiBcIl8zdUFXc01YdVIwOFpVcHhNaHRaNlJlXCIsXG5cdFwidGV4dGFyZWFcIjogXCJiZjg2VFhBMnlMRjE1OFlRWXU5YVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vY3NzLWxvYWRlcj97XCJtb2R1bGVzXCI6dHJ1ZSxcIm1pbmltaXplXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWV9IS4uL2NvbXBvbmVudHMvc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiQWFjdXRlXCI6IFwiw4FcIixcblx0XCJhYWN1dGVcIjogXCLDoVwiLFxuXHRcIkFicmV2ZVwiOiBcIsSCXCIsXG5cdFwiYWJyZXZlXCI6IFwixINcIixcblx0XCJhY1wiOiBcIuKIvlwiLFxuXHRcImFjZFwiOiBcIuKIv1wiLFxuXHRcImFjRVwiOiBcIuKIvsyzXCIsXG5cdFwiQWNpcmNcIjogXCLDglwiLFxuXHRcImFjaXJjXCI6IFwiw6JcIixcblx0XCJhY3V0ZVwiOiBcIsK0XCIsXG5cdFwiQWN5XCI6IFwi0JBcIixcblx0XCJhY3lcIjogXCLQsFwiLFxuXHRcIkFFbGlnXCI6IFwiw4ZcIixcblx0XCJhZWxpZ1wiOiBcIsOmXCIsXG5cdFwiYWZcIjogXCLigaFcIixcblx0XCJBZnJcIjogXCLwnZSEXCIsXG5cdFwiYWZyXCI6IFwi8J2UnlwiLFxuXHRcIkFncmF2ZVwiOiBcIsOAXCIsXG5cdFwiYWdyYXZlXCI6IFwiw6BcIixcblx0XCJhbGVmc3ltXCI6IFwi4oS1XCIsXG5cdFwiYWxlcGhcIjogXCLihLVcIixcblx0XCJBbHBoYVwiOiBcIs6RXCIsXG5cdFwiYWxwaGFcIjogXCLOsVwiLFxuXHRcIkFtYWNyXCI6IFwixIBcIixcblx0XCJhbWFjclwiOiBcIsSBXCIsXG5cdFwiYW1hbGdcIjogXCLiqL9cIixcblx0XCJhbXBcIjogXCImXCIsXG5cdFwiQU1QXCI6IFwiJlwiLFxuXHRcImFuZGFuZFwiOiBcIuKplVwiLFxuXHRcIkFuZFwiOiBcIuKpk1wiLFxuXHRcImFuZFwiOiBcIuKIp1wiLFxuXHRcImFuZGRcIjogXCLiqZxcIixcblx0XCJhbmRzbG9wZVwiOiBcIuKpmFwiLFxuXHRcImFuZHZcIjogXCLiqZpcIixcblx0XCJhbmdcIjogXCLiiKBcIixcblx0XCJhbmdlXCI6IFwi4qakXCIsXG5cdFwiYW5nbGVcIjogXCLiiKBcIixcblx0XCJhbmdtc2RhYVwiOiBcIuKmqFwiLFxuXHRcImFuZ21zZGFiXCI6IFwi4qapXCIsXG5cdFwiYW5nbXNkYWNcIjogXCLipqpcIixcblx0XCJhbmdtc2RhZFwiOiBcIuKmq1wiLFxuXHRcImFuZ21zZGFlXCI6IFwi4qasXCIsXG5cdFwiYW5nbXNkYWZcIjogXCLipq1cIixcblx0XCJhbmdtc2RhZ1wiOiBcIuKmrlwiLFxuXHRcImFuZ21zZGFoXCI6IFwi4qavXCIsXG5cdFwiYW5nbXNkXCI6IFwi4oihXCIsXG5cdFwiYW5ncnRcIjogXCLiiJ9cIixcblx0XCJhbmdydHZiXCI6IFwi4oq+XCIsXG5cdFwiYW5ncnR2YmRcIjogXCLipp1cIixcblx0XCJhbmdzcGhcIjogXCLiiKJcIixcblx0XCJhbmdzdFwiOiBcIsOFXCIsXG5cdFwiYW5nemFyclwiOiBcIuKNvFwiLFxuXHRcIkFvZ29uXCI6IFwixIRcIixcblx0XCJhb2dvblwiOiBcIsSFXCIsXG5cdFwiQW9wZlwiOiBcIvCdlLhcIixcblx0XCJhb3BmXCI6IFwi8J2VklwiLFxuXHRcImFwYWNpclwiOiBcIuKpr1wiLFxuXHRcImFwXCI6IFwi4omIXCIsXG5cdFwiYXBFXCI6IFwi4qmwXCIsXG5cdFwiYXBlXCI6IFwi4omKXCIsXG5cdFwiYXBpZFwiOiBcIuKJi1wiLFxuXHRcImFwb3NcIjogXCInXCIsXG5cdFwiQXBwbHlGdW5jdGlvblwiOiBcIuKBoVwiLFxuXHRcImFwcHJveFwiOiBcIuKJiFwiLFxuXHRcImFwcHJveGVxXCI6IFwi4omKXCIsXG5cdFwiQXJpbmdcIjogXCLDhVwiLFxuXHRcImFyaW5nXCI6IFwiw6VcIixcblx0XCJBc2NyXCI6IFwi8J2SnFwiLFxuXHRcImFzY3JcIjogXCLwnZK2XCIsXG5cdFwiQXNzaWduXCI6IFwi4omUXCIsXG5cdFwiYXN0XCI6IFwiKlwiLFxuXHRcImFzeW1wXCI6IFwi4omIXCIsXG5cdFwiYXN5bXBlcVwiOiBcIuKJjVwiLFxuXHRcIkF0aWxkZVwiOiBcIsODXCIsXG5cdFwiYXRpbGRlXCI6IFwiw6NcIixcblx0XCJBdW1sXCI6IFwiw4RcIixcblx0XCJhdW1sXCI6IFwiw6RcIixcblx0XCJhd2NvbmludFwiOiBcIuKIs1wiLFxuXHRcImF3aW50XCI6IFwi4qiRXCIsXG5cdFwiYmFja2NvbmdcIjogXCLiiYxcIixcblx0XCJiYWNrZXBzaWxvblwiOiBcIs+2XCIsXG5cdFwiYmFja3ByaW1lXCI6IFwi4oC1XCIsXG5cdFwiYmFja3NpbVwiOiBcIuKIvVwiLFxuXHRcImJhY2tzaW1lcVwiOiBcIuKLjVwiLFxuXHRcIkJhY2tzbGFzaFwiOiBcIuKIllwiLFxuXHRcIkJhcnZcIjogXCLiq6dcIixcblx0XCJiYXJ2ZWVcIjogXCLiir1cIixcblx0XCJiYXJ3ZWRcIjogXCLijIVcIixcblx0XCJCYXJ3ZWRcIjogXCLijIZcIixcblx0XCJiYXJ3ZWRnZVwiOiBcIuKMhVwiLFxuXHRcImJicmtcIjogXCLijrVcIixcblx0XCJiYnJrdGJya1wiOiBcIuKOtlwiLFxuXHRcImJjb25nXCI6IFwi4omMXCIsXG5cdFwiQmN5XCI6IFwi0JFcIixcblx0XCJiY3lcIjogXCLQsVwiLFxuXHRcImJkcXVvXCI6IFwi4oCeXCIsXG5cdFwiYmVjYXVzXCI6IFwi4oi1XCIsXG5cdFwiYmVjYXVzZVwiOiBcIuKItVwiLFxuXHRcIkJlY2F1c2VcIjogXCLiiLVcIixcblx0XCJiZW1wdHl2XCI6IFwi4qawXCIsXG5cdFwiYmVwc2lcIjogXCLPtlwiLFxuXHRcImJlcm5vdVwiOiBcIuKErFwiLFxuXHRcIkJlcm5vdWxsaXNcIjogXCLihKxcIixcblx0XCJCZXRhXCI6IFwizpJcIixcblx0XCJiZXRhXCI6IFwizrJcIixcblx0XCJiZXRoXCI6IFwi4oS2XCIsXG5cdFwiYmV0d2VlblwiOiBcIuKJrFwiLFxuXHRcIkJmclwiOiBcIvCdlIVcIixcblx0XCJiZnJcIjogXCLwnZSfXCIsXG5cdFwiYmlnY2FwXCI6IFwi4ouCXCIsXG5cdFwiYmlnY2lyY1wiOiBcIuKXr1wiLFxuXHRcImJpZ2N1cFwiOiBcIuKLg1wiLFxuXHRcImJpZ29kb3RcIjogXCLiqIBcIixcblx0XCJiaWdvcGx1c1wiOiBcIuKogVwiLFxuXHRcImJpZ290aW1lc1wiOiBcIuKoglwiLFxuXHRcImJpZ3NxY3VwXCI6IFwi4qiGXCIsXG5cdFwiYmlnc3RhclwiOiBcIuKYhVwiLFxuXHRcImJpZ3RyaWFuZ2xlZG93blwiOiBcIuKWvVwiLFxuXHRcImJpZ3RyaWFuZ2xldXBcIjogXCLilrNcIixcblx0XCJiaWd1cGx1c1wiOiBcIuKohFwiLFxuXHRcImJpZ3ZlZVwiOiBcIuKLgVwiLFxuXHRcImJpZ3dlZGdlXCI6IFwi4ouAXCIsXG5cdFwiYmthcm93XCI6IFwi4qSNXCIsXG5cdFwiYmxhY2tsb3plbmdlXCI6IFwi4qerXCIsXG5cdFwiYmxhY2tzcXVhcmVcIjogXCLilqpcIixcblx0XCJibGFja3RyaWFuZ2xlXCI6IFwi4pa0XCIsXG5cdFwiYmxhY2t0cmlhbmdsZWRvd25cIjogXCLilr5cIixcblx0XCJibGFja3RyaWFuZ2xlbGVmdFwiOiBcIuKXglwiLFxuXHRcImJsYWNrdHJpYW5nbGVyaWdodFwiOiBcIuKWuFwiLFxuXHRcImJsYW5rXCI6IFwi4pCjXCIsXG5cdFwiYmxrMTJcIjogXCLilpJcIixcblx0XCJibGsxNFwiOiBcIuKWkVwiLFxuXHRcImJsazM0XCI6IFwi4paTXCIsXG5cdFwiYmxvY2tcIjogXCLilohcIixcblx0XCJibmVcIjogXCI94oOlXCIsXG5cdFwiYm5lcXVpdlwiOiBcIuKJoeKDpVwiLFxuXHRcImJOb3RcIjogXCLiq61cIixcblx0XCJibm90XCI6IFwi4oyQXCIsXG5cdFwiQm9wZlwiOiBcIvCdlLlcIixcblx0XCJib3BmXCI6IFwi8J2Vk1wiLFxuXHRcImJvdFwiOiBcIuKKpVwiLFxuXHRcImJvdHRvbVwiOiBcIuKKpVwiLFxuXHRcImJvd3RpZVwiOiBcIuKLiFwiLFxuXHRcImJveGJveFwiOiBcIuKniVwiLFxuXHRcImJveGRsXCI6IFwi4pSQXCIsXG5cdFwiYm94ZExcIjogXCLilZVcIixcblx0XCJib3hEbFwiOiBcIuKVllwiLFxuXHRcImJveERMXCI6IFwi4pWXXCIsXG5cdFwiYm94ZHJcIjogXCLilIxcIixcblx0XCJib3hkUlwiOiBcIuKVklwiLFxuXHRcImJveERyXCI6IFwi4pWTXCIsXG5cdFwiYm94RFJcIjogXCLilZRcIixcblx0XCJib3hoXCI6IFwi4pSAXCIsXG5cdFwiYm94SFwiOiBcIuKVkFwiLFxuXHRcImJveGhkXCI6IFwi4pSsXCIsXG5cdFwiYm94SGRcIjogXCLilaRcIixcblx0XCJib3hoRFwiOiBcIuKVpVwiLFxuXHRcImJveEhEXCI6IFwi4pWmXCIsXG5cdFwiYm94aHVcIjogXCLilLRcIixcblx0XCJib3hIdVwiOiBcIuKVp1wiLFxuXHRcImJveGhVXCI6IFwi4pWoXCIsXG5cdFwiYm94SFVcIjogXCLilalcIixcblx0XCJib3htaW51c1wiOiBcIuKKn1wiLFxuXHRcImJveHBsdXNcIjogXCLiip5cIixcblx0XCJib3h0aW1lc1wiOiBcIuKKoFwiLFxuXHRcImJveHVsXCI6IFwi4pSYXCIsXG5cdFwiYm94dUxcIjogXCLilZtcIixcblx0XCJib3hVbFwiOiBcIuKVnFwiLFxuXHRcImJveFVMXCI6IFwi4pWdXCIsXG5cdFwiYm94dXJcIjogXCLilJRcIixcblx0XCJib3h1UlwiOiBcIuKVmFwiLFxuXHRcImJveFVyXCI6IFwi4pWZXCIsXG5cdFwiYm94VVJcIjogXCLilZpcIixcblx0XCJib3h2XCI6IFwi4pSCXCIsXG5cdFwiYm94VlwiOiBcIuKVkVwiLFxuXHRcImJveHZoXCI6IFwi4pS8XCIsXG5cdFwiYm94dkhcIjogXCLilapcIixcblx0XCJib3hWaFwiOiBcIuKVq1wiLFxuXHRcImJveFZIXCI6IFwi4pWsXCIsXG5cdFwiYm94dmxcIjogXCLilKRcIixcblx0XCJib3h2TFwiOiBcIuKVoVwiLFxuXHRcImJveFZsXCI6IFwi4pWiXCIsXG5cdFwiYm94VkxcIjogXCLilaNcIixcblx0XCJib3h2clwiOiBcIuKUnFwiLFxuXHRcImJveHZSXCI6IFwi4pWeXCIsXG5cdFwiYm94VnJcIjogXCLilZ9cIixcblx0XCJib3hWUlwiOiBcIuKVoFwiLFxuXHRcImJwcmltZVwiOiBcIuKAtVwiLFxuXHRcImJyZXZlXCI6IFwiy5hcIixcblx0XCJCcmV2ZVwiOiBcIsuYXCIsXG5cdFwiYnJ2YmFyXCI6IFwiwqZcIixcblx0XCJic2NyXCI6IFwi8J2St1wiLFxuXHRcIkJzY3JcIjogXCLihKxcIixcblx0XCJic2VtaVwiOiBcIuKBj1wiLFxuXHRcImJzaW1cIjogXCLiiL1cIixcblx0XCJic2ltZVwiOiBcIuKLjVwiLFxuXHRcImJzb2xiXCI6IFwi4qeFXCIsXG5cdFwiYnNvbFwiOiBcIlxcXFxcIixcblx0XCJic29saHN1YlwiOiBcIuKfiFwiLFxuXHRcImJ1bGxcIjogXCLigKJcIixcblx0XCJidWxsZXRcIjogXCLigKJcIixcblx0XCJidW1wXCI6IFwi4omOXCIsXG5cdFwiYnVtcEVcIjogXCLiqq5cIixcblx0XCJidW1wZVwiOiBcIuKJj1wiLFxuXHRcIkJ1bXBlcVwiOiBcIuKJjlwiLFxuXHRcImJ1bXBlcVwiOiBcIuKJj1wiLFxuXHRcIkNhY3V0ZVwiOiBcIsSGXCIsXG5cdFwiY2FjdXRlXCI6IFwixIdcIixcblx0XCJjYXBhbmRcIjogXCLiqYRcIixcblx0XCJjYXBicmN1cFwiOiBcIuKpiVwiLFxuXHRcImNhcGNhcFwiOiBcIuKpi1wiLFxuXHRcImNhcFwiOiBcIuKIqVwiLFxuXHRcIkNhcFwiOiBcIuKLklwiLFxuXHRcImNhcGN1cFwiOiBcIuKph1wiLFxuXHRcImNhcGRvdFwiOiBcIuKpgFwiLFxuXHRcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6IFwi4oWFXCIsXG5cdFwiY2Fwc1wiOiBcIuKIqe+4gFwiLFxuXHRcImNhcmV0XCI6IFwi4oGBXCIsXG5cdFwiY2Fyb25cIjogXCLLh1wiLFxuXHRcIkNheWxleXNcIjogXCLihK1cIixcblx0XCJjY2Fwc1wiOiBcIuKpjVwiLFxuXHRcIkNjYXJvblwiOiBcIsSMXCIsXG5cdFwiY2Nhcm9uXCI6IFwixI1cIixcblx0XCJDY2VkaWxcIjogXCLDh1wiLFxuXHRcImNjZWRpbFwiOiBcIsOnXCIsXG5cdFwiQ2NpcmNcIjogXCLEiFwiLFxuXHRcImNjaXJjXCI6IFwixIlcIixcblx0XCJDY29uaW50XCI6IFwi4oiwXCIsXG5cdFwiY2N1cHNcIjogXCLiqYxcIixcblx0XCJjY3Vwc3NtXCI6IFwi4qmQXCIsXG5cdFwiQ2RvdFwiOiBcIsSKXCIsXG5cdFwiY2RvdFwiOiBcIsSLXCIsXG5cdFwiY2VkaWxcIjogXCLCuFwiLFxuXHRcIkNlZGlsbGFcIjogXCLCuFwiLFxuXHRcImNlbXB0eXZcIjogXCLiprJcIixcblx0XCJjZW50XCI6IFwiwqJcIixcblx0XCJjZW50ZXJkb3RcIjogXCLCt1wiLFxuXHRcIkNlbnRlckRvdFwiOiBcIsK3XCIsXG5cdFwiY2ZyXCI6IFwi8J2UoFwiLFxuXHRcIkNmclwiOiBcIuKErVwiLFxuXHRcIkNIY3lcIjogXCLQp1wiLFxuXHRcImNoY3lcIjogXCLRh1wiLFxuXHRcImNoZWNrXCI6IFwi4pyTXCIsXG5cdFwiY2hlY2ttYXJrXCI6IFwi4pyTXCIsXG5cdFwiQ2hpXCI6IFwizqdcIixcblx0XCJjaGlcIjogXCLPh1wiLFxuXHRcImNpcmNcIjogXCLLhlwiLFxuXHRcImNpcmNlcVwiOiBcIuKJl1wiLFxuXHRcImNpcmNsZWFycm93bGVmdFwiOiBcIuKGulwiLFxuXHRcImNpcmNsZWFycm93cmlnaHRcIjogXCLihrtcIixcblx0XCJjaXJjbGVkYXN0XCI6IFwi4oqbXCIsXG5cdFwiY2lyY2xlZGNpcmNcIjogXCLiippcIixcblx0XCJjaXJjbGVkZGFzaFwiOiBcIuKKnVwiLFxuXHRcIkNpcmNsZURvdFwiOiBcIuKKmVwiLFxuXHRcImNpcmNsZWRSXCI6IFwiwq5cIixcblx0XCJjaXJjbGVkU1wiOiBcIuKTiFwiLFxuXHRcIkNpcmNsZU1pbnVzXCI6IFwi4oqWXCIsXG5cdFwiQ2lyY2xlUGx1c1wiOiBcIuKKlVwiLFxuXHRcIkNpcmNsZVRpbWVzXCI6IFwi4oqXXCIsXG5cdFwiY2lyXCI6IFwi4peLXCIsXG5cdFwiY2lyRVwiOiBcIuKng1wiLFxuXHRcImNpcmVcIjogXCLiiZdcIixcblx0XCJjaXJmbmludFwiOiBcIuKokFwiLFxuXHRcImNpcm1pZFwiOiBcIuKrr1wiLFxuXHRcImNpcnNjaXJcIjogXCLip4JcIixcblx0XCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjogXCLiiLJcIixcblx0XCJDbG9zZUN1cmx5RG91YmxlUXVvdGVcIjogXCLigJ1cIixcblx0XCJDbG9zZUN1cmx5UXVvdGVcIjogXCLigJlcIixcblx0XCJjbHVic1wiOiBcIuKZo1wiLFxuXHRcImNsdWJzdWl0XCI6IFwi4pmjXCIsXG5cdFwiY29sb25cIjogXCI6XCIsXG5cdFwiQ29sb25cIjogXCLiiLdcIixcblx0XCJDb2xvbmVcIjogXCLiqbRcIixcblx0XCJjb2xvbmVcIjogXCLiiZRcIixcblx0XCJjb2xvbmVxXCI6IFwi4omUXCIsXG5cdFwiY29tbWFcIjogXCIsXCIsXG5cdFwiY29tbWF0XCI6IFwiQFwiLFxuXHRcImNvbXBcIjogXCLiiIFcIixcblx0XCJjb21wZm5cIjogXCLiiJhcIixcblx0XCJjb21wbGVtZW50XCI6IFwi4oiBXCIsXG5cdFwiY29tcGxleGVzXCI6IFwi4oSCXCIsXG5cdFwiY29uZ1wiOiBcIuKJhVwiLFxuXHRcImNvbmdkb3RcIjogXCLiqa1cIixcblx0XCJDb25ncnVlbnRcIjogXCLiiaFcIixcblx0XCJjb25pbnRcIjogXCLiiK5cIixcblx0XCJDb25pbnRcIjogXCLiiK9cIixcblx0XCJDb250b3VySW50ZWdyYWxcIjogXCLiiK5cIixcblx0XCJjb3BmXCI6IFwi8J2VlFwiLFxuXHRcIkNvcGZcIjogXCLihIJcIixcblx0XCJjb3Byb2RcIjogXCLiiJBcIixcblx0XCJDb3Byb2R1Y3RcIjogXCLiiJBcIixcblx0XCJjb3B5XCI6IFwiwqlcIixcblx0XCJDT1BZXCI6IFwiwqlcIixcblx0XCJjb3B5c3JcIjogXCLihJdcIixcblx0XCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6IFwi4oizXCIsXG5cdFwiY3JhcnJcIjogXCLihrVcIixcblx0XCJjcm9zc1wiOiBcIuKcl1wiLFxuXHRcIkNyb3NzXCI6IFwi4qivXCIsXG5cdFwiQ3NjclwiOiBcIvCdkp5cIixcblx0XCJjc2NyXCI6IFwi8J2SuFwiLFxuXHRcImNzdWJcIjogXCLiq49cIixcblx0XCJjc3ViZVwiOiBcIuKrkVwiLFxuXHRcImNzdXBcIjogXCLiq5BcIixcblx0XCJjc3VwZVwiOiBcIuKrklwiLFxuXHRcImN0ZG90XCI6IFwi4ouvXCIsXG5cdFwiY3VkYXJybFwiOiBcIuKkuFwiLFxuXHRcImN1ZGFycnJcIjogXCLipLVcIixcblx0XCJjdWVwclwiOiBcIuKLnlwiLFxuXHRcImN1ZXNjXCI6IFwi4oufXCIsXG5cdFwiY3VsYXJyXCI6IFwi4oa2XCIsXG5cdFwiY3VsYXJycFwiOiBcIuKkvVwiLFxuXHRcImN1cGJyY2FwXCI6IFwi4qmIXCIsXG5cdFwiY3VwY2FwXCI6IFwi4qmGXCIsXG5cdFwiQ3VwQ2FwXCI6IFwi4omNXCIsXG5cdFwiY3VwXCI6IFwi4oiqXCIsXG5cdFwiQ3VwXCI6IFwi4ouTXCIsXG5cdFwiY3VwY3VwXCI6IFwi4qmKXCIsXG5cdFwiY3VwZG90XCI6IFwi4oqNXCIsXG5cdFwiY3Vwb3JcIjogXCLiqYVcIixcblx0XCJjdXBzXCI6IFwi4oiq77iAXCIsXG5cdFwiY3VyYXJyXCI6IFwi4oa3XCIsXG5cdFwiY3VyYXJybVwiOiBcIuKkvFwiLFxuXHRcImN1cmx5ZXFwcmVjXCI6IFwi4oueXCIsXG5cdFwiY3VybHllcXN1Y2NcIjogXCLii59cIixcblx0XCJjdXJseXZlZVwiOiBcIuKLjlwiLFxuXHRcImN1cmx5d2VkZ2VcIjogXCLii49cIixcblx0XCJjdXJyZW5cIjogXCLCpFwiLFxuXHRcImN1cnZlYXJyb3dsZWZ0XCI6IFwi4oa2XCIsXG5cdFwiY3VydmVhcnJvd3JpZ2h0XCI6IFwi4oa3XCIsXG5cdFwiY3V2ZWVcIjogXCLii45cIixcblx0XCJjdXdlZFwiOiBcIuKLj1wiLFxuXHRcImN3Y29uaW50XCI6IFwi4oiyXCIsXG5cdFwiY3dpbnRcIjogXCLiiLFcIixcblx0XCJjeWxjdHlcIjogXCLijK1cIixcblx0XCJkYWdnZXJcIjogXCLigKBcIixcblx0XCJEYWdnZXJcIjogXCLigKFcIixcblx0XCJkYWxldGhcIjogXCLihLhcIixcblx0XCJkYXJyXCI6IFwi4oaTXCIsXG5cdFwiRGFyclwiOiBcIuKGoVwiLFxuXHRcImRBcnJcIjogXCLih5NcIixcblx0XCJkYXNoXCI6IFwi4oCQXCIsXG5cdFwiRGFzaHZcIjogXCLiq6RcIixcblx0XCJkYXNodlwiOiBcIuKKo1wiLFxuXHRcImRia2Fyb3dcIjogXCLipI9cIixcblx0XCJkYmxhY1wiOiBcIsudXCIsXG5cdFwiRGNhcm9uXCI6IFwixI5cIixcblx0XCJkY2Fyb25cIjogXCLEj1wiLFxuXHRcIkRjeVwiOiBcItCUXCIsXG5cdFwiZGN5XCI6IFwi0LRcIixcblx0XCJkZGFnZ2VyXCI6IFwi4oChXCIsXG5cdFwiZGRhcnJcIjogXCLih4pcIixcblx0XCJERFwiOiBcIuKFhVwiLFxuXHRcImRkXCI6IFwi4oWGXCIsXG5cdFwiRERvdHJhaGRcIjogXCLipJFcIixcblx0XCJkZG90c2VxXCI6IFwi4qm3XCIsXG5cdFwiZGVnXCI6IFwiwrBcIixcblx0XCJEZWxcIjogXCLiiIdcIixcblx0XCJEZWx0YVwiOiBcIs6UXCIsXG5cdFwiZGVsdGFcIjogXCLOtFwiLFxuXHRcImRlbXB0eXZcIjogXCLiprFcIixcblx0XCJkZmlzaHRcIjogXCLipb9cIixcblx0XCJEZnJcIjogXCLwnZSHXCIsXG5cdFwiZGZyXCI6IFwi8J2UoVwiLFxuXHRcImRIYXJcIjogXCLipaVcIixcblx0XCJkaGFybFwiOiBcIuKHg1wiLFxuXHRcImRoYXJyXCI6IFwi4oeCXCIsXG5cdFwiRGlhY3JpdGljYWxBY3V0ZVwiOiBcIsK0XCIsXG5cdFwiRGlhY3JpdGljYWxEb3RcIjogXCLLmVwiLFxuXHRcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjogXCLLnVwiLFxuXHRcIkRpYWNyaXRpY2FsR3JhdmVcIjogXCJgXCIsXG5cdFwiRGlhY3JpdGljYWxUaWxkZVwiOiBcIsucXCIsXG5cdFwiZGlhbVwiOiBcIuKLhFwiLFxuXHRcImRpYW1vbmRcIjogXCLii4RcIixcblx0XCJEaWFtb25kXCI6IFwi4ouEXCIsXG5cdFwiZGlhbW9uZHN1aXRcIjogXCLimaZcIixcblx0XCJkaWFtc1wiOiBcIuKZplwiLFxuXHRcImRpZVwiOiBcIsKoXCIsXG5cdFwiRGlmZmVyZW50aWFsRFwiOiBcIuKFhlwiLFxuXHRcImRpZ2FtbWFcIjogXCLPnVwiLFxuXHRcImRpc2luXCI6IFwi4ouyXCIsXG5cdFwiZGl2XCI6IFwiw7dcIixcblx0XCJkaXZpZGVcIjogXCLDt1wiLFxuXHRcImRpdmlkZW9udGltZXNcIjogXCLii4dcIixcblx0XCJkaXZvbnhcIjogXCLii4dcIixcblx0XCJESmN5XCI6IFwi0IJcIixcblx0XCJkamN5XCI6IFwi0ZJcIixcblx0XCJkbGNvcm5cIjogXCLijJ5cIixcblx0XCJkbGNyb3BcIjogXCLijI1cIixcblx0XCJkb2xsYXJcIjogXCIkXCIsXG5cdFwiRG9wZlwiOiBcIvCdlLtcIixcblx0XCJkb3BmXCI6IFwi8J2VlVwiLFxuXHRcIkRvdFwiOiBcIsKoXCIsXG5cdFwiZG90XCI6IFwiy5lcIixcblx0XCJEb3REb3RcIjogXCLig5xcIixcblx0XCJkb3RlcVwiOiBcIuKJkFwiLFxuXHRcImRvdGVxZG90XCI6IFwi4omRXCIsXG5cdFwiRG90RXF1YWxcIjogXCLiiZBcIixcblx0XCJkb3RtaW51c1wiOiBcIuKIuFwiLFxuXHRcImRvdHBsdXNcIjogXCLiiJRcIixcblx0XCJkb3RzcXVhcmVcIjogXCLiiqFcIixcblx0XCJkb3VibGViYXJ3ZWRnZVwiOiBcIuKMhlwiLFxuXHRcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbFwiOiBcIuKIr1wiLFxuXHRcIkRvdWJsZURvdFwiOiBcIsKoXCIsXG5cdFwiRG91YmxlRG93bkFycm93XCI6IFwi4oeTXCIsXG5cdFwiRG91YmxlTGVmdEFycm93XCI6IFwi4oeQXCIsXG5cdFwiRG91YmxlTGVmdFJpZ2h0QXJyb3dcIjogXCLih5RcIixcblx0XCJEb3VibGVMZWZ0VGVlXCI6IFwi4qukXCIsXG5cdFwiRG91YmxlTG9uZ0xlZnRBcnJvd1wiOiBcIuKfuFwiLFxuXHRcIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvd1wiOiBcIuKfulwiLFxuXHRcIkRvdWJsZUxvbmdSaWdodEFycm93XCI6IFwi4p+5XCIsXG5cdFwiRG91YmxlUmlnaHRBcnJvd1wiOiBcIuKHklwiLFxuXHRcIkRvdWJsZVJpZ2h0VGVlXCI6IFwi4oqoXCIsXG5cdFwiRG91YmxlVXBBcnJvd1wiOiBcIuKHkVwiLFxuXHRcIkRvdWJsZVVwRG93bkFycm93XCI6IFwi4oeVXCIsXG5cdFwiRG91YmxlVmVydGljYWxCYXJcIjogXCLiiKVcIixcblx0XCJEb3duQXJyb3dCYXJcIjogXCLipJNcIixcblx0XCJkb3duYXJyb3dcIjogXCLihpNcIixcblx0XCJEb3duQXJyb3dcIjogXCLihpNcIixcblx0XCJEb3duYXJyb3dcIjogXCLih5NcIixcblx0XCJEb3duQXJyb3dVcEFycm93XCI6IFwi4oe1XCIsXG5cdFwiRG93bkJyZXZlXCI6IFwizJFcIixcblx0XCJkb3duZG93bmFycm93c1wiOiBcIuKHilwiLFxuXHRcImRvd25oYXJwb29ubGVmdFwiOiBcIuKHg1wiLFxuXHRcImRvd25oYXJwb29ucmlnaHRcIjogXCLih4JcIixcblx0XCJEb3duTGVmdFJpZ2h0VmVjdG9yXCI6IFwi4qWQXCIsXG5cdFwiRG93bkxlZnRUZWVWZWN0b3JcIjogXCLipZ5cIixcblx0XCJEb3duTGVmdFZlY3RvckJhclwiOiBcIuKlllwiLFxuXHRcIkRvd25MZWZ0VmVjdG9yXCI6IFwi4oa9XCIsXG5cdFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6IFwi4qWfXCIsXG5cdFwiRG93blJpZ2h0VmVjdG9yQmFyXCI6IFwi4qWXXCIsXG5cdFwiRG93blJpZ2h0VmVjdG9yXCI6IFwi4oeBXCIsXG5cdFwiRG93blRlZUFycm93XCI6IFwi4oanXCIsXG5cdFwiRG93blRlZVwiOiBcIuKKpFwiLFxuXHRcImRyYmthcm93XCI6IFwi4qSQXCIsXG5cdFwiZHJjb3JuXCI6IFwi4oyfXCIsXG5cdFwiZHJjcm9wXCI6IFwi4oyMXCIsXG5cdFwiRHNjclwiOiBcIvCdkp9cIixcblx0XCJkc2NyXCI6IFwi8J2SuVwiLFxuXHRcIkRTY3lcIjogXCLQhVwiLFxuXHRcImRzY3lcIjogXCLRlVwiLFxuXHRcImRzb2xcIjogXCLip7ZcIixcblx0XCJEc3Ryb2tcIjogXCLEkFwiLFxuXHRcImRzdHJva1wiOiBcIsSRXCIsXG5cdFwiZHRkb3RcIjogXCLii7FcIixcblx0XCJkdHJpXCI6IFwi4pa/XCIsXG5cdFwiZHRyaWZcIjogXCLilr5cIixcblx0XCJkdWFyclwiOiBcIuKHtVwiLFxuXHRcImR1aGFyXCI6IFwi4qWvXCIsXG5cdFwiZHdhbmdsZVwiOiBcIuKmplwiLFxuXHRcIkRaY3lcIjogXCLQj1wiLFxuXHRcImR6Y3lcIjogXCLRn1wiLFxuXHRcImR6aWdyYXJyXCI6IFwi4p+/XCIsXG5cdFwiRWFjdXRlXCI6IFwiw4lcIixcblx0XCJlYWN1dGVcIjogXCLDqVwiLFxuXHRcImVhc3RlclwiOiBcIuKprlwiLFxuXHRcIkVjYXJvblwiOiBcIsSaXCIsXG5cdFwiZWNhcm9uXCI6IFwixJtcIixcblx0XCJFY2lyY1wiOiBcIsOKXCIsXG5cdFwiZWNpcmNcIjogXCLDqlwiLFxuXHRcImVjaXJcIjogXCLiiZZcIixcblx0XCJlY29sb25cIjogXCLiiZVcIixcblx0XCJFY3lcIjogXCLQrVwiLFxuXHRcImVjeVwiOiBcItGNXCIsXG5cdFwiZUREb3RcIjogXCLiqbdcIixcblx0XCJFZG90XCI6IFwixJZcIixcblx0XCJlZG90XCI6IFwixJdcIixcblx0XCJlRG90XCI6IFwi4omRXCIsXG5cdFwiZWVcIjogXCLihYdcIixcblx0XCJlZkRvdFwiOiBcIuKJklwiLFxuXHRcIkVmclwiOiBcIvCdlIhcIixcblx0XCJlZnJcIjogXCLwnZSiXCIsXG5cdFwiZWdcIjogXCLiqppcIixcblx0XCJFZ3JhdmVcIjogXCLDiFwiLFxuXHRcImVncmF2ZVwiOiBcIsOoXCIsXG5cdFwiZWdzXCI6IFwi4qqWXCIsXG5cdFwiZWdzZG90XCI6IFwi4qqYXCIsXG5cdFwiZWxcIjogXCLiqplcIixcblx0XCJFbGVtZW50XCI6IFwi4oiIXCIsXG5cdFwiZWxpbnRlcnNcIjogXCLij6dcIixcblx0XCJlbGxcIjogXCLihJNcIixcblx0XCJlbHNcIjogXCLiqpVcIixcblx0XCJlbHNkb3RcIjogXCLiqpdcIixcblx0XCJFbWFjclwiOiBcIsSSXCIsXG5cdFwiZW1hY3JcIjogXCLEk1wiLFxuXHRcImVtcHR5XCI6IFwi4oiFXCIsXG5cdFwiZW1wdHlzZXRcIjogXCLiiIVcIixcblx0XCJFbXB0eVNtYWxsU3F1YXJlXCI6IFwi4pe7XCIsXG5cdFwiZW1wdHl2XCI6IFwi4oiFXCIsXG5cdFwiRW1wdHlWZXJ5U21hbGxTcXVhcmVcIjogXCLilqtcIixcblx0XCJlbXNwMTNcIjogXCLigIRcIixcblx0XCJlbXNwMTRcIjogXCLigIVcIixcblx0XCJlbXNwXCI6IFwi4oCDXCIsXG5cdFwiRU5HXCI6IFwixYpcIixcblx0XCJlbmdcIjogXCLFi1wiLFxuXHRcImVuc3BcIjogXCLigIJcIixcblx0XCJFb2dvblwiOiBcIsSYXCIsXG5cdFwiZW9nb25cIjogXCLEmVwiLFxuXHRcIkVvcGZcIjogXCLwnZS8XCIsXG5cdFwiZW9wZlwiOiBcIvCdlZZcIixcblx0XCJlcGFyXCI6IFwi4ouVXCIsXG5cdFwiZXBhcnNsXCI6IFwi4qejXCIsXG5cdFwiZXBsdXNcIjogXCLiqbFcIixcblx0XCJlcHNpXCI6IFwizrVcIixcblx0XCJFcHNpbG9uXCI6IFwizpVcIixcblx0XCJlcHNpbG9uXCI6IFwizrVcIixcblx0XCJlcHNpdlwiOiBcIs+1XCIsXG5cdFwiZXFjaXJjXCI6IFwi4omWXCIsXG5cdFwiZXFjb2xvblwiOiBcIuKJlVwiLFxuXHRcImVxc2ltXCI6IFwi4omCXCIsXG5cdFwiZXFzbGFudGd0clwiOiBcIuKqllwiLFxuXHRcImVxc2xhbnRsZXNzXCI6IFwi4qqVXCIsXG5cdFwiRXF1YWxcIjogXCLiqbVcIixcblx0XCJlcXVhbHNcIjogXCI9XCIsXG5cdFwiRXF1YWxUaWxkZVwiOiBcIuKJglwiLFxuXHRcImVxdWVzdFwiOiBcIuKJn1wiLFxuXHRcIkVxdWlsaWJyaXVtXCI6IFwi4oeMXCIsXG5cdFwiZXF1aXZcIjogXCLiiaFcIixcblx0XCJlcXVpdkREXCI6IFwi4qm4XCIsXG5cdFwiZXF2cGFyc2xcIjogXCLip6VcIixcblx0XCJlcmFyclwiOiBcIuKlsVwiLFxuXHRcImVyRG90XCI6IFwi4omTXCIsXG5cdFwiZXNjclwiOiBcIuKEr1wiLFxuXHRcIkVzY3JcIjogXCLihLBcIixcblx0XCJlc2RvdFwiOiBcIuKJkFwiLFxuXHRcIkVzaW1cIjogXCLiqbNcIixcblx0XCJlc2ltXCI6IFwi4omCXCIsXG5cdFwiRXRhXCI6IFwizpdcIixcblx0XCJldGFcIjogXCLOt1wiLFxuXHRcIkVUSFwiOiBcIsOQXCIsXG5cdFwiZXRoXCI6IFwiw7BcIixcblx0XCJFdW1sXCI6IFwiw4tcIixcblx0XCJldW1sXCI6IFwiw6tcIixcblx0XCJldXJvXCI6IFwi4oKsXCIsXG5cdFwiZXhjbFwiOiBcIiFcIixcblx0XCJleGlzdFwiOiBcIuKIg1wiLFxuXHRcIkV4aXN0c1wiOiBcIuKIg1wiLFxuXHRcImV4cGVjdGF0aW9uXCI6IFwi4oSwXCIsXG5cdFwiZXhwb25lbnRpYWxlXCI6IFwi4oWHXCIsXG5cdFwiRXhwb25lbnRpYWxFXCI6IFwi4oWHXCIsXG5cdFwiZmFsbGluZ2RvdHNlcVwiOiBcIuKJklwiLFxuXHRcIkZjeVwiOiBcItCkXCIsXG5cdFwiZmN5XCI6IFwi0YRcIixcblx0XCJmZW1hbGVcIjogXCLimYBcIixcblx0XCJmZmlsaWdcIjogXCLvrINcIixcblx0XCJmZmxpZ1wiOiBcIu+sgFwiLFxuXHRcImZmbGxpZ1wiOiBcIu+shFwiLFxuXHRcIkZmclwiOiBcIvCdlIlcIixcblx0XCJmZnJcIjogXCLwnZSjXCIsXG5cdFwiZmlsaWdcIjogXCLvrIFcIixcblx0XCJGaWxsZWRTbWFsbFNxdWFyZVwiOiBcIuKXvFwiLFxuXHRcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZVwiOiBcIuKWqlwiLFxuXHRcImZqbGlnXCI6IFwiZmpcIixcblx0XCJmbGF0XCI6IFwi4pmtXCIsXG5cdFwiZmxsaWdcIjogXCLvrIJcIixcblx0XCJmbHRuc1wiOiBcIuKWsVwiLFxuXHRcImZub2ZcIjogXCLGklwiLFxuXHRcIkZvcGZcIjogXCLwnZS9XCIsXG5cdFwiZm9wZlwiOiBcIvCdlZdcIixcblx0XCJmb3JhbGxcIjogXCLiiIBcIixcblx0XCJGb3JBbGxcIjogXCLiiIBcIixcblx0XCJmb3JrXCI6IFwi4ouUXCIsXG5cdFwiZm9ya3ZcIjogXCLiq5lcIixcblx0XCJGb3VyaWVydHJmXCI6IFwi4oSxXCIsXG5cdFwiZnBhcnRpbnRcIjogXCLiqI1cIixcblx0XCJmcmFjMTJcIjogXCLCvVwiLFxuXHRcImZyYWMxM1wiOiBcIuKFk1wiLFxuXHRcImZyYWMxNFwiOiBcIsK8XCIsXG5cdFwiZnJhYzE1XCI6IFwi4oWVXCIsXG5cdFwiZnJhYzE2XCI6IFwi4oWZXCIsXG5cdFwiZnJhYzE4XCI6IFwi4oWbXCIsXG5cdFwiZnJhYzIzXCI6IFwi4oWUXCIsXG5cdFwiZnJhYzI1XCI6IFwi4oWWXCIsXG5cdFwiZnJhYzM0XCI6IFwiwr5cIixcblx0XCJmcmFjMzVcIjogXCLihZdcIixcblx0XCJmcmFjMzhcIjogXCLihZxcIixcblx0XCJmcmFjNDVcIjogXCLihZhcIixcblx0XCJmcmFjNTZcIjogXCLihZpcIixcblx0XCJmcmFjNThcIjogXCLihZ1cIixcblx0XCJmcmFjNzhcIjogXCLihZ5cIixcblx0XCJmcmFzbFwiOiBcIuKBhFwiLFxuXHRcImZyb3duXCI6IFwi4oyiXCIsXG5cdFwiZnNjclwiOiBcIvCdkrtcIixcblx0XCJGc2NyXCI6IFwi4oSxXCIsXG5cdFwiZ2FjdXRlXCI6IFwix7VcIixcblx0XCJHYW1tYVwiOiBcIs6TXCIsXG5cdFwiZ2FtbWFcIjogXCLOs1wiLFxuXHRcIkdhbW1hZFwiOiBcIs+cXCIsXG5cdFwiZ2FtbWFkXCI6IFwiz51cIixcblx0XCJnYXBcIjogXCLiqoZcIixcblx0XCJHYnJldmVcIjogXCLEnlwiLFxuXHRcImdicmV2ZVwiOiBcIsSfXCIsXG5cdFwiR2NlZGlsXCI6IFwixKJcIixcblx0XCJHY2lyY1wiOiBcIsScXCIsXG5cdFwiZ2NpcmNcIjogXCLEnVwiLFxuXHRcIkdjeVwiOiBcItCTXCIsXG5cdFwiZ2N5XCI6IFwi0LNcIixcblx0XCJHZG90XCI6IFwixKBcIixcblx0XCJnZG90XCI6IFwixKFcIixcblx0XCJnZVwiOiBcIuKJpVwiLFxuXHRcImdFXCI6IFwi4omnXCIsXG5cdFwiZ0VsXCI6IFwi4qqMXCIsXG5cdFwiZ2VsXCI6IFwi4oubXCIsXG5cdFwiZ2VxXCI6IFwi4omlXCIsXG5cdFwiZ2VxcVwiOiBcIuKJp1wiLFxuXHRcImdlcXNsYW50XCI6IFwi4qm+XCIsXG5cdFwiZ2VzY2NcIjogXCLiqqlcIixcblx0XCJnZXNcIjogXCLiqb5cIixcblx0XCJnZXNkb3RcIjogXCLiqoBcIixcblx0XCJnZXNkb3RvXCI6IFwi4qqCXCIsXG5cdFwiZ2VzZG90b2xcIjogXCLiqoRcIixcblx0XCJnZXNsXCI6IFwi4oub77iAXCIsXG5cdFwiZ2VzbGVzXCI6IFwi4qqUXCIsXG5cdFwiR2ZyXCI6IFwi8J2UilwiLFxuXHRcImdmclwiOiBcIvCdlKRcIixcblx0XCJnZ1wiOiBcIuKJq1wiLFxuXHRcIkdnXCI6IFwi4ouZXCIsXG5cdFwiZ2dnXCI6IFwi4ouZXCIsXG5cdFwiZ2ltZWxcIjogXCLihLdcIixcblx0XCJHSmN5XCI6IFwi0INcIixcblx0XCJnamN5XCI6IFwi0ZNcIixcblx0XCJnbGFcIjogXCLiqqVcIixcblx0XCJnbFwiOiBcIuKJt1wiLFxuXHRcImdsRVwiOiBcIuKqklwiLFxuXHRcImdsalwiOiBcIuKqpFwiLFxuXHRcImduYXBcIjogXCLiqopcIixcblx0XCJnbmFwcHJveFwiOiBcIuKqilwiLFxuXHRcImduZVwiOiBcIuKqiFwiLFxuXHRcImduRVwiOiBcIuKJqVwiLFxuXHRcImduZXFcIjogXCLiqohcIixcblx0XCJnbmVxcVwiOiBcIuKJqVwiLFxuXHRcImduc2ltXCI6IFwi4ounXCIsXG5cdFwiR29wZlwiOiBcIvCdlL5cIixcblx0XCJnb3BmXCI6IFwi8J2VmFwiLFxuXHRcImdyYXZlXCI6IFwiYFwiLFxuXHRcIkdyZWF0ZXJFcXVhbFwiOiBcIuKJpVwiLFxuXHRcIkdyZWF0ZXJFcXVhbExlc3NcIjogXCLii5tcIixcblx0XCJHcmVhdGVyRnVsbEVxdWFsXCI6IFwi4omnXCIsXG5cdFwiR3JlYXRlckdyZWF0ZXJcIjogXCLiqqJcIixcblx0XCJHcmVhdGVyTGVzc1wiOiBcIuKJt1wiLFxuXHRcIkdyZWF0ZXJTbGFudEVxdWFsXCI6IFwi4qm+XCIsXG5cdFwiR3JlYXRlclRpbGRlXCI6IFwi4omzXCIsXG5cdFwiR3NjclwiOiBcIvCdkqJcIixcblx0XCJnc2NyXCI6IFwi4oSKXCIsXG5cdFwiZ3NpbVwiOiBcIuKJs1wiLFxuXHRcImdzaW1lXCI6IFwi4qqOXCIsXG5cdFwiZ3NpbWxcIjogXCLiqpBcIixcblx0XCJndGNjXCI6IFwi4qqnXCIsXG5cdFwiZ3RjaXJcIjogXCLiqbpcIixcblx0XCJndFwiOiBcIj5cIixcblx0XCJHVFwiOiBcIj5cIixcblx0XCJHdFwiOiBcIuKJq1wiLFxuXHRcImd0ZG90XCI6IFwi4ouXXCIsXG5cdFwiZ3RsUGFyXCI6IFwi4qaVXCIsXG5cdFwiZ3RxdWVzdFwiOiBcIuKpvFwiLFxuXHRcImd0cmFwcHJveFwiOiBcIuKqhlwiLFxuXHRcImd0cmFyclwiOiBcIuKluFwiLFxuXHRcImd0cmRvdFwiOiBcIuKLl1wiLFxuXHRcImd0cmVxbGVzc1wiOiBcIuKLm1wiLFxuXHRcImd0cmVxcWxlc3NcIjogXCLiqoxcIixcblx0XCJndHJsZXNzXCI6IFwi4om3XCIsXG5cdFwiZ3Ryc2ltXCI6IFwi4omzXCIsXG5cdFwiZ3ZlcnRuZXFxXCI6IFwi4omp77iAXCIsXG5cdFwiZ3ZuRVwiOiBcIuKJqe+4gFwiLFxuXHRcIkhhY2VrXCI6IFwiy4dcIixcblx0XCJoYWlyc3BcIjogXCLigIpcIixcblx0XCJoYWxmXCI6IFwiwr1cIixcblx0XCJoYW1pbHRcIjogXCLihItcIixcblx0XCJIQVJEY3lcIjogXCLQqlwiLFxuXHRcImhhcmRjeVwiOiBcItGKXCIsXG5cdFwiaGFycmNpclwiOiBcIuKliFwiLFxuXHRcImhhcnJcIjogXCLihpRcIixcblx0XCJoQXJyXCI6IFwi4oeUXCIsXG5cdFwiaGFycndcIjogXCLihq1cIixcblx0XCJIYXRcIjogXCJeXCIsXG5cdFwiaGJhclwiOiBcIuKEj1wiLFxuXHRcIkhjaXJjXCI6IFwixKRcIixcblx0XCJoY2lyY1wiOiBcIsSlXCIsXG5cdFwiaGVhcnRzXCI6IFwi4pmlXCIsXG5cdFwiaGVhcnRzdWl0XCI6IFwi4pmlXCIsXG5cdFwiaGVsbGlwXCI6IFwi4oCmXCIsXG5cdFwiaGVyY29uXCI6IFwi4oq5XCIsXG5cdFwiaGZyXCI6IFwi8J2UpVwiLFxuXHRcIkhmclwiOiBcIuKEjFwiLFxuXHRcIkhpbGJlcnRTcGFjZVwiOiBcIuKEi1wiLFxuXHRcImhrc2Vhcm93XCI6IFwi4qSlXCIsXG5cdFwiaGtzd2Fyb3dcIjogXCLipKZcIixcblx0XCJob2FyclwiOiBcIuKHv1wiLFxuXHRcImhvbXRodFwiOiBcIuKIu1wiLFxuXHRcImhvb2tsZWZ0YXJyb3dcIjogXCLihqlcIixcblx0XCJob29rcmlnaHRhcnJvd1wiOiBcIuKGqlwiLFxuXHRcImhvcGZcIjogXCLwnZWZXCIsXG5cdFwiSG9wZlwiOiBcIuKEjVwiLFxuXHRcImhvcmJhclwiOiBcIuKAlVwiLFxuXHRcIkhvcml6b250YWxMaW5lXCI6IFwi4pSAXCIsXG5cdFwiaHNjclwiOiBcIvCdkr1cIixcblx0XCJIc2NyXCI6IFwi4oSLXCIsXG5cdFwiaHNsYXNoXCI6IFwi4oSPXCIsXG5cdFwiSHN0cm9rXCI6IFwixKZcIixcblx0XCJoc3Ryb2tcIjogXCLEp1wiLFxuXHRcIkh1bXBEb3duSHVtcFwiOiBcIuKJjlwiLFxuXHRcIkh1bXBFcXVhbFwiOiBcIuKJj1wiLFxuXHRcImh5YnVsbFwiOiBcIuKBg1wiLFxuXHRcImh5cGhlblwiOiBcIuKAkFwiLFxuXHRcIklhY3V0ZVwiOiBcIsONXCIsXG5cdFwiaWFjdXRlXCI6IFwiw61cIixcblx0XCJpY1wiOiBcIuKBo1wiLFxuXHRcIkljaXJjXCI6IFwiw45cIixcblx0XCJpY2lyY1wiOiBcIsOuXCIsXG5cdFwiSWN5XCI6IFwi0JhcIixcblx0XCJpY3lcIjogXCLQuFwiLFxuXHRcIklkb3RcIjogXCLEsFwiLFxuXHRcIklFY3lcIjogXCLQlVwiLFxuXHRcImllY3lcIjogXCLQtVwiLFxuXHRcImlleGNsXCI6IFwiwqFcIixcblx0XCJpZmZcIjogXCLih5RcIixcblx0XCJpZnJcIjogXCLwnZSmXCIsXG5cdFwiSWZyXCI6IFwi4oSRXCIsXG5cdFwiSWdyYXZlXCI6IFwiw4xcIixcblx0XCJpZ3JhdmVcIjogXCLDrFwiLFxuXHRcImlpXCI6IFwi4oWIXCIsXG5cdFwiaWlpaW50XCI6IFwi4qiMXCIsXG5cdFwiaWlpbnRcIjogXCLiiK1cIixcblx0XCJpaW5maW5cIjogXCLip5xcIixcblx0XCJpaW90YVwiOiBcIuKEqVwiLFxuXHRcIklKbGlnXCI6IFwixLJcIixcblx0XCJpamxpZ1wiOiBcIsSzXCIsXG5cdFwiSW1hY3JcIjogXCLEqlwiLFxuXHRcImltYWNyXCI6IFwixKtcIixcblx0XCJpbWFnZVwiOiBcIuKEkVwiLFxuXHRcIkltYWdpbmFyeUlcIjogXCLihYhcIixcblx0XCJpbWFnbGluZVwiOiBcIuKEkFwiLFxuXHRcImltYWdwYXJ0XCI6IFwi4oSRXCIsXG5cdFwiaW1hdGhcIjogXCLEsVwiLFxuXHRcIkltXCI6IFwi4oSRXCIsXG5cdFwiaW1vZlwiOiBcIuKKt1wiLFxuXHRcImltcGVkXCI6IFwixrVcIixcblx0XCJJbXBsaWVzXCI6IFwi4oeSXCIsXG5cdFwiaW5jYXJlXCI6IFwi4oSFXCIsXG5cdFwiaW5cIjogXCLiiIhcIixcblx0XCJpbmZpblwiOiBcIuKInlwiLFxuXHRcImluZmludGllXCI6IFwi4qedXCIsXG5cdFwiaW5vZG90XCI6IFwixLFcIixcblx0XCJpbnRjYWxcIjogXCLiirpcIixcblx0XCJpbnRcIjogXCLiiKtcIixcblx0XCJJbnRcIjogXCLiiKxcIixcblx0XCJpbnRlZ2Vyc1wiOiBcIuKEpFwiLFxuXHRcIkludGVncmFsXCI6IFwi4oirXCIsXG5cdFwiaW50ZXJjYWxcIjogXCLiirpcIixcblx0XCJJbnRlcnNlY3Rpb25cIjogXCLii4JcIixcblx0XCJpbnRsYXJoa1wiOiBcIuKol1wiLFxuXHRcImludHByb2RcIjogXCLiqLxcIixcblx0XCJJbnZpc2libGVDb21tYVwiOiBcIuKBo1wiLFxuXHRcIkludmlzaWJsZVRpbWVzXCI6IFwi4oGiXCIsXG5cdFwiSU9jeVwiOiBcItCBXCIsXG5cdFwiaW9jeVwiOiBcItGRXCIsXG5cdFwiSW9nb25cIjogXCLErlwiLFxuXHRcImlvZ29uXCI6IFwixK9cIixcblx0XCJJb3BmXCI6IFwi8J2VgFwiLFxuXHRcImlvcGZcIjogXCLwnZWaXCIsXG5cdFwiSW90YVwiOiBcIs6ZXCIsXG5cdFwiaW90YVwiOiBcIs65XCIsXG5cdFwiaXByb2RcIjogXCLiqLxcIixcblx0XCJpcXVlc3RcIjogXCLCv1wiLFxuXHRcImlzY3JcIjogXCLwnZK+XCIsXG5cdFwiSXNjclwiOiBcIuKEkFwiLFxuXHRcImlzaW5cIjogXCLiiIhcIixcblx0XCJpc2luZG90XCI6IFwi4ou1XCIsXG5cdFwiaXNpbkVcIjogXCLii7lcIixcblx0XCJpc2luc1wiOiBcIuKLtFwiLFxuXHRcImlzaW5zdlwiOiBcIuKLs1wiLFxuXHRcImlzaW52XCI6IFwi4oiIXCIsXG5cdFwiaXRcIjogXCLigaJcIixcblx0XCJJdGlsZGVcIjogXCLEqFwiLFxuXHRcIml0aWxkZVwiOiBcIsSpXCIsXG5cdFwiSXVrY3lcIjogXCLQhlwiLFxuXHRcIml1a2N5XCI6IFwi0ZZcIixcblx0XCJJdW1sXCI6IFwiw49cIixcblx0XCJpdW1sXCI6IFwiw69cIixcblx0XCJKY2lyY1wiOiBcIsS0XCIsXG5cdFwiamNpcmNcIjogXCLEtVwiLFxuXHRcIkpjeVwiOiBcItCZXCIsXG5cdFwiamN5XCI6IFwi0LlcIixcblx0XCJKZnJcIjogXCLwnZSNXCIsXG5cdFwiamZyXCI6IFwi8J2Up1wiLFxuXHRcImptYXRoXCI6IFwiyLdcIixcblx0XCJKb3BmXCI6IFwi8J2VgVwiLFxuXHRcImpvcGZcIjogXCLwnZWbXCIsXG5cdFwiSnNjclwiOiBcIvCdkqVcIixcblx0XCJqc2NyXCI6IFwi8J2Sv1wiLFxuXHRcIkpzZXJjeVwiOiBcItCIXCIsXG5cdFwianNlcmN5XCI6IFwi0ZhcIixcblx0XCJKdWtjeVwiOiBcItCEXCIsXG5cdFwianVrY3lcIjogXCLRlFwiLFxuXHRcIkthcHBhXCI6IFwizppcIixcblx0XCJrYXBwYVwiOiBcIs66XCIsXG5cdFwia2FwcGF2XCI6IFwiz7BcIixcblx0XCJLY2VkaWxcIjogXCLEtlwiLFxuXHRcImtjZWRpbFwiOiBcIsS3XCIsXG5cdFwiS2N5XCI6IFwi0JpcIixcblx0XCJrY3lcIjogXCLQulwiLFxuXHRcIktmclwiOiBcIvCdlI5cIixcblx0XCJrZnJcIjogXCLwnZSoXCIsXG5cdFwia2dyZWVuXCI6IFwixLhcIixcblx0XCJLSGN5XCI6IFwi0KVcIixcblx0XCJraGN5XCI6IFwi0YVcIixcblx0XCJLSmN5XCI6IFwi0IxcIixcblx0XCJramN5XCI6IFwi0ZxcIixcblx0XCJLb3BmXCI6IFwi8J2VglwiLFxuXHRcImtvcGZcIjogXCLwnZWcXCIsXG5cdFwiS3NjclwiOiBcIvCdkqZcIixcblx0XCJrc2NyXCI6IFwi8J2TgFwiLFxuXHRcImxBYXJyXCI6IFwi4oeaXCIsXG5cdFwiTGFjdXRlXCI6IFwixLlcIixcblx0XCJsYWN1dGVcIjogXCLEulwiLFxuXHRcImxhZW1wdHl2XCI6IFwi4qa0XCIsXG5cdFwibGFncmFuXCI6IFwi4oSSXCIsXG5cdFwiTGFtYmRhXCI6IFwizptcIixcblx0XCJsYW1iZGFcIjogXCLOu1wiLFxuXHRcImxhbmdcIjogXCLin6hcIixcblx0XCJMYW5nXCI6IFwi4p+qXCIsXG5cdFwibGFuZ2RcIjogXCLippFcIixcblx0XCJsYW5nbGVcIjogXCLin6hcIixcblx0XCJsYXBcIjogXCLiqoVcIixcblx0XCJMYXBsYWNldHJmXCI6IFwi4oSSXCIsXG5cdFwibGFxdW9cIjogXCLCq1wiLFxuXHRcImxhcnJiXCI6IFwi4oekXCIsXG5cdFwibGFycmJmc1wiOiBcIuKkn1wiLFxuXHRcImxhcnJcIjogXCLihpBcIixcblx0XCJMYXJyXCI6IFwi4oaeXCIsXG5cdFwibEFyclwiOiBcIuKHkFwiLFxuXHRcImxhcnJmc1wiOiBcIuKknVwiLFxuXHRcImxhcnJoa1wiOiBcIuKGqVwiLFxuXHRcImxhcnJscFwiOiBcIuKGq1wiLFxuXHRcImxhcnJwbFwiOiBcIuKkuVwiLFxuXHRcImxhcnJzaW1cIjogXCLipbNcIixcblx0XCJsYXJydGxcIjogXCLihqJcIixcblx0XCJsYXRhaWxcIjogXCLipJlcIixcblx0XCJsQXRhaWxcIjogXCLipJtcIixcblx0XCJsYXRcIjogXCLiqqtcIixcblx0XCJsYXRlXCI6IFwi4qqtXCIsXG5cdFwibGF0ZXNcIjogXCLiqq3vuIBcIixcblx0XCJsYmFyclwiOiBcIuKkjFwiLFxuXHRcImxCYXJyXCI6IFwi4qSOXCIsXG5cdFwibGJicmtcIjogXCLinbJcIixcblx0XCJsYnJhY2VcIjogXCJ7XCIsXG5cdFwibGJyYWNrXCI6IFwiW1wiLFxuXHRcImxicmtlXCI6IFwi4qaLXCIsXG5cdFwibGJya3NsZFwiOiBcIuKmj1wiLFxuXHRcImxicmtzbHVcIjogXCLipo1cIixcblx0XCJMY2Fyb25cIjogXCLEvVwiLFxuXHRcImxjYXJvblwiOiBcIsS+XCIsXG5cdFwiTGNlZGlsXCI6IFwixLtcIixcblx0XCJsY2VkaWxcIjogXCLEvFwiLFxuXHRcImxjZWlsXCI6IFwi4oyIXCIsXG5cdFwibGN1YlwiOiBcIntcIixcblx0XCJMY3lcIjogXCLQm1wiLFxuXHRcImxjeVwiOiBcItC7XCIsXG5cdFwibGRjYVwiOiBcIuKktlwiLFxuXHRcImxkcXVvXCI6IFwi4oCcXCIsXG5cdFwibGRxdW9yXCI6IFwi4oCeXCIsXG5cdFwibGRyZGhhclwiOiBcIuKlp1wiLFxuXHRcImxkcnVzaGFyXCI6IFwi4qWLXCIsXG5cdFwibGRzaFwiOiBcIuKGslwiLFxuXHRcImxlXCI6IFwi4omkXCIsXG5cdFwibEVcIjogXCLiiaZcIixcblx0XCJMZWZ0QW5nbGVCcmFja2V0XCI6IFwi4p+oXCIsXG5cdFwiTGVmdEFycm93QmFyXCI6IFwi4oekXCIsXG5cdFwibGVmdGFycm93XCI6IFwi4oaQXCIsXG5cdFwiTGVmdEFycm93XCI6IFwi4oaQXCIsXG5cdFwiTGVmdGFycm93XCI6IFwi4oeQXCIsXG5cdFwiTGVmdEFycm93UmlnaHRBcnJvd1wiOiBcIuKHhlwiLFxuXHRcImxlZnRhcnJvd3RhaWxcIjogXCLihqJcIixcblx0XCJMZWZ0Q2VpbGluZ1wiOiBcIuKMiFwiLFxuXHRcIkxlZnREb3VibGVCcmFja2V0XCI6IFwi4p+mXCIsXG5cdFwiTGVmdERvd25UZWVWZWN0b3JcIjogXCLipaFcIixcblx0XCJMZWZ0RG93blZlY3RvckJhclwiOiBcIuKlmVwiLFxuXHRcIkxlZnREb3duVmVjdG9yXCI6IFwi4oeDXCIsXG5cdFwiTGVmdEZsb29yXCI6IFwi4oyKXCIsXG5cdFwibGVmdGhhcnBvb25kb3duXCI6IFwi4oa9XCIsXG5cdFwibGVmdGhhcnBvb251cFwiOiBcIuKGvFwiLFxuXHRcImxlZnRsZWZ0YXJyb3dzXCI6IFwi4oeHXCIsXG5cdFwibGVmdHJpZ2h0YXJyb3dcIjogXCLihpRcIixcblx0XCJMZWZ0UmlnaHRBcnJvd1wiOiBcIuKGlFwiLFxuXHRcIkxlZnRyaWdodGFycm93XCI6IFwi4oeUXCIsXG5cdFwibGVmdHJpZ2h0YXJyb3dzXCI6IFwi4oeGXCIsXG5cdFwibGVmdHJpZ2h0aGFycG9vbnNcIjogXCLih4tcIixcblx0XCJsZWZ0cmlnaHRzcXVpZ2Fycm93XCI6IFwi4oatXCIsXG5cdFwiTGVmdFJpZ2h0VmVjdG9yXCI6IFwi4qWOXCIsXG5cdFwiTGVmdFRlZUFycm93XCI6IFwi4oakXCIsXG5cdFwiTGVmdFRlZVwiOiBcIuKKo1wiLFxuXHRcIkxlZnRUZWVWZWN0b3JcIjogXCLipZpcIixcblx0XCJsZWZ0dGhyZWV0aW1lc1wiOiBcIuKLi1wiLFxuXHRcIkxlZnRUcmlhbmdsZUJhclwiOiBcIuKnj1wiLFxuXHRcIkxlZnRUcmlhbmdsZVwiOiBcIuKKslwiLFxuXHRcIkxlZnRUcmlhbmdsZUVxdWFsXCI6IFwi4oq0XCIsXG5cdFwiTGVmdFVwRG93blZlY3RvclwiOiBcIuKlkVwiLFxuXHRcIkxlZnRVcFRlZVZlY3RvclwiOiBcIuKloFwiLFxuXHRcIkxlZnRVcFZlY3RvckJhclwiOiBcIuKlmFwiLFxuXHRcIkxlZnRVcFZlY3RvclwiOiBcIuKGv1wiLFxuXHRcIkxlZnRWZWN0b3JCYXJcIjogXCLipZJcIixcblx0XCJMZWZ0VmVjdG9yXCI6IFwi4oa8XCIsXG5cdFwibEVnXCI6IFwi4qqLXCIsXG5cdFwibGVnXCI6IFwi4ouaXCIsXG5cdFwibGVxXCI6IFwi4omkXCIsXG5cdFwibGVxcVwiOiBcIuKJplwiLFxuXHRcImxlcXNsYW50XCI6IFwi4qm9XCIsXG5cdFwibGVzY2NcIjogXCLiqqhcIixcblx0XCJsZXNcIjogXCLiqb1cIixcblx0XCJsZXNkb3RcIjogXCLiqb9cIixcblx0XCJsZXNkb3RvXCI6IFwi4qqBXCIsXG5cdFwibGVzZG90b3JcIjogXCLiqoNcIixcblx0XCJsZXNnXCI6IFwi4oua77iAXCIsXG5cdFwibGVzZ2VzXCI6IFwi4qqTXCIsXG5cdFwibGVzc2FwcHJveFwiOiBcIuKqhVwiLFxuXHRcImxlc3Nkb3RcIjogXCLii5ZcIixcblx0XCJsZXNzZXFndHJcIjogXCLii5pcIixcblx0XCJsZXNzZXFxZ3RyXCI6IFwi4qqLXCIsXG5cdFwiTGVzc0VxdWFsR3JlYXRlclwiOiBcIuKLmlwiLFxuXHRcIkxlc3NGdWxsRXF1YWxcIjogXCLiiaZcIixcblx0XCJMZXNzR3JlYXRlclwiOiBcIuKJtlwiLFxuXHRcImxlc3NndHJcIjogXCLiibZcIixcblx0XCJMZXNzTGVzc1wiOiBcIuKqoVwiLFxuXHRcImxlc3NzaW1cIjogXCLiibJcIixcblx0XCJMZXNzU2xhbnRFcXVhbFwiOiBcIuKpvVwiLFxuXHRcIkxlc3NUaWxkZVwiOiBcIuKJslwiLFxuXHRcImxmaXNodFwiOiBcIuKlvFwiLFxuXHRcImxmbG9vclwiOiBcIuKMilwiLFxuXHRcIkxmclwiOiBcIvCdlI9cIixcblx0XCJsZnJcIjogXCLwnZSpXCIsXG5cdFwibGdcIjogXCLiibZcIixcblx0XCJsZ0VcIjogXCLiqpFcIixcblx0XCJsSGFyXCI6IFwi4qWiXCIsXG5cdFwibGhhcmRcIjogXCLihr1cIixcblx0XCJsaGFydVwiOiBcIuKGvFwiLFxuXHRcImxoYXJ1bFwiOiBcIuKlqlwiLFxuXHRcImxoYmxrXCI6IFwi4paEXCIsXG5cdFwiTEpjeVwiOiBcItCJXCIsXG5cdFwibGpjeVwiOiBcItGZXCIsXG5cdFwibGxhcnJcIjogXCLih4dcIixcblx0XCJsbFwiOiBcIuKJqlwiLFxuXHRcIkxsXCI6IFwi4ouYXCIsXG5cdFwibGxjb3JuZXJcIjogXCLijJ5cIixcblx0XCJMbGVmdGFycm93XCI6IFwi4oeaXCIsXG5cdFwibGxoYXJkXCI6IFwi4qWrXCIsXG5cdFwibGx0cmlcIjogXCLil7pcIixcblx0XCJMbWlkb3RcIjogXCLEv1wiLFxuXHRcImxtaWRvdFwiOiBcIsWAXCIsXG5cdFwibG1vdXN0YWNoZVwiOiBcIuKOsFwiLFxuXHRcImxtb3VzdFwiOiBcIuKOsFwiLFxuXHRcImxuYXBcIjogXCLiqolcIixcblx0XCJsbmFwcHJveFwiOiBcIuKqiVwiLFxuXHRcImxuZVwiOiBcIuKqh1wiLFxuXHRcImxuRVwiOiBcIuKJqFwiLFxuXHRcImxuZXFcIjogXCLiqodcIixcblx0XCJsbmVxcVwiOiBcIuKJqFwiLFxuXHRcImxuc2ltXCI6IFwi4oumXCIsXG5cdFwibG9hbmdcIjogXCLin6xcIixcblx0XCJsb2FyclwiOiBcIuKHvVwiLFxuXHRcImxvYnJrXCI6IFwi4p+mXCIsXG5cdFwibG9uZ2xlZnRhcnJvd1wiOiBcIuKftVwiLFxuXHRcIkxvbmdMZWZ0QXJyb3dcIjogXCLin7VcIixcblx0XCJMb25nbGVmdGFycm93XCI6IFwi4p+4XCIsXG5cdFwibG9uZ2xlZnRyaWdodGFycm93XCI6IFwi4p+3XCIsXG5cdFwiTG9uZ0xlZnRSaWdodEFycm93XCI6IFwi4p+3XCIsXG5cdFwiTG9uZ2xlZnRyaWdodGFycm93XCI6IFwi4p+6XCIsXG5cdFwibG9uZ21hcHN0b1wiOiBcIuKfvFwiLFxuXHRcImxvbmdyaWdodGFycm93XCI6IFwi4p+2XCIsXG5cdFwiTG9uZ1JpZ2h0QXJyb3dcIjogXCLin7ZcIixcblx0XCJMb25ncmlnaHRhcnJvd1wiOiBcIuKfuVwiLFxuXHRcImxvb3BhcnJvd2xlZnRcIjogXCLihqtcIixcblx0XCJsb29wYXJyb3dyaWdodFwiOiBcIuKGrFwiLFxuXHRcImxvcGFyXCI6IFwi4qaFXCIsXG5cdFwiTG9wZlwiOiBcIvCdlYNcIixcblx0XCJsb3BmXCI6IFwi8J2VnVwiLFxuXHRcImxvcGx1c1wiOiBcIuKorVwiLFxuXHRcImxvdGltZXNcIjogXCLiqLRcIixcblx0XCJsb3dhc3RcIjogXCLiiJdcIixcblx0XCJsb3diYXJcIjogXCJfXCIsXG5cdFwiTG93ZXJMZWZ0QXJyb3dcIjogXCLihplcIixcblx0XCJMb3dlclJpZ2h0QXJyb3dcIjogXCLihphcIixcblx0XCJsb3pcIjogXCLil4pcIixcblx0XCJsb3plbmdlXCI6IFwi4peKXCIsXG5cdFwibG96ZlwiOiBcIuKnq1wiLFxuXHRcImxwYXJcIjogXCIoXCIsXG5cdFwibHBhcmx0XCI6IFwi4qaTXCIsXG5cdFwibHJhcnJcIjogXCLih4ZcIixcblx0XCJscmNvcm5lclwiOiBcIuKMn1wiLFxuXHRcImxyaGFyXCI6IFwi4oeLXCIsXG5cdFwibHJoYXJkXCI6IFwi4qWtXCIsXG5cdFwibHJtXCI6IFwi4oCOXCIsXG5cdFwibHJ0cmlcIjogXCLiir9cIixcblx0XCJsc2FxdW9cIjogXCLigLlcIixcblx0XCJsc2NyXCI6IFwi8J2TgVwiLFxuXHRcIkxzY3JcIjogXCLihJJcIixcblx0XCJsc2hcIjogXCLihrBcIixcblx0XCJMc2hcIjogXCLihrBcIixcblx0XCJsc2ltXCI6IFwi4omyXCIsXG5cdFwibHNpbWVcIjogXCLiqo1cIixcblx0XCJsc2ltZ1wiOiBcIuKqj1wiLFxuXHRcImxzcWJcIjogXCJbXCIsXG5cdFwibHNxdW9cIjogXCLigJhcIixcblx0XCJsc3F1b3JcIjogXCLigJpcIixcblx0XCJMc3Ryb2tcIjogXCLFgVwiLFxuXHRcImxzdHJva1wiOiBcIsWCXCIsXG5cdFwibHRjY1wiOiBcIuKqplwiLFxuXHRcImx0Y2lyXCI6IFwi4qm5XCIsXG5cdFwibHRcIjogXCI8XCIsXG5cdFwiTFRcIjogXCI8XCIsXG5cdFwiTHRcIjogXCLiiapcIixcblx0XCJsdGRvdFwiOiBcIuKLllwiLFxuXHRcImx0aHJlZVwiOiBcIuKLi1wiLFxuXHRcImx0aW1lc1wiOiBcIuKLiVwiLFxuXHRcImx0bGFyclwiOiBcIuKltlwiLFxuXHRcImx0cXVlc3RcIjogXCLiqbtcIixcblx0XCJsdHJpXCI6IFwi4peDXCIsXG5cdFwibHRyaWVcIjogXCLiirRcIixcblx0XCJsdHJpZlwiOiBcIuKXglwiLFxuXHRcImx0clBhclwiOiBcIuKmllwiLFxuXHRcImx1cmRzaGFyXCI6IFwi4qWKXCIsXG5cdFwibHVydWhhclwiOiBcIuKlplwiLFxuXHRcImx2ZXJ0bmVxcVwiOiBcIuKJqO+4gFwiLFxuXHRcImx2bkVcIjogXCLiiajvuIBcIixcblx0XCJtYWNyXCI6IFwiwq9cIixcblx0XCJtYWxlXCI6IFwi4pmCXCIsXG5cdFwibWFsdFwiOiBcIuKcoFwiLFxuXHRcIm1hbHRlc2VcIjogXCLinKBcIixcblx0XCJNYXBcIjogXCLipIVcIixcblx0XCJtYXBcIjogXCLihqZcIixcblx0XCJtYXBzdG9cIjogXCLihqZcIixcblx0XCJtYXBzdG9kb3duXCI6IFwi4oanXCIsXG5cdFwibWFwc3RvbGVmdFwiOiBcIuKGpFwiLFxuXHRcIm1hcHN0b3VwXCI6IFwi4oalXCIsXG5cdFwibWFya2VyXCI6IFwi4pauXCIsXG5cdFwibWNvbW1hXCI6IFwi4qipXCIsXG5cdFwiTWN5XCI6IFwi0JxcIixcblx0XCJtY3lcIjogXCLQvFwiLFxuXHRcIm1kYXNoXCI6IFwi4oCUXCIsXG5cdFwibUREb3RcIjogXCLiiLpcIixcblx0XCJtZWFzdXJlZGFuZ2xlXCI6IFwi4oihXCIsXG5cdFwiTWVkaXVtU3BhY2VcIjogXCLigZ9cIixcblx0XCJNZWxsaW50cmZcIjogXCLihLNcIixcblx0XCJNZnJcIjogXCLwnZSQXCIsXG5cdFwibWZyXCI6IFwi8J2UqlwiLFxuXHRcIm1ob1wiOiBcIuKEp1wiLFxuXHRcIm1pY3JvXCI6IFwiwrVcIixcblx0XCJtaWRhc3RcIjogXCIqXCIsXG5cdFwibWlkY2lyXCI6IFwi4quwXCIsXG5cdFwibWlkXCI6IFwi4oijXCIsXG5cdFwibWlkZG90XCI6IFwiwrdcIixcblx0XCJtaW51c2JcIjogXCLiip9cIixcblx0XCJtaW51c1wiOiBcIuKIklwiLFxuXHRcIm1pbnVzZFwiOiBcIuKIuFwiLFxuXHRcIm1pbnVzZHVcIjogXCLiqKpcIixcblx0XCJNaW51c1BsdXNcIjogXCLiiJNcIixcblx0XCJtbGNwXCI6IFwi4qubXCIsXG5cdFwibWxkclwiOiBcIuKAplwiLFxuXHRcIm1ucGx1c1wiOiBcIuKIk1wiLFxuXHRcIm1vZGVsc1wiOiBcIuKKp1wiLFxuXHRcIk1vcGZcIjogXCLwnZWEXCIsXG5cdFwibW9wZlwiOiBcIvCdlZ5cIixcblx0XCJtcFwiOiBcIuKIk1wiLFxuXHRcIm1zY3JcIjogXCLwnZOCXCIsXG5cdFwiTXNjclwiOiBcIuKEs1wiLFxuXHRcIm1zdHBvc1wiOiBcIuKIvlwiLFxuXHRcIk11XCI6IFwizpxcIixcblx0XCJtdVwiOiBcIs68XCIsXG5cdFwibXVsdGltYXBcIjogXCLiirhcIixcblx0XCJtdW1hcFwiOiBcIuKKuFwiLFxuXHRcIm5hYmxhXCI6IFwi4oiHXCIsXG5cdFwiTmFjdXRlXCI6IFwixYNcIixcblx0XCJuYWN1dGVcIjogXCLFhFwiLFxuXHRcIm5hbmdcIjogXCLiiKDig5JcIixcblx0XCJuYXBcIjogXCLiiYlcIixcblx0XCJuYXBFXCI6IFwi4qmwzLhcIixcblx0XCJuYXBpZFwiOiBcIuKJi8y4XCIsXG5cdFwibmFwb3NcIjogXCLFiVwiLFxuXHRcIm5hcHByb3hcIjogXCLiiYlcIixcblx0XCJuYXR1cmFsXCI6IFwi4pmuXCIsXG5cdFwibmF0dXJhbHNcIjogXCLihJVcIixcblx0XCJuYXR1clwiOiBcIuKZrlwiLFxuXHRcIm5ic3BcIjogXCLCoFwiLFxuXHRcIm5idW1wXCI6IFwi4omOzLhcIixcblx0XCJuYnVtcGVcIjogXCLiiY/MuFwiLFxuXHRcIm5jYXBcIjogXCLiqYNcIixcblx0XCJOY2Fyb25cIjogXCLFh1wiLFxuXHRcIm5jYXJvblwiOiBcIsWIXCIsXG5cdFwiTmNlZGlsXCI6IFwixYVcIixcblx0XCJuY2VkaWxcIjogXCLFhlwiLFxuXHRcIm5jb25nXCI6IFwi4omHXCIsXG5cdFwibmNvbmdkb3RcIjogXCLiqa3MuFwiLFxuXHRcIm5jdXBcIjogXCLiqYJcIixcblx0XCJOY3lcIjogXCLQnVwiLFxuXHRcIm5jeVwiOiBcItC9XCIsXG5cdFwibmRhc2hcIjogXCLigJNcIixcblx0XCJuZWFyaGtcIjogXCLipKRcIixcblx0XCJuZWFyclwiOiBcIuKGl1wiLFxuXHRcIm5lQXJyXCI6IFwi4oeXXCIsXG5cdFwibmVhcnJvd1wiOiBcIuKGl1wiLFxuXHRcIm5lXCI6IFwi4omgXCIsXG5cdFwibmVkb3RcIjogXCLiiZDMuFwiLFxuXHRcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjogXCLigItcIixcblx0XCJOZWdhdGl2ZVRoaWNrU3BhY2VcIjogXCLigItcIixcblx0XCJOZWdhdGl2ZVRoaW5TcGFjZVwiOiBcIuKAi1wiLFxuXHRcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOiBcIuKAi1wiLFxuXHRcIm5lcXVpdlwiOiBcIuKJolwiLFxuXHRcIm5lc2VhclwiOiBcIuKkqFwiLFxuXHRcIm5lc2ltXCI6IFwi4omCzLhcIixcblx0XCJOZXN0ZWRHcmVhdGVyR3JlYXRlclwiOiBcIuKJq1wiLFxuXHRcIk5lc3RlZExlc3NMZXNzXCI6IFwi4omqXCIsXG5cdFwiTmV3TGluZVwiOiBcIlxcblwiLFxuXHRcIm5leGlzdFwiOiBcIuKIhFwiLFxuXHRcIm5leGlzdHNcIjogXCLiiIRcIixcblx0XCJOZnJcIjogXCLwnZSRXCIsXG5cdFwibmZyXCI6IFwi8J2Uq1wiLFxuXHRcIm5nRVwiOiBcIuKJp8y4XCIsXG5cdFwibmdlXCI6IFwi4omxXCIsXG5cdFwibmdlcVwiOiBcIuKJsVwiLFxuXHRcIm5nZXFxXCI6IFwi4omnzLhcIixcblx0XCJuZ2Vxc2xhbnRcIjogXCLiqb7MuFwiLFxuXHRcIm5nZXNcIjogXCLiqb7MuFwiLFxuXHRcIm5HZ1wiOiBcIuKLmcy4XCIsXG5cdFwibmdzaW1cIjogXCLiibVcIixcblx0XCJuR3RcIjogXCLiiavig5JcIixcblx0XCJuZ3RcIjogXCLiia9cIixcblx0XCJuZ3RyXCI6IFwi4omvXCIsXG5cdFwibkd0dlwiOiBcIuKJq8y4XCIsXG5cdFwibmhhcnJcIjogXCLihq5cIixcblx0XCJuaEFyclwiOiBcIuKHjlwiLFxuXHRcIm5ocGFyXCI6IFwi4quyXCIsXG5cdFwibmlcIjogXCLiiItcIixcblx0XCJuaXNcIjogXCLii7xcIixcblx0XCJuaXNkXCI6IFwi4ou6XCIsXG5cdFwibml2XCI6IFwi4oiLXCIsXG5cdFwiTkpjeVwiOiBcItCKXCIsXG5cdFwibmpjeVwiOiBcItGaXCIsXG5cdFwibmxhcnJcIjogXCLihppcIixcblx0XCJubEFyclwiOiBcIuKHjVwiLFxuXHRcIm5sZHJcIjogXCLigKVcIixcblx0XCJubEVcIjogXCLiiabMuFwiLFxuXHRcIm5sZVwiOiBcIuKJsFwiLFxuXHRcIm5sZWZ0YXJyb3dcIjogXCLihppcIixcblx0XCJuTGVmdGFycm93XCI6IFwi4oeNXCIsXG5cdFwibmxlZnRyaWdodGFycm93XCI6IFwi4oauXCIsXG5cdFwibkxlZnRyaWdodGFycm93XCI6IFwi4oeOXCIsXG5cdFwibmxlcVwiOiBcIuKJsFwiLFxuXHRcIm5sZXFxXCI6IFwi4ommzLhcIixcblx0XCJubGVxc2xhbnRcIjogXCLiqb3MuFwiLFxuXHRcIm5sZXNcIjogXCLiqb3MuFwiLFxuXHRcIm5sZXNzXCI6IFwi4omuXCIsXG5cdFwibkxsXCI6IFwi4ouYzLhcIixcblx0XCJubHNpbVwiOiBcIuKJtFwiLFxuXHRcIm5MdFwiOiBcIuKJquKDklwiLFxuXHRcIm5sdFwiOiBcIuKJrlwiLFxuXHRcIm5sdHJpXCI6IFwi4ouqXCIsXG5cdFwibmx0cmllXCI6IFwi4ousXCIsXG5cdFwibkx0dlwiOiBcIuKJqsy4XCIsXG5cdFwibm1pZFwiOiBcIuKIpFwiLFxuXHRcIk5vQnJlYWtcIjogXCLigaBcIixcblx0XCJOb25CcmVha2luZ1NwYWNlXCI6IFwiwqBcIixcblx0XCJub3BmXCI6IFwi8J2Vn1wiLFxuXHRcIk5vcGZcIjogXCLihJVcIixcblx0XCJOb3RcIjogXCLiq6xcIixcblx0XCJub3RcIjogXCLCrFwiLFxuXHRcIk5vdENvbmdydWVudFwiOiBcIuKJolwiLFxuXHRcIk5vdEN1cENhcFwiOiBcIuKJrVwiLFxuXHRcIk5vdERvdWJsZVZlcnRpY2FsQmFyXCI6IFwi4oimXCIsXG5cdFwiTm90RWxlbWVudFwiOiBcIuKIiVwiLFxuXHRcIk5vdEVxdWFsXCI6IFwi4omgXCIsXG5cdFwiTm90RXF1YWxUaWxkZVwiOiBcIuKJgsy4XCIsXG5cdFwiTm90RXhpc3RzXCI6IFwi4oiEXCIsXG5cdFwiTm90R3JlYXRlclwiOiBcIuKJr1wiLFxuXHRcIk5vdEdyZWF0ZXJFcXVhbFwiOiBcIuKJsVwiLFxuXHRcIk5vdEdyZWF0ZXJGdWxsRXF1YWxcIjogXCLiiafMuFwiLFxuXHRcIk5vdEdyZWF0ZXJHcmVhdGVyXCI6IFwi4omrzLhcIixcblx0XCJOb3RHcmVhdGVyTGVzc1wiOiBcIuKJuVwiLFxuXHRcIk5vdEdyZWF0ZXJTbGFudEVxdWFsXCI6IFwi4qm+zLhcIixcblx0XCJOb3RHcmVhdGVyVGlsZGVcIjogXCLiibVcIixcblx0XCJOb3RIdW1wRG93bkh1bXBcIjogXCLiiY7MuFwiLFxuXHRcIk5vdEh1bXBFcXVhbFwiOiBcIuKJj8y4XCIsXG5cdFwibm90aW5cIjogXCLiiIlcIixcblx0XCJub3RpbmRvdFwiOiBcIuKLtcy4XCIsXG5cdFwibm90aW5FXCI6IFwi4ou5zLhcIixcblx0XCJub3RpbnZhXCI6IFwi4oiJXCIsXG5cdFwibm90aW52YlwiOiBcIuKLt1wiLFxuXHRcIm5vdGludmNcIjogXCLii7ZcIixcblx0XCJOb3RMZWZ0VHJpYW5nbGVCYXJcIjogXCLip4/MuFwiLFxuXHRcIk5vdExlZnRUcmlhbmdsZVwiOiBcIuKLqlwiLFxuXHRcIk5vdExlZnRUcmlhbmdsZUVxdWFsXCI6IFwi4ousXCIsXG5cdFwiTm90TGVzc1wiOiBcIuKJrlwiLFxuXHRcIk5vdExlc3NFcXVhbFwiOiBcIuKJsFwiLFxuXHRcIk5vdExlc3NHcmVhdGVyXCI6IFwi4om4XCIsXG5cdFwiTm90TGVzc0xlc3NcIjogXCLiiarMuFwiLFxuXHRcIk5vdExlc3NTbGFudEVxdWFsXCI6IFwi4qm9zLhcIixcblx0XCJOb3RMZXNzVGlsZGVcIjogXCLiibRcIixcblx0XCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlclwiOiBcIuKqosy4XCIsXG5cdFwiTm90TmVzdGVkTGVzc0xlc3NcIjogXCLiqqHMuFwiLFxuXHRcIm5vdG5pXCI6IFwi4oiMXCIsXG5cdFwibm90bml2YVwiOiBcIuKIjFwiLFxuXHRcIm5vdG5pdmJcIjogXCLii75cIixcblx0XCJub3RuaXZjXCI6IFwi4ou9XCIsXG5cdFwiTm90UHJlY2VkZXNcIjogXCLiioBcIixcblx0XCJOb3RQcmVjZWRlc0VxdWFsXCI6IFwi4qqvzLhcIixcblx0XCJOb3RQcmVjZWRlc1NsYW50RXF1YWxcIjogXCLii6BcIixcblx0XCJOb3RSZXZlcnNlRWxlbWVudFwiOiBcIuKIjFwiLFxuXHRcIk5vdFJpZ2h0VHJpYW5nbGVCYXJcIjogXCLip5DMuFwiLFxuXHRcIk5vdFJpZ2h0VHJpYW5nbGVcIjogXCLii6tcIixcblx0XCJOb3RSaWdodFRyaWFuZ2xlRXF1YWxcIjogXCLii61cIixcblx0XCJOb3RTcXVhcmVTdWJzZXRcIjogXCLiio/MuFwiLFxuXHRcIk5vdFNxdWFyZVN1YnNldEVxdWFsXCI6IFwi4ouiXCIsXG5cdFwiTm90U3F1YXJlU3VwZXJzZXRcIjogXCLiipDMuFwiLFxuXHRcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWxcIjogXCLii6NcIixcblx0XCJOb3RTdWJzZXRcIjogXCLiioLig5JcIixcblx0XCJOb3RTdWJzZXRFcXVhbFwiOiBcIuKKiFwiLFxuXHRcIk5vdFN1Y2NlZWRzXCI6IFwi4oqBXCIsXG5cdFwiTm90U3VjY2VlZHNFcXVhbFwiOiBcIuKqsMy4XCIsXG5cdFwiTm90U3VjY2VlZHNTbGFudEVxdWFsXCI6IFwi4ouhXCIsXG5cdFwiTm90U3VjY2VlZHNUaWxkZVwiOiBcIuKJv8y4XCIsXG5cdFwiTm90U3VwZXJzZXRcIjogXCLiioPig5JcIixcblx0XCJOb3RTdXBlcnNldEVxdWFsXCI6IFwi4oqJXCIsXG5cdFwiTm90VGlsZGVcIjogXCLiiYFcIixcblx0XCJOb3RUaWxkZUVxdWFsXCI6IFwi4omEXCIsXG5cdFwiTm90VGlsZGVGdWxsRXF1YWxcIjogXCLiiYdcIixcblx0XCJOb3RUaWxkZVRpbGRlXCI6IFwi4omJXCIsXG5cdFwiTm90VmVydGljYWxCYXJcIjogXCLiiKRcIixcblx0XCJucGFyYWxsZWxcIjogXCLiiKZcIixcblx0XCJucGFyXCI6IFwi4oimXCIsXG5cdFwibnBhcnNsXCI6IFwi4qu94oOlXCIsXG5cdFwibnBhcnRcIjogXCLiiILMuFwiLFxuXHRcIm5wb2xpbnRcIjogXCLiqJRcIixcblx0XCJucHJcIjogXCLiioBcIixcblx0XCJucHJjdWVcIjogXCLii6BcIixcblx0XCJucHJlY1wiOiBcIuKKgFwiLFxuXHRcIm5wcmVjZXFcIjogXCLiqq/MuFwiLFxuXHRcIm5wcmVcIjogXCLiqq/MuFwiLFxuXHRcIm5yYXJyY1wiOiBcIuKks8y4XCIsXG5cdFwibnJhcnJcIjogXCLihptcIixcblx0XCJuckFyclwiOiBcIuKHj1wiLFxuXHRcIm5yYXJyd1wiOiBcIuKGncy4XCIsXG5cdFwibnJpZ2h0YXJyb3dcIjogXCLihptcIixcblx0XCJuUmlnaHRhcnJvd1wiOiBcIuKHj1wiLFxuXHRcIm5ydHJpXCI6IFwi4ourXCIsXG5cdFwibnJ0cmllXCI6IFwi4outXCIsXG5cdFwibnNjXCI6IFwi4oqBXCIsXG5cdFwibnNjY3VlXCI6IFwi4ouhXCIsXG5cdFwibnNjZVwiOiBcIuKqsMy4XCIsXG5cdFwiTnNjclwiOiBcIvCdkqlcIixcblx0XCJuc2NyXCI6IFwi8J2Tg1wiLFxuXHRcIm5zaG9ydG1pZFwiOiBcIuKIpFwiLFxuXHRcIm5zaG9ydHBhcmFsbGVsXCI6IFwi4oimXCIsXG5cdFwibnNpbVwiOiBcIuKJgVwiLFxuXHRcIm5zaW1lXCI6IFwi4omEXCIsXG5cdFwibnNpbWVxXCI6IFwi4omEXCIsXG5cdFwibnNtaWRcIjogXCLiiKRcIixcblx0XCJuc3BhclwiOiBcIuKIplwiLFxuXHRcIm5zcXN1YmVcIjogXCLii6JcIixcblx0XCJuc3FzdXBlXCI6IFwi4oujXCIsXG5cdFwibnN1YlwiOiBcIuKKhFwiLFxuXHRcIm5zdWJFXCI6IFwi4quFzLhcIixcblx0XCJuc3ViZVwiOiBcIuKKiFwiLFxuXHRcIm5zdWJzZXRcIjogXCLiioLig5JcIixcblx0XCJuc3Vic2V0ZXFcIjogXCLiiohcIixcblx0XCJuc3Vic2V0ZXFxXCI6IFwi4quFzLhcIixcblx0XCJuc3VjY1wiOiBcIuKKgVwiLFxuXHRcIm5zdWNjZXFcIjogXCLiqrDMuFwiLFxuXHRcIm5zdXBcIjogXCLiioVcIixcblx0XCJuc3VwRVwiOiBcIuKrhsy4XCIsXG5cdFwibnN1cGVcIjogXCLiiolcIixcblx0XCJuc3Vwc2V0XCI6IFwi4oqD4oOSXCIsXG5cdFwibnN1cHNldGVxXCI6IFwi4oqJXCIsXG5cdFwibnN1cHNldGVxcVwiOiBcIuKrhsy4XCIsXG5cdFwibnRnbFwiOiBcIuKJuVwiLFxuXHRcIk50aWxkZVwiOiBcIsORXCIsXG5cdFwibnRpbGRlXCI6IFwiw7FcIixcblx0XCJudGxnXCI6IFwi4om4XCIsXG5cdFwibnRyaWFuZ2xlbGVmdFwiOiBcIuKLqlwiLFxuXHRcIm50cmlhbmdsZWxlZnRlcVwiOiBcIuKLrFwiLFxuXHRcIm50cmlhbmdsZXJpZ2h0XCI6IFwi4ourXCIsXG5cdFwibnRyaWFuZ2xlcmlnaHRlcVwiOiBcIuKLrVwiLFxuXHRcIk51XCI6IFwizp1cIixcblx0XCJudVwiOiBcIs69XCIsXG5cdFwibnVtXCI6IFwiI1wiLFxuXHRcIm51bWVyb1wiOiBcIuKEllwiLFxuXHRcIm51bXNwXCI6IFwi4oCHXCIsXG5cdFwibnZhcFwiOiBcIuKJjeKDklwiLFxuXHRcIm52ZGFzaFwiOiBcIuKKrFwiLFxuXHRcIm52RGFzaFwiOiBcIuKKrVwiLFxuXHRcIm5WZGFzaFwiOiBcIuKKrlwiLFxuXHRcIm5WRGFzaFwiOiBcIuKKr1wiLFxuXHRcIm52Z2VcIjogXCLiiaXig5JcIixcblx0XCJudmd0XCI6IFwiPuKDklwiLFxuXHRcIm52SGFyclwiOiBcIuKkhFwiLFxuXHRcIm52aW5maW5cIjogXCLip55cIixcblx0XCJudmxBcnJcIjogXCLipIJcIixcblx0XCJudmxlXCI6IFwi4omk4oOSXCIsXG5cdFwibnZsdFwiOiBcIjzig5JcIixcblx0XCJudmx0cmllXCI6IFwi4oq04oOSXCIsXG5cdFwibnZyQXJyXCI6IFwi4qSDXCIsXG5cdFwibnZydHJpZVwiOiBcIuKKteKDklwiLFxuXHRcIm52c2ltXCI6IFwi4oi84oOSXCIsXG5cdFwibndhcmhrXCI6IFwi4qSjXCIsXG5cdFwibndhcnJcIjogXCLihpZcIixcblx0XCJud0FyclwiOiBcIuKHllwiLFxuXHRcIm53YXJyb3dcIjogXCLihpZcIixcblx0XCJud25lYXJcIjogXCLipKdcIixcblx0XCJPYWN1dGVcIjogXCLDk1wiLFxuXHRcIm9hY3V0ZVwiOiBcIsOzXCIsXG5cdFwib2FzdFwiOiBcIuKKm1wiLFxuXHRcIk9jaXJjXCI6IFwiw5RcIixcblx0XCJvY2lyY1wiOiBcIsO0XCIsXG5cdFwib2NpclwiOiBcIuKKmlwiLFxuXHRcIk9jeVwiOiBcItCeXCIsXG5cdFwib2N5XCI6IFwi0L5cIixcblx0XCJvZGFzaFwiOiBcIuKKnVwiLFxuXHRcIk9kYmxhY1wiOiBcIsWQXCIsXG5cdFwib2RibGFjXCI6IFwixZFcIixcblx0XCJvZGl2XCI6IFwi4qi4XCIsXG5cdFwib2RvdFwiOiBcIuKKmVwiLFxuXHRcIm9kc29sZFwiOiBcIuKmvFwiLFxuXHRcIk9FbGlnXCI6IFwixZJcIixcblx0XCJvZWxpZ1wiOiBcIsWTXCIsXG5cdFwib2ZjaXJcIjogXCLipr9cIixcblx0XCJPZnJcIjogXCLwnZSSXCIsXG5cdFwib2ZyXCI6IFwi8J2UrFwiLFxuXHRcIm9nb25cIjogXCLLm1wiLFxuXHRcIk9ncmF2ZVwiOiBcIsOSXCIsXG5cdFwib2dyYXZlXCI6IFwiw7JcIixcblx0XCJvZ3RcIjogXCLip4FcIixcblx0XCJvaGJhclwiOiBcIuKmtVwiLFxuXHRcIm9obVwiOiBcIs6pXCIsXG5cdFwib2ludFwiOiBcIuKIrlwiLFxuXHRcIm9sYXJyXCI6IFwi4oa6XCIsXG5cdFwib2xjaXJcIjogXCLipr5cIixcblx0XCJvbGNyb3NzXCI6IFwi4qa7XCIsXG5cdFwib2xpbmVcIjogXCLigL5cIixcblx0XCJvbHRcIjogXCLip4BcIixcblx0XCJPbWFjclwiOiBcIsWMXCIsXG5cdFwib21hY3JcIjogXCLFjVwiLFxuXHRcIk9tZWdhXCI6IFwizqlcIixcblx0XCJvbWVnYVwiOiBcIs+JXCIsXG5cdFwiT21pY3JvblwiOiBcIs6fXCIsXG5cdFwib21pY3JvblwiOiBcIs6/XCIsXG5cdFwib21pZFwiOiBcIuKmtlwiLFxuXHRcIm9taW51c1wiOiBcIuKKllwiLFxuXHRcIk9vcGZcIjogXCLwnZWGXCIsXG5cdFwib29wZlwiOiBcIvCdlaBcIixcblx0XCJvcGFyXCI6IFwi4qa3XCIsXG5cdFwiT3BlbkN1cmx5RG91YmxlUXVvdGVcIjogXCLigJxcIixcblx0XCJPcGVuQ3VybHlRdW90ZVwiOiBcIuKAmFwiLFxuXHRcIm9wZXJwXCI6IFwi4qa5XCIsXG5cdFwib3BsdXNcIjogXCLiipVcIixcblx0XCJvcmFyclwiOiBcIuKGu1wiLFxuXHRcIk9yXCI6IFwi4qmUXCIsXG5cdFwib3JcIjogXCLiiKhcIixcblx0XCJvcmRcIjogXCLiqZ1cIixcblx0XCJvcmRlclwiOiBcIuKEtFwiLFxuXHRcIm9yZGVyb2ZcIjogXCLihLRcIixcblx0XCJvcmRmXCI6IFwiwqpcIixcblx0XCJvcmRtXCI6IFwiwrpcIixcblx0XCJvcmlnb2ZcIjogXCLiirZcIixcblx0XCJvcm9yXCI6IFwi4qmWXCIsXG5cdFwib3JzbG9wZVwiOiBcIuKpl1wiLFxuXHRcIm9ydlwiOiBcIuKpm1wiLFxuXHRcIm9TXCI6IFwi4pOIXCIsXG5cdFwiT3NjclwiOiBcIvCdkqpcIixcblx0XCJvc2NyXCI6IFwi4oS0XCIsXG5cdFwiT3NsYXNoXCI6IFwiw5hcIixcblx0XCJvc2xhc2hcIjogXCLDuFwiLFxuXHRcIm9zb2xcIjogXCLiiphcIixcblx0XCJPdGlsZGVcIjogXCLDlVwiLFxuXHRcIm90aWxkZVwiOiBcIsO1XCIsXG5cdFwib3RpbWVzYXNcIjogXCLiqLZcIixcblx0XCJPdGltZXNcIjogXCLiqLdcIixcblx0XCJvdGltZXNcIjogXCLiipdcIixcblx0XCJPdW1sXCI6IFwiw5ZcIixcblx0XCJvdW1sXCI6IFwiw7ZcIixcblx0XCJvdmJhclwiOiBcIuKMvVwiLFxuXHRcIk92ZXJCYXJcIjogXCLigL5cIixcblx0XCJPdmVyQnJhY2VcIjogXCLij55cIixcblx0XCJPdmVyQnJhY2tldFwiOiBcIuKOtFwiLFxuXHRcIk92ZXJQYXJlbnRoZXNpc1wiOiBcIuKPnFwiLFxuXHRcInBhcmFcIjogXCLCtlwiLFxuXHRcInBhcmFsbGVsXCI6IFwi4oilXCIsXG5cdFwicGFyXCI6IFwi4oilXCIsXG5cdFwicGFyc2ltXCI6IFwi4quzXCIsXG5cdFwicGFyc2xcIjogXCLiq71cIixcblx0XCJwYXJ0XCI6IFwi4oiCXCIsXG5cdFwiUGFydGlhbERcIjogXCLiiIJcIixcblx0XCJQY3lcIjogXCLQn1wiLFxuXHRcInBjeVwiOiBcItC/XCIsXG5cdFwicGVyY250XCI6IFwiJVwiLFxuXHRcInBlcmlvZFwiOiBcIi5cIixcblx0XCJwZXJtaWxcIjogXCLigLBcIixcblx0XCJwZXJwXCI6IFwi4oqlXCIsXG5cdFwicGVydGVua1wiOiBcIuKAsVwiLFxuXHRcIlBmclwiOiBcIvCdlJNcIixcblx0XCJwZnJcIjogXCLwnZStXCIsXG5cdFwiUGhpXCI6IFwizqZcIixcblx0XCJwaGlcIjogXCLPhlwiLFxuXHRcInBoaXZcIjogXCLPlVwiLFxuXHRcInBobW1hdFwiOiBcIuKEs1wiLFxuXHRcInBob25lXCI6IFwi4piOXCIsXG5cdFwiUGlcIjogXCLOoFwiLFxuXHRcInBpXCI6IFwiz4BcIixcblx0XCJwaXRjaGZvcmtcIjogXCLii5RcIixcblx0XCJwaXZcIjogXCLPllwiLFxuXHRcInBsYW5ja1wiOiBcIuKEj1wiLFxuXHRcInBsYW5ja2hcIjogXCLihI5cIixcblx0XCJwbGFua3ZcIjogXCLihI9cIixcblx0XCJwbHVzYWNpclwiOiBcIuKoo1wiLFxuXHRcInBsdXNiXCI6IFwi4oqeXCIsXG5cdFwicGx1c2NpclwiOiBcIuKoolwiLFxuXHRcInBsdXNcIjogXCIrXCIsXG5cdFwicGx1c2RvXCI6IFwi4oiUXCIsXG5cdFwicGx1c2R1XCI6IFwi4qilXCIsXG5cdFwicGx1c2VcIjogXCLiqbJcIixcblx0XCJQbHVzTWludXNcIjogXCLCsVwiLFxuXHRcInBsdXNtblwiOiBcIsKxXCIsXG5cdFwicGx1c3NpbVwiOiBcIuKoplwiLFxuXHRcInBsdXN0d29cIjogXCLiqKdcIixcblx0XCJwbVwiOiBcIsKxXCIsXG5cdFwiUG9pbmNhcmVwbGFuZVwiOiBcIuKEjFwiLFxuXHRcInBvaW50aW50XCI6IFwi4qiVXCIsXG5cdFwicG9wZlwiOiBcIvCdlaFcIixcblx0XCJQb3BmXCI6IFwi4oSZXCIsXG5cdFwicG91bmRcIjogXCLCo1wiLFxuXHRcInByYXBcIjogXCLiqrdcIixcblx0XCJQclwiOiBcIuKqu1wiLFxuXHRcInByXCI6IFwi4om6XCIsXG5cdFwicHJjdWVcIjogXCLiibxcIixcblx0XCJwcmVjYXBwcm94XCI6IFwi4qq3XCIsXG5cdFwicHJlY1wiOiBcIuKJulwiLFxuXHRcInByZWNjdXJseWVxXCI6IFwi4om8XCIsXG5cdFwiUHJlY2VkZXNcIjogXCLiibpcIixcblx0XCJQcmVjZWRlc0VxdWFsXCI6IFwi4qqvXCIsXG5cdFwiUHJlY2VkZXNTbGFudEVxdWFsXCI6IFwi4om8XCIsXG5cdFwiUHJlY2VkZXNUaWxkZVwiOiBcIuKJvlwiLFxuXHRcInByZWNlcVwiOiBcIuKqr1wiLFxuXHRcInByZWNuYXBwcm94XCI6IFwi4qq5XCIsXG5cdFwicHJlY25lcXFcIjogXCLiqrVcIixcblx0XCJwcmVjbnNpbVwiOiBcIuKLqFwiLFxuXHRcInByZVwiOiBcIuKqr1wiLFxuXHRcInByRVwiOiBcIuKqs1wiLFxuXHRcInByZWNzaW1cIjogXCLiib5cIixcblx0XCJwcmltZVwiOiBcIuKAslwiLFxuXHRcIlByaW1lXCI6IFwi4oCzXCIsXG5cdFwicHJpbWVzXCI6IFwi4oSZXCIsXG5cdFwicHJuYXBcIjogXCLiqrlcIixcblx0XCJwcm5FXCI6IFwi4qq1XCIsXG5cdFwicHJuc2ltXCI6IFwi4ouoXCIsXG5cdFwicHJvZFwiOiBcIuKIj1wiLFxuXHRcIlByb2R1Y3RcIjogXCLiiI9cIixcblx0XCJwcm9mYWxhclwiOiBcIuKMrlwiLFxuXHRcInByb2ZsaW5lXCI6IFwi4oySXCIsXG5cdFwicHJvZnN1cmZcIjogXCLijJNcIixcblx0XCJwcm9wXCI6IFwi4oidXCIsXG5cdFwiUHJvcG9ydGlvbmFsXCI6IFwi4oidXCIsXG5cdFwiUHJvcG9ydGlvblwiOiBcIuKIt1wiLFxuXHRcInByb3B0b1wiOiBcIuKInVwiLFxuXHRcInByc2ltXCI6IFwi4om+XCIsXG5cdFwicHJ1cmVsXCI6IFwi4oqwXCIsXG5cdFwiUHNjclwiOiBcIvCdkqtcIixcblx0XCJwc2NyXCI6IFwi8J2ThVwiLFxuXHRcIlBzaVwiOiBcIs6oXCIsXG5cdFwicHNpXCI6IFwiz4hcIixcblx0XCJwdW5jc3BcIjogXCLigIhcIixcblx0XCJRZnJcIjogXCLwnZSUXCIsXG5cdFwicWZyXCI6IFwi8J2UrlwiLFxuXHRcInFpbnRcIjogXCLiqIxcIixcblx0XCJxb3BmXCI6IFwi8J2VolwiLFxuXHRcIlFvcGZcIjogXCLihJpcIixcblx0XCJxcHJpbWVcIjogXCLigZdcIixcblx0XCJRc2NyXCI6IFwi8J2SrFwiLFxuXHRcInFzY3JcIjogXCLwnZOGXCIsXG5cdFwicXVhdGVybmlvbnNcIjogXCLihI1cIixcblx0XCJxdWF0aW50XCI6IFwi4qiWXCIsXG5cdFwicXVlc3RcIjogXCI/XCIsXG5cdFwicXVlc3RlcVwiOiBcIuKJn1wiLFxuXHRcInF1b3RcIjogXCJcXFwiXCIsXG5cdFwiUVVPVFwiOiBcIlxcXCJcIixcblx0XCJyQWFyclwiOiBcIuKHm1wiLFxuXHRcInJhY2VcIjogXCLiiL3MsVwiLFxuXHRcIlJhY3V0ZVwiOiBcIsWUXCIsXG5cdFwicmFjdXRlXCI6IFwixZVcIixcblx0XCJyYWRpY1wiOiBcIuKImlwiLFxuXHRcInJhZW1wdHl2XCI6IFwi4qazXCIsXG5cdFwicmFuZ1wiOiBcIuKfqVwiLFxuXHRcIlJhbmdcIjogXCLin6tcIixcblx0XCJyYW5nZFwiOiBcIuKmklwiLFxuXHRcInJhbmdlXCI6IFwi4qalXCIsXG5cdFwicmFuZ2xlXCI6IFwi4p+pXCIsXG5cdFwicmFxdW9cIjogXCLCu1wiLFxuXHRcInJhcnJhcFwiOiBcIuKltVwiLFxuXHRcInJhcnJiXCI6IFwi4oelXCIsXG5cdFwicmFycmJmc1wiOiBcIuKkoFwiLFxuXHRcInJhcnJjXCI6IFwi4qSzXCIsXG5cdFwicmFyclwiOiBcIuKGklwiLFxuXHRcIlJhcnJcIjogXCLihqBcIixcblx0XCJyQXJyXCI6IFwi4oeSXCIsXG5cdFwicmFycmZzXCI6IFwi4qSeXCIsXG5cdFwicmFycmhrXCI6IFwi4oaqXCIsXG5cdFwicmFycmxwXCI6IFwi4oasXCIsXG5cdFwicmFycnBsXCI6IFwi4qWFXCIsXG5cdFwicmFycnNpbVwiOiBcIuKltFwiLFxuXHRcIlJhcnJ0bFwiOiBcIuKkllwiLFxuXHRcInJhcnJ0bFwiOiBcIuKGo1wiLFxuXHRcInJhcnJ3XCI6IFwi4oadXCIsXG5cdFwicmF0YWlsXCI6IFwi4qSaXCIsXG5cdFwickF0YWlsXCI6IFwi4qScXCIsXG5cdFwicmF0aW9cIjogXCLiiLZcIixcblx0XCJyYXRpb25hbHNcIjogXCLihJpcIixcblx0XCJyYmFyclwiOiBcIuKkjVwiLFxuXHRcInJCYXJyXCI6IFwi4qSPXCIsXG5cdFwiUkJhcnJcIjogXCLipJBcIixcblx0XCJyYmJya1wiOiBcIuKds1wiLFxuXHRcInJicmFjZVwiOiBcIn1cIixcblx0XCJyYnJhY2tcIjogXCJdXCIsXG5cdFwicmJya2VcIjogXCLipoxcIixcblx0XCJyYnJrc2xkXCI6IFwi4qaOXCIsXG5cdFwicmJya3NsdVwiOiBcIuKmkFwiLFxuXHRcIlJjYXJvblwiOiBcIsWYXCIsXG5cdFwicmNhcm9uXCI6IFwixZlcIixcblx0XCJSY2VkaWxcIjogXCLFllwiLFxuXHRcInJjZWRpbFwiOiBcIsWXXCIsXG5cdFwicmNlaWxcIjogXCLijIlcIixcblx0XCJyY3ViXCI6IFwifVwiLFxuXHRcIlJjeVwiOiBcItCgXCIsXG5cdFwicmN5XCI6IFwi0YBcIixcblx0XCJyZGNhXCI6IFwi4qS3XCIsXG5cdFwicmRsZGhhclwiOiBcIuKlqVwiLFxuXHRcInJkcXVvXCI6IFwi4oCdXCIsXG5cdFwicmRxdW9yXCI6IFwi4oCdXCIsXG5cdFwicmRzaFwiOiBcIuKGs1wiLFxuXHRcInJlYWxcIjogXCLihJxcIixcblx0XCJyZWFsaW5lXCI6IFwi4oSbXCIsXG5cdFwicmVhbHBhcnRcIjogXCLihJxcIixcblx0XCJyZWFsc1wiOiBcIuKEnVwiLFxuXHRcIlJlXCI6IFwi4oScXCIsXG5cdFwicmVjdFwiOiBcIuKWrVwiLFxuXHRcInJlZ1wiOiBcIsKuXCIsXG5cdFwiUkVHXCI6IFwiwq5cIixcblx0XCJSZXZlcnNlRWxlbWVudFwiOiBcIuKIi1wiLFxuXHRcIlJldmVyc2VFcXVpbGlicml1bVwiOiBcIuKHi1wiLFxuXHRcIlJldmVyc2VVcEVxdWlsaWJyaXVtXCI6IFwi4qWvXCIsXG5cdFwicmZpc2h0XCI6IFwi4qW9XCIsXG5cdFwicmZsb29yXCI6IFwi4oyLXCIsXG5cdFwicmZyXCI6IFwi8J2Ur1wiLFxuXHRcIlJmclwiOiBcIuKEnFwiLFxuXHRcInJIYXJcIjogXCLipaRcIixcblx0XCJyaGFyZFwiOiBcIuKHgVwiLFxuXHRcInJoYXJ1XCI6IFwi4oeAXCIsXG5cdFwicmhhcnVsXCI6IFwi4qWsXCIsXG5cdFwiUmhvXCI6IFwizqFcIixcblx0XCJyaG9cIjogXCLPgVwiLFxuXHRcInJob3ZcIjogXCLPsVwiLFxuXHRcIlJpZ2h0QW5nbGVCcmFja2V0XCI6IFwi4p+pXCIsXG5cdFwiUmlnaHRBcnJvd0JhclwiOiBcIuKHpVwiLFxuXHRcInJpZ2h0YXJyb3dcIjogXCLihpJcIixcblx0XCJSaWdodEFycm93XCI6IFwi4oaSXCIsXG5cdFwiUmlnaHRhcnJvd1wiOiBcIuKHklwiLFxuXHRcIlJpZ2h0QXJyb3dMZWZ0QXJyb3dcIjogXCLih4RcIixcblx0XCJyaWdodGFycm93dGFpbFwiOiBcIuKGo1wiLFxuXHRcIlJpZ2h0Q2VpbGluZ1wiOiBcIuKMiVwiLFxuXHRcIlJpZ2h0RG91YmxlQnJhY2tldFwiOiBcIuKfp1wiLFxuXHRcIlJpZ2h0RG93blRlZVZlY3RvclwiOiBcIuKlnVwiLFxuXHRcIlJpZ2h0RG93blZlY3RvckJhclwiOiBcIuKllVwiLFxuXHRcIlJpZ2h0RG93blZlY3RvclwiOiBcIuKHglwiLFxuXHRcIlJpZ2h0Rmxvb3JcIjogXCLijItcIixcblx0XCJyaWdodGhhcnBvb25kb3duXCI6IFwi4oeBXCIsXG5cdFwicmlnaHRoYXJwb29udXBcIjogXCLih4BcIixcblx0XCJyaWdodGxlZnRhcnJvd3NcIjogXCLih4RcIixcblx0XCJyaWdodGxlZnRoYXJwb29uc1wiOiBcIuKHjFwiLFxuXHRcInJpZ2h0cmlnaHRhcnJvd3NcIjogXCLih4lcIixcblx0XCJyaWdodHNxdWlnYXJyb3dcIjogXCLihp1cIixcblx0XCJSaWdodFRlZUFycm93XCI6IFwi4oamXCIsXG5cdFwiUmlnaHRUZWVcIjogXCLiiqJcIixcblx0XCJSaWdodFRlZVZlY3RvclwiOiBcIuKlm1wiLFxuXHRcInJpZ2h0dGhyZWV0aW1lc1wiOiBcIuKLjFwiLFxuXHRcIlJpZ2h0VHJpYW5nbGVCYXJcIjogXCLip5BcIixcblx0XCJSaWdodFRyaWFuZ2xlXCI6IFwi4oqzXCIsXG5cdFwiUmlnaHRUcmlhbmdsZUVxdWFsXCI6IFwi4oq1XCIsXG5cdFwiUmlnaHRVcERvd25WZWN0b3JcIjogXCLipY9cIixcblx0XCJSaWdodFVwVGVlVmVjdG9yXCI6IFwi4qWcXCIsXG5cdFwiUmlnaHRVcFZlY3RvckJhclwiOiBcIuKllFwiLFxuXHRcIlJpZ2h0VXBWZWN0b3JcIjogXCLihr5cIixcblx0XCJSaWdodFZlY3RvckJhclwiOiBcIuKlk1wiLFxuXHRcIlJpZ2h0VmVjdG9yXCI6IFwi4oeAXCIsXG5cdFwicmluZ1wiOiBcIsuaXCIsXG5cdFwicmlzaW5nZG90c2VxXCI6IFwi4omTXCIsXG5cdFwicmxhcnJcIjogXCLih4RcIixcblx0XCJybGhhclwiOiBcIuKHjFwiLFxuXHRcInJsbVwiOiBcIuKAj1wiLFxuXHRcInJtb3VzdGFjaGVcIjogXCLijrFcIixcblx0XCJybW91c3RcIjogXCLijrFcIixcblx0XCJybm1pZFwiOiBcIuKrrlwiLFxuXHRcInJvYW5nXCI6IFwi4p+tXCIsXG5cdFwicm9hcnJcIjogXCLih75cIixcblx0XCJyb2Jya1wiOiBcIuKfp1wiLFxuXHRcInJvcGFyXCI6IFwi4qaGXCIsXG5cdFwicm9wZlwiOiBcIvCdlaNcIixcblx0XCJSb3BmXCI6IFwi4oSdXCIsXG5cdFwicm9wbHVzXCI6IFwi4qiuXCIsXG5cdFwicm90aW1lc1wiOiBcIuKotVwiLFxuXHRcIlJvdW5kSW1wbGllc1wiOiBcIuKlsFwiLFxuXHRcInJwYXJcIjogXCIpXCIsXG5cdFwicnBhcmd0XCI6IFwi4qaUXCIsXG5cdFwicnBwb2xpbnRcIjogXCLiqJJcIixcblx0XCJycmFyclwiOiBcIuKHiVwiLFxuXHRcIlJyaWdodGFycm93XCI6IFwi4oebXCIsXG5cdFwicnNhcXVvXCI6IFwi4oC6XCIsXG5cdFwicnNjclwiOiBcIvCdk4dcIixcblx0XCJSc2NyXCI6IFwi4oSbXCIsXG5cdFwicnNoXCI6IFwi4oaxXCIsXG5cdFwiUnNoXCI6IFwi4oaxXCIsXG5cdFwicnNxYlwiOiBcIl1cIixcblx0XCJyc3F1b1wiOiBcIuKAmVwiLFxuXHRcInJzcXVvclwiOiBcIuKAmVwiLFxuXHRcInJ0aHJlZVwiOiBcIuKLjFwiLFxuXHRcInJ0aW1lc1wiOiBcIuKLilwiLFxuXHRcInJ0cmlcIjogXCLilrlcIixcblx0XCJydHJpZVwiOiBcIuKKtVwiLFxuXHRcInJ0cmlmXCI6IFwi4pa4XCIsXG5cdFwicnRyaWx0cmlcIjogXCLip45cIixcblx0XCJSdWxlRGVsYXllZFwiOiBcIuKntFwiLFxuXHRcInJ1bHVoYXJcIjogXCLipahcIixcblx0XCJyeFwiOiBcIuKEnlwiLFxuXHRcIlNhY3V0ZVwiOiBcIsWaXCIsXG5cdFwic2FjdXRlXCI6IFwixZtcIixcblx0XCJzYnF1b1wiOiBcIuKAmlwiLFxuXHRcInNjYXBcIjogXCLiqrhcIixcblx0XCJTY2Fyb25cIjogXCLFoFwiLFxuXHRcInNjYXJvblwiOiBcIsWhXCIsXG5cdFwiU2NcIjogXCLiqrxcIixcblx0XCJzY1wiOiBcIuKJu1wiLFxuXHRcInNjY3VlXCI6IFwi4om9XCIsXG5cdFwic2NlXCI6IFwi4qqwXCIsXG5cdFwic2NFXCI6IFwi4qq0XCIsXG5cdFwiU2NlZGlsXCI6IFwixZ5cIixcblx0XCJzY2VkaWxcIjogXCLFn1wiLFxuXHRcIlNjaXJjXCI6IFwixZxcIixcblx0XCJzY2lyY1wiOiBcIsWdXCIsXG5cdFwic2NuYXBcIjogXCLiqrpcIixcblx0XCJzY25FXCI6IFwi4qq2XCIsXG5cdFwic2Nuc2ltXCI6IFwi4oupXCIsXG5cdFwic2Nwb2xpbnRcIjogXCLiqJNcIixcblx0XCJzY3NpbVwiOiBcIuKJv1wiLFxuXHRcIlNjeVwiOiBcItChXCIsXG5cdFwic2N5XCI6IFwi0YFcIixcblx0XCJzZG90YlwiOiBcIuKKoVwiLFxuXHRcInNkb3RcIjogXCLii4VcIixcblx0XCJzZG90ZVwiOiBcIuKpplwiLFxuXHRcInNlYXJoa1wiOiBcIuKkpVwiLFxuXHRcInNlYXJyXCI6IFwi4oaYXCIsXG5cdFwic2VBcnJcIjogXCLih5hcIixcblx0XCJzZWFycm93XCI6IFwi4oaYXCIsXG5cdFwic2VjdFwiOiBcIsKnXCIsXG5cdFwic2VtaVwiOiBcIjtcIixcblx0XCJzZXN3YXJcIjogXCLipKlcIixcblx0XCJzZXRtaW51c1wiOiBcIuKIllwiLFxuXHRcInNldG1uXCI6IFwi4oiWXCIsXG5cdFwic2V4dFwiOiBcIuKctlwiLFxuXHRcIlNmclwiOiBcIvCdlJZcIixcblx0XCJzZnJcIjogXCLwnZSwXCIsXG5cdFwic2Zyb3duXCI6IFwi4oyiXCIsXG5cdFwic2hhcnBcIjogXCLima9cIixcblx0XCJTSENIY3lcIjogXCLQqVwiLFxuXHRcInNoY2hjeVwiOiBcItGJXCIsXG5cdFwiU0hjeVwiOiBcItCoXCIsXG5cdFwic2hjeVwiOiBcItGIXCIsXG5cdFwiU2hvcnREb3duQXJyb3dcIjogXCLihpNcIixcblx0XCJTaG9ydExlZnRBcnJvd1wiOiBcIuKGkFwiLFxuXHRcInNob3J0bWlkXCI6IFwi4oijXCIsXG5cdFwic2hvcnRwYXJhbGxlbFwiOiBcIuKIpVwiLFxuXHRcIlNob3J0UmlnaHRBcnJvd1wiOiBcIuKGklwiLFxuXHRcIlNob3J0VXBBcnJvd1wiOiBcIuKGkVwiLFxuXHRcInNoeVwiOiBcIsKtXCIsXG5cdFwiU2lnbWFcIjogXCLOo1wiLFxuXHRcInNpZ21hXCI6IFwiz4NcIixcblx0XCJzaWdtYWZcIjogXCLPglwiLFxuXHRcInNpZ21hdlwiOiBcIs+CXCIsXG5cdFwic2ltXCI6IFwi4oi8XCIsXG5cdFwic2ltZG90XCI6IFwi4qmqXCIsXG5cdFwic2ltZVwiOiBcIuKJg1wiLFxuXHRcInNpbWVxXCI6IFwi4omDXCIsXG5cdFwic2ltZ1wiOiBcIuKqnlwiLFxuXHRcInNpbWdFXCI6IFwi4qqgXCIsXG5cdFwic2ltbFwiOiBcIuKqnVwiLFxuXHRcInNpbWxFXCI6IFwi4qqfXCIsXG5cdFwic2ltbmVcIjogXCLiiYZcIixcblx0XCJzaW1wbHVzXCI6IFwi4qikXCIsXG5cdFwic2ltcmFyclwiOiBcIuKlslwiLFxuXHRcInNsYXJyXCI6IFwi4oaQXCIsXG5cdFwiU21hbGxDaXJjbGVcIjogXCLiiJhcIixcblx0XCJzbWFsbHNldG1pbnVzXCI6IFwi4oiWXCIsXG5cdFwic21hc2hwXCI6IFwi4qizXCIsXG5cdFwic21lcGFyc2xcIjogXCLip6RcIixcblx0XCJzbWlkXCI6IFwi4oijXCIsXG5cdFwic21pbGVcIjogXCLijKNcIixcblx0XCJzbXRcIjogXCLiqqpcIixcblx0XCJzbXRlXCI6IFwi4qqsXCIsXG5cdFwic210ZXNcIjogXCLiqqzvuIBcIixcblx0XCJTT0ZUY3lcIjogXCLQrFwiLFxuXHRcInNvZnRjeVwiOiBcItGMXCIsXG5cdFwic29sYmFyXCI6IFwi4oy/XCIsXG5cdFwic29sYlwiOiBcIuKnhFwiLFxuXHRcInNvbFwiOiBcIi9cIixcblx0XCJTb3BmXCI6IFwi8J2VilwiLFxuXHRcInNvcGZcIjogXCLwnZWkXCIsXG5cdFwic3BhZGVzXCI6IFwi4pmgXCIsXG5cdFwic3BhZGVzdWl0XCI6IFwi4pmgXCIsXG5cdFwic3BhclwiOiBcIuKIpVwiLFxuXHRcInNxY2FwXCI6IFwi4oqTXCIsXG5cdFwic3FjYXBzXCI6IFwi4oqT77iAXCIsXG5cdFwic3FjdXBcIjogXCLiipRcIixcblx0XCJzcWN1cHNcIjogXCLiipTvuIBcIixcblx0XCJTcXJ0XCI6IFwi4oiaXCIsXG5cdFwic3FzdWJcIjogXCLiio9cIixcblx0XCJzcXN1YmVcIjogXCLiipFcIixcblx0XCJzcXN1YnNldFwiOiBcIuKKj1wiLFxuXHRcInNxc3Vic2V0ZXFcIjogXCLiipFcIixcblx0XCJzcXN1cFwiOiBcIuKKkFwiLFxuXHRcInNxc3VwZVwiOiBcIuKKklwiLFxuXHRcInNxc3Vwc2V0XCI6IFwi4oqQXCIsXG5cdFwic3FzdXBzZXRlcVwiOiBcIuKKklwiLFxuXHRcInNxdWFyZVwiOiBcIuKWoVwiLFxuXHRcIlNxdWFyZVwiOiBcIuKWoVwiLFxuXHRcIlNxdWFyZUludGVyc2VjdGlvblwiOiBcIuKKk1wiLFxuXHRcIlNxdWFyZVN1YnNldFwiOiBcIuKKj1wiLFxuXHRcIlNxdWFyZVN1YnNldEVxdWFsXCI6IFwi4oqRXCIsXG5cdFwiU3F1YXJlU3VwZXJzZXRcIjogXCLiipBcIixcblx0XCJTcXVhcmVTdXBlcnNldEVxdWFsXCI6IFwi4oqSXCIsXG5cdFwiU3F1YXJlVW5pb25cIjogXCLiipRcIixcblx0XCJzcXVhcmZcIjogXCLilqpcIixcblx0XCJzcXVcIjogXCLilqFcIixcblx0XCJzcXVmXCI6IFwi4paqXCIsXG5cdFwic3JhcnJcIjogXCLihpJcIixcblx0XCJTc2NyXCI6IFwi8J2SrlwiLFxuXHRcInNzY3JcIjogXCLwnZOIXCIsXG5cdFwic3NldG1uXCI6IFwi4oiWXCIsXG5cdFwic3NtaWxlXCI6IFwi4oyjXCIsXG5cdFwic3N0YXJmXCI6IFwi4ouGXCIsXG5cdFwiU3RhclwiOiBcIuKLhlwiLFxuXHRcInN0YXJcIjogXCLimIZcIixcblx0XCJzdGFyZlwiOiBcIuKYhVwiLFxuXHRcInN0cmFpZ2h0ZXBzaWxvblwiOiBcIs+1XCIsXG5cdFwic3RyYWlnaHRwaGlcIjogXCLPlVwiLFxuXHRcInN0cm5zXCI6IFwiwq9cIixcblx0XCJzdWJcIjogXCLiioJcIixcblx0XCJTdWJcIjogXCLii5BcIixcblx0XCJzdWJkb3RcIjogXCLiqr1cIixcblx0XCJzdWJFXCI6IFwi4quFXCIsXG5cdFwic3ViZVwiOiBcIuKKhlwiLFxuXHRcInN1YmVkb3RcIjogXCLiq4NcIixcblx0XCJzdWJtdWx0XCI6IFwi4quBXCIsXG5cdFwic3VibkVcIjogXCLiq4tcIixcblx0XCJzdWJuZVwiOiBcIuKKilwiLFxuXHRcInN1YnBsdXNcIjogXCLiqr9cIixcblx0XCJzdWJyYXJyXCI6IFwi4qW5XCIsXG5cdFwic3Vic2V0XCI6IFwi4oqCXCIsXG5cdFwiU3Vic2V0XCI6IFwi4ouQXCIsXG5cdFwic3Vic2V0ZXFcIjogXCLiioZcIixcblx0XCJzdWJzZXRlcXFcIjogXCLiq4VcIixcblx0XCJTdWJzZXRFcXVhbFwiOiBcIuKKhlwiLFxuXHRcInN1YnNldG5lcVwiOiBcIuKKilwiLFxuXHRcInN1YnNldG5lcXFcIjogXCLiq4tcIixcblx0XCJzdWJzaW1cIjogXCLiq4dcIixcblx0XCJzdWJzdWJcIjogXCLiq5VcIixcblx0XCJzdWJzdXBcIjogXCLiq5NcIixcblx0XCJzdWNjYXBwcm94XCI6IFwi4qq4XCIsXG5cdFwic3VjY1wiOiBcIuKJu1wiLFxuXHRcInN1Y2NjdXJseWVxXCI6IFwi4om9XCIsXG5cdFwiU3VjY2VlZHNcIjogXCLiibtcIixcblx0XCJTdWNjZWVkc0VxdWFsXCI6IFwi4qqwXCIsXG5cdFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6IFwi4om9XCIsXG5cdFwiU3VjY2VlZHNUaWxkZVwiOiBcIuKJv1wiLFxuXHRcInN1Y2NlcVwiOiBcIuKqsFwiLFxuXHRcInN1Y2NuYXBwcm94XCI6IFwi4qq6XCIsXG5cdFwic3VjY25lcXFcIjogXCLiqrZcIixcblx0XCJzdWNjbnNpbVwiOiBcIuKLqVwiLFxuXHRcInN1Y2NzaW1cIjogXCLiib9cIixcblx0XCJTdWNoVGhhdFwiOiBcIuKIi1wiLFxuXHRcInN1bVwiOiBcIuKIkVwiLFxuXHRcIlN1bVwiOiBcIuKIkVwiLFxuXHRcInN1bmdcIjogXCLimapcIixcblx0XCJzdXAxXCI6IFwiwrlcIixcblx0XCJzdXAyXCI6IFwiwrJcIixcblx0XCJzdXAzXCI6IFwiwrNcIixcblx0XCJzdXBcIjogXCLiioNcIixcblx0XCJTdXBcIjogXCLii5FcIixcblx0XCJzdXBkb3RcIjogXCLiqr5cIixcblx0XCJzdXBkc3ViXCI6IFwi4quYXCIsXG5cdFwic3VwRVwiOiBcIuKrhlwiLFxuXHRcInN1cGVcIjogXCLiiodcIixcblx0XCJzdXBlZG90XCI6IFwi4quEXCIsXG5cdFwiU3VwZXJzZXRcIjogXCLiioNcIixcblx0XCJTdXBlcnNldEVxdWFsXCI6IFwi4oqHXCIsXG5cdFwic3VwaHNvbFwiOiBcIuKfiVwiLFxuXHRcInN1cGhzdWJcIjogXCLiq5dcIixcblx0XCJzdXBsYXJyXCI6IFwi4qW7XCIsXG5cdFwic3VwbXVsdFwiOiBcIuKrglwiLFxuXHRcInN1cG5FXCI6IFwi4quMXCIsXG5cdFwic3VwbmVcIjogXCLiiotcIixcblx0XCJzdXBwbHVzXCI6IFwi4quAXCIsXG5cdFwic3Vwc2V0XCI6IFwi4oqDXCIsXG5cdFwiU3Vwc2V0XCI6IFwi4ouRXCIsXG5cdFwic3Vwc2V0ZXFcIjogXCLiiodcIixcblx0XCJzdXBzZXRlcXFcIjogXCLiq4ZcIixcblx0XCJzdXBzZXRuZXFcIjogXCLiiotcIixcblx0XCJzdXBzZXRuZXFxXCI6IFwi4quMXCIsXG5cdFwic3Vwc2ltXCI6IFwi4quIXCIsXG5cdFwic3Vwc3ViXCI6IFwi4quUXCIsXG5cdFwic3Vwc3VwXCI6IFwi4quWXCIsXG5cdFwic3dhcmhrXCI6IFwi4qSmXCIsXG5cdFwic3dhcnJcIjogXCLihplcIixcblx0XCJzd0FyclwiOiBcIuKHmVwiLFxuXHRcInN3YXJyb3dcIjogXCLihplcIixcblx0XCJzd253YXJcIjogXCLipKpcIixcblx0XCJzemxpZ1wiOiBcIsOfXCIsXG5cdFwiVGFiXCI6IFwiXFx0XCIsXG5cdFwidGFyZ2V0XCI6IFwi4oyWXCIsXG5cdFwiVGF1XCI6IFwizqRcIixcblx0XCJ0YXVcIjogXCLPhFwiLFxuXHRcInRicmtcIjogXCLijrRcIixcblx0XCJUY2Fyb25cIjogXCLFpFwiLFxuXHRcInRjYXJvblwiOiBcIsWlXCIsXG5cdFwiVGNlZGlsXCI6IFwixaJcIixcblx0XCJ0Y2VkaWxcIjogXCLFo1wiLFxuXHRcIlRjeVwiOiBcItCiXCIsXG5cdFwidGN5XCI6IFwi0YJcIixcblx0XCJ0ZG90XCI6IFwi4oObXCIsXG5cdFwidGVscmVjXCI6IFwi4oyVXCIsXG5cdFwiVGZyXCI6IFwi8J2Ul1wiLFxuXHRcInRmclwiOiBcIvCdlLFcIixcblx0XCJ0aGVyZTRcIjogXCLiiLRcIixcblx0XCJ0aGVyZWZvcmVcIjogXCLiiLRcIixcblx0XCJUaGVyZWZvcmVcIjogXCLiiLRcIixcblx0XCJUaGV0YVwiOiBcIs6YXCIsXG5cdFwidGhldGFcIjogXCLOuFwiLFxuXHRcInRoZXRhc3ltXCI6IFwiz5FcIixcblx0XCJ0aGV0YXZcIjogXCLPkVwiLFxuXHRcInRoaWNrYXBwcm94XCI6IFwi4omIXCIsXG5cdFwidGhpY2tzaW1cIjogXCLiiLxcIixcblx0XCJUaGlja1NwYWNlXCI6IFwi4oGf4oCKXCIsXG5cdFwiVGhpblNwYWNlXCI6IFwi4oCJXCIsXG5cdFwidGhpbnNwXCI6IFwi4oCJXCIsXG5cdFwidGhrYXBcIjogXCLiiYhcIixcblx0XCJ0aGtzaW1cIjogXCLiiLxcIixcblx0XCJUSE9STlwiOiBcIsOeXCIsXG5cdFwidGhvcm5cIjogXCLDvlwiLFxuXHRcInRpbGRlXCI6IFwiy5xcIixcblx0XCJUaWxkZVwiOiBcIuKIvFwiLFxuXHRcIlRpbGRlRXF1YWxcIjogXCLiiYNcIixcblx0XCJUaWxkZUZ1bGxFcXVhbFwiOiBcIuKJhVwiLFxuXHRcIlRpbGRlVGlsZGVcIjogXCLiiYhcIixcblx0XCJ0aW1lc2JhclwiOiBcIuKosVwiLFxuXHRcInRpbWVzYlwiOiBcIuKKoFwiLFxuXHRcInRpbWVzXCI6IFwiw5dcIixcblx0XCJ0aW1lc2RcIjogXCLiqLBcIixcblx0XCJ0aW50XCI6IFwi4oitXCIsXG5cdFwidG9lYVwiOiBcIuKkqFwiLFxuXHRcInRvcGJvdFwiOiBcIuKMtlwiLFxuXHRcInRvcGNpclwiOiBcIuKrsVwiLFxuXHRcInRvcFwiOiBcIuKKpFwiLFxuXHRcIlRvcGZcIjogXCLwnZWLXCIsXG5cdFwidG9wZlwiOiBcIvCdlaVcIixcblx0XCJ0b3Bmb3JrXCI6IFwi4quaXCIsXG5cdFwidG9zYVwiOiBcIuKkqVwiLFxuXHRcInRwcmltZVwiOiBcIuKAtFwiLFxuXHRcInRyYWRlXCI6IFwi4oSiXCIsXG5cdFwiVFJBREVcIjogXCLihKJcIixcblx0XCJ0cmlhbmdsZVwiOiBcIuKWtVwiLFxuXHRcInRyaWFuZ2xlZG93blwiOiBcIuKWv1wiLFxuXHRcInRyaWFuZ2xlbGVmdFwiOiBcIuKXg1wiLFxuXHRcInRyaWFuZ2xlbGVmdGVxXCI6IFwi4oq0XCIsXG5cdFwidHJpYW5nbGVxXCI6IFwi4omcXCIsXG5cdFwidHJpYW5nbGVyaWdodFwiOiBcIuKWuVwiLFxuXHRcInRyaWFuZ2xlcmlnaHRlcVwiOiBcIuKKtVwiLFxuXHRcInRyaWRvdFwiOiBcIuKXrFwiLFxuXHRcInRyaWVcIjogXCLiiZxcIixcblx0XCJ0cmltaW51c1wiOiBcIuKoulwiLFxuXHRcIlRyaXBsZURvdFwiOiBcIuKDm1wiLFxuXHRcInRyaXBsdXNcIjogXCLiqLlcIixcblx0XCJ0cmlzYlwiOiBcIuKnjVwiLFxuXHRcInRyaXRpbWVcIjogXCLiqLtcIixcblx0XCJ0cnBleml1bVwiOiBcIuKPolwiLFxuXHRcIlRzY3JcIjogXCLwnZKvXCIsXG5cdFwidHNjclwiOiBcIvCdk4lcIixcblx0XCJUU2N5XCI6IFwi0KZcIixcblx0XCJ0c2N5XCI6IFwi0YZcIixcblx0XCJUU0hjeVwiOiBcItCLXCIsXG5cdFwidHNoY3lcIjogXCLRm1wiLFxuXHRcIlRzdHJva1wiOiBcIsWmXCIsXG5cdFwidHN0cm9rXCI6IFwixadcIixcblx0XCJ0d2l4dFwiOiBcIuKJrFwiLFxuXHRcInR3b2hlYWRsZWZ0YXJyb3dcIjogXCLihp5cIixcblx0XCJ0d29oZWFkcmlnaHRhcnJvd1wiOiBcIuKGoFwiLFxuXHRcIlVhY3V0ZVwiOiBcIsOaXCIsXG5cdFwidWFjdXRlXCI6IFwiw7pcIixcblx0XCJ1YXJyXCI6IFwi4oaRXCIsXG5cdFwiVWFyclwiOiBcIuKGn1wiLFxuXHRcInVBcnJcIjogXCLih5FcIixcblx0XCJVYXJyb2NpclwiOiBcIuKliVwiLFxuXHRcIlVicmN5XCI6IFwi0I5cIixcblx0XCJ1YnJjeVwiOiBcItGeXCIsXG5cdFwiVWJyZXZlXCI6IFwixaxcIixcblx0XCJ1YnJldmVcIjogXCLFrVwiLFxuXHRcIlVjaXJjXCI6IFwiw5tcIixcblx0XCJ1Y2lyY1wiOiBcIsO7XCIsXG5cdFwiVWN5XCI6IFwi0KNcIixcblx0XCJ1Y3lcIjogXCLRg1wiLFxuXHRcInVkYXJyXCI6IFwi4oeFXCIsXG5cdFwiVWRibGFjXCI6IFwixbBcIixcblx0XCJ1ZGJsYWNcIjogXCLFsVwiLFxuXHRcInVkaGFyXCI6IFwi4qWuXCIsXG5cdFwidWZpc2h0XCI6IFwi4qW+XCIsXG5cdFwiVWZyXCI6IFwi8J2UmFwiLFxuXHRcInVmclwiOiBcIvCdlLJcIixcblx0XCJVZ3JhdmVcIjogXCLDmVwiLFxuXHRcInVncmF2ZVwiOiBcIsO5XCIsXG5cdFwidUhhclwiOiBcIuKlo1wiLFxuXHRcInVoYXJsXCI6IFwi4oa/XCIsXG5cdFwidWhhcnJcIjogXCLihr5cIixcblx0XCJ1aGJsa1wiOiBcIuKWgFwiLFxuXHRcInVsY29yblwiOiBcIuKMnFwiLFxuXHRcInVsY29ybmVyXCI6IFwi4oycXCIsXG5cdFwidWxjcm9wXCI6IFwi4oyPXCIsXG5cdFwidWx0cmlcIjogXCLil7hcIixcblx0XCJVbWFjclwiOiBcIsWqXCIsXG5cdFwidW1hY3JcIjogXCLFq1wiLFxuXHRcInVtbFwiOiBcIsKoXCIsXG5cdFwiVW5kZXJCYXJcIjogXCJfXCIsXG5cdFwiVW5kZXJCcmFjZVwiOiBcIuKPn1wiLFxuXHRcIlVuZGVyQnJhY2tldFwiOiBcIuKOtVwiLFxuXHRcIlVuZGVyUGFyZW50aGVzaXNcIjogXCLij51cIixcblx0XCJVbmlvblwiOiBcIuKLg1wiLFxuXHRcIlVuaW9uUGx1c1wiOiBcIuKKjlwiLFxuXHRcIlVvZ29uXCI6IFwixbJcIixcblx0XCJ1b2dvblwiOiBcIsWzXCIsXG5cdFwiVW9wZlwiOiBcIvCdlYxcIixcblx0XCJ1b3BmXCI6IFwi8J2VplwiLFxuXHRcIlVwQXJyb3dCYXJcIjogXCLipJJcIixcblx0XCJ1cGFycm93XCI6IFwi4oaRXCIsXG5cdFwiVXBBcnJvd1wiOiBcIuKGkVwiLFxuXHRcIlVwYXJyb3dcIjogXCLih5FcIixcblx0XCJVcEFycm93RG93bkFycm93XCI6IFwi4oeFXCIsXG5cdFwidXBkb3duYXJyb3dcIjogXCLihpVcIixcblx0XCJVcERvd25BcnJvd1wiOiBcIuKGlVwiLFxuXHRcIlVwZG93bmFycm93XCI6IFwi4oeVXCIsXG5cdFwiVXBFcXVpbGlicml1bVwiOiBcIuKlrlwiLFxuXHRcInVwaGFycG9vbmxlZnRcIjogXCLihr9cIixcblx0XCJ1cGhhcnBvb25yaWdodFwiOiBcIuKGvlwiLFxuXHRcInVwbHVzXCI6IFwi4oqOXCIsXG5cdFwiVXBwZXJMZWZ0QXJyb3dcIjogXCLihpZcIixcblx0XCJVcHBlclJpZ2h0QXJyb3dcIjogXCLihpdcIixcblx0XCJ1cHNpXCI6IFwiz4VcIixcblx0XCJVcHNpXCI6IFwiz5JcIixcblx0XCJ1cHNpaFwiOiBcIs+SXCIsXG5cdFwiVXBzaWxvblwiOiBcIs6lXCIsXG5cdFwidXBzaWxvblwiOiBcIs+FXCIsXG5cdFwiVXBUZWVBcnJvd1wiOiBcIuKGpVwiLFxuXHRcIlVwVGVlXCI6IFwi4oqlXCIsXG5cdFwidXB1cGFycm93c1wiOiBcIuKHiFwiLFxuXHRcInVyY29yblwiOiBcIuKMnVwiLFxuXHRcInVyY29ybmVyXCI6IFwi4oydXCIsXG5cdFwidXJjcm9wXCI6IFwi4oyOXCIsXG5cdFwiVXJpbmdcIjogXCLFrlwiLFxuXHRcInVyaW5nXCI6IFwixa9cIixcblx0XCJ1cnRyaVwiOiBcIuKXuVwiLFxuXHRcIlVzY3JcIjogXCLwnZKwXCIsXG5cdFwidXNjclwiOiBcIvCdk4pcIixcblx0XCJ1dGRvdFwiOiBcIuKLsFwiLFxuXHRcIlV0aWxkZVwiOiBcIsWoXCIsXG5cdFwidXRpbGRlXCI6IFwixalcIixcblx0XCJ1dHJpXCI6IFwi4pa1XCIsXG5cdFwidXRyaWZcIjogXCLilrRcIixcblx0XCJ1dWFyclwiOiBcIuKHiFwiLFxuXHRcIlV1bWxcIjogXCLDnFwiLFxuXHRcInV1bWxcIjogXCLDvFwiLFxuXHRcInV3YW5nbGVcIjogXCLipqdcIixcblx0XCJ2YW5ncnRcIjogXCLippxcIixcblx0XCJ2YXJlcHNpbG9uXCI6IFwiz7VcIixcblx0XCJ2YXJrYXBwYVwiOiBcIs+wXCIsXG5cdFwidmFybm90aGluZ1wiOiBcIuKIhVwiLFxuXHRcInZhcnBoaVwiOiBcIs+VXCIsXG5cdFwidmFycGlcIjogXCLPllwiLFxuXHRcInZhcnByb3B0b1wiOiBcIuKInVwiLFxuXHRcInZhcnJcIjogXCLihpVcIixcblx0XCJ2QXJyXCI6IFwi4oeVXCIsXG5cdFwidmFycmhvXCI6IFwiz7FcIixcblx0XCJ2YXJzaWdtYVwiOiBcIs+CXCIsXG5cdFwidmFyc3Vic2V0bmVxXCI6IFwi4oqK77iAXCIsXG5cdFwidmFyc3Vic2V0bmVxcVwiOiBcIuKri++4gFwiLFxuXHRcInZhcnN1cHNldG5lcVwiOiBcIuKKi++4gFwiLFxuXHRcInZhcnN1cHNldG5lcXFcIjogXCLiq4zvuIBcIixcblx0XCJ2YXJ0aGV0YVwiOiBcIs+RXCIsXG5cdFwidmFydHJpYW5nbGVsZWZ0XCI6IFwi4oqyXCIsXG5cdFwidmFydHJpYW5nbGVyaWdodFwiOiBcIuKKs1wiLFxuXHRcInZCYXJcIjogXCLiq6hcIixcblx0XCJWYmFyXCI6IFwi4qurXCIsXG5cdFwidkJhcnZcIjogXCLiq6lcIixcblx0XCJWY3lcIjogXCLQklwiLFxuXHRcInZjeVwiOiBcItCyXCIsXG5cdFwidmRhc2hcIjogXCLiiqJcIixcblx0XCJ2RGFzaFwiOiBcIuKKqFwiLFxuXHRcIlZkYXNoXCI6IFwi4oqpXCIsXG5cdFwiVkRhc2hcIjogXCLiiqtcIixcblx0XCJWZGFzaGxcIjogXCLiq6ZcIixcblx0XCJ2ZWViYXJcIjogXCLiirtcIixcblx0XCJ2ZWVcIjogXCLiiKhcIixcblx0XCJWZWVcIjogXCLii4FcIixcblx0XCJ2ZWVlcVwiOiBcIuKJmlwiLFxuXHRcInZlbGxpcFwiOiBcIuKLrlwiLFxuXHRcInZlcmJhclwiOiBcInxcIixcblx0XCJWZXJiYXJcIjogXCLigJZcIixcblx0XCJ2ZXJ0XCI6IFwifFwiLFxuXHRcIlZlcnRcIjogXCLigJZcIixcblx0XCJWZXJ0aWNhbEJhclwiOiBcIuKIo1wiLFxuXHRcIlZlcnRpY2FsTGluZVwiOiBcInxcIixcblx0XCJWZXJ0aWNhbFNlcGFyYXRvclwiOiBcIuKdmFwiLFxuXHRcIlZlcnRpY2FsVGlsZGVcIjogXCLiiYBcIixcblx0XCJWZXJ5VGhpblNwYWNlXCI6IFwi4oCKXCIsXG5cdFwiVmZyXCI6IFwi8J2UmVwiLFxuXHRcInZmclwiOiBcIvCdlLNcIixcblx0XCJ2bHRyaVwiOiBcIuKKslwiLFxuXHRcInZuc3ViXCI6IFwi4oqC4oOSXCIsXG5cdFwidm5zdXBcIjogXCLiioPig5JcIixcblx0XCJWb3BmXCI6IFwi8J2VjVwiLFxuXHRcInZvcGZcIjogXCLwnZWnXCIsXG5cdFwidnByb3BcIjogXCLiiJ1cIixcblx0XCJ2cnRyaVwiOiBcIuKKs1wiLFxuXHRcIlZzY3JcIjogXCLwnZKxXCIsXG5cdFwidnNjclwiOiBcIvCdk4tcIixcblx0XCJ2c3VibkVcIjogXCLiq4vvuIBcIixcblx0XCJ2c3VibmVcIjogXCLiiorvuIBcIixcblx0XCJ2c3VwbkVcIjogXCLiq4zvuIBcIixcblx0XCJ2c3VwbmVcIjogXCLiiovvuIBcIixcblx0XCJWdmRhc2hcIjogXCLiiqpcIixcblx0XCJ2emlnemFnXCI6IFwi4qaaXCIsXG5cdFwiV2NpcmNcIjogXCLFtFwiLFxuXHRcIndjaXJjXCI6IFwixbVcIixcblx0XCJ3ZWRiYXJcIjogXCLiqZ9cIixcblx0XCJ3ZWRnZVwiOiBcIuKIp1wiLFxuXHRcIldlZGdlXCI6IFwi4ouAXCIsXG5cdFwid2VkZ2VxXCI6IFwi4omZXCIsXG5cdFwid2VpZXJwXCI6IFwi4oSYXCIsXG5cdFwiV2ZyXCI6IFwi8J2UmlwiLFxuXHRcIndmclwiOiBcIvCdlLRcIixcblx0XCJXb3BmXCI6IFwi8J2VjlwiLFxuXHRcIndvcGZcIjogXCLwnZWoXCIsXG5cdFwid3BcIjogXCLihJhcIixcblx0XCJ3clwiOiBcIuKJgFwiLFxuXHRcIndyZWF0aFwiOiBcIuKJgFwiLFxuXHRcIldzY3JcIjogXCLwnZKyXCIsXG5cdFwid3NjclwiOiBcIvCdk4xcIixcblx0XCJ4Y2FwXCI6IFwi4ouCXCIsXG5cdFwieGNpcmNcIjogXCLil69cIixcblx0XCJ4Y3VwXCI6IFwi4ouDXCIsXG5cdFwieGR0cmlcIjogXCLilr1cIixcblx0XCJYZnJcIjogXCLwnZSbXCIsXG5cdFwieGZyXCI6IFwi8J2UtVwiLFxuXHRcInhoYXJyXCI6IFwi4p+3XCIsXG5cdFwieGhBcnJcIjogXCLin7pcIixcblx0XCJYaVwiOiBcIs6eXCIsXG5cdFwieGlcIjogXCLOvlwiLFxuXHRcInhsYXJyXCI6IFwi4p+1XCIsXG5cdFwieGxBcnJcIjogXCLin7hcIixcblx0XCJ4bWFwXCI6IFwi4p+8XCIsXG5cdFwieG5pc1wiOiBcIuKLu1wiLFxuXHRcInhvZG90XCI6IFwi4qiAXCIsXG5cdFwiWG9wZlwiOiBcIvCdlY9cIixcblx0XCJ4b3BmXCI6IFwi8J2VqVwiLFxuXHRcInhvcGx1c1wiOiBcIuKogVwiLFxuXHRcInhvdGltZVwiOiBcIuKoglwiLFxuXHRcInhyYXJyXCI6IFwi4p+2XCIsXG5cdFwieHJBcnJcIjogXCLin7lcIixcblx0XCJYc2NyXCI6IFwi8J2Ss1wiLFxuXHRcInhzY3JcIjogXCLwnZONXCIsXG5cdFwieHNxY3VwXCI6IFwi4qiGXCIsXG5cdFwieHVwbHVzXCI6IFwi4qiEXCIsXG5cdFwieHV0cmlcIjogXCLilrNcIixcblx0XCJ4dmVlXCI6IFwi4ouBXCIsXG5cdFwieHdlZGdlXCI6IFwi4ouAXCIsXG5cdFwiWWFjdXRlXCI6IFwiw51cIixcblx0XCJ5YWN1dGVcIjogXCLDvVwiLFxuXHRcIllBY3lcIjogXCLQr1wiLFxuXHRcInlhY3lcIjogXCLRj1wiLFxuXHRcIlljaXJjXCI6IFwixbZcIixcblx0XCJ5Y2lyY1wiOiBcIsW3XCIsXG5cdFwiWWN5XCI6IFwi0KtcIixcblx0XCJ5Y3lcIjogXCLRi1wiLFxuXHRcInllblwiOiBcIsKlXCIsXG5cdFwiWWZyXCI6IFwi8J2UnFwiLFxuXHRcInlmclwiOiBcIvCdlLZcIixcblx0XCJZSWN5XCI6IFwi0IdcIixcblx0XCJ5aWN5XCI6IFwi0ZdcIixcblx0XCJZb3BmXCI6IFwi8J2VkFwiLFxuXHRcInlvcGZcIjogXCLwnZWqXCIsXG5cdFwiWXNjclwiOiBcIvCdkrRcIixcblx0XCJ5c2NyXCI6IFwi8J2TjlwiLFxuXHRcIllVY3lcIjogXCLQrlwiLFxuXHRcInl1Y3lcIjogXCLRjlwiLFxuXHRcInl1bWxcIjogXCLDv1wiLFxuXHRcIll1bWxcIjogXCLFuFwiLFxuXHRcIlphY3V0ZVwiOiBcIsW5XCIsXG5cdFwiemFjdXRlXCI6IFwixbpcIixcblx0XCJaY2Fyb25cIjogXCLFvVwiLFxuXHRcInpjYXJvblwiOiBcIsW+XCIsXG5cdFwiWmN5XCI6IFwi0JdcIixcblx0XCJ6Y3lcIjogXCLQt1wiLFxuXHRcIlpkb3RcIjogXCLFu1wiLFxuXHRcInpkb3RcIjogXCLFvFwiLFxuXHRcInplZXRyZlwiOiBcIuKEqFwiLFxuXHRcIlplcm9XaWR0aFNwYWNlXCI6IFwi4oCLXCIsXG5cdFwiWmV0YVwiOiBcIs6WXCIsXG5cdFwiemV0YVwiOiBcIs62XCIsXG5cdFwiemZyXCI6IFwi8J2Ut1wiLFxuXHRcIlpmclwiOiBcIuKEqFwiLFxuXHRcIlpIY3lcIjogXCLQllwiLFxuXHRcInpoY3lcIjogXCLQtlwiLFxuXHRcInppZ3JhcnJcIjogXCLih51cIixcblx0XCJ6b3BmXCI6IFwi8J2Vq1wiLFxuXHRcIlpvcGZcIjogXCLihKRcIixcblx0XCJac2NyXCI6IFwi8J2StVwiLFxuXHRcInpzY3JcIjogXCLwnZOPXCIsXG5cdFwiendqXCI6IFwi4oCNXCIsXG5cdFwiendualwiOiBcIuKAjFwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEtMSEuL3N0eWxlcy5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEtMSEuL3N0eWxlcy5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICdjb21wb25lbnRzL2NlbGwnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gICAgdm5vZGUuc3RhdGUub25jaGFuZ2UgPSB2ID0+IHtcbiAgICAgIHZub2RlLnN0YXRlLm1vZGVsLmRhdGEudGFncyA9IHYuc3BsaXQoJywnKTtcbiAgICB9O1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSA8aW5wdXQgdHlwZT0ndGV4dCcgY2xhc3NOYW1lPXtzdHlsZXMudGFnc31cbiAgICAgIG9uY2hhbmdlPXttLndpdGhBdHRyKCd2YWx1ZScsIHZub2RlLnN0YXRlLm9uY2hhbmFnZSl9XG4gICAgICB2YWx1ZT17dm5vZGUuc3RhdGUubW9kZWwuZGF0YS50YWdzLmpvaW4oJywnKX1cbiAgICAvPlxuICAgIHJldHVybiA8Q2VsbCBzcGFuPXsxMn0gaW5uZXI9e2lubmVyfSAvPlxuICB9XG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vY29tcG9uZW50cy90YWdzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==