/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 20);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Utilities
//


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(9);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(7);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(13);
exports.lib.ucmicro = __webpack_require__(89);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

;(function () {
	"use strict";

	function Vnode(tag, key, attrs0, children, text, dom) {
		return { tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false };
	}
	Vnode.normalize = function (node) {
		if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined);
		if (node != null && (typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined);
		return node;
	};
	Vnode.normalizeChildren = function normalizeChildren(children) {
		for (var i = 0; i < children.length; i++) {
			children[i] = Vnode.normalize(children[i]);
		}
		return children;
	};
	var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
	var selectorCache = {};
	var hasOwn = {}.hasOwnProperty;
	function compileSelector(selector) {
		var match,
		    tag = "div",
		    classes = [],
		    attrs = {};
		while (match = selectorParser.exec(selector)) {
			var type = match[1],
			    value = match[2];
			if (type === "" && value !== "") tag = value;else if (type === "#") attrs.id = value;else if (type === ".") classes.push(value);else if (match[3][0] === "[") {
				var attrValue = match[6];
				if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
				if (match[4] === "class") classes.push(attrValue);else attrs[match[4]] = attrValue || true;
			}
		}
		if (classes.length > 0) attrs.className = classes.join(" ");
		return selectorCache[selector] = { tag: tag, attrs: attrs };
	}
	function execSelector(state, attrs, children) {
		var hasAttrs = false,
		    childList,
		    text;
		var className = attrs.className || attrs.class;
		for (var key in state.attrs) {
			if (hasOwn.call(state.attrs, key)) {
				attrs[key] = state.attrs[key];
			}
		}
		if (className !== undefined) {
			if (attrs.class !== undefined) {
				attrs.class = undefined;
				attrs.className = className;
			}
			if (state.attrs.className != null) {
				attrs.className = state.attrs.className + " " + className;
			}
		}
		for (var key in attrs) {
			if (hasOwn.call(attrs, key) && key !== "key") {
				hasAttrs = true;
				break;
			}
		}
		if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
			text = children[0].children;
		} else {
			childList = children;
		}
		return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text);
	}
	function hyperscript(selector) {
		// Because sloppy mode sucks
		var attrs = arguments[1],
		    start = 2,
		    children;
		if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
			throw Error("The selector must be either a string or a component.");
		}
		if (typeof selector === "string") {
			var cached = selectorCache[selector] || compileSelector(selector);
		}
		if (attrs == null) {
			attrs = {};
		} else if ((typeof attrs === "undefined" ? "undefined" : _typeof(attrs)) !== "object" || attrs.tag != null || Array.isArray(attrs)) {
			attrs = {};
			start = 1;
		}
		if (arguments.length === start + 1) {
			children = arguments[start];
			if (!Array.isArray(children)) children = [children];
		} else {
			children = [];
			while (start < arguments.length) {
				children.push(arguments[start++]);
			}
		}
		var normalized = Vnode.normalizeChildren(children);
		if (typeof selector === "string") {
			return execSelector(cached, attrs, normalized);
		} else {
			return Vnode(selector, attrs.key, attrs, normalized);
		}
	}
	hyperscript.trust = function (html) {
		if (html == null) html = "";
		return Vnode("<", undefined, undefined, html, undefined, undefined);
	};
	hyperscript.fragment = function (attrs1, children) {
		return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined);
	};
	var m = hyperscript;
	/** @constructor */
	var PromisePolyfill = function PromisePolyfill(executor) {
		if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`");
		if (typeof executor !== "function") throw new TypeError("executor must be a function");
		var self = this,
		    resolvers = [],
		    rejectors = [],
		    resolveCurrent = handler(resolvers, true),
		    rejectCurrent = handler(rejectors, false);
		var instance = self._instance = { resolvers: resolvers, rejectors: rejectors };
		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function handler(list, shouldAbsorb) {
			return function execute(value) {
				var then;
				try {
					if (shouldAbsorb && value != null && ((typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
						if (value === self) throw new TypeError("Promise can't be resolved w/ itself");
						executeOnce(then.bind(value));
					} else {
						callAsync(function () {
							if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value);
							for (var i = 0; i < list.length; i++) {
								list[i](value);
							}resolvers.length = 0, rejectors.length = 0;
							instance.state = shouldAbsorb;
							instance.retry = function () {
								execute(value);
							};
						});
					}
				} catch (e) {
					rejectCurrent(e);
				}
			};
		}
		function executeOnce(then) {
			var runs = 0;
			function run(fn) {
				return function (value) {
					if (runs++ > 0) return;
					fn(value);
				};
			}
			var onerror = run(rejectCurrent);
			try {
				then(run(resolveCurrent), onerror);
			} catch (e) {
				onerror(e);
			}
		}
		executeOnce(executor);
	};
	PromisePolyfill.prototype.then = function (onFulfilled, onRejection) {
		var self = this,
		    instance = self._instance;
		function handle(callback, list, next, state) {
			list.push(function (value) {
				if (typeof callback !== "function") next(value);else try {
					resolveNext(callback(value));
				} catch (e) {
					if (rejectNext) rejectNext(e);
				}
			});
			if (typeof instance.retry === "function" && state === instance.state) instance.retry();
		}
		var resolveNext, rejectNext;
		var promise = new PromisePolyfill(function (resolve, reject) {
			resolveNext = resolve, rejectNext = reject;
		});
		handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
		return promise;
	};
	PromisePolyfill.prototype.catch = function (onRejection) {
		return this.then(null, onRejection);
	};
	PromisePolyfill.resolve = function (value) {
		if (value instanceof PromisePolyfill) return value;
		return new PromisePolyfill(function (resolve) {
			resolve(value);
		});
	};
	PromisePolyfill.reject = function (value) {
		return new PromisePolyfill(function (resolve, reject) {
			reject(value);
		});
	};
	PromisePolyfill.all = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			var total = list.length,
			    count = 0,
			    values = [];
			if (list.length === 0) resolve([]);else for (var i = 0; i < list.length; i++) {
				(function (i) {
					function consume(value) {
						count++;
						values[i] = value;
						if (count === total) resolve(values);
					}
					if (list[i] != null && (_typeof(list[i]) === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
						list[i].then(consume, reject);
					} else consume(list[i]);
				})(i);
			}
		});
	};
	PromisePolyfill.race = function (list) {
		return new PromisePolyfill(function (resolve, reject) {
			for (var i = 0; i < list.length; i++) {
				list[i].then(resolve, reject);
			}
		});
	};
	if (typeof window !== "undefined") {
		if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill;
		var PromisePolyfill = window.Promise;
	} else if (typeof global !== "undefined") {
		if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill;
		var PromisePolyfill = global.Promise;
	} else {}
	var buildQueryString = function buildQueryString(object) {
		if (Object.prototype.toString.call(object) !== "[object Object]") return "";
		var args = [];
		for (var key0 in object) {
			destructure(key0, object[key0]);
		}
		return args.join("&");
		function destructure(key0, value) {
			if (Array.isArray(value)) {
				for (var i = 0; i < value.length; i++) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else if (Object.prototype.toString.call(value) === "[object Object]") {
				for (var i in value) {
					destructure(key0 + "[" + i + "]", value[i]);
				}
			} else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
		}
	};
	var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i");
	var _8 = function _8($window, Promise) {
		var callbackCount = 0;
		var oncompletion;
		function setCompletionCallback(callback) {
			oncompletion = callback;
		}
		function finalizer() {
			var count = 0;
			function complete() {
				if (--count === 0 && typeof oncompletion === "function") oncompletion();
			}
			return function finalize(promise0) {
				var then0 = promise0.then;
				promise0.then = function () {
					count++;
					var next = then0.apply(promise0, arguments);
					next.then(complete, function (e) {
						complete();
						if (count === 0) throw e;
					});
					return finalize(next);
				};
				return promise0;
			};
		}
		function normalize(args, extra) {
			if (typeof args === "string") {
				var url = args;
				args = extra || {};
				if (args.url == null) args.url = url;
			}
			return args;
		}
		function request(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				if (args.method == null) args.method = "GET";
				args.method = args.method.toUpperCase();
				var useBody = args.method === "GET" || args.method === "TRACE" ? false : typeof args.useBody === "boolean" ? args.useBody : true;
				if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function (value) {
					return value;
				} : JSON.stringify;
				if (typeof args.deserialize !== "function") args.deserialize = deserialize;
				if (typeof args.extract !== "function") args.extract = extract;
				args.url = interpolate(args.url, args.data);
				if (useBody) args.data = args.serialize(args.data);else args.url = assemble(args.url, args.data);
				var xhr = new $window.XMLHttpRequest(),
				    aborted = false,
				    _abort = xhr.abort;
				xhr.abort = function abort() {
					aborted = true;
					_abort.call(xhr);
				};
				xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);
				if (args.serialize === JSON.stringify && useBody) {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
				}
				if (args.deserialize === deserialize) {
					xhr.setRequestHeader("Accept", "application/json, text/*");
				}
				if (args.withCredentials) xhr.withCredentials = args.withCredentials;
				for (var key in args.headers) {
					if ({}.hasOwnProperty.call(args.headers, key)) {
						xhr.setRequestHeader(key, args.headers[key]);
					}
				}if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr;
				xhr.onreadystatechange = function () {
					// Don't throw errors on xhr.abort().
					if (aborted) return;
					if (xhr.readyState === 4) {
						try {
							var response = args.extract !== extract ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args));
							if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
								resolve(cast(args.type, response));
							} else {
								var error = new Error(xhr.responseText);
								for (var key in response) {
									error[key] = response[key];
								}reject(error);
							}
						} catch (e) {
							reject(e);
						}
					}
				};
				if (useBody && args.data != null) xhr.send(args.data);else xhr.send();
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function jsonp(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);
			var promise0 = new Promise(function (resolve, reject) {
				var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
				var script = $window.document.createElement("script");
				$window[callbackName] = function (data) {
					script.parentNode.removeChild(script);
					resolve(cast(args.type, data));
					delete $window[callbackName];
				};
				script.onerror = function () {
					script.parentNode.removeChild(script);
					reject(new Error("JSONP request failed"));
					delete $window[callbackName];
				};
				if (args.data == null) args.data = {};
				args.url = interpolate(args.url, args.data);
				args.data[args.callbackKey || "callback"] = callbackName;
				script.src = assemble(args.url, args.data);
				$window.document.documentElement.appendChild(script);
			});
			return args.background === true ? promise0 : finalize(promise0);
		}
		function interpolate(url, data) {
			if (data == null) return url;
			var tokens = url.match(/:[^\/]+/gi) || [];
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1);
				if (data[key] != null) {
					url = url.replace(tokens[i], data[key]);
				}
			}
			return url;
		}
		function assemble(url, data) {
			var querystring = buildQueryString(data);
			if (querystring !== "") {
				var prefix = url.indexOf("?") < 0 ? "?" : "&";
				url += prefix + querystring;
			}
			return url;
		}
		function deserialize(data) {
			try {
				return data !== "" ? JSON.parse(data) : null;
			} catch (e) {
				throw new Error(data);
			}
		}
		function extract(xhr) {
			return xhr.responseText;
		}
		function cast(type0, data) {
			if (typeof type0 === "function") {
				if (Array.isArray(data)) {
					for (var i = 0; i < data.length; i++) {
						data[i] = new type0(data[i]);
					}
				} else return new type0(data);
			}
			return data;
		}
		return { request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback };
	};
	var requestService = _8(window, PromisePolyfill);
	var coreRenderer = function coreRenderer($window) {
		var $doc = $window.document;
		var $emptyFragment = $doc.createDocumentFragment();
		var onevent;
		function setEventCallback(callback) {
			return onevent = callback;
		}
		//create
		function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					createNode(parent, vnode, hooks, ns, nextSibling);
				}
			}
		}
		function createNode(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			if (typeof tag === "string") {
				vnode.state = {};
				if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
				switch (tag) {
					case "#":
						return createText(parent, vnode, nextSibling);
					case "<":
						return createHTML(parent, vnode, nextSibling);
					case "[":
						return createFragment(parent, vnode, hooks, ns, nextSibling);
					default:
						return createElement(parent, vnode, hooks, ns, nextSibling);
				}
			} else return createComponent(parent, vnode, hooks, ns, nextSibling);
		}
		function createText(parent, vnode, nextSibling) {
			vnode.dom = $doc.createTextNode(vnode.children);
			insertNode(parent, vnode.dom, nextSibling);
			return vnode.dom;
		}
		function createHTML(parent, vnode, nextSibling) {
			var match1 = vnode.children.match(/^\s*?<(\w+)/im) || [];
			var parent1 = { caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup" }[match1[1]] || "div";
			var temp = $doc.createElement(parent1);
			temp.innerHTML = vnode.children;
			vnode.dom = temp.firstChild;
			vnode.domSize = temp.childNodes.length;
			var fragment = $doc.createDocumentFragment();
			var child;
			while (child = temp.firstChild) {
				fragment.appendChild(child);
			}
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createFragment(parent, vnode, hooks, ns, nextSibling) {
			var fragment = $doc.createDocumentFragment();
			if (vnode.children != null) {
				var children = vnode.children;
				createNodes(fragment, children, 0, children.length, hooks, null, ns);
			}
			vnode.dom = fragment.firstChild;
			vnode.domSize = fragment.childNodes.length;
			insertNode(parent, fragment, nextSibling);
			return fragment;
		}
		function createElement(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			var attrs2 = vnode.attrs;
			var is = attrs2 && attrs2.is;
			var element = ns ? is ? $doc.createElementNS(ns, tag, { is: is }) : $doc.createElementNS(ns, tag) : is ? $doc.createElement(tag, { is: is }) : $doc.createElement(tag);
			vnode.dom = element;
			if (attrs2 != null) {
				setAttrs(vnode, attrs2, ns);
			}
			insertNode(parent, element, nextSibling);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else {
				if (vnode.text != null) {
					if (vnode.text !== "") element.textContent = vnode.text;else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				}
				if (vnode.children != null) {
					var children = vnode.children;
					createNodes(element, children, 0, children.length, hooks, null, ns);
					setLateAttrs(vnode);
				}
			}
			return element;
		}
		function initComponent(vnode, hooks) {
			var sentinel;
			if (typeof vnode.tag.view === "function") {
				vnode.state = Object.create(vnode.tag);
				sentinel = vnode.state.view;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
			} else {
				vnode.state = void 0;
				sentinel = vnode.tag;
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment;
				sentinel.$$reentrantLock$$ = true;
				vnode.state = vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function" ? new vnode.tag(vnode) : vnode.tag(vnode);
			}
			vnode._state = vnode.state;
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
			initLifecycle(vnode._state, vnode, hooks);
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
			sentinel.$$reentrantLock$$ = null;
		}
		function createComponent(parent, vnode, hooks, ns, nextSibling) {
			initComponent(vnode, hooks);
			if (vnode.instance != null) {
				var element = createNode(parent, vnode.instance, hooks, ns, nextSibling);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
				insertNode(parent, element, nextSibling);
				return element;
			} else {
				vnode.domSize = 0;
				return $emptyFragment;
			}
		}
		//update
		function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
			if (old === vnodes || old == null && vnodes == null) return;else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined);else if (vnodes == null) removeNodes(old, 0, old.length, vnodes);else {
				if (old.length === vnodes.length) {
					var isUnkeyed = false;
					for (var i = 0; i < vnodes.length; i++) {
						if (vnodes[i] != null && old[i] != null) {
							isUnkeyed = vnodes[i].key == null && old[i].key == null;
							break;
						}
					}
					if (isUnkeyed) {
						for (var i = 0; i < old.length; i++) {
							if (old[i] === vnodes[i]) continue;else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling));else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes);else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns);
						}
						return;
					}
				}
				recycling = recycling || isRecyclable(old, vnodes);
				if (recycling) {
					var pool = old.pool;
					old = old.concat(old.pool);
				}
				var oldStart = 0,
				    start = 0,
				    oldEnd = old.length - 1,
				    end = vnodes.length - 1,
				    map;
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldStart],
					    v = vnodes[start];
					if (o === v && !recycling) oldStart++, start++;else if (o == null) oldStart++;else if (v == null) start++;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldStart >= old.length - pool.length || pool == null && recycling;
						oldStart++, start++;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
					} else {
						var o = old[oldEnd];
						if (o === v && !recycling) oldEnd--, start++;else if (o == null) oldEnd--;else if (v == null) start++;else if (o.key === v.key) {
							var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
							updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
							if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling));
							oldEnd--, start++;
						} else break;
					}
				}
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldEnd],
					    v = vnodes[end];
					if (o === v && !recycling) oldEnd--, end--;else if (o == null) oldEnd--;else if (v == null) end--;else if (o.key === v.key) {
						var shouldRecycle = pool != null && oldEnd >= old.length - pool.length || pool == null && recycling;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
						if (o.dom != null) nextSibling = o.dom;
						oldEnd--, end--;
					} else {
						if (!map) map = getKeyMap(old, oldEnd);
						if (v != null) {
							var oldIndex = map[v.key];
							if (oldIndex != null) {
								var movable = old[oldIndex];
								var shouldRecycle = pool != null && oldIndex >= old.length - pool.length || pool == null && recycling;
								updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns);
								insertNode(parent, toFragment(movable), nextSibling);
								old[oldIndex].skip = true;
								if (movable.dom != null) nextSibling = movable.dom;
							} else {
								var dom = createNode(parent, v, hooks, undefined, nextSibling);
								nextSibling = dom;
							}
						}
						end--;
					}
					if (end < start) break;
				}
				createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
				removeNodes(old, oldStart, oldEnd + 1, vnodes);
			}
		}
		function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			var oldTag = old.tag,
			    tag = vnode.tag;
			if (oldTag === tag) {
				vnode.state = old.state;
				vnode._state = old._state;
				vnode.events = old.events;
				if (!recycling && shouldNotUpdate(vnode, old)) return;
				if (typeof oldTag === "string") {
					if (vnode.attrs != null) {
						if (recycling) {
							vnode.state = {};
							initLifecycle(vnode.attrs, vnode, hooks);
						} else updateLifecycle(vnode.attrs, vnode, hooks);
					}
					switch (oldTag) {
						case "#":
							updateText(old, vnode);break;
						case "<":
							updateHTML(parent, old, vnode, nextSibling);break;
						case "[":
							updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns);break;
						default:
							updateElement(old, vnode, recycling, hooks, ns);
					}
				} else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns);
			} else {
				removeNode(old, null);
				createNode(parent, vnode, hooks, ns, nextSibling);
			}
		}
		function updateText(old, vnode) {
			if (old.children.toString() !== vnode.children.toString()) {
				old.dom.nodeValue = vnode.children;
			}
			vnode.dom = old.dom;
		}
		function updateHTML(parent, old, vnode, nextSibling) {
			if (old.children !== vnode.children) {
				toFragment(old);
				createHTML(parent, vnode, nextSibling);
			} else vnode.dom = old.dom, vnode.domSize = old.domSize;
		}
		function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
			updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns);
			var domSize = 0,
			    children = vnode.children;
			vnode.dom = null;
			if (children != null) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i];
					if (child != null && child.dom != null) {
						if (vnode.dom == null) vnode.dom = child.dom;
						domSize += child.domSize || 1;
					}
				}
				if (domSize !== 1) vnode.domSize = domSize;
			}
		}
		function updateElement(old, vnode, recycling, hooks, ns) {
			var element = vnode.dom = old.dom;
			switch (vnode.tag) {
				case "svg":
					ns = "http://www.w3.org/2000/svg";break;
				case "math":
					ns = "http://www.w3.org/1998/Math/MathML";break;
			}
			if (vnode.tag === "textarea") {
				if (vnode.attrs == null) vnode.attrs = {};
				if (vnode.text != null) {
					vnode.attrs.value = vnode.text; //FIXME handle0 multiple children
					vnode.text = undefined;
				}
			}
			updateAttrs(vnode, old.attrs, vnode.attrs, ns);
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode);
			} else if (old.text != null && vnode.text != null && vnode.text !== "") {
				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text;
			} else {
				if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)];
				if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
				updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns);
			}
		}
		function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			if (recycling) {
				initComponent(vnode, hooks);
			} else {
				vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
				if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument");
				if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);
				updateLifecycle(vnode._state, vnode, hooks);
			}
			if (vnode.instance != null) {
				if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns);
				vnode.dom = vnode.instance.dom;
				vnode.domSize = vnode.instance.domSize;
			} else if (old.instance != null) {
				removeNode(old.instance, null);
				vnode.dom = undefined;
				vnode.domSize = 0;
			} else {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
			}
		}
		function isRecyclable(old, vnodes) {
			if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
				var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0;
				var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0;
				var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0;
				if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
					return true;
				}
			}
			return false;
		}
		function getKeyMap(vnodes, end) {
			var map = {},
			    i = 0;
			for (var i = 0; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					var key2 = vnode.key;
					if (key2 != null) map[key2] = i;
				}
			}
			return map;
		}
		function toFragment(vnode) {
			var count0 = vnode.domSize;
			if (count0 != null || vnode.dom == null) {
				var fragment = $doc.createDocumentFragment();
				if (count0 > 0) {
					var dom = vnode.dom;
					while (--count0) {
						fragment.appendChild(dom.nextSibling);
					}fragment.insertBefore(dom, fragment.firstChild);
				}
				return fragment;
			} else return vnode.dom;
		}
		function getNextSibling(vnodes, i, nextSibling) {
			for (; i < vnodes.length; i++) {
				if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom;
			}
			return nextSibling;
		}
		function insertNode(parent, dom, nextSibling) {
			if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling);else parent.appendChild(dom);
		}
		function setContentEditable(vnode) {
			var children = vnode.children;
			if (children != null && children.length === 1 && children[0].tag === "<") {
				var content = children[0].children;
				if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;
			} else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted");
		}
		//remove
		function removeNodes(vnodes, start, end, context) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i];
				if (vnode != null) {
					if (vnode.skip) vnode.skip = false;else removeNode(vnode, context);
				}
			}
		}
		function removeNode(vnode, context) {
			var expected = 1,
			    called = 0;
			if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
				var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
				var result = vnode._state.onbeforeremove.call(vnode.state, vnode);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			continuation();
			function continuation() {
				if (++called === expected) {
					onremove(vnode);
					if (vnode.dom) {
						var count0 = vnode.domSize || 1;
						if (count0 > 1) {
							var dom = vnode.dom;
							while (--count0) {
								removeNodeFromDOM(dom.nextSibling);
							}
						}
						removeNodeFromDOM(vnode.dom);
						if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") {
							//TODO test custom elements
							if (!context.pool) context.pool = [vnode];else context.pool.push(vnode);
						}
					}
				}
			}
		}
		function removeNodeFromDOM(node) {
			var parent = node.parentNode;
			if (parent != null) parent.removeChild(node);
		}
		function onremove(vnode) {
			if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode);
			if (vnode.instance != null) onremove(vnode.instance);else {
				var children = vnode.children;
				if (Array.isArray(children)) {
					for (var i = 0; i < children.length; i++) {
						var child = children[i];
						if (child != null) onremove(child);
					}
				}
			}
		}
		//attrs2
		function setAttrs(vnode, attrs2, ns) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, null, attrs2[key2], ns);
			}
		}
		function setAttr(vnode, key2, old, value, ns) {
			var element = vnode.dom;
			if (key2 === "key" || key2 === "is" || old === value && !isFormAttribute(vnode, key2) && (typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return;
			var nsLastIndex = key2.indexOf(":");
			if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
				element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value);
			} else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value);else if (key2 === "style") updateStyle(element, old, value);else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if (vnode.tag === "input" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select" && key2 === "value" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return;
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && key2 === "value" && vnode.dom.value == value) return;
				// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
				if (vnode.tag === "input" && key2 === "type") {
					element.setAttribute(key2, value);
					return;
				}
				element[key2] = value;
			} else {
				if (typeof value === "boolean") {
					if (value) element.setAttribute(key2, "");else element.removeAttribute(key2);
				} else element.setAttribute(key2 === "className" ? "class" : key2, value);
			}
		}
		function setLateAttrs(vnode) {
			var attrs2 = vnode.attrs;
			if (vnode.tag === "select" && attrs2 != null) {
				if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined);
				if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined);
			}
		}
		function updateAttrs(vnode, old, attrs2, ns) {
			if (attrs2 != null) {
				for (var key2 in attrs2) {
					setAttr(vnode, key2, old && old[key2], attrs2[key2], ns);
				}
			}
			if (old != null) {
				for (var key2 in old) {
					if (attrs2 == null || !(key2 in attrs2)) {
						if (key2 === "className") key2 = "class";
						if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined);else if (key2 !== "key") vnode.dom.removeAttribute(key2);
					}
				}
			}
		}
		function isFormAttribute(vnode, attr) {
			return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement;
		}
		function isLifecycleMethod(attr) {
			return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate";
		}
		function isAttribute(attr) {
			return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"; // || attr === "type"
		}
		function isCustomElement(vnode) {
			return vnode.attrs.is || vnode.tag.indexOf("-") > -1;
		}
		function hasIntegrationMethods(source) {
			return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove);
		}
		//style
		function updateStyle(element, old, style) {
			if (old === style) element.style.cssText = "", old = null;
			if (style == null) element.style.cssText = "";else if (typeof style === "string") element.style.cssText = style;else {
				if (typeof old === "string") element.style.cssText = "";
				for (var key2 in style) {
					element.style[key2] = style[key2];
				}
				if (old != null && typeof old !== "string") {
					for (var key2 in old) {
						if (!(key2 in style)) element.style[key2] = "";
					}
				}
			}
		}
		//event
		function updateEvent(vnode, key2, value) {
			var element = vnode.dom;
			var callback = typeof onevent !== "function" ? value : function (e) {
				var result = value.call(element, e);
				onevent.call(element, e);
				return result;
			};
			if (key2 in element) element[key2] = typeof value === "function" ? callback : null;else {
				var eventName = key2.slice(2);
				if (vnode.events === undefined) vnode.events = {};
				if (vnode.events[key2] === callback) return;
				if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false);
				if (typeof value === "function") {
					vnode.events[key2] = callback;
					element.addEventListener(eventName, vnode.events[key2], false);
				}
			}
		}
		//lifecycle
		function initLifecycle(source, vnode, hooks) {
			if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode);
			if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode));
		}
		function updateLifecycle(source, vnode, hooks) {
			if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode));
		}
		function shouldNotUpdate(vnode, old) {
			var forceVnodeUpdate, forceComponentUpdate;
			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old);
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old);
			if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
				vnode.instance = old.instance;
				return true;
			}
			return false;
		}
		function render(dom, vnodes) {
			if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");
			var hooks = [];
			var active = $doc.activeElement;
			// First time0 rendering into a node clears it out
			if (dom.vnodes == null) dom.textContent = "";
			if (!Array.isArray(vnodes)) vnodes = [vnodes];
			updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined);
			dom.vnodes = vnodes;
			for (var i = 0; i < hooks.length; i++) {
				hooks[i]();
			}if ($doc.activeElement !== active) active.focus();
		}
		return { render: render, setEventCallback: setEventCallback };
	};
	function throttle(callback) {
		//60fps translates to 16.6ms, round it down since setTimeout requires int
		var time = 16;
		var last = 0,
		    pending = null;
		var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout;
		return function () {
			var now = Date.now();
			if (last === 0 || now - last >= time) {
				last = now;
				callback();
			} else if (pending === null) {
				pending = timeout(function () {
					pending = null;
					callback();
					last = Date.now();
				}, time - (now - last));
			}
		};
	}
	var _11 = function _11($window) {
		var renderService = coreRenderer($window);
		renderService.setEventCallback(function (e) {
			if (e.redraw !== false) redraw();
		});
		var callbacks = [];
		function subscribe(key1, callback) {
			unsubscribe(key1);
			callbacks.push(key1, throttle(callback));
		}
		function unsubscribe(key1) {
			var index = callbacks.indexOf(key1);
			if (index > -1) callbacks.splice(index, 2);
		}
		function redraw() {
			for (var i = 1; i < callbacks.length; i += 2) {
				callbacks[i]();
			}
		}
		return { subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render };
	};
	var redrawService = _11(window);
	requestService.setCompletionCallback(redrawService.redraw);
	var _16 = function _16(redrawService0) {
		return function (root, component) {
			if (component === null) {
				redrawService0.render(root, []);
				redrawService0.unsubscribe(root);
				return;
			}

			if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode");

			var run0 = function run0() {
				redrawService0.render(root, Vnode(component));
			};
			redrawService0.subscribe(root, run0);
			redrawService0.redraw();
		};
	};
	m.mount = _16(redrawService);
	var Promise = PromisePolyfill;
	var parseQueryString = function parseQueryString(string) {
		if (string === "" || string == null) return {};
		if (string.charAt(0) === "?") string = string.slice(1);
		var entries = string.split("&"),
		    data0 = {},
		    counters = {};
		for (var i = 0; i < entries.length; i++) {
			var entry = entries[i].split("=");
			var key5 = decodeURIComponent(entry[0]);
			var value = entry.length === 2 ? decodeURIComponent(entry[1]) : "";
			if (value === "true") value = true;else if (value === "false") value = false;
			var levels = key5.split(/\]\[?|\[/);
			var cursor = data0;
			if (key5.indexOf("[") > -1) levels.pop();
			for (var j = 0; j < levels.length; j++) {
				var level = levels[j],
				    nextLevel = levels[j + 1];
				var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
				var isValue = j === levels.length - 1;
				if (level === "") {
					var key5 = levels.slice(0, j).join();
					if (counters[key5] == null) counters[key5] = 0;
					level = counters[key5]++;
				}
				if (cursor[level] == null) {
					cursor[level] = isValue ? value : isNumber ? [] : {};
				}
				cursor = cursor[level];
			}
		}
		return data0;
	};
	var coreRouter = function coreRouter($window) {
		var supportsPushState = typeof $window.history.pushState === "function";
		var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function normalize1(fragment0) {
			var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent);
			if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data;
			return data;
		}
		var asyncId;
		function debounceAsync(callback0) {
			return function () {
				if (asyncId != null) return;
				asyncId = callAsync0(function () {
					asyncId = null;
					callback0();
				});
			};
		}
		function parsePath(path, queryData, hashData) {
			var queryIndex = path.indexOf("?");
			var hashIndex = path.indexOf("#");
			var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length;
			if (queryIndex > -1) {
				var queryEnd = hashIndex > -1 ? hashIndex : path.length;
				var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd));
				for (var key4 in queryParams) {
					queryData[key4] = queryParams[key4];
				}
			}
			if (hashIndex > -1) {
				var hashParams = parseQueryString(path.slice(hashIndex + 1));
				for (var key4 in hashParams) {
					hashData[key4] = hashParams[key4];
				}
			}
			return path.slice(0, pathEnd);
		}
		var router = { prefix: "#!" };
		router.getPath = function () {
			var type2 = router.prefix.charAt(0);
			switch (type2) {
				case "#":
					return normalize1("hash").slice(router.prefix.length);
				case "?":
					return normalize1("search").slice(router.prefix.length) + normalize1("hash");
				default:
					return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash");
			}
		};
		router.setPath = function (path, data, options) {
			var queryData = {},
			    hashData = {};
			path = parsePath(path, queryData, hashData);
			if (data != null) {
				for (var key4 in data) {
					queryData[key4] = data[key4];
				}path = path.replace(/:([^\/]+)/g, function (match2, token) {
					delete queryData[token];
					return data[token];
				});
			}
			var query = buildQueryString(queryData);
			if (query) path += "?" + query;
			var hash = buildQueryString(hashData);
			if (hash) path += "#" + hash;
			if (supportsPushState) {
				var state = options ? options.state : null;
				var title = options ? options.title : null;
				$window.onpopstate();
				if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path);else $window.history.pushState(state, title, router.prefix + path);
			} else $window.location.href = router.prefix + path;
		};
		router.defineRoutes = function (routes, resolve, reject) {
			function resolveRoute() {
				var path = router.getPath();
				var params = {};
				var pathname = parsePath(path, params, params);
				var state = $window.history.state;
				if (state != null) {
					for (var k in state) {
						params[k] = state[k];
					}
				}
				for (var route0 in routes) {
					var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");
					if (matcher.test(pathname)) {
						pathname.replace(matcher, function () {
							var keys = route0.match(/:[^\/]+/g) || [];
							var values = [].slice.call(arguments, 1, -2);
							for (var i = 0; i < keys.length; i++) {
								params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i]);
							}
							resolve(routes[route0], params, path, route0);
						});
						return;
					}
				}
				reject(path, params);
			}
			if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute);else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute;
			resolveRoute();
		};
		return router;
	};
	var _20 = function _20($window, redrawService0) {
		var routeService = coreRouter($window);
		var identity = function identity(v) {
			return v;
		};
		var render1, component, attrs3, currentPath, _lastUpdate;
		var route = function route(root, defaultRoute, routes) {
			if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined");
			var run1 = function run1() {
				if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)));
			};
			var bail = function bail(path) {
				if (path !== defaultRoute) routeService.setPath(defaultRoute, null, { replace: true });else throw new Error("Could not resolve default route " + defaultRoute);
			};
			routeService.defineRoutes(routes, function (payload, params, path) {
				var update = _lastUpdate = function lastUpdate(routeResolver, comp) {
					if (update !== _lastUpdate) return;
					component = comp != null && (typeof comp.view === "function" || typeof comp === "function") ? comp : "div";
					attrs3 = params, currentPath = path, _lastUpdate = null;
					render1 = (routeResolver.render || identity).bind(routeResolver);
					run1();
				};
				if (payload.view || typeof payload === "function") update({}, payload);else {
					if (payload.onmatch) {
						Promise.resolve(payload.onmatch(params, path)).then(function (resolved) {
							update(payload, resolved);
						}, bail);
					} else update(payload, "div");
				}
			}, bail);
			redrawService0.subscribe(root, run1);
		};
		route.set = function (path, data, options) {
			if (_lastUpdate != null) options = { replace: true };
			_lastUpdate = null;
			routeService.setPath(path, data, options);
		};
		route.get = function () {
			return currentPath;
		};
		route.prefix = function (prefix0) {
			routeService.prefix = prefix0;
		};
		route.link = function (vnode1) {
			vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href);
			vnode1.dom.onclick = function (e) {
				if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return;
				e.preventDefault();
				e.redraw = false;
				var href = this.getAttribute("href");
				if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length);
				route.set(href, undefined, undefined);
			};
		};
		route.param = function (key3) {
			if (typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3];
			return attrs3;
		};
		return route;
	};
	m.route = _20(window, redrawService);
	m.withAttr = function (attrName, callback1, context) {
		return function (e) {
			callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName));
		};
	};
	var _28 = coreRenderer(window);
	m.render = _28.render;
	m.redraw = redrawService.redraw;
	m.request = requestService.request;
	m.jsonp = requestService.jsonp;
	m.parseQueryString = parseQueryString;
	m.buildQueryString = buildQueryString;
	m.version = "1.1.1";
	m.vnode = Vnode;
	if (true) module["exports"] = m;else window.m = m;
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(87).setImmediate, __webpack_require__(4)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.span = vnode.attrs.span;
    vnode.state.cls = vnode.attrs.cls || '';
  },
  view: function view(vnode) {
    return (0, _mithril2.default)(
      'div',
      { className: 'mdl-cell mdl-cell--' + vnode.state.span + '-col ' + vnode.state.cls },
      vnode.attrs.inner
    );
  }
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(92);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(17)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/


/**
 * new Ruler()
 **/

function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typorgapher replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Token class



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/

function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29).Buffer))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML5 entities map: { name -> utf16string }
//


/*eslint quotes:0*/

module.exports = __webpack_require__(93);

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = '';
      state.tokens[delimiters[startDelim.end - 1].token].content = '';
      i++;
    }
  }
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ~~strike through~~
//


// Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports.encode = __webpack_require__(80);
module.exports.decode = __webpack_require__(79);
module.exports.format = __webpack_require__(81);
module.exports.parse = __webpack_require__(82);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(86);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 18 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(94);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

var _title = __webpack_require__(25);

var _title2 = _interopRequireDefault(_title);

var _tags = __webpack_require__(24);

var _tags2 = _interopRequireDefault(_tags);

var _slug = __webpack_require__(95);

var _slug2 = _interopRequireDefault(_slug);

var _editor = __webpack_require__(21);

var _editor2 = _interopRequireDefault(_editor);

var _preview = __webpack_require__(22);

var _preview2 = _interopRequireDefault(_preview);

var _save = __webpack_require__(23);

var _save2 = _interopRequireDefault(_save);

var _article = __webpack_require__(26);

var _article2 = _interopRequireDefault(_article);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var model = new _article2.default();

exports.default = {
  oninit: function oninit(vnode) {
    model.fetch();
  },
  view: function view(vnode) {
    if (model.fetched) {
      return (0, _mithril2.default)(
        'div',
        { className: 'mdl-grid' },
        (0, _mithril2.default)(_title2.default, { model: model }),
        (0, _mithril2.default)(_slug2.default, { model: model }),
        (0, _mithril2.default)(_tags2.default, { model: model }),
        (0, _mithril2.default)(
          'div',
          { className: _styles2.default.editorWrap },
          (0, _mithril2.default)(_editor2.default, { key: 'editor', model: model }),
          (0, _mithril2.default)(_preview2.default, { key: 'preview', body: model.mdBody() })
        ),
        (0, _mithril2.default)(_save2.default, { model: model, onclick: model.update })
      );
    }
    return (0, _mithril2.default)(
      'div',
      null,
      '\u30C7\u30FC\u30BF\u53D6\u5F97\u4E2D...'
    );
  }
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _component = __webpack_require__(19);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_mithril2.default.mount(document.getElementById('main'), _component2.default);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.oninput = function (v) {
      vnode.state.model.data.body = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'textarea',
      {
        className: _styles2.default.textarea,
        oninput: _mithril2.default.withAttr('value', vnode.state.oninput) },
      vnode.state.model.data.body
    );
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorLeftSide, inner: inner });
  }
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(vnode) {
    return (0, _mithril2.default)(_cell2.default, { span: 6, cls: _styles2.default.editor + ' ' + _styles2.default.editorRightSide,
      inner: _mithril2.default.trust(vnode.attrs.body) });
  }
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onclick = vnode.attrs.onclick;
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'button',
      {
        className: 'mdl-button mdl-js-button mdl-button--raised mdl-button--colored',
        onclick: vnode.state.onclick },
      'save'
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, cls: _styles2.default.saveButton, inner: inner });
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.tags = v.split(',');
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'label',
      null,
      '\u30BF\u30B0',
      (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.tags,
        onchange: _mithril2.default.withAttr('value', vnode.state.onchange),
        value: vnode.state.model.data.tags.join(',')
      })
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.title = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'label',
      null,
      '\u30BF\u30A4\u30C8\u30EB',
      (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.title,
        onchange: _mithril2.default.withAttr('value', vnode.state.onchange),
        value: vnode.state.model.data.title
      })
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _request = __webpack_require__(27);

var _request2 = _interopRequireDefault(_request);

var _markdownIt = __webpack_require__(34);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var md = new _markdownIt2.default();

var Model = function () {
  function Model(data) {
    _classCallCheck(this, Model);

    this.data = data || {
      title: '',
      body: '',
      slug: '',
      publish: false,
      tags: [],
      date: null
    };
    this.fetched = false;
    this.resourcesUrl = '/api/articles';
    this.resourceUrl = this.resourcesUrl + '/' + location.href.split('/').slice(4).join('/');
  }

  _createClass(Model, [{
    key: 'fetch',
    value: function fetch() {
      var _this = this;

      return (0, _request2.default)('GET', this.resourceUrl).then(function (response) {
        _this.fetched = true;
        _this.data = response;
      });
    }
  }, {
    key: 'create',
    value: function create() {
      var _this2 = this;

      return (0, _request2.default)('POST', this.resourcesUrl, this.data).then(function (response) {
        _this2.data = response;
      });
    }
  }, {
    key: 'update',
    value: function update() {
      var _this3 = this;

      return (0, _request2.default)('PUT', this.resourceUrl, this.data).then(function (response) {
        _this3.data = response;
      });
    }
  }, {
    key: 'delete',
    value: function _delete() {
      var _this4 = this;

      return (0, _request2.default)('DELETE', this.resourceUrl).then(function (response) {
        _this4.data = null;
      });
    }
  }, {
    key: 'mdBody',
    value: function mdBody() {
      return md.render(this.data.body);
    }
  }]);

  return Model;
}();

exports.default = Model;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (method, url, data) {
  return _mithril2.default.request({ method: method, url: url, data: data, deserialize: JSON.parse });
};

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(28);
var ieee754 = __webpack_require__(30);
var isArray = __webpack_require__(31);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//

function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(33)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(16).source;
  re.src_Cc = __webpack_require__(14).source;
  re.src_Z = __webpack_require__(15).source;
  re.src_P = __webpack_require__(7).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(40);

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Just a shortcut for bulk export


exports.parseLinkLabel = __webpack_require__(38);
exports.parseLinkDestination = __webpack_require__(37);
exports.parseLinkTitle = __webpack_require__(39);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link destination
//


var isSpace = __webpack_require__(0).isSpace;
var unescapeAll = __webpack_require__(0).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
        if (level > 1) {
          break;
        }
      }

    if (code === 0x29 /* ) */) {
        level--;
        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//


module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link title
//


var unescapeAll = __webpack_require__(0).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Main parser class



var utils = __webpack_require__(0);
var helpers = __webpack_require__(36);
var Renderer = __webpack_require__(47);
var ParserCore = __webpack_require__(42);
var ParserBlock = __webpack_require__(41);
var ParserInline = __webpack_require__(43);
var LinkifyIt = __webpack_require__(32);
var mdurl = __webpack_require__(13);
var punycode = __webpack_require__(84);

var config = {
  'default': __webpack_require__(45),
  zero: __webpack_require__(46),
  commonmark: __webpack_require__(44)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/


var Ruler = __webpack_require__(5);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(59), ['paragraph', 'reference']], ['code', __webpack_require__(49)], ['fence', __webpack_require__(50), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(48), ['paragraph', 'reference', 'list']], ['hr', __webpack_require__(52), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(55), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(57)], ['heading', __webpack_require__(51), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(54)], ['html_block', __webpack_require__(53), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(56)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(58);

module.exports = ParserBlock;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/


var Ruler = __webpack_require__(5);

var _rules = [['normalize', __webpack_require__(63)], ['block', __webpack_require__(60)], ['inline', __webpack_require__(61)], ['linkify', __webpack_require__(62)], ['replacements', __webpack_require__(64)], ['smartquotes', __webpack_require__(65)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(66);

module.exports = Core;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/


var Ruler = __webpack_require__(5);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(77)], ['newline', __webpack_require__(75)], ['escape', __webpack_require__(71)], ['backticks', __webpack_require__(68)], ['strikethrough', __webpack_require__(12).tokenize], ['emphasis', __webpack_require__(11).tokenize], ['link', __webpack_require__(74)], ['image', __webpack_require__(73)], ['autolink', __webpack_require__(67)], ['html_inline', __webpack_require__(72)], ['entity', __webpack_require__(70)]];

var _rules2 = [['balance_pairs', __webpack_require__(69)], ['strikethrough', __webpack_require__(12).postProcess], ['emphasis', __webpack_require__(11).postProcess], ['text_collapse', __webpack_require__(78)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(76);

module.exports = ParserInline;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// markdown-it default options



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign = __webpack_require__(0).assign;
var unescapeAll = __webpack_require__(0).unescapeAll;
var escapeHtml = __webpack_require__(0).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without mudofying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes



var isSpace = __webpack_require__(0).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      isOutdented,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    if (isOutdented) break;

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)



var isSpace = __webpack_require__(0).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule



var isSpace = __webpack_require__(0).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block



var block_names = __webpack_require__(35);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(10).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists



var isSpace = __webpack_require__(0).isSpace;

// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finilize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class



var Token = __webpack_require__(6);
var isSpace = __webpack_require__(0).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard



var isSpace = __webpack_require__(0).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//


var arrayReplaceAt = __webpack_require__(0).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Normalize input string



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographyc replacements
//
// (c) (C) → ©
// (tm) (TM) → ™
// (r) (R) → ®
// +- → ±
// (p) (P) -> §
// ... → … (also ?.... → ?.., !.... → !..)
// ???????? → ???, !!!!! → !!!, `,,` → `,`
// -- → &ndash;, --- → &mdash;
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//


var isWhiteSpace = __webpack_require__(0).isWhiteSpace;
var isPunctChar = __webpack_require__(0).isPunctChar;
var isMdAsciiPunct = __webpack_require__(0).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Core state object
//


var Token = __webpack_require__(6);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'



/*eslint max-len:0*/

var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// For each opening emphasis-like marker find a matching closing one
//


module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities = __webpack_require__(9);
var has = __webpack_require__(0).has;
var isValidEntityCode = __webpack_require__(0).isValidEntityCode;
var fromCodePoint = __webpack_require__(0).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess escaped chars and hardbreaks



var isSpace = __webpack_require__(0).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags



var HTML_TAG_RE = __webpack_require__(10).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ![image](<src> "title")



var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [link](<to> "stuff")



var normalizeReference = __webpack_require__(0).normalizeReference;
var isSpace = __webpack_require__(0).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'



var isSpace = __webpack_require__(0).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state



var Token = __webpack_require__(6);
var isWhiteSpace = __webpack_require__(0).isWhiteSpace;
var isPunctChar = __webpack_require__(0).isPunctChar;
var isMdAsciiPunct = __webpack_require__(0).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Merge adjacent text nodes into one, and re-calculate all token levels
//


module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(18)) == 'object' && __webpack_require__(18)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(90)(module), __webpack_require__(4)))

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(83)))

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(85);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Any = __webpack_require__(16);
exports.Cc = __webpack_require__(14);
exports.Cf = __webpack_require__(88);
exports.P = __webpack_require__(7);
exports.Z = __webpack_require__(15);

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(8)(undefined);
// imports


// module
exports.push([module.i, "._2YrKEmruSXq-LY8HT9gjcA{position:relative;width:100%;height:calc(100% - 230px)}._3L5NEB84KxPflxBZveysdd{text-align:right;margin-top:15px}", ""]);

// exports
exports.locals = {
	"editorWrap": "_2YrKEmruSXq-LY8HT9gjcA",
	"saveButton": "_3L5NEB84KxPflxBZveysdd"
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(8)(undefined);
// imports


// module
exports.push([module.i, ".ZeW3HIwa_BWIGW0yZJi5G{width:100%;font-size:24pt;padding-left:10px}.AAMENcndmo-o7IjjzQHRY,.ZcsaZvcof0txWdeqikCGZ{width:100%;font-size:18pt;padding-left:10px}._1ouasj646M7i9oKw-0Q_55{position:relative;width:100%;height:calc(100% - 230px)}._2MLWR8W_pHfNBkBmp0ni08{position:absolute;top:0;background:#fcfcfc;padding:10px;overflow:auto;height:100%}.GJYonSHLOXZJhPSUwZdvb{left:0}.u_RSyvBLD7b0Z12hpK8D4{left:50%;background-color:#fff}._2gAtgm9oADOrZYt1udmcJR{text-align:right;margin-top:15px}._3NBbIr4WlHyUQc29YW6bSX{width:100%;height:100%;resize:none;background-color:#fcfcfc;border:none;font-size:10pt}", ""]);

// exports
exports.locals = {
	"title": "ZeW3HIwa_BWIGW0yZJi5G",
	"tags": "ZcsaZvcof0txWdeqikCGZ",
	"slug": "AAMENcndmo-o7IjjzQHRY",
	"editorWrap": "_1ouasj646M7i9oKw-0Q_55",
	"editor": "_2MLWR8W_pHfNBkBmp0ni08",
	"editorLeftSide": "GJYonSHLOXZJhPSUwZdvb",
	"editorRightSide": "u_RSyvBLD7b0Z12hpK8D4",
	"saveButton": "_2gAtgm9oADOrZYt1udmcJR",
	"textarea": "_3NBbIr4WlHyUQc29YW6bSX"
};

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = {
	"Aacute": "Á",
	"aacute": "á",
	"Abreve": "Ă",
	"abreve": "ă",
	"ac": "∾",
	"acd": "∿",
	"acE": "∾̳",
	"Acirc": "Â",
	"acirc": "â",
	"acute": "´",
	"Acy": "А",
	"acy": "а",
	"AElig": "Æ",
	"aelig": "æ",
	"af": "⁡",
	"Afr": "𝔄",
	"afr": "𝔞",
	"Agrave": "À",
	"agrave": "à",
	"alefsym": "ℵ",
	"aleph": "ℵ",
	"Alpha": "Α",
	"alpha": "α",
	"Amacr": "Ā",
	"amacr": "ā",
	"amalg": "⨿",
	"amp": "&",
	"AMP": "&",
	"andand": "⩕",
	"And": "⩓",
	"and": "∧",
	"andd": "⩜",
	"andslope": "⩘",
	"andv": "⩚",
	"ang": "∠",
	"ange": "⦤",
	"angle": "∠",
	"angmsdaa": "⦨",
	"angmsdab": "⦩",
	"angmsdac": "⦪",
	"angmsdad": "⦫",
	"angmsdae": "⦬",
	"angmsdaf": "⦭",
	"angmsdag": "⦮",
	"angmsdah": "⦯",
	"angmsd": "∡",
	"angrt": "∟",
	"angrtvb": "⊾",
	"angrtvbd": "⦝",
	"angsph": "∢",
	"angst": "Å",
	"angzarr": "⍼",
	"Aogon": "Ą",
	"aogon": "ą",
	"Aopf": "𝔸",
	"aopf": "𝕒",
	"apacir": "⩯",
	"ap": "≈",
	"apE": "⩰",
	"ape": "≊",
	"apid": "≋",
	"apos": "'",
	"ApplyFunction": "⁡",
	"approx": "≈",
	"approxeq": "≊",
	"Aring": "Å",
	"aring": "å",
	"Ascr": "𝒜",
	"ascr": "𝒶",
	"Assign": "≔",
	"ast": "*",
	"asymp": "≈",
	"asympeq": "≍",
	"Atilde": "Ã",
	"atilde": "ã",
	"Auml": "Ä",
	"auml": "ä",
	"awconint": "∳",
	"awint": "⨑",
	"backcong": "≌",
	"backepsilon": "϶",
	"backprime": "‵",
	"backsim": "∽",
	"backsimeq": "⋍",
	"Backslash": "∖",
	"Barv": "⫧",
	"barvee": "⊽",
	"barwed": "⌅",
	"Barwed": "⌆",
	"barwedge": "⌅",
	"bbrk": "⎵",
	"bbrktbrk": "⎶",
	"bcong": "≌",
	"Bcy": "Б",
	"bcy": "б",
	"bdquo": "„",
	"becaus": "∵",
	"because": "∵",
	"Because": "∵",
	"bemptyv": "⦰",
	"bepsi": "϶",
	"bernou": "ℬ",
	"Bernoullis": "ℬ",
	"Beta": "Β",
	"beta": "β",
	"beth": "ℶ",
	"between": "≬",
	"Bfr": "𝔅",
	"bfr": "𝔟",
	"bigcap": "⋂",
	"bigcirc": "◯",
	"bigcup": "⋃",
	"bigodot": "⨀",
	"bigoplus": "⨁",
	"bigotimes": "⨂",
	"bigsqcup": "⨆",
	"bigstar": "★",
	"bigtriangledown": "▽",
	"bigtriangleup": "△",
	"biguplus": "⨄",
	"bigvee": "⋁",
	"bigwedge": "⋀",
	"bkarow": "⤍",
	"blacklozenge": "⧫",
	"blacksquare": "▪",
	"blacktriangle": "▴",
	"blacktriangledown": "▾",
	"blacktriangleleft": "◂",
	"blacktriangleright": "▸",
	"blank": "␣",
	"blk12": "▒",
	"blk14": "░",
	"blk34": "▓",
	"block": "█",
	"bne": "=⃥",
	"bnequiv": "≡⃥",
	"bNot": "⫭",
	"bnot": "⌐",
	"Bopf": "𝔹",
	"bopf": "𝕓",
	"bot": "⊥",
	"bottom": "⊥",
	"bowtie": "⋈",
	"boxbox": "⧉",
	"boxdl": "┐",
	"boxdL": "╕",
	"boxDl": "╖",
	"boxDL": "╗",
	"boxdr": "┌",
	"boxdR": "╒",
	"boxDr": "╓",
	"boxDR": "╔",
	"boxh": "─",
	"boxH": "═",
	"boxhd": "┬",
	"boxHd": "╤",
	"boxhD": "╥",
	"boxHD": "╦",
	"boxhu": "┴",
	"boxHu": "╧",
	"boxhU": "╨",
	"boxHU": "╩",
	"boxminus": "⊟",
	"boxplus": "⊞",
	"boxtimes": "⊠",
	"boxul": "┘",
	"boxuL": "╛",
	"boxUl": "╜",
	"boxUL": "╝",
	"boxur": "└",
	"boxuR": "╘",
	"boxUr": "╙",
	"boxUR": "╚",
	"boxv": "│",
	"boxV": "║",
	"boxvh": "┼",
	"boxvH": "╪",
	"boxVh": "╫",
	"boxVH": "╬",
	"boxvl": "┤",
	"boxvL": "╡",
	"boxVl": "╢",
	"boxVL": "╣",
	"boxvr": "├",
	"boxvR": "╞",
	"boxVr": "╟",
	"boxVR": "╠",
	"bprime": "‵",
	"breve": "˘",
	"Breve": "˘",
	"brvbar": "¦",
	"bscr": "𝒷",
	"Bscr": "ℬ",
	"bsemi": "⁏",
	"bsim": "∽",
	"bsime": "⋍",
	"bsolb": "⧅",
	"bsol": "\\",
	"bsolhsub": "⟈",
	"bull": "•",
	"bullet": "•",
	"bump": "≎",
	"bumpE": "⪮",
	"bumpe": "≏",
	"Bumpeq": "≎",
	"bumpeq": "≏",
	"Cacute": "Ć",
	"cacute": "ć",
	"capand": "⩄",
	"capbrcup": "⩉",
	"capcap": "⩋",
	"cap": "∩",
	"Cap": "⋒",
	"capcup": "⩇",
	"capdot": "⩀",
	"CapitalDifferentialD": "ⅅ",
	"caps": "∩︀",
	"caret": "⁁",
	"caron": "ˇ",
	"Cayleys": "ℭ",
	"ccaps": "⩍",
	"Ccaron": "Č",
	"ccaron": "č",
	"Ccedil": "Ç",
	"ccedil": "ç",
	"Ccirc": "Ĉ",
	"ccirc": "ĉ",
	"Cconint": "∰",
	"ccups": "⩌",
	"ccupssm": "⩐",
	"Cdot": "Ċ",
	"cdot": "ċ",
	"cedil": "¸",
	"Cedilla": "¸",
	"cemptyv": "⦲",
	"cent": "¢",
	"centerdot": "·",
	"CenterDot": "·",
	"cfr": "𝔠",
	"Cfr": "ℭ",
	"CHcy": "Ч",
	"chcy": "ч",
	"check": "✓",
	"checkmark": "✓",
	"Chi": "Χ",
	"chi": "χ",
	"circ": "ˆ",
	"circeq": "≗",
	"circlearrowleft": "↺",
	"circlearrowright": "↻",
	"circledast": "⊛",
	"circledcirc": "⊚",
	"circleddash": "⊝",
	"CircleDot": "⊙",
	"circledR": "®",
	"circledS": "Ⓢ",
	"CircleMinus": "⊖",
	"CirclePlus": "⊕",
	"CircleTimes": "⊗",
	"cir": "○",
	"cirE": "⧃",
	"cire": "≗",
	"cirfnint": "⨐",
	"cirmid": "⫯",
	"cirscir": "⧂",
	"ClockwiseContourIntegral": "∲",
	"CloseCurlyDoubleQuote": "”",
	"CloseCurlyQuote": "’",
	"clubs": "♣",
	"clubsuit": "♣",
	"colon": ":",
	"Colon": "∷",
	"Colone": "⩴",
	"colone": "≔",
	"coloneq": "≔",
	"comma": ",",
	"commat": "@",
	"comp": "∁",
	"compfn": "∘",
	"complement": "∁",
	"complexes": "ℂ",
	"cong": "≅",
	"congdot": "⩭",
	"Congruent": "≡",
	"conint": "∮",
	"Conint": "∯",
	"ContourIntegral": "∮",
	"copf": "𝕔",
	"Copf": "ℂ",
	"coprod": "∐",
	"Coproduct": "∐",
	"copy": "©",
	"COPY": "©",
	"copysr": "℗",
	"CounterClockwiseContourIntegral": "∳",
	"crarr": "↵",
	"cross": "✗",
	"Cross": "⨯",
	"Cscr": "𝒞",
	"cscr": "𝒸",
	"csub": "⫏",
	"csube": "⫑",
	"csup": "⫐",
	"csupe": "⫒",
	"ctdot": "⋯",
	"cudarrl": "⤸",
	"cudarrr": "⤵",
	"cuepr": "⋞",
	"cuesc": "⋟",
	"cularr": "↶",
	"cularrp": "⤽",
	"cupbrcap": "⩈",
	"cupcap": "⩆",
	"CupCap": "≍",
	"cup": "∪",
	"Cup": "⋓",
	"cupcup": "⩊",
	"cupdot": "⊍",
	"cupor": "⩅",
	"cups": "∪︀",
	"curarr": "↷",
	"curarrm": "⤼",
	"curlyeqprec": "⋞",
	"curlyeqsucc": "⋟",
	"curlyvee": "⋎",
	"curlywedge": "⋏",
	"curren": "¤",
	"curvearrowleft": "↶",
	"curvearrowright": "↷",
	"cuvee": "⋎",
	"cuwed": "⋏",
	"cwconint": "∲",
	"cwint": "∱",
	"cylcty": "⌭",
	"dagger": "†",
	"Dagger": "‡",
	"daleth": "ℸ",
	"darr": "↓",
	"Darr": "↡",
	"dArr": "⇓",
	"dash": "‐",
	"Dashv": "⫤",
	"dashv": "⊣",
	"dbkarow": "⤏",
	"dblac": "˝",
	"Dcaron": "Ď",
	"dcaron": "ď",
	"Dcy": "Д",
	"dcy": "д",
	"ddagger": "‡",
	"ddarr": "⇊",
	"DD": "ⅅ",
	"dd": "ⅆ",
	"DDotrahd": "⤑",
	"ddotseq": "⩷",
	"deg": "°",
	"Del": "∇",
	"Delta": "Δ",
	"delta": "δ",
	"demptyv": "⦱",
	"dfisht": "⥿",
	"Dfr": "𝔇",
	"dfr": "𝔡",
	"dHar": "⥥",
	"dharl": "⇃",
	"dharr": "⇂",
	"DiacriticalAcute": "´",
	"DiacriticalDot": "˙",
	"DiacriticalDoubleAcute": "˝",
	"DiacriticalGrave": "`",
	"DiacriticalTilde": "˜",
	"diam": "⋄",
	"diamond": "⋄",
	"Diamond": "⋄",
	"diamondsuit": "♦",
	"diams": "♦",
	"die": "¨",
	"DifferentialD": "ⅆ",
	"digamma": "ϝ",
	"disin": "⋲",
	"div": "÷",
	"divide": "÷",
	"divideontimes": "⋇",
	"divonx": "⋇",
	"DJcy": "Ђ",
	"djcy": "ђ",
	"dlcorn": "⌞",
	"dlcrop": "⌍",
	"dollar": "$",
	"Dopf": "𝔻",
	"dopf": "𝕕",
	"Dot": "¨",
	"dot": "˙",
	"DotDot": "⃜",
	"doteq": "≐",
	"doteqdot": "≑",
	"DotEqual": "≐",
	"dotminus": "∸",
	"dotplus": "∔",
	"dotsquare": "⊡",
	"doublebarwedge": "⌆",
	"DoubleContourIntegral": "∯",
	"DoubleDot": "¨",
	"DoubleDownArrow": "⇓",
	"DoubleLeftArrow": "⇐",
	"DoubleLeftRightArrow": "⇔",
	"DoubleLeftTee": "⫤",
	"DoubleLongLeftArrow": "⟸",
	"DoubleLongLeftRightArrow": "⟺",
	"DoubleLongRightArrow": "⟹",
	"DoubleRightArrow": "⇒",
	"DoubleRightTee": "⊨",
	"DoubleUpArrow": "⇑",
	"DoubleUpDownArrow": "⇕",
	"DoubleVerticalBar": "∥",
	"DownArrowBar": "⤓",
	"downarrow": "↓",
	"DownArrow": "↓",
	"Downarrow": "⇓",
	"DownArrowUpArrow": "⇵",
	"DownBreve": "̑",
	"downdownarrows": "⇊",
	"downharpoonleft": "⇃",
	"downharpoonright": "⇂",
	"DownLeftRightVector": "⥐",
	"DownLeftTeeVector": "⥞",
	"DownLeftVectorBar": "⥖",
	"DownLeftVector": "↽",
	"DownRightTeeVector": "⥟",
	"DownRightVectorBar": "⥗",
	"DownRightVector": "⇁",
	"DownTeeArrow": "↧",
	"DownTee": "⊤",
	"drbkarow": "⤐",
	"drcorn": "⌟",
	"drcrop": "⌌",
	"Dscr": "𝒟",
	"dscr": "𝒹",
	"DScy": "Ѕ",
	"dscy": "ѕ",
	"dsol": "⧶",
	"Dstrok": "Đ",
	"dstrok": "đ",
	"dtdot": "⋱",
	"dtri": "▿",
	"dtrif": "▾",
	"duarr": "⇵",
	"duhar": "⥯",
	"dwangle": "⦦",
	"DZcy": "Џ",
	"dzcy": "џ",
	"dzigrarr": "⟿",
	"Eacute": "É",
	"eacute": "é",
	"easter": "⩮",
	"Ecaron": "Ě",
	"ecaron": "ě",
	"Ecirc": "Ê",
	"ecirc": "ê",
	"ecir": "≖",
	"ecolon": "≕",
	"Ecy": "Э",
	"ecy": "э",
	"eDDot": "⩷",
	"Edot": "Ė",
	"edot": "ė",
	"eDot": "≑",
	"ee": "ⅇ",
	"efDot": "≒",
	"Efr": "𝔈",
	"efr": "𝔢",
	"eg": "⪚",
	"Egrave": "È",
	"egrave": "è",
	"egs": "⪖",
	"egsdot": "⪘",
	"el": "⪙",
	"Element": "∈",
	"elinters": "⏧",
	"ell": "ℓ",
	"els": "⪕",
	"elsdot": "⪗",
	"Emacr": "Ē",
	"emacr": "ē",
	"empty": "∅",
	"emptyset": "∅",
	"EmptySmallSquare": "◻",
	"emptyv": "∅",
	"EmptyVerySmallSquare": "▫",
	"emsp13": " ",
	"emsp14": " ",
	"emsp": " ",
	"ENG": "Ŋ",
	"eng": "ŋ",
	"ensp": " ",
	"Eogon": "Ę",
	"eogon": "ę",
	"Eopf": "𝔼",
	"eopf": "𝕖",
	"epar": "⋕",
	"eparsl": "⧣",
	"eplus": "⩱",
	"epsi": "ε",
	"Epsilon": "Ε",
	"epsilon": "ε",
	"epsiv": "ϵ",
	"eqcirc": "≖",
	"eqcolon": "≕",
	"eqsim": "≂",
	"eqslantgtr": "⪖",
	"eqslantless": "⪕",
	"Equal": "⩵",
	"equals": "=",
	"EqualTilde": "≂",
	"equest": "≟",
	"Equilibrium": "⇌",
	"equiv": "≡",
	"equivDD": "⩸",
	"eqvparsl": "⧥",
	"erarr": "⥱",
	"erDot": "≓",
	"escr": "ℯ",
	"Escr": "ℰ",
	"esdot": "≐",
	"Esim": "⩳",
	"esim": "≂",
	"Eta": "Η",
	"eta": "η",
	"ETH": "Ð",
	"eth": "ð",
	"Euml": "Ë",
	"euml": "ë",
	"euro": "€",
	"excl": "!",
	"exist": "∃",
	"Exists": "∃",
	"expectation": "ℰ",
	"exponentiale": "ⅇ",
	"ExponentialE": "ⅇ",
	"fallingdotseq": "≒",
	"Fcy": "Ф",
	"fcy": "ф",
	"female": "♀",
	"ffilig": "ﬃ",
	"fflig": "ﬀ",
	"ffllig": "ﬄ",
	"Ffr": "𝔉",
	"ffr": "𝔣",
	"filig": "ﬁ",
	"FilledSmallSquare": "◼",
	"FilledVerySmallSquare": "▪",
	"fjlig": "fj",
	"flat": "♭",
	"fllig": "ﬂ",
	"fltns": "▱",
	"fnof": "ƒ",
	"Fopf": "𝔽",
	"fopf": "𝕗",
	"forall": "∀",
	"ForAll": "∀",
	"fork": "⋔",
	"forkv": "⫙",
	"Fouriertrf": "ℱ",
	"fpartint": "⨍",
	"frac12": "½",
	"frac13": "⅓",
	"frac14": "¼",
	"frac15": "⅕",
	"frac16": "⅙",
	"frac18": "⅛",
	"frac23": "⅔",
	"frac25": "⅖",
	"frac34": "¾",
	"frac35": "⅗",
	"frac38": "⅜",
	"frac45": "⅘",
	"frac56": "⅚",
	"frac58": "⅝",
	"frac78": "⅞",
	"frasl": "⁄",
	"frown": "⌢",
	"fscr": "𝒻",
	"Fscr": "ℱ",
	"gacute": "ǵ",
	"Gamma": "Γ",
	"gamma": "γ",
	"Gammad": "Ϝ",
	"gammad": "ϝ",
	"gap": "⪆",
	"Gbreve": "Ğ",
	"gbreve": "ğ",
	"Gcedil": "Ģ",
	"Gcirc": "Ĝ",
	"gcirc": "ĝ",
	"Gcy": "Г",
	"gcy": "г",
	"Gdot": "Ġ",
	"gdot": "ġ",
	"ge": "≥",
	"gE": "≧",
	"gEl": "⪌",
	"gel": "⋛",
	"geq": "≥",
	"geqq": "≧",
	"geqslant": "⩾",
	"gescc": "⪩",
	"ges": "⩾",
	"gesdot": "⪀",
	"gesdoto": "⪂",
	"gesdotol": "⪄",
	"gesl": "⋛︀",
	"gesles": "⪔",
	"Gfr": "𝔊",
	"gfr": "𝔤",
	"gg": "≫",
	"Gg": "⋙",
	"ggg": "⋙",
	"gimel": "ℷ",
	"GJcy": "Ѓ",
	"gjcy": "ѓ",
	"gla": "⪥",
	"gl": "≷",
	"glE": "⪒",
	"glj": "⪤",
	"gnap": "⪊",
	"gnapprox": "⪊",
	"gne": "⪈",
	"gnE": "≩",
	"gneq": "⪈",
	"gneqq": "≩",
	"gnsim": "⋧",
	"Gopf": "𝔾",
	"gopf": "𝕘",
	"grave": "`",
	"GreaterEqual": "≥",
	"GreaterEqualLess": "⋛",
	"GreaterFullEqual": "≧",
	"GreaterGreater": "⪢",
	"GreaterLess": "≷",
	"GreaterSlantEqual": "⩾",
	"GreaterTilde": "≳",
	"Gscr": "𝒢",
	"gscr": "ℊ",
	"gsim": "≳",
	"gsime": "⪎",
	"gsiml": "⪐",
	"gtcc": "⪧",
	"gtcir": "⩺",
	"gt": ">",
	"GT": ">",
	"Gt": "≫",
	"gtdot": "⋗",
	"gtlPar": "⦕",
	"gtquest": "⩼",
	"gtrapprox": "⪆",
	"gtrarr": "⥸",
	"gtrdot": "⋗",
	"gtreqless": "⋛",
	"gtreqqless": "⪌",
	"gtrless": "≷",
	"gtrsim": "≳",
	"gvertneqq": "≩︀",
	"gvnE": "≩︀",
	"Hacek": "ˇ",
	"hairsp": " ",
	"half": "½",
	"hamilt": "ℋ",
	"HARDcy": "Ъ",
	"hardcy": "ъ",
	"harrcir": "⥈",
	"harr": "↔",
	"hArr": "⇔",
	"harrw": "↭",
	"Hat": "^",
	"hbar": "ℏ",
	"Hcirc": "Ĥ",
	"hcirc": "ĥ",
	"hearts": "♥",
	"heartsuit": "♥",
	"hellip": "…",
	"hercon": "⊹",
	"hfr": "𝔥",
	"Hfr": "ℌ",
	"HilbertSpace": "ℋ",
	"hksearow": "⤥",
	"hkswarow": "⤦",
	"hoarr": "⇿",
	"homtht": "∻",
	"hookleftarrow": "↩",
	"hookrightarrow": "↪",
	"hopf": "𝕙",
	"Hopf": "ℍ",
	"horbar": "―",
	"HorizontalLine": "─",
	"hscr": "𝒽",
	"Hscr": "ℋ",
	"hslash": "ℏ",
	"Hstrok": "Ħ",
	"hstrok": "ħ",
	"HumpDownHump": "≎",
	"HumpEqual": "≏",
	"hybull": "⁃",
	"hyphen": "‐",
	"Iacute": "Í",
	"iacute": "í",
	"ic": "⁣",
	"Icirc": "Î",
	"icirc": "î",
	"Icy": "И",
	"icy": "и",
	"Idot": "İ",
	"IEcy": "Е",
	"iecy": "е",
	"iexcl": "¡",
	"iff": "⇔",
	"ifr": "𝔦",
	"Ifr": "ℑ",
	"Igrave": "Ì",
	"igrave": "ì",
	"ii": "ⅈ",
	"iiiint": "⨌",
	"iiint": "∭",
	"iinfin": "⧜",
	"iiota": "℩",
	"IJlig": "Ĳ",
	"ijlig": "ĳ",
	"Imacr": "Ī",
	"imacr": "ī",
	"image": "ℑ",
	"ImaginaryI": "ⅈ",
	"imagline": "ℐ",
	"imagpart": "ℑ",
	"imath": "ı",
	"Im": "ℑ",
	"imof": "⊷",
	"imped": "Ƶ",
	"Implies": "⇒",
	"incare": "℅",
	"in": "∈",
	"infin": "∞",
	"infintie": "⧝",
	"inodot": "ı",
	"intcal": "⊺",
	"int": "∫",
	"Int": "∬",
	"integers": "ℤ",
	"Integral": "∫",
	"intercal": "⊺",
	"Intersection": "⋂",
	"intlarhk": "⨗",
	"intprod": "⨼",
	"InvisibleComma": "⁣",
	"InvisibleTimes": "⁢",
	"IOcy": "Ё",
	"iocy": "ё",
	"Iogon": "Į",
	"iogon": "į",
	"Iopf": "𝕀",
	"iopf": "𝕚",
	"Iota": "Ι",
	"iota": "ι",
	"iprod": "⨼",
	"iquest": "¿",
	"iscr": "𝒾",
	"Iscr": "ℐ",
	"isin": "∈",
	"isindot": "⋵",
	"isinE": "⋹",
	"isins": "⋴",
	"isinsv": "⋳",
	"isinv": "∈",
	"it": "⁢",
	"Itilde": "Ĩ",
	"itilde": "ĩ",
	"Iukcy": "І",
	"iukcy": "і",
	"Iuml": "Ï",
	"iuml": "ï",
	"Jcirc": "Ĵ",
	"jcirc": "ĵ",
	"Jcy": "Й",
	"jcy": "й",
	"Jfr": "𝔍",
	"jfr": "𝔧",
	"jmath": "ȷ",
	"Jopf": "𝕁",
	"jopf": "𝕛",
	"Jscr": "𝒥",
	"jscr": "𝒿",
	"Jsercy": "Ј",
	"jsercy": "ј",
	"Jukcy": "Є",
	"jukcy": "є",
	"Kappa": "Κ",
	"kappa": "κ",
	"kappav": "ϰ",
	"Kcedil": "Ķ",
	"kcedil": "ķ",
	"Kcy": "К",
	"kcy": "к",
	"Kfr": "𝔎",
	"kfr": "𝔨",
	"kgreen": "ĸ",
	"KHcy": "Х",
	"khcy": "х",
	"KJcy": "Ќ",
	"kjcy": "ќ",
	"Kopf": "𝕂",
	"kopf": "𝕜",
	"Kscr": "𝒦",
	"kscr": "𝓀",
	"lAarr": "⇚",
	"Lacute": "Ĺ",
	"lacute": "ĺ",
	"laemptyv": "⦴",
	"lagran": "ℒ",
	"Lambda": "Λ",
	"lambda": "λ",
	"lang": "⟨",
	"Lang": "⟪",
	"langd": "⦑",
	"langle": "⟨",
	"lap": "⪅",
	"Laplacetrf": "ℒ",
	"laquo": "«",
	"larrb": "⇤",
	"larrbfs": "⤟",
	"larr": "←",
	"Larr": "↞",
	"lArr": "⇐",
	"larrfs": "⤝",
	"larrhk": "↩",
	"larrlp": "↫",
	"larrpl": "⤹",
	"larrsim": "⥳",
	"larrtl": "↢",
	"latail": "⤙",
	"lAtail": "⤛",
	"lat": "⪫",
	"late": "⪭",
	"lates": "⪭︀",
	"lbarr": "⤌",
	"lBarr": "⤎",
	"lbbrk": "❲",
	"lbrace": "{",
	"lbrack": "[",
	"lbrke": "⦋",
	"lbrksld": "⦏",
	"lbrkslu": "⦍",
	"Lcaron": "Ľ",
	"lcaron": "ľ",
	"Lcedil": "Ļ",
	"lcedil": "ļ",
	"lceil": "⌈",
	"lcub": "{",
	"Lcy": "Л",
	"lcy": "л",
	"ldca": "⤶",
	"ldquo": "“",
	"ldquor": "„",
	"ldrdhar": "⥧",
	"ldrushar": "⥋",
	"ldsh": "↲",
	"le": "≤",
	"lE": "≦",
	"LeftAngleBracket": "⟨",
	"LeftArrowBar": "⇤",
	"leftarrow": "←",
	"LeftArrow": "←",
	"Leftarrow": "⇐",
	"LeftArrowRightArrow": "⇆",
	"leftarrowtail": "↢",
	"LeftCeiling": "⌈",
	"LeftDoubleBracket": "⟦",
	"LeftDownTeeVector": "⥡",
	"LeftDownVectorBar": "⥙",
	"LeftDownVector": "⇃",
	"LeftFloor": "⌊",
	"leftharpoondown": "↽",
	"leftharpoonup": "↼",
	"leftleftarrows": "⇇",
	"leftrightarrow": "↔",
	"LeftRightArrow": "↔",
	"Leftrightarrow": "⇔",
	"leftrightarrows": "⇆",
	"leftrightharpoons": "⇋",
	"leftrightsquigarrow": "↭",
	"LeftRightVector": "⥎",
	"LeftTeeArrow": "↤",
	"LeftTee": "⊣",
	"LeftTeeVector": "⥚",
	"leftthreetimes": "⋋",
	"LeftTriangleBar": "⧏",
	"LeftTriangle": "⊲",
	"LeftTriangleEqual": "⊴",
	"LeftUpDownVector": "⥑",
	"LeftUpTeeVector": "⥠",
	"LeftUpVectorBar": "⥘",
	"LeftUpVector": "↿",
	"LeftVectorBar": "⥒",
	"LeftVector": "↼",
	"lEg": "⪋",
	"leg": "⋚",
	"leq": "≤",
	"leqq": "≦",
	"leqslant": "⩽",
	"lescc": "⪨",
	"les": "⩽",
	"lesdot": "⩿",
	"lesdoto": "⪁",
	"lesdotor": "⪃",
	"lesg": "⋚︀",
	"lesges": "⪓",
	"lessapprox": "⪅",
	"lessdot": "⋖",
	"lesseqgtr": "⋚",
	"lesseqqgtr": "⪋",
	"LessEqualGreater": "⋚",
	"LessFullEqual": "≦",
	"LessGreater": "≶",
	"lessgtr": "≶",
	"LessLess": "⪡",
	"lesssim": "≲",
	"LessSlantEqual": "⩽",
	"LessTilde": "≲",
	"lfisht": "⥼",
	"lfloor": "⌊",
	"Lfr": "𝔏",
	"lfr": "𝔩",
	"lg": "≶",
	"lgE": "⪑",
	"lHar": "⥢",
	"lhard": "↽",
	"lharu": "↼",
	"lharul": "⥪",
	"lhblk": "▄",
	"LJcy": "Љ",
	"ljcy": "љ",
	"llarr": "⇇",
	"ll": "≪",
	"Ll": "⋘",
	"llcorner": "⌞",
	"Lleftarrow": "⇚",
	"llhard": "⥫",
	"lltri": "◺",
	"Lmidot": "Ŀ",
	"lmidot": "ŀ",
	"lmoustache": "⎰",
	"lmoust": "⎰",
	"lnap": "⪉",
	"lnapprox": "⪉",
	"lne": "⪇",
	"lnE": "≨",
	"lneq": "⪇",
	"lneqq": "≨",
	"lnsim": "⋦",
	"loang": "⟬",
	"loarr": "⇽",
	"lobrk": "⟦",
	"longleftarrow": "⟵",
	"LongLeftArrow": "⟵",
	"Longleftarrow": "⟸",
	"longleftrightarrow": "⟷",
	"LongLeftRightArrow": "⟷",
	"Longleftrightarrow": "⟺",
	"longmapsto": "⟼",
	"longrightarrow": "⟶",
	"LongRightArrow": "⟶",
	"Longrightarrow": "⟹",
	"looparrowleft": "↫",
	"looparrowright": "↬",
	"lopar": "⦅",
	"Lopf": "𝕃",
	"lopf": "𝕝",
	"loplus": "⨭",
	"lotimes": "⨴",
	"lowast": "∗",
	"lowbar": "_",
	"LowerLeftArrow": "↙",
	"LowerRightArrow": "↘",
	"loz": "◊",
	"lozenge": "◊",
	"lozf": "⧫",
	"lpar": "(",
	"lparlt": "⦓",
	"lrarr": "⇆",
	"lrcorner": "⌟",
	"lrhar": "⇋",
	"lrhard": "⥭",
	"lrm": "‎",
	"lrtri": "⊿",
	"lsaquo": "‹",
	"lscr": "𝓁",
	"Lscr": "ℒ",
	"lsh": "↰",
	"Lsh": "↰",
	"lsim": "≲",
	"lsime": "⪍",
	"lsimg": "⪏",
	"lsqb": "[",
	"lsquo": "‘",
	"lsquor": "‚",
	"Lstrok": "Ł",
	"lstrok": "ł",
	"ltcc": "⪦",
	"ltcir": "⩹",
	"lt": "<",
	"LT": "<",
	"Lt": "≪",
	"ltdot": "⋖",
	"lthree": "⋋",
	"ltimes": "⋉",
	"ltlarr": "⥶",
	"ltquest": "⩻",
	"ltri": "◃",
	"ltrie": "⊴",
	"ltrif": "◂",
	"ltrPar": "⦖",
	"lurdshar": "⥊",
	"luruhar": "⥦",
	"lvertneqq": "≨︀",
	"lvnE": "≨︀",
	"macr": "¯",
	"male": "♂",
	"malt": "✠",
	"maltese": "✠",
	"Map": "⤅",
	"map": "↦",
	"mapsto": "↦",
	"mapstodown": "↧",
	"mapstoleft": "↤",
	"mapstoup": "↥",
	"marker": "▮",
	"mcomma": "⨩",
	"Mcy": "М",
	"mcy": "м",
	"mdash": "—",
	"mDDot": "∺",
	"measuredangle": "∡",
	"MediumSpace": " ",
	"Mellintrf": "ℳ",
	"Mfr": "𝔐",
	"mfr": "𝔪",
	"mho": "℧",
	"micro": "µ",
	"midast": "*",
	"midcir": "⫰",
	"mid": "∣",
	"middot": "·",
	"minusb": "⊟",
	"minus": "−",
	"minusd": "∸",
	"minusdu": "⨪",
	"MinusPlus": "∓",
	"mlcp": "⫛",
	"mldr": "…",
	"mnplus": "∓",
	"models": "⊧",
	"Mopf": "𝕄",
	"mopf": "𝕞",
	"mp": "∓",
	"mscr": "𝓂",
	"Mscr": "ℳ",
	"mstpos": "∾",
	"Mu": "Μ",
	"mu": "μ",
	"multimap": "⊸",
	"mumap": "⊸",
	"nabla": "∇",
	"Nacute": "Ń",
	"nacute": "ń",
	"nang": "∠⃒",
	"nap": "≉",
	"napE": "⩰̸",
	"napid": "≋̸",
	"napos": "ŉ",
	"napprox": "≉",
	"natural": "♮",
	"naturals": "ℕ",
	"natur": "♮",
	"nbsp": " ",
	"nbump": "≎̸",
	"nbumpe": "≏̸",
	"ncap": "⩃",
	"Ncaron": "Ň",
	"ncaron": "ň",
	"Ncedil": "Ņ",
	"ncedil": "ņ",
	"ncong": "≇",
	"ncongdot": "⩭̸",
	"ncup": "⩂",
	"Ncy": "Н",
	"ncy": "н",
	"ndash": "–",
	"nearhk": "⤤",
	"nearr": "↗",
	"neArr": "⇗",
	"nearrow": "↗",
	"ne": "≠",
	"nedot": "≐̸",
	"NegativeMediumSpace": "​",
	"NegativeThickSpace": "​",
	"NegativeThinSpace": "​",
	"NegativeVeryThinSpace": "​",
	"nequiv": "≢",
	"nesear": "⤨",
	"nesim": "≂̸",
	"NestedGreaterGreater": "≫",
	"NestedLessLess": "≪",
	"NewLine": "\n",
	"nexist": "∄",
	"nexists": "∄",
	"Nfr": "𝔑",
	"nfr": "𝔫",
	"ngE": "≧̸",
	"nge": "≱",
	"ngeq": "≱",
	"ngeqq": "≧̸",
	"ngeqslant": "⩾̸",
	"nges": "⩾̸",
	"nGg": "⋙̸",
	"ngsim": "≵",
	"nGt": "≫⃒",
	"ngt": "≯",
	"ngtr": "≯",
	"nGtv": "≫̸",
	"nharr": "↮",
	"nhArr": "⇎",
	"nhpar": "⫲",
	"ni": "∋",
	"nis": "⋼",
	"nisd": "⋺",
	"niv": "∋",
	"NJcy": "Њ",
	"njcy": "њ",
	"nlarr": "↚",
	"nlArr": "⇍",
	"nldr": "‥",
	"nlE": "≦̸",
	"nle": "≰",
	"nleftarrow": "↚",
	"nLeftarrow": "⇍",
	"nleftrightarrow": "↮",
	"nLeftrightarrow": "⇎",
	"nleq": "≰",
	"nleqq": "≦̸",
	"nleqslant": "⩽̸",
	"nles": "⩽̸",
	"nless": "≮",
	"nLl": "⋘̸",
	"nlsim": "≴",
	"nLt": "≪⃒",
	"nlt": "≮",
	"nltri": "⋪",
	"nltrie": "⋬",
	"nLtv": "≪̸",
	"nmid": "∤",
	"NoBreak": "⁠",
	"NonBreakingSpace": " ",
	"nopf": "𝕟",
	"Nopf": "ℕ",
	"Not": "⫬",
	"not": "¬",
	"NotCongruent": "≢",
	"NotCupCap": "≭",
	"NotDoubleVerticalBar": "∦",
	"NotElement": "∉",
	"NotEqual": "≠",
	"NotEqualTilde": "≂̸",
	"NotExists": "∄",
	"NotGreater": "≯",
	"NotGreaterEqual": "≱",
	"NotGreaterFullEqual": "≧̸",
	"NotGreaterGreater": "≫̸",
	"NotGreaterLess": "≹",
	"NotGreaterSlantEqual": "⩾̸",
	"NotGreaterTilde": "≵",
	"NotHumpDownHump": "≎̸",
	"NotHumpEqual": "≏̸",
	"notin": "∉",
	"notindot": "⋵̸",
	"notinE": "⋹̸",
	"notinva": "∉",
	"notinvb": "⋷",
	"notinvc": "⋶",
	"NotLeftTriangleBar": "⧏̸",
	"NotLeftTriangle": "⋪",
	"NotLeftTriangleEqual": "⋬",
	"NotLess": "≮",
	"NotLessEqual": "≰",
	"NotLessGreater": "≸",
	"NotLessLess": "≪̸",
	"NotLessSlantEqual": "⩽̸",
	"NotLessTilde": "≴",
	"NotNestedGreaterGreater": "⪢̸",
	"NotNestedLessLess": "⪡̸",
	"notni": "∌",
	"notniva": "∌",
	"notnivb": "⋾",
	"notnivc": "⋽",
	"NotPrecedes": "⊀",
	"NotPrecedesEqual": "⪯̸",
	"NotPrecedesSlantEqual": "⋠",
	"NotReverseElement": "∌",
	"NotRightTriangleBar": "⧐̸",
	"NotRightTriangle": "⋫",
	"NotRightTriangleEqual": "⋭",
	"NotSquareSubset": "⊏̸",
	"NotSquareSubsetEqual": "⋢",
	"NotSquareSuperset": "⊐̸",
	"NotSquareSupersetEqual": "⋣",
	"NotSubset": "⊂⃒",
	"NotSubsetEqual": "⊈",
	"NotSucceeds": "⊁",
	"NotSucceedsEqual": "⪰̸",
	"NotSucceedsSlantEqual": "⋡",
	"NotSucceedsTilde": "≿̸",
	"NotSuperset": "⊃⃒",
	"NotSupersetEqual": "⊉",
	"NotTilde": "≁",
	"NotTildeEqual": "≄",
	"NotTildeFullEqual": "≇",
	"NotTildeTilde": "≉",
	"NotVerticalBar": "∤",
	"nparallel": "∦",
	"npar": "∦",
	"nparsl": "⫽⃥",
	"npart": "∂̸",
	"npolint": "⨔",
	"npr": "⊀",
	"nprcue": "⋠",
	"nprec": "⊀",
	"npreceq": "⪯̸",
	"npre": "⪯̸",
	"nrarrc": "⤳̸",
	"nrarr": "↛",
	"nrArr": "⇏",
	"nrarrw": "↝̸",
	"nrightarrow": "↛",
	"nRightarrow": "⇏",
	"nrtri": "⋫",
	"nrtrie": "⋭",
	"nsc": "⊁",
	"nsccue": "⋡",
	"nsce": "⪰̸",
	"Nscr": "𝒩",
	"nscr": "𝓃",
	"nshortmid": "∤",
	"nshortparallel": "∦",
	"nsim": "≁",
	"nsime": "≄",
	"nsimeq": "≄",
	"nsmid": "∤",
	"nspar": "∦",
	"nsqsube": "⋢",
	"nsqsupe": "⋣",
	"nsub": "⊄",
	"nsubE": "⫅̸",
	"nsube": "⊈",
	"nsubset": "⊂⃒",
	"nsubseteq": "⊈",
	"nsubseteqq": "⫅̸",
	"nsucc": "⊁",
	"nsucceq": "⪰̸",
	"nsup": "⊅",
	"nsupE": "⫆̸",
	"nsupe": "⊉",
	"nsupset": "⊃⃒",
	"nsupseteq": "⊉",
	"nsupseteqq": "⫆̸",
	"ntgl": "≹",
	"Ntilde": "Ñ",
	"ntilde": "ñ",
	"ntlg": "≸",
	"ntriangleleft": "⋪",
	"ntrianglelefteq": "⋬",
	"ntriangleright": "⋫",
	"ntrianglerighteq": "⋭",
	"Nu": "Ν",
	"nu": "ν",
	"num": "#",
	"numero": "№",
	"numsp": " ",
	"nvap": "≍⃒",
	"nvdash": "⊬",
	"nvDash": "⊭",
	"nVdash": "⊮",
	"nVDash": "⊯",
	"nvge": "≥⃒",
	"nvgt": ">⃒",
	"nvHarr": "⤄",
	"nvinfin": "⧞",
	"nvlArr": "⤂",
	"nvle": "≤⃒",
	"nvlt": "<⃒",
	"nvltrie": "⊴⃒",
	"nvrArr": "⤃",
	"nvrtrie": "⊵⃒",
	"nvsim": "∼⃒",
	"nwarhk": "⤣",
	"nwarr": "↖",
	"nwArr": "⇖",
	"nwarrow": "↖",
	"nwnear": "⤧",
	"Oacute": "Ó",
	"oacute": "ó",
	"oast": "⊛",
	"Ocirc": "Ô",
	"ocirc": "ô",
	"ocir": "⊚",
	"Ocy": "О",
	"ocy": "о",
	"odash": "⊝",
	"Odblac": "Ő",
	"odblac": "ő",
	"odiv": "⨸",
	"odot": "⊙",
	"odsold": "⦼",
	"OElig": "Œ",
	"oelig": "œ",
	"ofcir": "⦿",
	"Ofr": "𝔒",
	"ofr": "𝔬",
	"ogon": "˛",
	"Ograve": "Ò",
	"ograve": "ò",
	"ogt": "⧁",
	"ohbar": "⦵",
	"ohm": "Ω",
	"oint": "∮",
	"olarr": "↺",
	"olcir": "⦾",
	"olcross": "⦻",
	"oline": "‾",
	"olt": "⧀",
	"Omacr": "Ō",
	"omacr": "ō",
	"Omega": "Ω",
	"omega": "ω",
	"Omicron": "Ο",
	"omicron": "ο",
	"omid": "⦶",
	"ominus": "⊖",
	"Oopf": "𝕆",
	"oopf": "𝕠",
	"opar": "⦷",
	"OpenCurlyDoubleQuote": "“",
	"OpenCurlyQuote": "‘",
	"operp": "⦹",
	"oplus": "⊕",
	"orarr": "↻",
	"Or": "⩔",
	"or": "∨",
	"ord": "⩝",
	"order": "ℴ",
	"orderof": "ℴ",
	"ordf": "ª",
	"ordm": "º",
	"origof": "⊶",
	"oror": "⩖",
	"orslope": "⩗",
	"orv": "⩛",
	"oS": "Ⓢ",
	"Oscr": "𝒪",
	"oscr": "ℴ",
	"Oslash": "Ø",
	"oslash": "ø",
	"osol": "⊘",
	"Otilde": "Õ",
	"otilde": "õ",
	"otimesas": "⨶",
	"Otimes": "⨷",
	"otimes": "⊗",
	"Ouml": "Ö",
	"ouml": "ö",
	"ovbar": "⌽",
	"OverBar": "‾",
	"OverBrace": "⏞",
	"OverBracket": "⎴",
	"OverParenthesis": "⏜",
	"para": "¶",
	"parallel": "∥",
	"par": "∥",
	"parsim": "⫳",
	"parsl": "⫽",
	"part": "∂",
	"PartialD": "∂",
	"Pcy": "П",
	"pcy": "п",
	"percnt": "%",
	"period": ".",
	"permil": "‰",
	"perp": "⊥",
	"pertenk": "‱",
	"Pfr": "𝔓",
	"pfr": "𝔭",
	"Phi": "Φ",
	"phi": "φ",
	"phiv": "ϕ",
	"phmmat": "ℳ",
	"phone": "☎",
	"Pi": "Π",
	"pi": "π",
	"pitchfork": "⋔",
	"piv": "ϖ",
	"planck": "ℏ",
	"planckh": "ℎ",
	"plankv": "ℏ",
	"plusacir": "⨣",
	"plusb": "⊞",
	"pluscir": "⨢",
	"plus": "+",
	"plusdo": "∔",
	"plusdu": "⨥",
	"pluse": "⩲",
	"PlusMinus": "±",
	"plusmn": "±",
	"plussim": "⨦",
	"plustwo": "⨧",
	"pm": "±",
	"Poincareplane": "ℌ",
	"pointint": "⨕",
	"popf": "𝕡",
	"Popf": "ℙ",
	"pound": "£",
	"prap": "⪷",
	"Pr": "⪻",
	"pr": "≺",
	"prcue": "≼",
	"precapprox": "⪷",
	"prec": "≺",
	"preccurlyeq": "≼",
	"Precedes": "≺",
	"PrecedesEqual": "⪯",
	"PrecedesSlantEqual": "≼",
	"PrecedesTilde": "≾",
	"preceq": "⪯",
	"precnapprox": "⪹",
	"precneqq": "⪵",
	"precnsim": "⋨",
	"pre": "⪯",
	"prE": "⪳",
	"precsim": "≾",
	"prime": "′",
	"Prime": "″",
	"primes": "ℙ",
	"prnap": "⪹",
	"prnE": "⪵",
	"prnsim": "⋨",
	"prod": "∏",
	"Product": "∏",
	"profalar": "⌮",
	"profline": "⌒",
	"profsurf": "⌓",
	"prop": "∝",
	"Proportional": "∝",
	"Proportion": "∷",
	"propto": "∝",
	"prsim": "≾",
	"prurel": "⊰",
	"Pscr": "𝒫",
	"pscr": "𝓅",
	"Psi": "Ψ",
	"psi": "ψ",
	"puncsp": " ",
	"Qfr": "𝔔",
	"qfr": "𝔮",
	"qint": "⨌",
	"qopf": "𝕢",
	"Qopf": "ℚ",
	"qprime": "⁗",
	"Qscr": "𝒬",
	"qscr": "𝓆",
	"quaternions": "ℍ",
	"quatint": "⨖",
	"quest": "?",
	"questeq": "≟",
	"quot": "\"",
	"QUOT": "\"",
	"rAarr": "⇛",
	"race": "∽̱",
	"Racute": "Ŕ",
	"racute": "ŕ",
	"radic": "√",
	"raemptyv": "⦳",
	"rang": "⟩",
	"Rang": "⟫",
	"rangd": "⦒",
	"range": "⦥",
	"rangle": "⟩",
	"raquo": "»",
	"rarrap": "⥵",
	"rarrb": "⇥",
	"rarrbfs": "⤠",
	"rarrc": "⤳",
	"rarr": "→",
	"Rarr": "↠",
	"rArr": "⇒",
	"rarrfs": "⤞",
	"rarrhk": "↪",
	"rarrlp": "↬",
	"rarrpl": "⥅",
	"rarrsim": "⥴",
	"Rarrtl": "⤖",
	"rarrtl": "↣",
	"rarrw": "↝",
	"ratail": "⤚",
	"rAtail": "⤜",
	"ratio": "∶",
	"rationals": "ℚ",
	"rbarr": "⤍",
	"rBarr": "⤏",
	"RBarr": "⤐",
	"rbbrk": "❳",
	"rbrace": "}",
	"rbrack": "]",
	"rbrke": "⦌",
	"rbrksld": "⦎",
	"rbrkslu": "⦐",
	"Rcaron": "Ř",
	"rcaron": "ř",
	"Rcedil": "Ŗ",
	"rcedil": "ŗ",
	"rceil": "⌉",
	"rcub": "}",
	"Rcy": "Р",
	"rcy": "р",
	"rdca": "⤷",
	"rdldhar": "⥩",
	"rdquo": "”",
	"rdquor": "”",
	"rdsh": "↳",
	"real": "ℜ",
	"realine": "ℛ",
	"realpart": "ℜ",
	"reals": "ℝ",
	"Re": "ℜ",
	"rect": "▭",
	"reg": "®",
	"REG": "®",
	"ReverseElement": "∋",
	"ReverseEquilibrium": "⇋",
	"ReverseUpEquilibrium": "⥯",
	"rfisht": "⥽",
	"rfloor": "⌋",
	"rfr": "𝔯",
	"Rfr": "ℜ",
	"rHar": "⥤",
	"rhard": "⇁",
	"rharu": "⇀",
	"rharul": "⥬",
	"Rho": "Ρ",
	"rho": "ρ",
	"rhov": "ϱ",
	"RightAngleBracket": "⟩",
	"RightArrowBar": "⇥",
	"rightarrow": "→",
	"RightArrow": "→",
	"Rightarrow": "⇒",
	"RightArrowLeftArrow": "⇄",
	"rightarrowtail": "↣",
	"RightCeiling": "⌉",
	"RightDoubleBracket": "⟧",
	"RightDownTeeVector": "⥝",
	"RightDownVectorBar": "⥕",
	"RightDownVector": "⇂",
	"RightFloor": "⌋",
	"rightharpoondown": "⇁",
	"rightharpoonup": "⇀",
	"rightleftarrows": "⇄",
	"rightleftharpoons": "⇌",
	"rightrightarrows": "⇉",
	"rightsquigarrow": "↝",
	"RightTeeArrow": "↦",
	"RightTee": "⊢",
	"RightTeeVector": "⥛",
	"rightthreetimes": "⋌",
	"RightTriangleBar": "⧐",
	"RightTriangle": "⊳",
	"RightTriangleEqual": "⊵",
	"RightUpDownVector": "⥏",
	"RightUpTeeVector": "⥜",
	"RightUpVectorBar": "⥔",
	"RightUpVector": "↾",
	"RightVectorBar": "⥓",
	"RightVector": "⇀",
	"ring": "˚",
	"risingdotseq": "≓",
	"rlarr": "⇄",
	"rlhar": "⇌",
	"rlm": "‏",
	"rmoustache": "⎱",
	"rmoust": "⎱",
	"rnmid": "⫮",
	"roang": "⟭",
	"roarr": "⇾",
	"robrk": "⟧",
	"ropar": "⦆",
	"ropf": "𝕣",
	"Ropf": "ℝ",
	"roplus": "⨮",
	"rotimes": "⨵",
	"RoundImplies": "⥰",
	"rpar": ")",
	"rpargt": "⦔",
	"rppolint": "⨒",
	"rrarr": "⇉",
	"Rrightarrow": "⇛",
	"rsaquo": "›",
	"rscr": "𝓇",
	"Rscr": "ℛ",
	"rsh": "↱",
	"Rsh": "↱",
	"rsqb": "]",
	"rsquo": "’",
	"rsquor": "’",
	"rthree": "⋌",
	"rtimes": "⋊",
	"rtri": "▹",
	"rtrie": "⊵",
	"rtrif": "▸",
	"rtriltri": "⧎",
	"RuleDelayed": "⧴",
	"ruluhar": "⥨",
	"rx": "℞",
	"Sacute": "Ś",
	"sacute": "ś",
	"sbquo": "‚",
	"scap": "⪸",
	"Scaron": "Š",
	"scaron": "š",
	"Sc": "⪼",
	"sc": "≻",
	"sccue": "≽",
	"sce": "⪰",
	"scE": "⪴",
	"Scedil": "Ş",
	"scedil": "ş",
	"Scirc": "Ŝ",
	"scirc": "ŝ",
	"scnap": "⪺",
	"scnE": "⪶",
	"scnsim": "⋩",
	"scpolint": "⨓",
	"scsim": "≿",
	"Scy": "С",
	"scy": "с",
	"sdotb": "⊡",
	"sdot": "⋅",
	"sdote": "⩦",
	"searhk": "⤥",
	"searr": "↘",
	"seArr": "⇘",
	"searrow": "↘",
	"sect": "§",
	"semi": ";",
	"seswar": "⤩",
	"setminus": "∖",
	"setmn": "∖",
	"sext": "✶",
	"Sfr": "𝔖",
	"sfr": "𝔰",
	"sfrown": "⌢",
	"sharp": "♯",
	"SHCHcy": "Щ",
	"shchcy": "щ",
	"SHcy": "Ш",
	"shcy": "ш",
	"ShortDownArrow": "↓",
	"ShortLeftArrow": "←",
	"shortmid": "∣",
	"shortparallel": "∥",
	"ShortRightArrow": "→",
	"ShortUpArrow": "↑",
	"shy": "­",
	"Sigma": "Σ",
	"sigma": "σ",
	"sigmaf": "ς",
	"sigmav": "ς",
	"sim": "∼",
	"simdot": "⩪",
	"sime": "≃",
	"simeq": "≃",
	"simg": "⪞",
	"simgE": "⪠",
	"siml": "⪝",
	"simlE": "⪟",
	"simne": "≆",
	"simplus": "⨤",
	"simrarr": "⥲",
	"slarr": "←",
	"SmallCircle": "∘",
	"smallsetminus": "∖",
	"smashp": "⨳",
	"smeparsl": "⧤",
	"smid": "∣",
	"smile": "⌣",
	"smt": "⪪",
	"smte": "⪬",
	"smtes": "⪬︀",
	"SOFTcy": "Ь",
	"softcy": "ь",
	"solbar": "⌿",
	"solb": "⧄",
	"sol": "/",
	"Sopf": "𝕊",
	"sopf": "𝕤",
	"spades": "♠",
	"spadesuit": "♠",
	"spar": "∥",
	"sqcap": "⊓",
	"sqcaps": "⊓︀",
	"sqcup": "⊔",
	"sqcups": "⊔︀",
	"Sqrt": "√",
	"sqsub": "⊏",
	"sqsube": "⊑",
	"sqsubset": "⊏",
	"sqsubseteq": "⊑",
	"sqsup": "⊐",
	"sqsupe": "⊒",
	"sqsupset": "⊐",
	"sqsupseteq": "⊒",
	"square": "□",
	"Square": "□",
	"SquareIntersection": "⊓",
	"SquareSubset": "⊏",
	"SquareSubsetEqual": "⊑",
	"SquareSuperset": "⊐",
	"SquareSupersetEqual": "⊒",
	"SquareUnion": "⊔",
	"squarf": "▪",
	"squ": "□",
	"squf": "▪",
	"srarr": "→",
	"Sscr": "𝒮",
	"sscr": "𝓈",
	"ssetmn": "∖",
	"ssmile": "⌣",
	"sstarf": "⋆",
	"Star": "⋆",
	"star": "☆",
	"starf": "★",
	"straightepsilon": "ϵ",
	"straightphi": "ϕ",
	"strns": "¯",
	"sub": "⊂",
	"Sub": "⋐",
	"subdot": "⪽",
	"subE": "⫅",
	"sube": "⊆",
	"subedot": "⫃",
	"submult": "⫁",
	"subnE": "⫋",
	"subne": "⊊",
	"subplus": "⪿",
	"subrarr": "⥹",
	"subset": "⊂",
	"Subset": "⋐",
	"subseteq": "⊆",
	"subseteqq": "⫅",
	"SubsetEqual": "⊆",
	"subsetneq": "⊊",
	"subsetneqq": "⫋",
	"subsim": "⫇",
	"subsub": "⫕",
	"subsup": "⫓",
	"succapprox": "⪸",
	"succ": "≻",
	"succcurlyeq": "≽",
	"Succeeds": "≻",
	"SucceedsEqual": "⪰",
	"SucceedsSlantEqual": "≽",
	"SucceedsTilde": "≿",
	"succeq": "⪰",
	"succnapprox": "⪺",
	"succneqq": "⪶",
	"succnsim": "⋩",
	"succsim": "≿",
	"SuchThat": "∋",
	"sum": "∑",
	"Sum": "∑",
	"sung": "♪",
	"sup1": "¹",
	"sup2": "²",
	"sup3": "³",
	"sup": "⊃",
	"Sup": "⋑",
	"supdot": "⪾",
	"supdsub": "⫘",
	"supE": "⫆",
	"supe": "⊇",
	"supedot": "⫄",
	"Superset": "⊃",
	"SupersetEqual": "⊇",
	"suphsol": "⟉",
	"suphsub": "⫗",
	"suplarr": "⥻",
	"supmult": "⫂",
	"supnE": "⫌",
	"supne": "⊋",
	"supplus": "⫀",
	"supset": "⊃",
	"Supset": "⋑",
	"supseteq": "⊇",
	"supseteqq": "⫆",
	"supsetneq": "⊋",
	"supsetneqq": "⫌",
	"supsim": "⫈",
	"supsub": "⫔",
	"supsup": "⫖",
	"swarhk": "⤦",
	"swarr": "↙",
	"swArr": "⇙",
	"swarrow": "↙",
	"swnwar": "⤪",
	"szlig": "ß",
	"Tab": "\t",
	"target": "⌖",
	"Tau": "Τ",
	"tau": "τ",
	"tbrk": "⎴",
	"Tcaron": "Ť",
	"tcaron": "ť",
	"Tcedil": "Ţ",
	"tcedil": "ţ",
	"Tcy": "Т",
	"tcy": "т",
	"tdot": "⃛",
	"telrec": "⌕",
	"Tfr": "𝔗",
	"tfr": "𝔱",
	"there4": "∴",
	"therefore": "∴",
	"Therefore": "∴",
	"Theta": "Θ",
	"theta": "θ",
	"thetasym": "ϑ",
	"thetav": "ϑ",
	"thickapprox": "≈",
	"thicksim": "∼",
	"ThickSpace": "  ",
	"ThinSpace": " ",
	"thinsp": " ",
	"thkap": "≈",
	"thksim": "∼",
	"THORN": "Þ",
	"thorn": "þ",
	"tilde": "˜",
	"Tilde": "∼",
	"TildeEqual": "≃",
	"TildeFullEqual": "≅",
	"TildeTilde": "≈",
	"timesbar": "⨱",
	"timesb": "⊠",
	"times": "×",
	"timesd": "⨰",
	"tint": "∭",
	"toea": "⤨",
	"topbot": "⌶",
	"topcir": "⫱",
	"top": "⊤",
	"Topf": "𝕋",
	"topf": "𝕥",
	"topfork": "⫚",
	"tosa": "⤩",
	"tprime": "‴",
	"trade": "™",
	"TRADE": "™",
	"triangle": "▵",
	"triangledown": "▿",
	"triangleleft": "◃",
	"trianglelefteq": "⊴",
	"triangleq": "≜",
	"triangleright": "▹",
	"trianglerighteq": "⊵",
	"tridot": "◬",
	"trie": "≜",
	"triminus": "⨺",
	"TripleDot": "⃛",
	"triplus": "⨹",
	"trisb": "⧍",
	"tritime": "⨻",
	"trpezium": "⏢",
	"Tscr": "𝒯",
	"tscr": "𝓉",
	"TScy": "Ц",
	"tscy": "ц",
	"TSHcy": "Ћ",
	"tshcy": "ћ",
	"Tstrok": "Ŧ",
	"tstrok": "ŧ",
	"twixt": "≬",
	"twoheadleftarrow": "↞",
	"twoheadrightarrow": "↠",
	"Uacute": "Ú",
	"uacute": "ú",
	"uarr": "↑",
	"Uarr": "↟",
	"uArr": "⇑",
	"Uarrocir": "⥉",
	"Ubrcy": "Ў",
	"ubrcy": "ў",
	"Ubreve": "Ŭ",
	"ubreve": "ŭ",
	"Ucirc": "Û",
	"ucirc": "û",
	"Ucy": "У",
	"ucy": "у",
	"udarr": "⇅",
	"Udblac": "Ű",
	"udblac": "ű",
	"udhar": "⥮",
	"ufisht": "⥾",
	"Ufr": "𝔘",
	"ufr": "𝔲",
	"Ugrave": "Ù",
	"ugrave": "ù",
	"uHar": "⥣",
	"uharl": "↿",
	"uharr": "↾",
	"uhblk": "▀",
	"ulcorn": "⌜",
	"ulcorner": "⌜",
	"ulcrop": "⌏",
	"ultri": "◸",
	"Umacr": "Ū",
	"umacr": "ū",
	"uml": "¨",
	"UnderBar": "_",
	"UnderBrace": "⏟",
	"UnderBracket": "⎵",
	"UnderParenthesis": "⏝",
	"Union": "⋃",
	"UnionPlus": "⊎",
	"Uogon": "Ų",
	"uogon": "ų",
	"Uopf": "𝕌",
	"uopf": "𝕦",
	"UpArrowBar": "⤒",
	"uparrow": "↑",
	"UpArrow": "↑",
	"Uparrow": "⇑",
	"UpArrowDownArrow": "⇅",
	"updownarrow": "↕",
	"UpDownArrow": "↕",
	"Updownarrow": "⇕",
	"UpEquilibrium": "⥮",
	"upharpoonleft": "↿",
	"upharpoonright": "↾",
	"uplus": "⊎",
	"UpperLeftArrow": "↖",
	"UpperRightArrow": "↗",
	"upsi": "υ",
	"Upsi": "ϒ",
	"upsih": "ϒ",
	"Upsilon": "Υ",
	"upsilon": "υ",
	"UpTeeArrow": "↥",
	"UpTee": "⊥",
	"upuparrows": "⇈",
	"urcorn": "⌝",
	"urcorner": "⌝",
	"urcrop": "⌎",
	"Uring": "Ů",
	"uring": "ů",
	"urtri": "◹",
	"Uscr": "𝒰",
	"uscr": "𝓊",
	"utdot": "⋰",
	"Utilde": "Ũ",
	"utilde": "ũ",
	"utri": "▵",
	"utrif": "▴",
	"uuarr": "⇈",
	"Uuml": "Ü",
	"uuml": "ü",
	"uwangle": "⦧",
	"vangrt": "⦜",
	"varepsilon": "ϵ",
	"varkappa": "ϰ",
	"varnothing": "∅",
	"varphi": "ϕ",
	"varpi": "ϖ",
	"varpropto": "∝",
	"varr": "↕",
	"vArr": "⇕",
	"varrho": "ϱ",
	"varsigma": "ς",
	"varsubsetneq": "⊊︀",
	"varsubsetneqq": "⫋︀",
	"varsupsetneq": "⊋︀",
	"varsupsetneqq": "⫌︀",
	"vartheta": "ϑ",
	"vartriangleleft": "⊲",
	"vartriangleright": "⊳",
	"vBar": "⫨",
	"Vbar": "⫫",
	"vBarv": "⫩",
	"Vcy": "В",
	"vcy": "в",
	"vdash": "⊢",
	"vDash": "⊨",
	"Vdash": "⊩",
	"VDash": "⊫",
	"Vdashl": "⫦",
	"veebar": "⊻",
	"vee": "∨",
	"Vee": "⋁",
	"veeeq": "≚",
	"vellip": "⋮",
	"verbar": "|",
	"Verbar": "‖",
	"vert": "|",
	"Vert": "‖",
	"VerticalBar": "∣",
	"VerticalLine": "|",
	"VerticalSeparator": "❘",
	"VerticalTilde": "≀",
	"VeryThinSpace": " ",
	"Vfr": "𝔙",
	"vfr": "𝔳",
	"vltri": "⊲",
	"vnsub": "⊂⃒",
	"vnsup": "⊃⃒",
	"Vopf": "𝕍",
	"vopf": "𝕧",
	"vprop": "∝",
	"vrtri": "⊳",
	"Vscr": "𝒱",
	"vscr": "𝓋",
	"vsubnE": "⫋︀",
	"vsubne": "⊊︀",
	"vsupnE": "⫌︀",
	"vsupne": "⊋︀",
	"Vvdash": "⊪",
	"vzigzag": "⦚",
	"Wcirc": "Ŵ",
	"wcirc": "ŵ",
	"wedbar": "⩟",
	"wedge": "∧",
	"Wedge": "⋀",
	"wedgeq": "≙",
	"weierp": "℘",
	"Wfr": "𝔚",
	"wfr": "𝔴",
	"Wopf": "𝕎",
	"wopf": "𝕨",
	"wp": "℘",
	"wr": "≀",
	"wreath": "≀",
	"Wscr": "𝒲",
	"wscr": "𝓌",
	"xcap": "⋂",
	"xcirc": "◯",
	"xcup": "⋃",
	"xdtri": "▽",
	"Xfr": "𝔛",
	"xfr": "𝔵",
	"xharr": "⟷",
	"xhArr": "⟺",
	"Xi": "Ξ",
	"xi": "ξ",
	"xlarr": "⟵",
	"xlArr": "⟸",
	"xmap": "⟼",
	"xnis": "⋻",
	"xodot": "⨀",
	"Xopf": "𝕏",
	"xopf": "𝕩",
	"xoplus": "⨁",
	"xotime": "⨂",
	"xrarr": "⟶",
	"xrArr": "⟹",
	"Xscr": "𝒳",
	"xscr": "𝓍",
	"xsqcup": "⨆",
	"xuplus": "⨄",
	"xutri": "△",
	"xvee": "⋁",
	"xwedge": "⋀",
	"Yacute": "Ý",
	"yacute": "ý",
	"YAcy": "Я",
	"yacy": "я",
	"Ycirc": "Ŷ",
	"ycirc": "ŷ",
	"Ycy": "Ы",
	"ycy": "ы",
	"yen": "¥",
	"Yfr": "𝔜",
	"yfr": "𝔶",
	"YIcy": "Ї",
	"yicy": "ї",
	"Yopf": "𝕐",
	"yopf": "𝕪",
	"Yscr": "𝒴",
	"yscr": "𝓎",
	"YUcy": "Ю",
	"yucy": "ю",
	"yuml": "ÿ",
	"Yuml": "Ÿ",
	"Zacute": "Ź",
	"zacute": "ź",
	"Zcaron": "Ž",
	"zcaron": "ž",
	"Zcy": "З",
	"zcy": "з",
	"Zdot": "Ż",
	"zdot": "ż",
	"zeetrf": "ℨ",
	"ZeroWidthSpace": "​",
	"Zeta": "Ζ",
	"zeta": "ζ",
	"zfr": "𝔷",
	"Zfr": "ℨ",
	"ZHcy": "Ж",
	"zhcy": "ж",
	"zigrarr": "⇝",
	"zopf": "𝕫",
	"Zopf": "ℤ",
	"Zscr": "𝒵",
	"zscr": "𝓏",
	"zwj": "‍",
	"zwnj": "‌"
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(91);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(17)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js??ref--1-1!./styles.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(1);

var _mithril2 = _interopRequireDefault(_mithril);

var _cell = __webpack_require__(2);

var _cell2 = _interopRequireDefault(_cell);

var _styles = __webpack_require__(3);

var _styles2 = _interopRequireDefault(_styles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    vnode.state.model = vnode.attrs.model;
    vnode.state.onchange = function (v) {
      vnode.state.model.data.slug = v;
    };
  },
  view: function view(vnode) {
    var inner = (0, _mithril2.default)(
      'label',
      null,
      'URL',
      (0, _mithril2.default)('input', { type: 'text', className: _styles2.default.slug,
        onchange: _mithril2.default.withAttr('value', vnode.state.onchange),
        value: vnode.state.model.data.slug
      })
    );
    return (0, _mithril2.default)(_cell2.default, { span: 12, inner: inner });
  }
};

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzI4MzIyMjdiZmFhZWJjMGFjZjAiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9taXRocmlsL21pdGhyaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvY29tcG9uZW50cy9jZWxsLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvc3R5bGVzLmNzcz8xNGM5Iiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2VudHJ5LmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvZWRpdG9yLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvcHJldmlldy5qcyIsIndlYnBhY2s6Ly8vLi4vbGlicy9jb21wb25lbnRzL3NhdmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvY29tcG9uZW50cy90YWdzLmpzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvbW9kZWxzL2FydGljbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYnMvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9saW5raWZ5LWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2xpbmtpZnktaXQvbGliL3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2xhYmVsLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9odG1sX2lubGluZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZW5jb2RlLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8vaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zdHlsZXMuY3NzIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvc3R5bGVzLmNzcyIsIndlYnBhY2s6Ly8vL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzLmNzcz8yMjNhIiwid2VicGFjazovLy8uLi9saWJzL2NvbXBvbmVudHMvc2x1Zy5qcyJdLCJuYW1lcyI6WyJfY2xhc3MiLCJvYmoiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1N0cmluZyIsIl9oYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiaGFzIiwib2JqZWN0Iiwia2V5IiwiYXNzaWduIiwic291cmNlcyIsIkFycmF5Iiwic2xpY2UiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwic291cmNlIiwiVHlwZUVycm9yIiwia2V5cyIsImFycmF5UmVwbGFjZUF0Iiwic3JjIiwicG9zIiwibmV3RWxlbWVudHMiLCJjb25jYXQiLCJpc1ZhbGlkRW50aXR5Q29kZSIsImMiLCJmcm9tQ29kZVBvaW50Iiwic3Vycm9nYXRlMSIsInN1cnJvZ2F0ZTIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVTkVTQ0FQRV9NRF9SRSIsIkVOVElUWV9SRSIsIlVORVNDQVBFX0FMTF9SRSIsIlJlZ0V4cCIsIkRJR0lUQUxfRU5USVRZX1RFU1RfUkUiLCJlbnRpdGllcyIsInJlcXVpcmUiLCJyZXBsYWNlRW50aXR5UGF0dGVybiIsIm1hdGNoIiwibmFtZSIsImNvZGUiLCJjaGFyQ29kZUF0IiwidGVzdCIsInRvTG93ZXJDYXNlIiwicGFyc2VJbnQiLCJ1bmVzY2FwZU1kIiwic3RyIiwiaW5kZXhPZiIsInJlcGxhY2UiLCJ1bmVzY2FwZUFsbCIsImVzY2FwZWQiLCJlbnRpdHkiLCJIVE1MX0VTQ0FQRV9URVNUX1JFIiwiSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSIsIkhUTUxfUkVQTEFDRU1FTlRTIiwicmVwbGFjZVVuc2FmZUNoYXIiLCJjaCIsImVzY2FwZUh0bWwiLCJSRUdFWFBfRVNDQVBFX1JFIiwiZXNjYXBlUkUiLCJpc1NwYWNlIiwiaXNXaGl0ZVNwYWNlIiwiVU5JQ09ERV9QVU5DVF9SRSIsImlzUHVuY3RDaGFyIiwiaXNNZEFzY2lpUHVuY3QiLCJub3JtYWxpemVSZWZlcmVuY2UiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJleHBvcnRzIiwibGliIiwibWR1cmwiLCJ1Y21pY3JvIiwiVm5vZGUiLCJ0YWciLCJhdHRyczAiLCJjaGlsZHJlbiIsInRleHQiLCJkb20iLCJhdHRycyIsImRvbVNpemUiLCJ1bmRlZmluZWQiLCJzdGF0ZSIsIl9zdGF0ZSIsImV2ZW50cyIsImluc3RhbmNlIiwic2tpcCIsIm5vcm1hbGl6ZSIsIm5vZGUiLCJpc0FycmF5Iiwibm9ybWFsaXplQ2hpbGRyZW4iLCJpIiwibGVuZ3RoIiwic2VsZWN0b3JQYXJzZXIiLCJzZWxlY3RvckNhY2hlIiwiaGFzT3duIiwiY29tcGlsZVNlbGVjdG9yIiwic2VsZWN0b3IiLCJjbGFzc2VzIiwiZXhlYyIsInR5cGUiLCJ2YWx1ZSIsImlkIiwicHVzaCIsImF0dHJWYWx1ZSIsImNsYXNzTmFtZSIsImpvaW4iLCJleGVjU2VsZWN0b3IiLCJoYXNBdHRycyIsImNoaWxkTGlzdCIsImNsYXNzIiwiaHlwZXJzY3JpcHQiLCJzdGFydCIsInZpZXciLCJFcnJvciIsImNhY2hlZCIsIm5vcm1hbGl6ZWQiLCJ0cnVzdCIsImh0bWwiLCJmcmFnbWVudCIsImF0dHJzMSIsIm0iLCJQcm9taXNlUG9seWZpbGwiLCJleGVjdXRvciIsInNlbGYiLCJyZXNvbHZlcnMiLCJyZWplY3RvcnMiLCJyZXNvbHZlQ3VycmVudCIsImhhbmRsZXIiLCJyZWplY3RDdXJyZW50IiwiX2luc3RhbmNlIiwiY2FsbEFzeW5jIiwic2V0SW1tZWRpYXRlIiwic2V0VGltZW91dCIsImxpc3QiLCJzaG91bGRBYnNvcmIiLCJleGVjdXRlIiwidGhlbiIsImV4ZWN1dGVPbmNlIiwiYmluZCIsImNvbnNvbGUiLCJlcnJvciIsInJldHJ5IiwiZSIsInJ1bnMiLCJydW4iLCJmbiIsIm9uZXJyb3IiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0aW9uIiwiaGFuZGxlIiwiY2FsbGJhY2siLCJuZXh0IiwicmVzb2x2ZU5leHQiLCJyZWplY3ROZXh0IiwicHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYXRjaCIsImFsbCIsInRvdGFsIiwiY291bnQiLCJ2YWx1ZXMiLCJjb25zdW1lIiwicmFjZSIsIndpbmRvdyIsIlByb21pc2UiLCJnbG9iYWwiLCJidWlsZFF1ZXJ5U3RyaW5nIiwiYXJncyIsImtleTAiLCJkZXN0cnVjdHVyZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkZJTEVfUFJPVE9DT0xfUkVHRVgiLCJfOCIsIiR3aW5kb3ciLCJjYWxsYmFja0NvdW50Iiwib25jb21wbGV0aW9uIiwic2V0Q29tcGxldGlvbkNhbGxiYWNrIiwiZmluYWxpemVyIiwiY29tcGxldGUiLCJmaW5hbGl6ZSIsInByb21pc2UwIiwidGhlbjAiLCJhcHBseSIsImV4dHJhIiwidXJsIiwicmVxdWVzdCIsIm1ldGhvZCIsInVzZUJvZHkiLCJzZXJpYWxpemUiLCJGb3JtRGF0YSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzZXJpYWxpemUiLCJleHRyYWN0IiwiaW50ZXJwb2xhdGUiLCJhc3NlbWJsZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiYWJvcnRlZCIsIl9hYm9ydCIsImFib3J0Iiwib3BlbiIsImFzeW5jIiwidXNlciIsInBhc3N3b3JkIiwic2V0UmVxdWVzdEhlYWRlciIsIndpdGhDcmVkZW50aWFscyIsImhlYWRlcnMiLCJjb25maWciLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJjYXN0IiwicmVzcG9uc2VUZXh0Iiwic2VuZCIsImJhY2tncm91bmQiLCJqc29ucCIsImNhbGxiYWNrTmFtZSIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsInNjcmlwdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNhbGxiYWNrS2V5IiwiZG9jdW1lbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJ0b2tlbnMiLCJxdWVyeXN0cmluZyIsInByZWZpeCIsInBhcnNlIiwidHlwZTAiLCJyZXF1ZXN0U2VydmljZSIsImNvcmVSZW5kZXJlciIsIiRkb2MiLCIkZW1wdHlGcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJvbmV2ZW50Iiwic2V0RXZlbnRDYWxsYmFjayIsImNyZWF0ZU5vZGVzIiwicGFyZW50Iiwidm5vZGVzIiwiZW5kIiwiaG9va3MiLCJuZXh0U2libGluZyIsIm5zIiwidm5vZGUiLCJjcmVhdGVOb2RlIiwiaW5pdExpZmVjeWNsZSIsImNyZWF0ZVRleHQiLCJjcmVhdGVIVE1MIiwiY3JlYXRlRnJhZ21lbnQiLCJjcmVhdGVDb21wb25lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImluc2VydE5vZGUiLCJtYXRjaDEiLCJwYXJlbnQxIiwiY2FwdGlvbiIsInRoZWFkIiwidGJvZHkiLCJ0Zm9vdCIsInRyIiwidGgiLCJ0ZCIsImNvbGdyb3VwIiwiY29sIiwidGVtcCIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwiY2hpbGQiLCJhdHRyczIiLCJpcyIsImVsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJzZXRBdHRycyIsImNvbnRlbnRlZGl0YWJsZSIsInNldENvbnRlbnRFZGl0YWJsZSIsInRleHRDb250ZW50Iiwic2V0TGF0ZUF0dHJzIiwiaW5pdENvbXBvbmVudCIsInNlbnRpbmVsIiwiY3JlYXRlIiwiJCRyZWVudHJhbnRMb2NrJCQiLCJ1cGRhdGVOb2RlcyIsIm9sZCIsInJlY3ljbGluZyIsInJlbW92ZU5vZGVzIiwiaXNVbmtleWVkIiwiZ2V0TmV4dFNpYmxpbmciLCJ1cGRhdGVOb2RlIiwiaXNSZWN5Y2xhYmxlIiwicG9vbCIsIm9sZFN0YXJ0Iiwib2xkRW5kIiwibWFwIiwibyIsInYiLCJzaG91bGRSZWN5Y2xlIiwidG9GcmFnbWVudCIsImdldEtleU1hcCIsIm9sZEluZGV4IiwibW92YWJsZSIsIm9sZFRhZyIsInNob3VsZE5vdFVwZGF0ZSIsInVwZGF0ZUxpZmVjeWNsZSIsInVwZGF0ZVRleHQiLCJ1cGRhdGVIVE1MIiwidXBkYXRlRnJhZ21lbnQiLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlQ29tcG9uZW50IiwicmVtb3ZlTm9kZSIsIm5vZGVWYWx1ZSIsInVwZGF0ZUF0dHJzIiwiYWJzIiwib2xkQ2hpbGRyZW5MZW5ndGgiLCJwb29sQ2hpbGRyZW5MZW5ndGgiLCJ2bm9kZXNDaGlsZHJlbkxlbmd0aCIsImtleTIiLCJjb3VudDAiLCJpbnNlcnRCZWZvcmUiLCJjb250ZW50IiwiY29udGV4dCIsImV4cGVjdGVkIiwiY2FsbGVkIiwib25iZWZvcmVyZW1vdmUiLCJyZXN1bHQiLCJjb250aW51YXRpb24iLCJvbnJlbW92ZSIsInJlbW92ZU5vZGVGcm9tRE9NIiwiaGFzSW50ZWdyYXRpb25NZXRob2RzIiwic2V0QXR0ciIsImlzRm9ybUF0dHJpYnV0ZSIsImlzTGlmZWN5Y2xlTWV0aG9kIiwibnNMYXN0SW5kZXgiLCJzdWJzdHIiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUV2ZW50IiwidXBkYXRlU3R5bGUiLCJpc0F0dHJpYnV0ZSIsImlzQ3VzdG9tRWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZWxlY3RlZEluZGV4IiwiYXR0ciIsIm9uY3JlYXRlIiwib251cGRhdGUiLCJzdHlsZSIsImNzc1RleHQiLCJldmVudE5hbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uaW5pdCIsImZvcmNlVm5vZGVVcGRhdGUiLCJmb3JjZUNvbXBvbmVudFVwZGF0ZSIsIm9uYmVmb3JldXBkYXRlIiwicmVuZGVyIiwiYWN0aXZlIiwiZm9jdXMiLCJ0aHJvdHRsZSIsInRpbWUiLCJsYXN0IiwicGVuZGluZyIsInRpbWVvdXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJub3ciLCJEYXRlIiwiXzExIiwicmVuZGVyU2VydmljZSIsInJlZHJhdyIsImNhbGxiYWNrcyIsInN1YnNjcmliZSIsImtleTEiLCJ1bnN1YnNjcmliZSIsImluZGV4Iiwic3BsaWNlIiwicmVkcmF3U2VydmljZSIsIl8xNiIsInJlZHJhd1NlcnZpY2UwIiwicm9vdCIsImNvbXBvbmVudCIsInJ1bjAiLCJtb3VudCIsInBhcnNlUXVlcnlTdHJpbmciLCJzdHJpbmciLCJjaGFyQXQiLCJlbnRyaWVzIiwic3BsaXQiLCJkYXRhMCIsImNvdW50ZXJzIiwiZW50cnkiLCJrZXk1IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwibGV2ZWxzIiwiY3Vyc29yIiwicG9wIiwiaiIsImxldmVsIiwibmV4dExldmVsIiwiaXNOdW1iZXIiLCJpc05hTiIsImlzVmFsdWUiLCJjb3JlUm91dGVyIiwic3VwcG9ydHNQdXNoU3RhdGUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiY2FsbEFzeW5jMCIsIm5vcm1hbGl6ZTEiLCJmcmFnbWVudDAiLCJsb2NhdGlvbiIsImFzeW5jSWQiLCJkZWJvdW5jZUFzeW5jIiwiY2FsbGJhY2swIiwicGFyc2VQYXRoIiwicGF0aCIsInF1ZXJ5RGF0YSIsImhhc2hEYXRhIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsInBhdGhFbmQiLCJxdWVyeUVuZCIsInF1ZXJ5UGFyYW1zIiwia2V5NCIsImhhc2hQYXJhbXMiLCJyb3V0ZXIiLCJnZXRQYXRoIiwidHlwZTIiLCJzZXRQYXRoIiwib3B0aW9ucyIsIm1hdGNoMiIsInRva2VuIiwicXVlcnkiLCJoYXNoIiwidGl0bGUiLCJvbnBvcHN0YXRlIiwicmVwbGFjZVN0YXRlIiwiaHJlZiIsImRlZmluZVJvdXRlcyIsInJvdXRlcyIsInJlc29sdmVSb3V0ZSIsInBhcmFtcyIsInBhdGhuYW1lIiwiayIsInJvdXRlMCIsIm1hdGNoZXIiLCJvbmhhc2hjaGFuZ2UiLCJfMjAiLCJyb3V0ZVNlcnZpY2UiLCJpZGVudGl0eSIsInJlbmRlcjEiLCJhdHRyczMiLCJjdXJyZW50UGF0aCIsImxhc3RVcGRhdGUiLCJyb3V0ZSIsImRlZmF1bHRSb3V0ZSIsInJ1bjEiLCJiYWlsIiwicGF5bG9hZCIsInVwZGF0ZSIsInJvdXRlUmVzb2x2ZXIiLCJjb21wIiwib25tYXRjaCIsInJlc29sdmVkIiwic2V0IiwiZ2V0IiwicHJlZml4MCIsImxpbmsiLCJ2bm9kZTEiLCJvbmNsaWNrIiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsIndoaWNoIiwicHJldmVudERlZmF1bHQiLCJnZXRBdHRyaWJ1dGUiLCJwYXJhbSIsImtleTMiLCJ3aXRoQXR0ciIsImF0dHJOYW1lIiwiY2FsbGJhY2sxIiwiY3VycmVudFRhcmdldCIsIl8yOCIsInZlcnNpb24iLCJtb2R1bGUiLCJzcGFuIiwiY2xzIiwiaW5uZXIiLCJnIiwiRnVuY3Rpb24iLCJldmFsIiwiUnVsZXIiLCJfX3J1bGVzX18iLCJfX2NhY2hlX18iLCJfX2ZpbmRfXyIsIl9fY29tcGlsZV9fIiwiY2hhaW5zIiwicnVsZSIsImVuYWJsZWQiLCJhbHQiLCJhbHROYW1lIiwiY2hhaW4iLCJhdCIsIm9wdCIsImJlZm9yZSIsImJlZm9yZU5hbWUiLCJydWxlTmFtZSIsImFmdGVyIiwiYWZ0ZXJOYW1lIiwiZW5hYmxlIiwiaWdub3JlSW52YWxpZCIsImlkeCIsImVuYWJsZU9ubHkiLCJkaXNhYmxlIiwiZ2V0UnVsZXMiLCJjaGFpbk5hbWUiLCJUb2tlbiIsIm5lc3RpbmciLCJtYXJrdXAiLCJpbmZvIiwibWV0YSIsImJsb2NrIiwiaGlkZGVuIiwiYXR0ckluZGV4IiwibGVuIiwiYXR0clB1c2giLCJhdHRyRGF0YSIsImF0dHJTZXQiLCJhdHRyR2V0IiwiYXR0ckpvaW4iLCJ1c2VTb3VyY2VNYXAiLCJpdGVtIiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImNzc01hcHBpbmciLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJCdWZmZXIiLCJhdHRyX25hbWUiLCJ1bnF1b3RlZCIsInNpbmdsZV9xdW90ZWQiLCJkb3VibGVfcXVvdGVkIiwiYXR0cl92YWx1ZSIsImF0dHJpYnV0ZSIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwiY29tbWVudCIsInByb2Nlc3NpbmciLCJkZWNsYXJhdGlvbiIsImNkYXRhIiwiSFRNTF9UQUdfUkUiLCJIVE1MX09QRU5fQ0xPU0VfVEFHX1JFIiwidG9rZW5pemUiLCJlbXBoYXNpcyIsInNpbGVudCIsInNjYW5uZWQiLCJtYXJrZXIiLCJzY2FuRGVsaW1zIiwiZGVsaW1pdGVycyIsImp1bXAiLCJjYW5fb3BlbiIsImNsb3NlIiwiY2FuX2Nsb3NlIiwicG9zdFByb2Nlc3MiLCJzdGFydERlbGltIiwiZW5kRGVsaW0iLCJpc1N0cm9uZyIsIm1heCIsInN0cmlrZXRocm91Z2giLCJsb25lTWFya2VycyIsImVuY29kZSIsImRlY29kZSIsImZvcm1hdCIsIm1vZGVsIiwiZmV0Y2giLCJmZXRjaGVkIiwiZWRpdG9yV3JhcCIsIm1kQm9keSIsImdldEVsZW1lbnRCeUlkIiwib25pbnB1dCIsImJvZHkiLCJ0ZXh0YXJlYSIsImVkaXRvciIsImVkaXRvckxlZnRTaWRlIiwiZWRpdG9yUmlnaHRTaWRlIiwic2F2ZUJ1dHRvbiIsIm9uY2hhbmdlIiwidGFncyIsIm1kIiwiTW9kZWwiLCJzbHVnIiwicHVibGlzaCIsImRhdGUiLCJyZXNvdXJjZXNVcmwiLCJyZXNvdXJjZVVybCIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJVaW50OEFycmF5IiwicGxhY2VIb2xkZXJzQ291bnQiLCJiNjQiLCJsIiwidG1wIiwicGxhY2VIb2xkZXJzIiwiYXJyIiwiTCIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJvdXRwdXQiLCJleHRyYUJ5dGVzIiwicGFydHMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsIl9fcHJvdG9fXyIsImZvbyIsInN1YmFycmF5IiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsIlJhbmdlRXJyb3IiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJmcm9tIiwicG9vbFNpemUiLCJfYXVnbWVudCIsIkFycmF5QnVmZmVyIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJTeW1ib2wiLCJzcGVjaWVzIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJhc3NlcnRTaXplIiwic2l6ZSIsImFsbG9jIiwiZmlsbCIsImVuY29kaW5nIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJ3cml0ZSIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImJ5dGVPZmZzZXQiLCJpc0J1ZmZlciIsImNvcHkiLCJidWZmZXIiLCJpc25hbiIsImIiLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwiYSIsIngiLCJ5IiwibWluIiwiYnVmIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsIm4iLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJlcXVhbHMiLCJpbnNwZWN0IiwidGFyZ2V0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwidmFsIiwiZGlyIiwiYXJyYXlJbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIm9mZnNldCIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsInJldCIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4IiwiZmxvb3IiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJkc3QiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsImQiLCJzIiwiTmFOIiwicnQiLCJsb2ciLCJMTjIiLCJpc09iamVjdCIsImlzUmVnRXhwIiwiaXNGdW5jdGlvbiIsImRlZmF1bHRPcHRpb25zIiwiZnV6enlMaW5rIiwiZnV6enlFbWFpbCIsImZ1enp5SVAiLCJpc09wdGlvbnNPYmoiLCJyZWR1Y2UiLCJhY2MiLCJkZWZhdWx0U2NoZW1hcyIsInZhbGlkYXRlIiwidGFpbCIsInJlIiwiaHR0cCIsInNyY19hdXRoIiwic3JjX2hvc3RfcG9ydF9zdHJpY3QiLCJzcmNfcGF0aCIsIm5vX2h0dHAiLCJzcmNfZG9tYWluIiwic3JjX2RvbWFpbl9yb290Iiwic3JjX3BvcnQiLCJzcmNfaG9zdF90ZXJtaW5hdG9yIiwibWFpbHRvIiwic3JjX2VtYWlsX25hbWUiLCJzcmNfaG9zdF9zdHJpY3QiLCJ0bGRzXzJjaF9zcmNfcmUiLCJ0bGRzX2RlZmF1bHQiLCJyZXNldFNjYW5DYWNoZSIsIl9faW5kZXhfXyIsIl9fdGV4dF9jYWNoZV9fIiwiY3JlYXRlVmFsaWRhdG9yIiwiY3JlYXRlTm9ybWFsaXplciIsImNvbXBpbGUiLCJfX29wdHNfXyIsInRsZHMiLCJfX3RsZHNfXyIsIm9uQ29tcGlsZSIsIl9fdGxkc19yZXBsYWNlZF9fIiwic3JjX3huIiwic3JjX3RsZHMiLCJ1bnRwbCIsInRwbCIsImVtYWlsX2Z1enp5IiwidHBsX2VtYWlsX2Z1enp5IiwibGlua19mdXp6eSIsInRwbF9saW5rX2Z1enp5IiwibGlua19ub19pcF9mdXp6eSIsInRwbF9saW5rX25vX2lwX2Z1enp5IiwiaG9zdF9mdXp6eV90ZXN0IiwidHBsX2hvc3RfZnV6enlfdGVzdCIsImFsaWFzZXMiLCJfX2NvbXBpbGVkX18iLCJzY2hlbWFFcnJvciIsIl9fc2NoZW1hc19fIiwiY29tcGlsZWQiLCJhbGlhcyIsInNsaXN0IiwiZmlsdGVyIiwic2NoZW1hX3Rlc3QiLCJzcmNfWlBDYyIsInNjaGVtYV9zZWFyY2giLCJwcmV0ZXN0IiwiTWF0Y2giLCJzaGlmdCIsIl9fbGFzdF9pbmRleF9fIiwic2NoZW1hIiwiX19zY2hlbWFfXyIsImxhc3RJbmRleCIsInJhdyIsImNyZWF0ZU1hdGNoIiwiTGlua2lmeUl0Iiwic2NoZW1hcyIsImFkZCIsImRlZmluaXRpb24iLCJtbCIsIm1lIiwidGxkX3BvcyIsImF0X3BvcyIsInRlc3RTY2hlbWFBdCIsInNlYXJjaCIsImtlZXBPbGQiLCJzb3J0IiwiZWwiLCJyZXZlcnNlIiwib3B0cyIsInNyY19BbnkiLCJzcmNfQ2MiLCJzcmNfWiIsInNyY19QIiwic3JjX1pDYyIsInRleHRfc2VwYXJhdG9ycyIsInNyY19wc2V1ZG9fbGV0dGVyIiwic3JjX2lwNCIsInNyY19ob3N0IiwidHBsX2hvc3RfZnV6enkiLCJ0cGxfaG9zdF9ub19pcF9mdXp6eSIsInRwbF9ob3N0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QiLCJwYXJzZUxpbmtMYWJlbCIsInBhcnNlTGlua0Rlc3RpbmF0aW9uIiwicGFyc2VMaW5rVGl0bGUiLCJsaW5lcyIsIm9rIiwiZGlzYWJsZU5lc3RlZCIsInByZXZQb3MiLCJsYWJlbEVuZCIsInBvc01heCIsIm9sZFBvcyIsImlubGluZSIsInNraXBUb2tlbiIsInV0aWxzIiwiaGVscGVycyIsIlJlbmRlcmVyIiwiUGFyc2VyQ29yZSIsIlBhcnNlckJsb2NrIiwiUGFyc2VySW5saW5lIiwicHVueWNvZGUiLCJ6ZXJvIiwiY29tbW9ubWFyayIsIkJBRF9QUk9UT19SRSIsIkdPT0RfREFUQV9SRSIsInZhbGlkYXRlTGluayIsIlJFQ09ERV9IT1NUTkFNRV9GT1IiLCJub3JtYWxpemVMaW5rIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInRvQVNDSUkiLCJlciIsIm5vcm1hbGl6ZUxpbmtUZXh0IiwidG9Vbmljb2RlIiwiTWFya2Rvd25JdCIsInByZXNldE5hbWUiLCJjb3JlIiwicmVuZGVyZXIiLCJsaW5raWZ5IiwiY29uZmlndXJlIiwicHJlc2V0cyIsImNvbXBvbmVudHMiLCJydWxlcyIsInJ1bGVyIiwicnVsZXMyIiwicnVsZXIyIiwibWlzc2VkIiwidXNlIiwicGx1Z2luIiwiZW52IiwiU3RhdGUiLCJwcm9jZXNzIiwicGFyc2VJbmxpbmUiLCJpbmxpbmVNb2RlIiwicmVuZGVySW5saW5lIiwiX3J1bGVzIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsImxpbmUiLCJoYXNFbXB0eUxpbmVzIiwibWF4TmVzdGluZyIsInNraXBFbXB0eUxpbmVzIiwic0NvdW50IiwiYmxrSW5kZW50IiwidGlnaHQiLCJpc0VtcHR5Iiwib3V0VG9rZW5zIiwibGluZU1heCIsIkNvcmUiLCJfcnVsZXMyIiwiY2FjaGUiLCJwdXNoUGVuZGluZyIsInhodG1sT3V0IiwiYnJlYWtzIiwibGFuZ1ByZWZpeCIsInR5cG9ncmFwaGVyIiwicXVvdGVzIiwiaGlnaGxpZ2h0IiwiZGVmYXVsdF9ydWxlcyIsImNvZGVfaW5saW5lIiwic2xmIiwicmVuZGVyQXR0cnMiLCJjb2RlX2Jsb2NrIiwiZmVuY2UiLCJsYW5nTmFtZSIsImhpZ2hsaWdodGVkIiwidG1wQXR0cnMiLCJ0bXBUb2tlbiIsImltYWdlIiwicmVuZGVySW5saW5lQXNUZXh0IiwicmVuZGVyVG9rZW4iLCJoYXJkYnJlYWsiLCJzb2Z0YnJlYWsiLCJodG1sX2Jsb2NrIiwiaHRtbF9pbmxpbmUiLCJuZXh0VG9rZW4iLCJuZWVkTGYiLCJibG9ja3F1b3RlIiwiYWRqdXN0VGFiIiwiaW5pdGlhbCIsImlzT3V0ZGVudGVkIiwibGFzdExpbmVFbXB0eSIsIm5leHRMaW5lIiwib2xkQk1hcmtzIiwib2xkQlNDb3VudCIsIm9sZEluZGVudCIsIm9sZFBhcmVudFR5cGUiLCJvbGRTQ291bnQiLCJvbGRUU2hpZnQiLCJzcGFjZUFmdGVyTWFya2VyIiwidGVybWluYXRlIiwidGVybWluYXRvclJ1bGVzIiwib2xkTGluZU1heCIsImJNYXJrcyIsInRTaGlmdCIsImVNYXJrcyIsImJzQ291bnQiLCJwYXJlbnRUeXBlIiwiZ2V0TGluZXMiLCJtZW0iLCJoYXZlRW5kTWFya2VyIiwic2tpcENoYXJzIiwic2tpcFNwYWNlcyIsImhlYWRpbmciLCJza2lwU3BhY2VzQmFjayIsInNraXBDaGFyc0JhY2siLCJociIsImNudCIsImJsb2NrX25hbWVzIiwiSFRNTF9TRVFVRU5DRVMiLCJsaW5lVGV4dCIsImxoZWFkaW5nIiwic2tpcEJ1bGxldExpc3RNYXJrZXIiLCJza2lwT3JkZXJlZExpc3RNYXJrZXIiLCJtYXJrVGlnaHRQYXJhZ3JhcGhzIiwiY29udGVudFN0YXJ0IiwiaW5kZW50IiwiaW5kZW50QWZ0ZXJNYXJrZXIiLCJpc09yZGVyZWQiLCJpdGVtTGluZXMiLCJsaXN0TGluZXMiLCJsaXN0VG9rSWR4IiwibWFya2VyQ2hhckNvZGUiLCJtYXJrZXJWYWx1ZSIsIm9sZExJbmRlbnQiLCJvbGRUaWdodCIsInBvc0FmdGVyTWFya2VyIiwicHJldkVtcHR5RW5kIiwiaXNUZXJtaW5hdGluZ1BhcmFncmFwaCIsInBhcmFncmFwaCIsInJlZmVyZW5jZSIsIl9lbmRMaW5lIiwiZGVzdEVuZFBvcyIsImRlc3RFbmRMaW5lTm8iLCJsYWJlbCIsInJlZmVyZW5jZXMiLCJTdGF0ZUJsb2NrIiwiaW5kZW50X2ZvdW5kIiwiZGRJbmRlbnQiLCJiZWdpbiIsImtlZXBMYXN0TEYiLCJsaW5lSW5kZW50IiwiZmlyc3QiLCJxdWV1ZSIsImxpbmVTdGFydCIsImdldExpbmUiLCJlc2NhcGVkU3BsaXQiLCJlc2NhcGVzIiwibGFzdFBvcyIsImJhY2tUaWNrZWQiLCJsYXN0QmFja1RpY2siLCJzdWJzdHJpbmciLCJ0YWJsZSIsImNvbHVtbnMiLCJjb2x1bW5Db3VudCIsImFsaWducyIsInQiLCJ0YWJsZUxpbmVzIiwidGJvZHlMaW5lcyIsInRvayIsImlzTGlua09wZW4iLCJpc0xpbmtDbG9zZSIsImN1cnJlbnRUb2tlbiIsIm5vZGVzIiwibG4iLCJodG1sTGlua0xldmVsIiwiZnVsbFVybCIsInVybFRleHQiLCJibG9ja1Rva2VucyIsImxpbmtzIiwiTkVXTElORVNfUkUiLCJOVUxMX1JFIiwiUkFSRV9SRSIsIlNDT1BFRF9BQkJSX1RFU1RfUkUiLCJTQ09QRURfQUJCUl9SRSIsIlNDT1BFRF9BQkJSIiwiciIsInAiLCJ0bSIsInJlcGxhY2VGbiIsInJlcGxhY2Vfc2NvcGVkIiwiaW5saW5lVG9rZW5zIiwiaW5zaWRlX2F1dG9saW5rIiwicmVwbGFjZV9yYXJlIiwiYmxrSWR4IiwiUVVPVEVfVEVTVF9SRSIsIlFVT1RFX1JFIiwiQVBPU1RST1BIRSIsInJlcGxhY2VBdCIsInByb2Nlc3NfaW5saW5lcyIsInRoaXNMZXZlbCIsImxhc3RDaGFyIiwibmV4dENoYXIiLCJpc0xhc3RQdW5jdENoYXIiLCJpc05leHRQdW5jdENoYXIiLCJpc0xhc3RXaGl0ZVNwYWNlIiwiaXNOZXh0V2hpdGVTcGFjZSIsImNhbk9wZW4iLCJjYW5DbG9zZSIsImlzU2luZ2xlIiwic3RhY2siLCJvcGVuUXVvdGUiLCJjbG9zZVF1b3RlIiwiT1VURVIiLCJzaW5nbGUiLCJzbWFydHF1b3RlcyIsIlN0YXRlQ29yZSIsIkVNQUlMX1JFIiwiQVVUT0xJTktfUkUiLCJhdXRvbGluayIsImxpbmtNYXRjaCIsImVtYWlsTWF0Y2giLCJiYWNrdGljayIsIm1hdGNoU3RhcnQiLCJtYXRjaEVuZCIsImxpbmtfcGFpcnMiLCJsYXN0RGVsaW0iLCJjdXJyRGVsaW0iLCJvZGRfbWF0Y2giLCJESUdJVEFMX1JFIiwiTkFNRURfUkUiLCJFU0NBUEVEIiwiZXNjYXBlIiwiaXNMZXR0ZXIiLCJsYyIsImxhYmVsU3RhcnQiLCJyZWYiLCJwYXJzZVJlZmVyZW5jZSIsIm5ld2xpbmUiLCJwbWF4IiwiU3RhdGVJbmxpbmUiLCJwZW5kaW5nTGV2ZWwiLCJjYW5TcGxpdFdvcmQiLCJsZWZ0X2ZsYW5raW5nIiwicmlnaHRfZmxhbmtpbmciLCJpc1Rlcm1pbmF0b3JDaGFyIiwidGV4dF9jb2xsYXBzZSIsImN1cnIiLCJkZWNvZGVDYWNoZSIsImdldERlY29kZUNhY2hlIiwiZXhjbHVkZSIsImRlZmF1bHRDaGFycyIsInNlcSIsImIxIiwiYjIiLCJiMyIsImI0IiwiY2hyIiwiY29tcG9uZW50Q2hhcnMiLCJlbmNvZGVDYWNoZSIsImdldEVuY29kZUNhY2hlIiwia2VlcEVzY2FwZWQiLCJuZXh0Q29kZSIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsIlVybCIsInByb3RvY29sUGF0dGVybiIsInBvcnRQYXR0ZXJuIiwic2ltcGxlUGF0aFBhdHRlcm4iLCJkZWxpbXMiLCJ1bndpc2UiLCJhdXRvRXNjYXBlIiwibm9uSG9zdENoYXJzIiwiaG9zdEVuZGluZ0NoYXJzIiwiaG9zdG5hbWVNYXhMZW4iLCJob3N0bmFtZVBhcnRQYXR0ZXJuIiwiaG9zdG5hbWVQYXJ0U3RhcnQiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwidXJsUGFyc2UiLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJsb3dlclByb3RvIiwiaGVjIiwicmVzdCIsInNpbXBsZVBhdGgiLCJwcm90byIsImhvc3RFbmQiLCJhdFNpZ24iLCJob3N0IiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsInVuc2hpZnQiLCJxbSIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwibmV4dFRpY2siLCJJdGVtIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlR2xvYmFsIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZGVsaW1pdGVyIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJlcnJvcnMiLCJiYXNlTWludXNUTWluIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJjb3VudGVyIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsInciLCJiYXNlTWludXNUIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwiZGVmaW5lIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJkb2MiLCJyZWdpc3RlckltbWVkaWF0ZSIsInRhc2siLCJjbGVhckltbWVkaWF0ZSIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiZXZlbnQiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3J0MiIsImluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24iLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJnZXRQcm90b3R5cGVPZiIsImNzcyIsImJhc2VVcmwiLCJjdXJyZW50RGlyIiwiZml4ZWRDc3MiLCJmdWxsTWF0Y2giLCJvcmlnVXJsIiwidW5xdW90ZWRPcmlnVXJsIiwiJDEiLCJuZXdVcmwiLCJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwiQW55IiwiQ2MiLCJDZiIsIlAiLCJaIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJlbnVtZXJhYmxlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBOzs7O0FBR0EsU0FBU0EsTUFBVCxDQUFnQkMsR0FBaEIsRUFBcUI7QUFBRSxTQUFPQyxPQUFPQyxTQUFQLENBQWlCQyxRQUFqQixDQUEwQkMsSUFBMUIsQ0FBK0JKLEdBQS9CLENBQVA7QUFBNkM7O0FBRXBFLFNBQVNLLFFBQVQsQ0FBa0JMLEdBQWxCLEVBQXVCO0FBQUUsU0FBT0QsT0FBT0MsR0FBUCxNQUFnQixpQkFBdkI7QUFBMkM7O0FBRXBFLElBQUlNLGtCQUFrQkwsT0FBT0MsU0FBUCxDQUFpQkssY0FBdkM7O0FBRUEsU0FBU0MsR0FBVCxDQUFhQyxNQUFiLEVBQXFCQyxHQUFyQixFQUEwQjtBQUN4QixTQUFPSixnQkFBZ0JGLElBQWhCLENBQXFCSyxNQUFyQixFQUE2QkMsR0FBN0IsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxTQUFTQyxNQUFULENBQWdCWCxHQUFoQixDQUFvQiw0QkFBcEIsRUFBa0Q7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Q0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDOWtFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7Ozs7Ozs7OztBQ3BCQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztrQkFFZTtBQUNibkksVUFBUSx1QkFBUztBQUNmM0csVUFBTTFLLEtBQU4sQ0FBWXVmLEtBQVosR0FBb0I3VSxNQUFNN0ssS0FBTixDQUFZMGYsS0FBaEM7QUFDQTdVLFVBQU0xSyxLQUFOLENBQVlvZ0IsUUFBWixHQUF1QixhQUFLO0FBQzFCMVYsWUFBTTFLLEtBQU4sQ0FBWXVmLEtBQVosQ0FBa0J6WSxJQUFsQixDQUF1QjBaLElBQXZCLEdBQThCM1MsQ0FBOUI7QUFDRCxLQUZEO0FBR0QsR0FOWTtBQU9iOUwsUUFBTSxxQkFBUztBQUNiLFFBQU00WCxRQUFRO0FBQUE7QUFBQTtBQUFBO0FBRVosd0NBQU8sTUFBSyxNQUFaLEVBQW1CLFdBQVcsaUJBQU82RyxJQUFyQztBQUNFLGtCQUFVLGtCQUFFdEgsUUFBRixDQUFXLE9BQVgsRUFBb0J4TyxNQUFNMUssS0FBTixDQUFZb2dCLFFBQWhDLENBRFo7QUFFRSxlQUFPMVYsTUFBTTFLLEtBQU4sQ0FBWXVmLEtBQVosQ0FBa0J6WSxJQUFsQixDQUF1QjBaO0FBRmhDO0FBRlksS0FBZDtBQU9BLFdBQU8seUNBQU0sTUFBTSxFQUFaLEVBQWdCLE9BQU83RyxLQUF2QixHQUFQO0FBQ0Q7QUFoQlksQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMzI4MzIyMjdiZmFhZWJjMGFjZjAiLCIvLyBVdGlsaXRpZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG9iamVjdCcpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cbi8vIFVzZWZ1bCBmb3Igc29tZSBvcGVyYXRpb25zIHdpdGggdG9rZW5zXG5mdW5jdGlvbiBhcnJheVJlcGxhY2VBdChzcmMsIHBvcywgbmV3RWxlbWVudHMpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChzcmMuc2xpY2UoMCwgcG9zKSwgbmV3RWxlbWVudHMsIHNyYy5zbGljZShwb3MgKyAxKSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlKGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gbmV2ZXIgdXNlZFxuICBpZiAoYyA+PSAweEZERDAgJiYgYyA8PSAweEZERUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICgoYyAmIDB4RkZGRikgPT09IDB4RkZGRiB8fCAoYyAmIDB4RkZGRikgPT09IDB4RkZGRSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPT09IDB4MEIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gb3V0IG9mIHJhbmdlXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDA7XG4gICAgdmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoYyA+PiAxMCksXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuXG5cbnZhciBVTkVTQ0FQRV9NRF9SRSAgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZztcbnZhciBFTlRJVFlfUkUgICAgICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xudmFyIFVORVNDQVBFX0FMTF9SRSA9IG5ldyBSZWdFeHAoVU5FU0NBUEVfTURfUkUuc291cmNlICsgJ3wnICsgRU5USVRZX1JFLnNvdXJjZSwgJ2dpJyk7XG5cbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xuXG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCcuL2VudGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gIHZhciBjb2RlID0gMDtcblxuICBpZiAoaGFzKGVudGl0aWVzLCBuYW1lKSkge1xuICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgfVxuXG4gIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MjMvKiAjICovICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNilcbiAgICA6XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG4gICAgaWYgKGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShFTlRJVFlfUkUsIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKTtcbn0qL1xuXG5mdW5jdGlvbiB1bmVzY2FwZU1kKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfTURfUkUsICckMScpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUFsbChzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCdcXFxcJykgPCAwICYmIHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfQUxMX1JFLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZWQsIGVudGl0eSkge1xuICAgIGlmIChlc2NhcGVkKSB7IHJldHVybiBlc2NhcGVkOyB9XG4gICAgcmV0dXJuIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBlbnRpdHkpO1xuICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIEhUTUxfRVNDQVBFX1RFU1RfUkUgPSAvWyY8PlwiXS87XG52YXIgSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSA9IC9bJjw+XCJdL2c7XG52YXIgSFRNTF9SRVBMQUNFTUVOVFMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7J1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIoY2gpIHtcbiAgcmV0dXJuIEhUTUxfUkVQTEFDRU1FTlRTW2NoXTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgaWYgKEhUTUxfRVNDQVBFX1RFU1RfUkUudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgUkVHRVhQX0VTQ0FQRV9SRSA9IC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRV9SRSwgJ1xcXFwkJicpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1NwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OlxuICAgIGNhc2UgMHgyMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWnMgKHVuaWNvZGUgY2xhc3MpIHx8IFtcXHRcXGZcXHZcXHJcXG5dXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY29kZSkge1xuICBpZiAoY29kZSA+PSAweDIwMDAgJiYgY29kZSA8PSAweDIwMEEpIHsgcmV0dXJuIHRydWU7IH1cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OiAvLyBcXHRcbiAgICBjYXNlIDB4MEE6IC8vIFxcblxuICAgIGNhc2UgMHgwQjogLy8gXFx2XG4gICAgY2FzZSAweDBDOiAvLyBcXGZcbiAgICBjYXNlIDB4MEQ6IC8vIFxcclxuICAgIGNhc2UgMHgyMDpcbiAgICBjYXNlIDB4QTA6XG4gICAgY2FzZSAweDE2ODA6XG4gICAgY2FzZSAweDIwMkY6XG4gICAgY2FzZSAweDIwNUY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG52YXIgVU5JQ09ERV9QVU5DVF9SRSA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuXG4vLyBDdXJyZW50bHkgd2l0aG91dCBhc3RyYWwgY2hhcmFjdGVycyBzdXBwb3J0LlxuZnVuY3Rpb24gaXNQdW5jdENoYXIoY2gpIHtcbiAgcmV0dXJuIFVOSUNPREVfUFVOQ1RfUkUudGVzdChjaCk7XG59XG5cblxuLy8gTWFya2Rvd24gQVNDSUkgcHVuY3R1YXRpb24gY2hhcmFjdGVycy5cbi8vXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuLy9cbi8vIERvbid0IGNvbmZ1c2Ugd2l0aCB1bmljb2RlIHB1bmN0dWF0aW9uICEhISBJdCBsYWNrcyBzb21lIGNoYXJzIGluIGFzY2lpIHJhbmdlLlxuLy9cbmZ1bmN0aW9uIGlzTWRBc2NpaVB1bmN0KGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMi8qIFwiICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDI3LyogJyAqLzpcbiAgICBjYXNlIDB4MjgvKiAoICovOlxuICAgIGNhc2UgMHgyOS8qICkgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyQy8qICwgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4MkUvKiAuICovOlxuICAgIGNhc2UgMHgyRi8qIC8gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0IvKiA7ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHgzRi8qID8gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0MvKiB8ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVwbGVyIHRvIHVuaWZ5IFtyZWZlcmVuY2UgbGFiZWxzXS5cbi8vXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gIC8vIHVzZSAudG9VcHBlckNhc2UoKSBpbnN0ZWFkIG9mIC50b0xvd2VyQ2FzZSgpXG4gIC8vIGhlcmUgdG8gYXZvaWQgYSBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGVcbiAgLy8gbWVtYmVycyAobW9zdCBub3RhYmx5LCBgX19wcm90b19fYClcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFJlLWV4cG9ydCBsaWJyYXJpZXMgY29tbW9ubHkgdXNlZCBpbiBib3RoIG1hcmtkb3duLWl0IGFuZCBpdHMgcGx1Z2lucyxcbi8vIHNvIHBsdWdpbnMgd29uJ3QgaGF2ZSB0byBkZXBlbmQgb24gdGhlbSBleHBsaWNpdGx5LCB3aGljaCByZWR1Y2VzIHRoZWlyXG4vLyBidW5kbGVkIHNpemUgKGUuZy4gYSBicm93c2VyIGJ1aWxkKS5cbi8vXG5leHBvcnRzLmxpYiAgICAgICAgICAgICAgICAgPSB7fTtcbmV4cG9ydHMubGliLm1kdXJsICAgICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XG5leHBvcnRzLmxpYi51Y21pY3JvICAgICAgICAgPSByZXF1aXJlKCd1Yy5taWNybycpO1xuXG5leHBvcnRzLmFzc2lnbiAgICAgICAgICAgICAgPSBhc3NpZ247XG5leHBvcnRzLmlzU3RyaW5nICAgICAgICAgICAgPSBpc1N0cmluZztcbmV4cG9ydHMuaGFzICAgICAgICAgICAgICAgICA9IGhhcztcbmV4cG9ydHMudW5lc2NhcGVNZCAgICAgICAgICA9IHVuZXNjYXBlTWQ7XG5leHBvcnRzLnVuZXNjYXBlQWxsICAgICAgICAgPSB1bmVzY2FwZUFsbDtcbmV4cG9ydHMuaXNWYWxpZEVudGl0eUNvZGUgICA9IGlzVmFsaWRFbnRpdHlDb2RlO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ICAgICAgID0gZnJvbUNvZGVQb2ludDtcbi8vIGV4cG9ydHMucmVwbGFjZUVudGl0aWVzICAgICA9IHJlcGxhY2VFbnRpdGllcztcbmV4cG9ydHMuZXNjYXBlSHRtbCAgICAgICAgICA9IGVzY2FwZUh0bWw7XG5leHBvcnRzLmFycmF5UmVwbGFjZUF0ICAgICAgPSBhcnJheVJlcGxhY2VBdDtcbmV4cG9ydHMuaXNTcGFjZSAgICAgICAgICAgICA9IGlzU3BhY2U7XG5leHBvcnRzLmlzV2hpdGVTcGFjZSAgICAgICAgPSBpc1doaXRlU3BhY2U7XG5leHBvcnRzLmlzTWRBc2NpaVB1bmN0ICAgICAgPSBpc01kQXNjaWlQdW5jdDtcbmV4cG9ydHMuaXNQdW5jdENoYXIgICAgICAgICA9IGlzUHVuY3RDaGFyO1xuZXhwb3J0cy5lc2NhcGVSRSAgICAgICAgICAgID0gZXNjYXBlUkU7XG5leHBvcnRzLm5vcm1hbGl6ZVJlZmVyZW5jZSAgPSBub3JtYWxpemVSZWZlcmVuY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgdW5kZWZpbmVkKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIHVuZGVmaW5lZCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSkgcmV0dXJuXG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCBcIlwiKVxuXHRcdFx0XHRlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXkyLCB2YWx1ZSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0TGF0ZUF0dHJzKHZub2RlKSB7XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwidmFsdWVcIiwgbnVsbCwgYXR0cnMyLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMyLnNlbGVjdGVkSW5kZXgsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cnModm5vZGUsIG9sZCwgYXR0cnMyLCBucykge1xuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5Miwgb2xkICYmIG9sZFtrZXkyXSwgYXR0cnMyW2tleTJdLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRpZiAoYXR0cnMyID09IG51bGwgfHwgIShrZXkyIGluIGF0dHJzMikpIHtcblx0XHRcdFx0XHRpZiAoa2V5MiA9PT0gXCJjbGFzc05hbWVcIikga2V5MiA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZWxzZSBpZiAoa2V5MiAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXHQvL3N0eWxlXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgc3R5bGUpIHtcblx0XHRpZiAob2xkID09PSBzdHlsZSkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIiwgb2xkID0gbnVsbFxuXHRcdGlmIChzdHlsZSA9PSBudWxsKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0ZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGQgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRcdGZvciAodmFyIGtleTIgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXkyXSA9IHN0eWxlW2tleTJdXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkICE9IG51bGwgJiYgdHlwZW9mIG9sZCAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleTIgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleTJdID0gXCJcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkyIGluIGVsZW1lbnQpIGVsZW1lbnRba2V5Ml0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleTIuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gPT09IGNhbGxiYWNrKSByZXR1cm5cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5Ml0gPSBjYWxsYmFja1xuXHRcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyKGRvbSwgdm5vZGVzKSB7XG5cdFx0aWYgKCFkb20pIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKVxuXHRcdHZhciBob29rcyA9IFtdXG5cdFx0dmFyIGFjdGl2ZSA9ICRkb2MuYWN0aXZlRWxlbWVudFxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCB1bmRlZmluZWQpXG5cdFx0ZG9tLnZub2RlcyA9IHZub2Rlc1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIGhvb2tzW2ldKClcblx0XHRpZiAoJGRvYy5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpXG5cdH1cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0RXZlbnRDYWxsYmFjazogc2V0RXZlbnRDYWxsYmFja31cbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrKSB7XG5cdC8vNjBmcHMgdHJhbnNsYXRlcyB0byAxNi42bXMsIHJvdW5kIGl0IGRvd24gc2luY2Ugc2V0VGltZW91dCByZXF1aXJlcyBpbnRcblx0dmFyIHRpbWUgPSAxNlxuXHR2YXIgbGFzdCA9IDAsIHBlbmRpbmcgPSBudWxsXG5cdHZhciB0aW1lb3V0ID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dFxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KClcblx0XHRpZiAobGFzdCA9PT0gMCB8fCBub3cgLSBsYXN0ID49IHRpbWUpIHtcblx0XHRcdGxhc3QgPSBub3dcblx0XHRcdGNhbGxiYWNrKClcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuXHRcdFx0cGVuZGluZyA9IHRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrKClcblx0XHRcdFx0bGFzdCA9IERhdGUubm93KClcblx0XHRcdH0sIHRpbWUgLSAobm93IC0gbGFzdCkpXG5cdFx0fVxuXHR9XG59XG52YXIgXzExID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgcmVuZGVyU2VydmljZSA9IGNvcmVSZW5kZXJlcigkd2luZG93KVxuXHRyZW5kZXJTZXJ2aWNlLnNldEV2ZW50Q2FsbGJhY2soZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLnJlZHJhdyAhPT0gZmFsc2UpIHJlZHJhdygpXG5cdH0pXG5cdHZhciBjYWxsYmFja3MgPSBbXVxuXHRmdW5jdGlvbiBzdWJzY3JpYmUoa2V5MSwgY2FsbGJhY2spIHtcblx0XHR1bnN1YnNjcmliZShrZXkxKVxuXHRcdGNhbGxiYWNrcy5wdXNoKGtleTEsIHRocm90dGxlKGNhbGxiYWNrKSlcblx0fVxuXHRmdW5jdGlvbiB1bnN1YnNjcmliZShrZXkxKSB7XG5cdFx0dmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2Yoa2V5MSlcblx0XHRpZiAoaW5kZXggPiAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMilcblx0fVxuXHRmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdGNhbGxiYWNrc1tpXSgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiB7c3Vic2NyaWJlOiBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSwgcmVkcmF3OiByZWRyYXcsIHJlbmRlcjogcmVuZGVyU2VydmljZS5yZW5kZXJ9XG59XG52YXIgcmVkcmF3U2VydmljZSA9IF8xMSh3aW5kb3cpXG5yZXF1ZXN0U2VydmljZS5zZXRDb21wbGV0aW9uQ2FsbGJhY2socmVkcmF3U2VydmljZS5yZWRyYXcpXG52YXIgXzE2ID0gZnVuY3Rpb24ocmVkcmF3U2VydmljZTApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudCkge1xuXHRcdGlmIChjb21wb25lbnQgPT09IG51bGwpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBbXSlcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnVuc3Vic2NyaWJlKHJvb3QpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNvbXBvbmVudC52aWV3ID09IG51bGwgJiYgdHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJtLm1vdW50KGVsZW1lbnQsIGNvbXBvbmVudCkgZXhwZWN0cyBhIGNvbXBvbmVudCwgbm90IGEgdm5vZGVcIilcblx0XHRcblx0XHR2YXIgcnVuMCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFZub2RlKGNvbXBvbmVudCkpXG5cdFx0fVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4wKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnJlZHJhdygpXG5cdH1cbn1cbm0ubW91bnQgPSBfMTYocmVkcmF3U2VydmljZSlcbnZhciBQcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG52YXIgcGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRpZiAoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PSBudWxsKSByZXR1cm4ge31cblx0aWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSlcblx0dmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCImXCIpLCBkYXRhMCA9IHt9LCBjb3VudGVycyA9IHt9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IGVudHJpZXNbaV0uc3BsaXQoXCI9XCIpXG5cdFx0dmFyIGtleTUgPSBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMF0pXG5cdFx0dmFyIHZhbHVlID0gZW50cnkubGVuZ3RoID09PSAyID8gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzFdKSA6IFwiXCJcblx0XHRpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWVcblx0XHRlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB2YWx1ZSA9IGZhbHNlXG5cdFx0dmFyIGxldmVscyA9IGtleTUuc3BsaXQoL1xcXVxcWz98XFxbLylcblx0XHR2YXIgY3Vyc29yID0gZGF0YTBcblx0XHRpZiAoa2V5NS5pbmRleE9mKFwiW1wiKSA+IC0xKSBsZXZlbHMucG9wKClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzW2pdLCBuZXh0TGV2ZWwgPSBsZXZlbHNbaiArIDFdXG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBuZXh0TGV2ZWwgPT0gXCJcIiB8fCAhaXNOYU4ocGFyc2VJbnQobmV4dExldmVsLCAxMCkpXG5cdFx0XHR2YXIgaXNWYWx1ZSA9IGogPT09IGxldmVscy5sZW5ndGggLSAxXG5cdFx0XHRpZiAobGV2ZWwgPT09IFwiXCIpIHtcblx0XHRcdFx0dmFyIGtleTUgPSBsZXZlbHMuc2xpY2UoMCwgaikuam9pbigpXG5cdFx0XHRcdGlmIChjb3VudGVyc1trZXk1XSA9PSBudWxsKSBjb3VudGVyc1trZXk1XSA9IDBcblx0XHRcdFx0bGV2ZWwgPSBjb3VudGVyc1trZXk1XSsrXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3Vyc29yW2xldmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdGN1cnNvcltsZXZlbF0gPSBpc1ZhbHVlID8gdmFsdWUgOiBpc051bWJlciA/IFtdIDoge31cblx0XHRcdH1cblx0XHRcdGN1cnNvciA9IGN1cnNvcltsZXZlbF1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGEwXG59XG52YXIgY29yZVJvdXRlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gdHlwZW9mICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPT09IFwiZnVuY3Rpb25cIlxuXHR2YXIgY2FsbEFzeW5jMCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gbm9ybWFsaXplMShmcmFnbWVudDApIHtcblx0XHR2YXIgZGF0YSA9ICR3aW5kb3cubG9jYXRpb25bZnJhZ21lbnQwXS5yZXBsYWNlKC8oPzolW2EtZjg5XVthLWYwLTldKSsvZ2ltLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0aWYgKGZyYWdtZW50MCA9PT0gXCJwYXRobmFtZVwiICYmIGRhdGFbMF0gIT09IFwiL1wiKSBkYXRhID0gXCIvXCIgKyBkYXRhXG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHR2YXIgYXN5bmNJZFxuXHRmdW5jdGlvbiBkZWJvdW5jZUFzeW5jKGNhbGxiYWNrMCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChhc3luY0lkICE9IG51bGwpIHJldHVyblxuXHRcdFx0YXN5bmNJZCA9IGNhbGxBc3luYzAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFzeW5jSWQgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrMCgpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSkge1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKVxuXHRcdHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpXG5cdFx0dmFyIHBhdGhFbmQgPSBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRcdHZhciBxdWVyeVBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSwgcXVlcnlFbmQpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBxdWVyeVBhcmFtcykgcXVlcnlEYXRhW2tleTRdID0gcXVlcnlQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0aWYgKGhhc2hJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgaGFzaFBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShoYXNoSW5kZXggKyAxKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gaGFzaFBhcmFtcykgaGFzaERhdGFba2V5NF0gPSBoYXNoUGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdHJldHVybiBwYXRoLnNsaWNlKDAsIHBhdGhFbmQpXG5cdH1cblx0dmFyIHJvdXRlciA9IHtwcmVmaXg6IFwiIyFcIn1cblx0cm91dGVyLmdldFBhdGggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZTIgPSByb3V0ZXIucHJlZml4LmNoYXJBdCgwKVxuXHRcdHN3aXRjaCAodHlwZTIpIHtcblx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBub3JtYWxpemUxKFwiaGFzaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aClcblx0XHRcdGNhc2UgXCI/XCI6IHJldHVybiBub3JtYWxpemUxKFwic2VhcmNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gbm9ybWFsaXplMShcInBhdGhuYW1lXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdH1cblx0fVxuXHRyb3V0ZXIuc2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHR2YXIgcXVlcnlEYXRhID0ge30sIGhhc2hEYXRhID0ge31cblx0XHRwYXRoID0gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpXG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBkYXRhKSBxdWVyeURhdGFba2V5NF0gPSBkYXRhW2tleTRdXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXSspL2csIGZ1bmN0aW9uKG1hdGNoMiwgdG9rZW4pIHtcblx0XHRcdFx0ZGVsZXRlIHF1ZXJ5RGF0YVt0b2tlbl1cblx0XHRcdFx0cmV0dXJuIGRhdGFbdG9rZW5dXG5cdFx0XHR9KVxuXHRcdH1cblx0XHR2YXIgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKHF1ZXJ5RGF0YSlcblx0XHRpZiAocXVlcnkpIHBhdGggKz0gXCI/XCIgKyBxdWVyeVxuXHRcdHZhciBoYXNoID0gYnVpbGRRdWVyeVN0cmluZyhoYXNoRGF0YSlcblx0XHRpZiAoaGFzaCkgcGF0aCArPSBcIiNcIiArIGhhc2hcblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnN0YXRlIDogbnVsbFxuXHRcdFx0dmFyIHRpdGxlID0gb3B0aW9ucyA/IG9wdGlvbnMudGl0bGUgOiBudWxsXG5cdFx0XHQkd2luZG93Lm9ucG9wc3RhdGUoKVxuXHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0XHRlbHNlICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHR9XG5cdFx0ZWxzZSAkd2luZG93LmxvY2F0aW9uLmhyZWYgPSByb3V0ZXIucHJlZml4ICsgcGF0aFxuXHR9XG5cdHJvdXRlci5kZWZpbmVSb3V0ZXMgPSBmdW5jdGlvbihyb3V0ZXMsIHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZ1bmN0aW9uIHJlc29sdmVSb3V0ZSgpIHtcblx0XHRcdHZhciBwYXRoID0gcm91dGVyLmdldFBhdGgoKVxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9XG5cdFx0XHR2YXIgcGF0aG5hbWUgPSBwYXJzZVBhdGgocGF0aCwgcGFyYW1zLCBwYXJhbXMpXG5cdFx0XHR2YXIgc3RhdGUgPSAkd2luZG93Lmhpc3Rvcnkuc3RhdGVcblx0XHRcdGlmIChzdGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGsgaW4gc3RhdGUpIHBhcmFtc1trXSA9IHN0YXRlW2tdXG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciByb3V0ZTAgaW4gcm91dGVzKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChcIl5cIiArIHJvdXRlMC5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZywgXCIoLio/KVwiKS5yZXBsYWNlKC86W15cXC9dKy9nLCBcIihbXlxcXFwvXSspXCIpICsgXCJcXC8/JFwiKVxuXHRcdFx0XHRpZiAobWF0Y2hlci50ZXN0KHBhdGhuYW1lKSkge1xuXHRcdFx0XHRcdHBhdGhuYW1lLnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5cyA9IHJvdXRlMC5tYXRjaCgvOlteXFwvXSsvZykgfHwgW11cblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTIpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zW2tleXNbaV0ucmVwbGFjZSgvOnxcXC4vZywgXCJcIildID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpXSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc29sdmUocm91dGVzW3JvdXRlMF0sIHBhcmFtcywgcGF0aCwgcm91dGUwKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlamVjdChwYXRoLCBwYXJhbXMpXG5cdFx0fVxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkgJHdpbmRvdy5vbnBvcHN0YXRlID0gZGVib3VuY2VBc3luYyhyZXNvbHZlUm91dGUpXG5cdFx0ZWxzZSBpZiAocm91dGVyLnByZWZpeC5jaGFyQXQoMCkgPT09IFwiI1wiKSAkd2luZG93Lm9uaGFzaGNoYW5nZSA9IHJlc29sdmVSb3V0ZVxuXHRcdHJlc29sdmVSb3V0ZSgpXG5cdH1cblx0cmV0dXJuIHJvdXRlclxufVxudmFyIF8yMCA9IGZ1bmN0aW9uKCR3aW5kb3csIHJlZHJhd1NlcnZpY2UwKSB7XG5cdHZhciByb3V0ZVNlcnZpY2UgPSBjb3JlUm91dGVyKCR3aW5kb3cpXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHYpIHtyZXR1cm4gdn1cblx0dmFyIHJlbmRlcjEsIGNvbXBvbmVudCwgYXR0cnMzLCBjdXJyZW50UGF0aCwgbGFzdFVwZGF0ZVxuXHR2YXIgcm91dGUgPSBmdW5jdGlvbihyb290LCBkZWZhdWx0Um91dGUsIHJvdXRlcykge1xuXHRcdGlmIChyb290ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIGBtLnJvdXRlYCBpcyBub3QgdW5kZWZpbmVkXCIpXG5cdFx0dmFyIHJ1bjEgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZW5kZXIxICE9IG51bGwpIHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCByZW5kZXIxKFZub2RlKGNvbXBvbmVudCwgYXR0cnMzLmtleSwgYXR0cnMzKSkpXG5cdFx0fVxuXHRcdHZhciBiYWlsID0gZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0aWYgKHBhdGggIT09IGRlZmF1bHRSb3V0ZSkgcm91dGVTZXJ2aWNlLnNldFBhdGgoZGVmYXVsdFJvdXRlLCBudWxsLCB7cmVwbGFjZTogdHJ1ZX0pXG5cdFx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGRlZmF1bHQgcm91dGUgXCIgKyBkZWZhdWx0Um91dGUpXG5cdFx0fVxuXHRcdHJvdXRlU2VydmljZS5kZWZpbmVSb3V0ZXMocm91dGVzLCBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIHBhdGgpIHtcblx0XHRcdHZhciB1cGRhdGUgPSBsYXN0VXBkYXRlID0gZnVuY3Rpb24ocm91dGVSZXNvbHZlciwgY29tcCkge1xuXHRcdFx0XHRpZiAodXBkYXRlICE9PSBsYXN0VXBkYXRlKSByZXR1cm5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcCAhPSBudWxsICYmICh0eXBlb2YgY29tcC52aWV3ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNvbXAgPT09IFwiZnVuY3Rpb25cIik/IGNvbXAgOiBcImRpdlwiXG5cdFx0XHRcdGF0dHJzMyA9IHBhcmFtcywgY3VycmVudFBhdGggPSBwYXRoLCBsYXN0VXBkYXRlID0gbnVsbFxuXHRcdFx0XHRyZW5kZXIxID0gKHJvdXRlUmVzb2x2ZXIucmVuZGVyIHx8IGlkZW50aXR5KS5iaW5kKHJvdXRlUmVzb2x2ZXIpXG5cdFx0XHRcdHJ1bjEoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBheWxvYWQudmlldyB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGUoe30sIHBheWxvYWQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHBheWxvYWQub25tYXRjaCkge1xuXHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShwYXlsb2FkLm9ubWF0Y2gocGFyYW1zLCBwYXRoKSkudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKHBheWxvYWQsIHJlc29sdmVkKVxuXHRcdFx0XHRcdH0sIGJhaWwpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB1cGRhdGUocGF5bG9hZCwgXCJkaXZcIilcblx0XHRcdH1cblx0XHR9LCBiYWlsKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4xKVxuXHR9XG5cdHJvdXRlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRpZiAobGFzdFVwZGF0ZSAhPSBudWxsKSBvcHRpb25zID0ge3JlcGxhY2U6IHRydWV9XG5cdFx0bGFzdFVwZGF0ZSA9IG51bGxcblx0XHRyb3V0ZVNlcnZpY2Uuc2V0UGF0aChwYXRoLCBkYXRhLCBvcHRpb25zKVxuXHR9XG5cdHJvdXRlLmdldCA9IGZ1bmN0aW9uKCkge3JldHVybiBjdXJyZW50UGF0aH1cblx0cm91dGUucHJlZml4ID0gZnVuY3Rpb24ocHJlZml4MCkge3JvdXRlU2VydmljZS5wcmVmaXggPSBwcmVmaXgwfVxuXHRyb3V0ZS5saW5rID0gZnVuY3Rpb24odm5vZGUxKSB7XG5cdFx0dm5vZGUxLmRvbS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHJvdXRlU2VydmljZS5wcmVmaXggKyB2bm9kZTEuYXR0cnMuaHJlZilcblx0XHR2bm9kZTEuZG9tLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGUud2hpY2ggPT09IDIpIHJldHVyblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRlLnJlZHJhdyA9IGZhbHNlXG5cdFx0XHR2YXIgaHJlZiA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuXHRcdFx0aWYgKGhyZWYuaW5kZXhPZihyb3V0ZVNlcnZpY2UucHJlZml4KSA9PT0gMCkgaHJlZiA9IGhyZWYuc2xpY2Uocm91dGVTZXJ2aWNlLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRyb3V0ZS5zZXQoaHJlZiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdHJvdXRlLnBhcmFtID0gZnVuY3Rpb24oa2V5Mykge1xuXHRcdGlmKHR5cGVvZiBhdHRyczMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGtleTMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBhdHRyczNba2V5M11cblx0XHRyZXR1cm4gYXR0cnMzXG5cdH1cblx0cmV0dXJuIHJvdXRlXG59XG5tLnJvdXRlID0gXzIwKHdpbmRvdywgcmVkcmF3U2VydmljZSlcbm0ud2l0aEF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSwgY2FsbGJhY2sxLCBjb250ZXh0KSB7XG5cdHJldHVybiBmdW5jdGlvbihlKSB7XG5cdFx0Y2FsbGJhY2sxLmNhbGwoY29udGV4dCB8fCB0aGlzLCBhdHRyTmFtZSBpbiBlLmN1cnJlbnRUYXJnZXQgPyBlLmN1cnJlbnRUYXJnZXRbYXR0ck5hbWVdIDogZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpXG5cdH1cbn1cbnZhciBfMjggPSBjb3JlUmVuZGVyZXIod2luZG93KVxubS5yZW5kZXIgPSBfMjgucmVuZGVyXG5tLnJlZHJhdyA9IHJlZHJhd1NlcnZpY2UucmVkcmF3XG5tLnJlcXVlc3QgPSByZXF1ZXN0U2VydmljZS5yZXF1ZXN0XG5tLmpzb25wID0gcmVxdWVzdFNlcnZpY2UuanNvbnBcbm0ucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmdcbm0uYnVpbGRRdWVyeVN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmdcbm0udmVyc2lvbiA9IFwiMS4xLjFcIlxubS52bm9kZSA9IFZub2RlXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IG1cbmVsc2Ugd2luZG93Lm0gPSBtXG59KCkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21pdGhyaWwvbWl0aHJpbC5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgdm5vZGUuc3RhdGUuc3BhbiA9IHZub2RlLmF0dHJzLnNwYW47XG4gICAgdm5vZGUuc3RhdGUuY2xzID0gdm5vZGUuYXR0cnMuY2xzIHx8ICcnO1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtgbWRsLWNlbGwgbWRsLWNlbGwtLSR7dm5vZGUuc3RhdGUuc3Bhbn0tY29sICR7dm5vZGUuc3RhdGUuY2xzfWB9PlxuICAgICAge3Zub2RlLmF0dHJzLmlubmVyfVxuICAgIDwvZGl2PlxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL2NlbGwuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9saWJzL2NvbXBvbmVudHMvc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwiLyoqXG4gKiBjbGFzcyBSdWxlclxuICpcbiAqIEhlbHBlciBjbGFzcywgdXNlZCBieSBbW01hcmtkb3duSXQjY29yZV1dLCBbW01hcmtkb3duSXQjYmxvY2tdXSBhbmRcbiAqIFtbTWFya2Rvd25JdCNpbmxpbmVdXSB0byBtYW5hZ2Ugc2VxdWVuY2VzIG9mIGZ1bmN0aW9ucyAocnVsZXMpOlxuICpcbiAqIC0ga2VlcCBydWxlcyBpbiBkZWZpbmVkIG9yZGVyXG4gKiAtIGFzc2lnbiB0aGUgbmFtZSB0byBlYWNoIHJ1bGVcbiAqIC0gZW5hYmxlL2Rpc2FibGUgcnVsZXNcbiAqIC0gYWRkL3JlcGxhY2UgcnVsZXNcbiAqIC0gYWxsb3cgYXNzaWduIHJ1bGVzIHRvIGFkZGl0aW9uYWwgbmFtZWQgY2hhaW5zIChpbiB0aGUgc2FtZSlcbiAqIC0gY2FjaGVpbmcgbGlzdHMgb2YgYWN0aXZlIHJ1bGVzXG4gKlxuICogWW91IHdpbGwgbm90IG5lZWQgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHkgdW50aWwgd3JpdGUgcGx1Z2lucy4gRm9yIHNpbXBsZVxuICogcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSwgW1tNYXJrZG93bkl0LmVuYWJsZV1dIGFuZFxuICogW1tNYXJrZG93bkl0LnVzZV1dLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogbmV3IFJ1bGVyKClcbiAqKi9cbmZ1bmN0aW9uIFJ1bGVyKCkge1xuICAvLyBMaXN0IG9mIGFkZGVkIHJ1bGVzLiBFYWNoIGVsZW1lbnQgaXM6XG4gIC8vXG4gIC8vIHtcbiAgLy8gICBuYW1lOiBYWFgsXG4gIC8vICAgZW5hYmxlZDogQm9vbGVhbixcbiAgLy8gICBmbjogRnVuY3Rpb24oKSxcbiAgLy8gICBhbHQ6IFsgbmFtZTIsIG5hbWUzIF1cbiAgLy8gfVxuICAvL1xuICB0aGlzLl9fcnVsZXNfXyA9IFtdO1xuXG4gIC8vIENhY2hlZCBydWxlIGNoYWlucy5cbiAgLy9cbiAgLy8gRmlyc3QgbGV2ZWwgLSBjaGFpbiBuYW1lLCAnJyBmb3IgZGVmYXVsdC5cbiAgLy8gU2Vjb25kIGxldmVsIC0gZGlnaW5hbCBhbmNob3IgZm9yIGZhc3QgZmlsdGVyaW5nIGJ5IGNoYXJjb2Rlcy5cbiAgLy9cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIG1ldGhvZHMsIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseVxuXG5cbi8vIEZpbmQgcnVsZSBpbmRleCBieSBuYW1lXG4vL1xuUnVsZXIucHJvdG90eXBlLl9fZmluZF9fID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9fcnVsZXNfXy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLl9fcnVsZXNfX1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vLyBCdWlsZCBydWxlcyBsb29rdXAgY2FjaGVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19jb21waWxlX18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNoYWlucyA9IFsgJycgXTtcblxuICAvLyBjb2xsZWN0IHVuaXF1ZSBuYW1lc1xuICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBydWxlLmFsdC5mb3JFYWNoKGZ1bmN0aW9uIChhbHROYW1lKSB7XG4gICAgICBpZiAoY2hhaW5zLmluZGV4T2YoYWx0TmFtZSkgPCAwKSB7XG4gICAgICAgIGNoYWlucy5wdXNoKGFsdE5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBzZWxmLl9fY2FjaGVfXyA9IHt9O1xuXG4gIGNoYWlucy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXSA9IFtdO1xuICAgIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIGlmICghcnVsZS5lbmFibGVkKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAoY2hhaW4gJiYgcnVsZS5hbHQuaW5kZXhPZihjaGFpbikgPCAwKSB7IHJldHVybjsgfVxuXG4gICAgICBzZWxmLl9fY2FjaGVfX1tjaGFpbl0ucHVzaChydWxlLmZuKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuYXQobmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgbmFtZSB0byByZXBsYWNlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBuZXcgcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogbmV3IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogUmVwbGFjZSBydWxlIGJ5IG5hbWUgd2l0aCBuZXcgZnVuY3Rpb24gJiBvcHRpb25zLiBUaHJvd3MgZXJyb3IgaWYgbmFtZSBub3RcbiAqIGZvdW5kLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogUmVwbGFjZSBleGlzdGluZyB0eXBvcmdhcGhlciByZXBsYWNlbWVudCBydWxlIHdpdGggbmV3IG9uZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5hdCgncmVwbGFjZW1lbnRzJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgbmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uZm4gPSBmbjtcbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmFsdCA9IG9wdC5hbHQgfHwgW107XG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5iZWZvcmUoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBiZWZvcmVOYW1lIChTdHJpbmcpOiBuZXcgcnVsZSB3aWxsIGJlIGFkZGVkIGJlZm9yZSB0aGlzIG9uZS5cbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgdG8gY2hhaW4gYmVmb3JlIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmFmdGVyXV0sIFtbUnVsZXIucHVzaF1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmJsb2NrLnJ1bGVyLmJlZm9yZSgncGFyYWdyYXBoJywgJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uIChiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhiZWZvcmVOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGJlZm9yZU5hbWUpOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hZnRlcihhZnRlck5hbWUsIHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gYWZ0ZXJOYW1lIChTdHJpbmcpOiBuZXcgcnVsZSB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBhZnRlciBvbmUgd2l0aCBnaXZlbiBuYW1lLiBTZWUgYWxzb1xuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuaW5saW5lLnJ1bGVyLmFmdGVyKCd0ZXh0JywgJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmFmdGVyID0gZnVuY3Rpb24gKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18oYWZ0ZXJOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGFmdGVyTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXggKyAxLCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cbi8qKlxuICogUnVsZXIucHVzaChydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogUHVzaCBuZXcgcnVsZSB0byB0aGUgZW5kIG9mIGNoYWluLiBTZWUgYWxzb1xuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5hZnRlcl1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmNvcmUucnVsZXIucHVzaCgnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fX3J1bGVzX18ucHVzaCh7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGUobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSkgLT4gQXJyYXlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGVuYWJsZVxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICBpZiAoaWdub3JlSW52YWxpZCkgeyByZXR1cm47IH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZXMgbWFuYWdlcjogaW52YWxpZCBydWxlIG5hbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSB0cnVlO1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZW5hYmxlT25seShsaXN0IFssIGlnbm9yZUludmFsaWRdKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlICh3aGl0ZWxpc3QpLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMsIGFuZCBkaXNhYmxlIGV2ZXJ5dGhpbmcgZWxzZS4gSWYgYW55IHJ1bGUgbmFtZVxuICogbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZGlzYWJsZV1dLCBbW1J1bGVyLmVuYWJsZV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmVuYWJsZU9ubHkgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkgeyBydWxlLmVuYWJsZWQgPSBmYWxzZTsgfSk7XG5cbiAgdGhpcy5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZCk7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZGlzYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZGlzYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIERpc2FibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgYW55IHJ1bGUgbmFtZSBub3QgZm91bmQgLSB0aHJvdyBFcnJvci5cbiAqIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFJldHVybnMgbGlzdCBvZiBmb3VuZCBydWxlIG5hbWVzIChpZiBubyBleGNlcHRpb24gaGFwcGVuZWQpLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZW5hYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFNlYXJjaCBieSBuYW1lIGFuZCBkaXNhYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IGZhbHNlO1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZ2V0UnVsZXMoY2hhaW5OYW1lKSAtPiBBcnJheVxuICpcbiAqIFJldHVybiBhcnJheSBvZiBhY3RpdmUgZnVuY3Rpb25zIChydWxlcykgZm9yIGdpdmVuIGNoYWluIG5hbWUuIEl0IGFuYWx5emVzXG4gKiBydWxlcyBjb25maWd1cmF0aW9uLCBjb21waWxlcyBjYWNoZXMgaWYgbm90IGV4aXN0cyBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogRGVmYXVsdCBjaGFpbiBuYW1lIGlzIGAnJ2AgKGVtcHR5IHN0cmluZykuIEl0IGNhbid0IGJlIHNraXBwZWQuIFRoYXQnc1xuICogZG9uZSBpbnRlbnRpb25hbGx5LCB0byBrZWVwIHNpZ25hdHVyZSBtb25vbW9ycGhpYyBmb3IgaGlnaCBzcGVlZC5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5nZXRSdWxlcyA9IGZ1bmN0aW9uIChjaGFpbk5hbWUpIHtcbiAgaWYgKHRoaXMuX19jYWNoZV9fID09PSBudWxsKSB7XG4gICAgdGhpcy5fX2NvbXBpbGVfXygpO1xuICB9XG5cbiAgLy8gQ2hhaW4gY2FuIGJlIGVtcHR5LCBpZiBydWxlcyBkaXNhYmxlZC4gQnV0IHdlIHN0aWxsIGhhdmUgdG8gcmV0dXJuIEFycmF5LlxuICByZXR1cm4gdGhpcy5fX2NhY2hlX19bY2hhaW5OYW1lXSB8fCBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUnVsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCIvLyBUb2tlbiBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBjbGFzcyBUb2tlblxuICoqL1xuXG4vKipcbiAqIG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpXG4gKlxuICogQ3JlYXRlIG5ldyB0b2tlbiBhbmQgZmlsbCBwYXNzZWQgcHJvcGVydGllcy5cbiAqKi9cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAvKipcbiAgICogVG9rZW4jdHlwZSAtPiBTdHJpbmdcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgdG9rZW4gKHN0cmluZywgZS5nLiBcInBhcmFncmFwaF9vcGVuXCIpXG4gICAqKi9cbiAgdGhpcy50eXBlICAgICA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRva2VuI3RhZyAtPiBTdHJpbmdcbiAgICpcbiAgICogaHRtbCB0YWcgbmFtZSwgZS5nLiBcInBcIlxuICAgKiovXG4gIHRoaXMudGFnICAgICAgPSB0YWc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2F0dHJzIC0+IEFycmF5XG4gICAqXG4gICAqIEh0bWwgYXR0cmlidXRlcy4gRm9ybWF0OiBgWyBbIG5hbWUxLCB2YWx1ZTEgXSwgWyBuYW1lMiwgdmFsdWUyIF0gXWBcbiAgICoqL1xuICB0aGlzLmF0dHJzICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbWFwIC0+IEFycmF5XG4gICAqXG4gICAqIFNvdXJjZSBtYXAgaW5mby4gRm9ybWF0OiBgWyBsaW5lX2JlZ2luLCBsaW5lX2VuZCBdYFxuICAgKiovXG4gIHRoaXMubWFwICAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNuZXN0aW5nIC0+IE51bWJlclxuICAgKlxuICAgKiBMZXZlbCBjaGFuZ2UgKG51bWJlciBpbiB7LTEsIDAsIDF9IHNldCksIHdoZXJlOlxuICAgKlxuICAgKiAtICBgMWAgbWVhbnMgdGhlIHRhZyBpcyBvcGVuaW5nXG4gICAqIC0gIGAwYCBtZWFucyB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZ1xuICAgKiAtIGAtMWAgbWVhbnMgdGhlIHRhZyBpcyBjbG9zaW5nXG4gICAqKi9cbiAgdGhpcy5uZXN0aW5nICA9IG5lc3Rpbmc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2xldmVsIC0+IE51bWJlclxuICAgKlxuICAgKiBuZXN0aW5nIGxldmVsLCB0aGUgc2FtZSBhcyBgc3RhdGUubGV2ZWxgXG4gICAqKi9cbiAgdGhpcy5sZXZlbCAgICA9IDA7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XG4gICAqXG4gICAqIEFuIGFycmF5IG9mIGNoaWxkIG5vZGVzIChpbmxpbmUgYW5kIGltZyB0b2tlbnMpXG4gICAqKi9cbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NvbnRlbnQgLT4gU3RyaW5nXG4gICAqXG4gICAqIEluIGEgY2FzZSBvZiBzZWxmLWNsb3NpbmcgdGFnIChjb2RlLCBodG1sLCBmZW5jZSwgZXRjLiksXG4gICAqIGl0IGhhcyBjb250ZW50cyBvZiB0aGlzIHRhZy5cbiAgICoqL1xuICB0aGlzLmNvbnRlbnQgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcmt1cCAtPiBTdHJpbmdcbiAgICpcbiAgICogJyonIG9yICdfJyBmb3IgZW1waGFzaXMsIGZlbmNlIHN0cmluZyBmb3IgZmVuY2UsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm1hcmt1cCAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2luZm8gLT4gU3RyaW5nXG4gICAqXG4gICAqIGZlbmNlIGluZm9zdHJpbmdcbiAgICoqL1xuICB0aGlzLmluZm8gICAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21ldGEgLT4gT2JqZWN0XG4gICAqXG4gICAqIEEgcGxhY2UgZm9yIHBsdWdpbnMgdG8gc3RvcmUgYW4gYXJiaXRyYXJ5IGRhdGFcbiAgICoqL1xuICB0aGlzLm1ldGEgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jYmxvY2sgLT4gQm9vbGVhblxuICAgKlxuICAgKiBUcnVlIGZvciBibG9jay1sZXZlbCB0b2tlbnMsIGZhbHNlIGZvciBpbmxpbmUgdG9rZW5zLlxuICAgKiBVc2VkIGluIHJlbmRlcmVyIHRvIGNhbGN1bGF0ZSBsaW5lIGJyZWFrc1xuICAgKiovXG4gIHRoaXMuYmxvY2sgICAgPSBmYWxzZTtcblxuICAvKipcbiAgICogVG9rZW4jaGlkZGVuIC0+IEJvb2xlYW5cbiAgICpcbiAgICogSWYgaXQncyB0cnVlLCBpZ25vcmUgdGhpcyBlbGVtZW50IHdoZW4gcmVuZGVyaW5nLiBVc2VkIGZvciB0aWdodCBsaXN0c1xuICAgKiB0byBoaWRlIHBhcmFncmFwaHMuXG4gICAqKi9cbiAgdGhpcy5oaWRkZW4gICA9IGZhbHNlO1xufVxuXG5cbi8qKlxuICogVG9rZW4uYXR0ckluZGV4KG5hbWUpIC0+IE51bWJlclxuICpcbiAqIFNlYXJjaCBhdHRyaWJ1dGUgaW5kZXggYnkgbmFtZS5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySW5kZXggPSBmdW5jdGlvbiBhdHRySW5kZXgobmFtZSkge1xuICB2YXIgYXR0cnMsIGksIGxlbjtcblxuICBpZiAoIXRoaXMuYXR0cnMpIHsgcmV0dXJuIC0xOyB9XG5cbiAgYXR0cnMgPSB0aGlzLmF0dHJzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGF0dHJzW2ldWzBdID09PSBuYW1lKSB7IHJldHVybiBpOyB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJQdXNoKGF0dHJEYXRhKVxuICpcbiAqIEFkZCBgWyBuYW1lLCB2YWx1ZSBdYCBhdHRyaWJ1dGUgdG8gbGlzdC4gSW5pdCBhdHRycyBpZiBuZWNlc3NhcnlcbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyUHVzaCA9IGZ1bmN0aW9uIGF0dHJQdXNoKGF0dHJEYXRhKSB7XG4gIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgdGhpcy5hdHRycy5wdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzID0gWyBhdHRyRGF0YSBdO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clNldChuYW1lLCB2YWx1ZSlcbiAqXG4gKiBTZXQgYG5hbWVgIGF0dHJpYnV0ZSB0byBgdmFsdWVgLiBPdmVycmlkZSBvbGQgdmFsdWUgaWYgZXhpc3RzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJTZXQgPSBmdW5jdGlvbiBhdHRyU2V0KG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSxcbiAgICAgIGF0dHJEYXRhID0gWyBuYW1lLCB2YWx1ZSBdO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdID0gYXR0ckRhdGE7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyR2V0KG5hbWUpXG4gKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhdHRyaWJ1dGUgYG5hbWVgLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJHZXQgPSBmdW5jdGlvbiBhdHRyR2V0KG5hbWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLCB2YWx1ZSA9IG51bGw7XG4gIGlmIChpZHggPj0gMCkge1xuICAgIHZhbHVlID0gdGhpcy5hdHRyc1tpZHhdWzFdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySm9pbihuYW1lLCB2YWx1ZSlcbiAqXG4gKiBKb2luIHZhbHVlIHRvIGV4aXN0aW5nIGF0dHJpYnV0ZSB2aWEgc3BhY2UuIE9yIGNyZWF0ZSBuZXcgYXR0cmlidXRlIGlmIG5vdFxuICogZXhpc3RzLiBVc2VmdWwgdG8gb3BlcmF0ZSB3aXRoIHRva2VuIGNsYXNzZXMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckpvaW4gPSBmdW5jdGlvbiBhdHRySm9pbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSk7XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKFsgbmFtZSwgdmFsdWUgXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdWzFdID0gdGhpcy5hdHRyc1tpZHhdWzFdICsgJyAnICsgdmFsdWU7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIS0jJS1cXCosLS86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDRcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQzRCLVxcdURDNEZcXHVEQzVCXFx1REM1RFxcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERTYwLVxcdURFNkNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDdbXFx1REM0MS1cXHVEQzQ1XFx1REM3MFxcdURDNzFdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODNBW1xcdURENUVcXHVERDVGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCkge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgdmFyIGJhc2U2NCA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG4gIHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8vIEhUTUw1IGVudGl0aWVzIG1hcDogeyBuYW1lIC0+IHV0ZjE2c3RyaW5nIH1cbi8vXG4ndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50IHF1b3RlczowKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzIiwiLy8gUmVnZXhwcyB0byBtYXRjaCBodG1sIGVsZW1lbnRzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dHJfbmFtZSAgICAgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xuXG52YXIgdW5xdW90ZWQgICAgICA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBzaW5nbGVfcXVvdGVkID0gXCInW14nXSonXCI7XG52YXIgZG91YmxlX3F1b3RlZCA9ICdcIlteXCJdKlwiJztcblxudmFyIGF0dHJfdmFsdWUgID0gJyg/OicgKyB1bnF1b3RlZCArICd8JyArIHNpbmdsZV9xdW90ZWQgKyAnfCcgKyBkb3VibGVfcXVvdGVkICsgJyknO1xuXG52YXIgYXR0cmlidXRlICAgPSAnKD86XFxcXHMrJyArIGF0dHJfbmFtZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJfdmFsdWUgKyAnKT8pJztcblxudmFyIG9wZW5fdGFnICAgID0gJzxbQS1aYS16XVtBLVphLXowLTlcXFxcLV0qJyArIGF0dHJpYnV0ZSArICcqXFxcXHMqXFxcXC8/Pic7XG5cbnZhciBjbG9zZV90YWcgICA9ICc8XFxcXC9bQS1aYS16XVtBLVphLXowLTlcXFxcLV0qXFxcXHMqPic7XG52YXIgY29tbWVudCAgICAgPSAnPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPic7XG52YXIgcHJvY2Vzc2luZyAgPSAnPFs/XS4qP1s/XT4nO1xudmFyIGRlY2xhcmF0aW9uID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBjZGF0YSAgICAgICA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xuXG52YXIgSFRNTF9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJ3wnICsgY29tbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBwcm9jZXNzaW5nICsgJ3wnICsgZGVjbGFyYXRpb24gKyAnfCcgKyBjZGF0YSArICcpJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpO1xuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xubW9kdWxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IEhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanMiLCIvLyBQcm9jZXNzICp0aGlzKiBhbmQgX3RoYXRfXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDVGIC8qIF8gKi8gJiYgbWFya2VyICE9PSAweDJBIC8qICogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCBtYXJrZXIgPT09IDB4MkEpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzY2FubmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICAvLyBDaGFyIGNvZGUgb2YgdGhlIHN0YXJ0aW5nIG1hcmtlciAobnVtYmVyKS5cbiAgICAgIC8vXG4gICAgICBtYXJrZXI6IG1hcmtlcixcblxuICAgICAgLy8gVG90YWwgbGVuZ3RoIG9mIHRoZXNlIHNlcmllcyBvZiBkZWxpbWl0ZXJzLlxuICAgICAgLy9cbiAgICAgIGxlbmd0aDogc2Nhbm5lZC5sZW5ndGgsXG5cbiAgICAgIC8vIEFuIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGJlZm9yZSB0aGlzIG9uZSB0aGF0J3MgZXF1aXZhbGVudCB0b1xuICAgICAgLy8gY3VycmVudCBvbmUuIEluIHBsYWluIEVuZ2xpc2g6IGlmIHRoaXMgZGVsaW1pdGVyIGRvZXMgbm90IG9wZW5cbiAgICAgIC8vIGFuIGVtcGhhc2lzLCBuZWl0aGVyIGRvIHByZXZpb3VzIGBqdW1wYCBjaGFyYWN0ZXJzLlxuICAgICAgLy9cbiAgICAgIC8vIFVzZWQgdG8gc2tpcCBzZXF1ZW5jZXMgbGlrZSBcIioqKioqXCIgaW4gb25lIHN0ZXAsIGZvciAxc3QgYXN0ZXJpc2tcbiAgICAgIC8vIHZhbHVlIHdpbGwgYmUgMCwgZm9yIDJuZCBpdCdzIDEgYW5kIHNvIG9uLlxuICAgICAgLy9cbiAgICAgIGp1bXA6ICAgaSxcblxuICAgICAgLy8gQSBwb3NpdGlvbiBvZiB0aGUgdG9rZW4gdGhpcyBkZWxpbWl0ZXIgY29ycmVzcG9uZHMgdG8uXG4gICAgICAvL1xuICAgICAgdG9rZW46ICBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMSxcblxuICAgICAgLy8gVG9rZW4gbGV2ZWwuXG4gICAgICAvL1xuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcblxuICAgICAgLy8gSWYgdGhpcyBkZWxpbWl0ZXIgaXMgbWF0Y2hlZCBhcyBhIHZhbGlkIG9wZW5lciwgYGVuZGAgd2lsbCBiZVxuICAgICAgLy8gZXF1YWwgdG8gaXRzIHBvc2l0aW9uLCBvdGhlcndpc2UgaXQncyBgLTFgLlxuICAgICAgLy9cbiAgICAgIGVuZDogICAgLTEsXG5cbiAgICAgIC8vIEJvb2xlYW4gZmxhZ3MgdGhhdCBkZXRlcm1pbmUgaWYgdGhpcyBkZWxpbWl0ZXIgY291bGQgb3BlbiBvciBjbG9zZVxuICAgICAgLy8gYW4gZW1waGFzaXMuXG4gICAgICAvL1xuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBXYWxrIHRocm91Z2ggZGVsaW1pdGVyIGxpc3QgYW5kIHJlcGxhY2UgdGV4dCB0b2tlbnMgd2l0aCB0YWdzXG4vL1xubW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBlbXBoYXNpcyhzdGF0ZSkge1xuICB2YXIgaSxcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgY2gsXG4gICAgICBpc1N0cm9uZyxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4NUYvKiBfICovICYmIHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDJBLyogKiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBvbmx5IG9wZW5pbmcgbWFya2Vyc1xuICAgIGlmIChzdGFydERlbGltLmVuZCA9PT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVuZERlbGltID0gZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZF07XG5cbiAgICAvLyBJZiB0aGUgbmV4dCBkZWxpbWl0ZXIgaGFzIHRoZSBzYW1lIG1hcmtlciBhbmQgaXMgYWRqYWNlbnQgdG8gdGhpcyBvbmUsXG4gICAgLy8gbWVyZ2UgdGhvc2UgaW50byBvbmUgc3Ryb25nIGRlbGltaXRlci5cbiAgICAvL1xuICAgIC8vIGA8ZW0+PGVtPndoYXRldmVyPC9lbT48L2VtPmAgLT4gYDxzdHJvbmc+d2hhdGV2ZXI8L3N0cm9uZz5gXG4gICAgLy9cbiAgICBpc1N0cm9uZyA9IGkgKyAxIDwgbWF4ICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS5lbmQgPT09IHN0YXJ0RGVsaW0uZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpICsgMV0udG9rZW4gPT09IHN0YXJ0RGVsaW0udG9rZW4gKyAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kIC0gMV0udG9rZW4gPT09IGVuZERlbGltLnRva2VuIC0gMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpICsgMV0ubWFya2VyID09PSBzdGFydERlbGltLm1hcmtlcjtcblxuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydERlbGltLm1hcmtlcik7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfb3BlbicgOiAnZW1fb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX2Nsb3NlJyA6ICdlbV9jbG9zZSc7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgaWYgKGlzU3Ryb25nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tpICsgMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kIC0gMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VtcGhhc2lzLmpzIiwiLy8gfn5zdHJpa2UgdGhyb3VnaH5+XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIHN0cmlrZXRocm91Z2goc3RhdGUsIHNpbGVudCkge1xuICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sIGxlbiwgY2gsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHNjYW5uZWQgPSBzdGF0ZS5zY2FuRGVsaW1zKHN0YXRlLnBvcywgdHJ1ZSk7XG4gIGxlbiA9IHNjYW5uZWQubGVuZ3RoO1xuICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICBpZiAobGVuIDwgMikgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobGVuICUgMikge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBjaDtcbiAgICBsZW4tLTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBjaCArIGNoO1xuXG4gICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgIG1hcmtlcjogbWFya2VyLFxuICAgICAganVtcDogICBpLFxuICAgICAgdG9rZW46ICBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMSxcbiAgICAgIGxldmVsOiAgc3RhdGUubGV2ZWwsXG4gICAgICBlbmQ6ICAgIC0xLFxuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBXYWxrIHRocm91Z2ggZGVsaW1pdGVyIGxpc3QgYW5kIHJlcGxhY2UgdGV4dCB0b2tlbnMgd2l0aCB0YWdzXG4vL1xubW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlKSB7XG4gIHZhciBpLCBqLFxuICAgICAgc3RhcnREZWxpbSxcbiAgICAgIGVuZERlbGltLFxuICAgICAgdG9rZW4sXG4gICAgICBsb25lTWFya2VycyA9IFtdLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBzdGFydERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdGFydERlbGltLmVuZCA9PT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVuZERlbGltID0gZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZF07XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSAnc19vcGVuJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgIHRva2VuLm1hcmt1cCAgPSAnfn4nO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSAnc19jbG9zZSc7XG4gICAgdG9rZW4udGFnICAgICA9ICdzJztcbiAgICB0b2tlbi5uZXN0aW5nID0gLTE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW4gLSAxXS5jb250ZW50ID09PSAnficpIHtcblxuICAgICAgbG9uZU1hcmtlcnMucHVzaChlbmREZWxpbS50b2tlbiAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIGEgbWFya2VyIHNlcXVlbmNlIGhhcyBhbiBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGl0J3Mgc3BsaXR0ZWRcbiAgLy8gbGlrZSB0aGlzOiBgfn5+fn5gIC0+IGB+YCArIGB+fmAgKyBgfn5gLCBsZWF2aW5nIG9uZSBtYXJrZXIgYXQgdGhlXG4gIC8vIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgLy9cbiAgLy8gU28sIHdlIGhhdmUgdG8gbW92ZSBhbGwgdGhvc2UgbWFya2VycyBhZnRlciBzdWJzZXF1ZW50IHNfY2xvc2UgdGFncy5cbiAgLy9cbiAgd2hpbGUgKGxvbmVNYXJrZXJzLmxlbmd0aCkge1xuICAgIGkgPSBsb25lTWFya2Vycy5wb3AoKTtcbiAgICBqID0gaSArIDE7XG5cbiAgICB3aGlsZSAoaiA8IHN0YXRlLnRva2Vucy5sZW5ndGggJiYgc3RhdGUudG9rZW5zW2pdLnR5cGUgPT09ICdzX2Nsb3NlJykge1xuICAgICAgaisrO1xuICAgIH1cblxuICAgIGotLTtcblxuICAgIGlmIChpICE9PSBqKSB7XG4gICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tqXTtcbiAgICAgIHN0YXRlLnRva2Vuc1tqXSA9IHN0YXRlLnRva2Vuc1tpXTtcbiAgICAgIHN0YXRlLnRva2Vuc1tpXSA9IHRva2VuO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxceDFGXFx4N0YtXFx4OUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vWyBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXguanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xudmFyIHN0eWxlc0luRG9tID0ge30sXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0fTtcblx0fSxcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0XHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdFx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlciBcblx0XHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0XHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0XHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG5cdH0pLFxuXHRnZXRFbGVtZW50ID0gKGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW8gPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHRcdH07XG5cdH0pKGZ1bmN0aW9uIChzdHlsZVRhcmdldCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN0eWxlVGFyZ2V0KVxuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdLFxuXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vZml4VXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0SW50byA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cdGlmICghc3R5bGVUYXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHN0eWxlVGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIHN0eWxlVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XG5cdHJldHVybiBsaW5rRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0LyogSWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpe1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XG5cblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKVxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICdsaWJzL2NvbXBvbmVudHMvY2VsbCc7XG5pbXBvcnQgVGl0bGUgZnJvbSAnbGlicy9jb21wb25lbnRzL3RpdGxlJztcbmltcG9ydCBUYWdzIGZyb20gJ2xpYnMvY29tcG9uZW50cy90YWdzJztcbmltcG9ydCBTbHVnIGZyb20gJ2xpYnMvY29tcG9uZW50cy9zbHVnJztcbmltcG9ydCBFZGl0b3IgZnJvbSAnbGlicy9jb21wb25lbnRzL2VkaXRvcic7XG5pbXBvcnQgUHJldmlldyBmcm9tICdsaWJzL2NvbXBvbmVudHMvcHJldmlldyc7XG5pbXBvcnQgU2F2ZSBmcm9tICdsaWJzL2NvbXBvbmVudHMvc2F2ZSc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnbGlicy9tb2RlbHMvYXJ0aWNsZSc7XG5cbmNvbnN0IG1vZGVsID0gbmV3IE1vZGVsKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgbW9kZWwuZmV0Y2goKTtcbiAgfSxcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIGlmIChtb2RlbC5mZXRjaGVkKSB7XG4gICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9J21kbC1ncmlkJz5cbiAgICAgICAgPFRpdGxlIG1vZGVsPXttb2RlbH0gLz5cbiAgICAgICAgPFNsdWcgbW9kZWw9e21vZGVsfSAvPlxuICAgICAgICA8VGFncyBtb2RlbD17bW9kZWx9IC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZWRpdG9yV3JhcH0+XG4gICAgICAgICAgPEVkaXRvciBrZXk9J2VkaXRvcicgbW9kZWw9e21vZGVsfSAvPlxuICAgICAgICAgIDxQcmV2aWV3IGtleT0ncHJldmlldycgYm9keT17bW9kZWwubWRCb2R5KCl9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8U2F2ZSBtb2RlbD17bW9kZWx9IG9uY2xpY2s9e21vZGVsLnVwZGF0ZX0gLz5cbiAgICAgIDwvZGl2PlxuICAgIH1cbiAgICByZXR1cm4gPGRpdj7jg4fjg7zjgr/lj5blvpfkuK0uLi48L2Rpdj5cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50LmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQuanMnXG5cbm0ubW91bnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKSwgQ29tcG9uZW50KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VudHJ5LmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gICAgdm5vZGUuc3RhdGUub25pbnB1dCA9IHYgPT4ge1xuICAgICAgdm5vZGUuc3RhdGUubW9kZWwuZGF0YS5ib2R5ID0gdjtcbiAgICB9O1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSA8dGV4dGFyZWFcbiAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRleHRhcmVhfVxuICAgICAgb25pbnB1dD17bS53aXRoQXR0cigndmFsdWUnLCB2bm9kZS5zdGF0ZS5vbmlucHV0KX0+XG4gICAgICAgIHt2bm9kZS5zdGF0ZS5tb2RlbC5kYXRhLmJvZHl9XG4gICAgPC90ZXh0YXJlYT5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17Nn0gY2xzPXtgJHtzdHlsZXMuZWRpdG9yfSAke3N0eWxlcy5lZGl0b3JMZWZ0U2lkZX1gfSBpbm5lcj17aW5uZXJ9IC8+XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL2VkaXRvci5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9jZWxsLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgcmV0dXJuIDxDZWxsIHNwYW49ezZ9IGNscz17YCR7c3R5bGVzLmVkaXRvcn0gJHtzdHlsZXMuZWRpdG9yUmlnaHRTaWRlfWB9XG4gICAgICAgICAgICAgICAgIGlubmVyPXttLnRydXN0KHZub2RlLmF0dHJzLmJvZHkpfSAvPlxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL3ByZXZpZXcuanMiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMuY3NzJztcbmltcG9ydCBDZWxsIGZyb20gJy4vY2VsbC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgdm5vZGUuc3RhdGUubW9kZWwgPSB2bm9kZS5hdHRycy5tb2RlbDtcbiAgICB2bm9kZS5zdGF0ZS5vbmNsaWNrID0gdm5vZGUuYXR0cnMub25jbGljaztcbiAgfSxcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPSdtZGwtYnV0dG9uIG1kbC1qcy1idXR0b24gbWRsLWJ1dHRvbi0tcmFpc2VkIG1kbC1idXR0b24tLWNvbG9yZWQnXG4gICAgICBvbmNsaWNrPXt2bm9kZS5zdGF0ZS5vbmNsaWNrfT5cbiAgICAgIHNhdmVcbiAgICA8L2J1dHRvbj5cbiAgICByZXR1cm4gPENlbGwgc3Bhbj17MTJ9IGNscz17c3R5bGVzLnNhdmVCdXR0b259IGlubmVyPXtpbm5lcn0gLz5cbiAgfVxufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2xpYnMvY29tcG9uZW50cy9zYXZlLmpzIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdDogdm5vZGUgPT4ge1xuICAgIHZub2RlLnN0YXRlLm1vZGVsID0gdm5vZGUuYXR0cnMubW9kZWw7XG4gICAgdm5vZGUuc3RhdGUub25jaGFuZ2UgPSB2ID0+IHtcbiAgICAgIHZub2RlLnN0YXRlLm1vZGVsLmRhdGEudGFncyA9IHYuc3BsaXQoJywnKTtcbiAgICB9O1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSA8bGFiZWw+XG4gICAgICDjgr/jgrBcbiAgICAgIDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzc05hbWU9e3N0eWxlcy50YWdzfVxuICAgICAgICBvbmNoYW5nZT17bS53aXRoQXR0cigndmFsdWUnLCB2bm9kZS5zdGF0ZS5vbmNoYW5nZSl9XG4gICAgICAgIHZhbHVlPXt2bm9kZS5zdGF0ZS5tb2RlbC5kYXRhLnRhZ3Muam9pbignLCcpfVxuICAgICAgLz5cbiAgICA8L2xhYmVsPlxuICAgIHJldHVybiA8Q2VsbCBzcGFuPXsxMn0gaW5uZXI9e2lubmVyfSAvPlxuICB9XG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL3RhZ3MuanMiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBDZWxsIGZyb20gJy4vY2VsbC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgdm5vZGUuc3RhdGUubW9kZWwgPSB2bm9kZS5hdHRycy5tb2RlbDtcbiAgICB2bm9kZS5zdGF0ZS5vbmNoYW5nZSA9IHYgPT4ge1xuICAgICAgdm5vZGUuc3RhdGUubW9kZWwuZGF0YS50aXRsZSA9IHY7XG4gICAgfTtcbiAgfSxcbiAgdmlldzogdm5vZGUgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gPGxhYmVsPlxuICAgICAg44K/44Kk44OI44OrXG4gICAgICA8aW5wdXQgdHlwZT0ndGV4dCcgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9XG4gICAgICAgIG9uY2hhbmdlPXttLndpdGhBdHRyKCd2YWx1ZScsIHZub2RlLnN0YXRlLm9uY2hhbmdlKX1cbiAgICAgICAgdmFsdWU9e3Zub2RlLnN0YXRlLm1vZGVsLmRhdGEudGl0bGV9XG4gICAgICAvPlxuICAgIDwvbGFiZWw+XG4gICAgcmV0dXJuIDxDZWxsIHNwYW49ezEyfSBpbm5lcj17aW5uZXJ9IC8+XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL3RpdGxlLmpzIiwiaW1wb3J0IHJlcXVlc3QgZnJvbSAnLi4vcmVxdWVzdC5qcyc7XG5pbXBvcnQgTWFya2Rvd25JdCBmcm9tICdtYXJrZG93bi1pdCc7XG5cbmNvbnN0IG1kID0gbmV3IE1hcmtkb3duSXQoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWwge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YSB8fCB7XG4gICAgICB0aXRsZTogJycsXG4gICAgICBib2R5OiAnJyxcbiAgICAgIHNsdWc6ICcnLFxuICAgICAgcHVibGlzaDogZmFsc2UsXG4gICAgICB0YWdzOiBbXSxcbiAgICAgIGRhdGU6IG51bGwsXG4gICAgfTtcbiAgICB0aGlzLmZldGNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlc291cmNlc1VybCA9ICcvYXBpL2FydGljbGVzJztcbiAgICB0aGlzLnJlc291cmNlVXJsID0gYCR7dGhpcy5yZXNvdXJjZXNVcmx9LyR7bG9jYXRpb24uaHJlZi5zcGxpdCgnLycpLnNsaWNlKDQpLmpvaW4oJy8nKX1gO1xuICB9XG4gIGZldGNoKCkge1xuICAgIHJldHVybiByZXF1ZXN0KCdHRVQnLCB0aGlzLnJlc291cmNlVXJsKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICB0aGlzLmZldGNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRhdGEgPSByZXNwb25zZTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QoJ1BPU1QnLCB0aGlzLnJlc291cmNlc1VybCwgdGhpcy5kYXRhKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICB0aGlzLmRhdGEgPSByZXNwb25zZTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QoJ1BVVCcsIHRoaXMucmVzb3VyY2VVcmwsIHRoaXMuZGF0YSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgdGhpcy5kYXRhID0gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbiAgZGVsZXRlKCkge1xuICAgIHJldHVybiByZXF1ZXN0KCdERUxFVEUnLCB0aGlzLnJlc291cmNlVXJsKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgfSk7XG4gIH1cbiAgbWRCb2R5KCkge1xuICAgIHJldHVybiBtZC5yZW5kZXIodGhpcy5kYXRhLmJvZHkpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9tb2RlbHMvYXJ0aWNsZS5qcyIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtZXRob2QsIHVybCwgZGF0YSkge1xuICByZXR1cm4gbS5yZXF1ZXN0KHsgbWV0aG9kLCB1cmwsIGRhdGEsIGRlc2VyaWFsaXplOiBKU09OLnBhcnNlfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9yZXF1ZXN0LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vYmFzZTY0LWpzL2luZGV4LmpzIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vYnVmZmVyL2luZGV4LmpzIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9pZWVlNzU0L2luZGV4LmpzIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9pc2FycmF5L2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXJzXG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBPYmplY3RdJzsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJzsgfVxuXG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpOyB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmdXp6eUxpbms6IHRydWUsXG4gIGZ1enp5RW1haWw6IHRydWUsXG4gIGZ1enp5SVA6IGZhbHNlXG59O1xuXG5cbmZ1bmN0aW9uIGlzT3B0aW9uc09iaihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGspIHtcbiAgICByZXR1cm4gYWNjIHx8IGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KGspO1xuICB9LCBmYWxzZSk7XG59XG5cblxudmFyIGRlZmF1bHRTY2hlbWFzID0ge1xuICAnaHR0cDonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUuaHR0cCkge1xuICAgICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLmh0dHAgPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXlxcXFwvXFxcXC8nICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLmh0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLmh0dHApWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgJ2h0dHBzOic6ICAnaHR0cDonLFxuICAnZnRwOic6ICAgICdodHRwOicsXG4gICcvLyc6ICAgICAge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm5vX2h0dHApIHtcbiAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUubm9faHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfYXV0aCArXG4gICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgc2luZ2xlLWxldmVsIGRvbWFpbnMsIGJlY2F1c2Ugb2YgZmFsc2UgcG9zaXRpdmVzIGxpa2UgJy8vdGVzdCdcbiAgICAgICAgICAvLyB3aXRoIGNvZGUgY29tbWVudHNcbiAgICAgICAgICAnKD86bG9jYWxob3N0fCg/Oig/OicgKyBzZWxmLnJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsnICsgc2VsZi5yZS5zcmNfZG9tYWluX3Jvb3QgKyAnKScgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BvcnQgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2hvc3RfdGVybWluYXRvciArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcGF0aCxcblxuICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5yZS5ub19odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSBgOi8vYCAmIGAvLy9gLCB0aGF0IHByb3RlY3RzIGZyb20gZXJyb3JzIGluIHByb3RvY29sIG5hbWVcbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICc6JykgeyByZXR1cm4gMDsgfVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJy8nKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubm9faHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnbWFpbHRvOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5tYWlsdG8pIHtcbiAgICAgICAgc2VsZi5yZS5tYWlsdG8gPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXicgKyBzZWxmLnJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgc2VsZi5yZS5zcmNfaG9zdF9zdHJpY3QsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5tYWlsdG8pWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxuLy8gUkUgcGF0dGVybiBmb3IgMi1jaGFyYWN0ZXIgdGxkcyAoYXV0b2dlbmVyYXRlZCBieSAuL3N1cHBvcnQvdGxkc18yY2hhcl9nZW4uanMpXG52YXIgdGxkc18yY2hfc3JjX3JlID0gJ2FbY2RlZmdpbG1ub3Fyc3R1d3h6XXxiW2FiZGVmZ2hpam1ub3JzdHZ3eXpdfGNbYWNkZmdoaWtsbW5vcnV2d3h5el18ZFtlamttb3pdfGVbY2VncnN0dV18Zltpamttb3JdfGdbYWJkZWZnaGlsbW5wcXJzdHV3eV18aFtrbW5ydHVdfGlbZGVsbW5vcXJzdF18altlbW9wXXxrW2VnaGltbnByd3l6XXxsW2FiY2lrcnN0dXZ5XXxtW2FjZGVnaGtsbW5vcHFyc3R1dnd4eXpdfG5bYWNlZmdpbG9wcnV6XXxvbXxwW2FlZmdoa2xtbnJzdHd5XXxxYXxyW2Vvc3V3XXxzW2FiY2RlZ2hpamtsbW5vcnR1dnh5el18dFtjZGZnaGprbG1ub3J0dnd6XXx1W2Fna3N5el18dlthY2VnaW51XXx3W2ZzXXx5W2V0XXx6W2Ftd10nO1xuXG4vLyBET04nVCB0cnkgdG8gbWFrZSBQUnMgd2l0aCBjaGFuZ2VzLiBFeHRlbmQgVExEcyB3aXRoIExpbmtpZnlJdC50bGRzKCkgaW5zdGVhZFxudmFyIHRsZHNfZGVmYXVsdCA9ICdiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhCcuc3BsaXQoJ3wnKTtcblxuLyplc2xpbnQtZW5hYmxlIG1heC1sZW4qL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiByZXNldFNjYW5DYWNoZShzZWxmKSB7XG4gIHNlbGYuX19pbmRleF9fID0gLTE7XG4gIHNlbGYuX190ZXh0X2NhY2hlX18gICA9ICcnO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0b3IocmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0LCBwb3MpIHtcbiAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgIGlmIChyZS50ZXN0KHRhaWwpKSB7XG4gICAgICByZXR1cm4gdGFpbC5tYXRjaChyZSlbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXplcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwgc2VsZikge1xuICAgIHNlbGYubm9ybWFsaXplKG1hdGNoKTtcbiAgfTtcbn1cblxuLy8gU2NoZW1hcyBjb21waWxlci4gQnVpbGQgcmVnZXhwcy5cbi8vXG5mdW5jdGlvbiBjb21waWxlKHNlbGYpIHtcblxuICAvLyBMb2FkICYgY2xvbmUgUkUgcGF0dGVybnMuXG4gIHZhciByZSA9IHNlbGYucmUgPSByZXF1aXJlKCcuL2xpYi9yZScpKHNlbGYuX19vcHRzX18pO1xuXG4gIC8vIERlZmluZSBkeW5hbWljIHBhdHRlcm5zXG4gIHZhciB0bGRzID0gc2VsZi5fX3RsZHNfXy5zbGljZSgpO1xuXG4gIHNlbGYub25Db21waWxlKCk7XG5cbiAgaWYgKCFzZWxmLl9fdGxkc19yZXBsYWNlZF9fKSB7XG4gICAgdGxkcy5wdXNoKHRsZHNfMmNoX3NyY19yZSk7XG4gIH1cbiAgdGxkcy5wdXNoKHJlLnNyY194bik7XG5cbiAgcmUuc3JjX3RsZHMgPSB0bGRzLmpvaW4oJ3wnKTtcblxuICBmdW5jdGlvbiB1bnRwbCh0cGwpIHsgcmV0dXJuIHRwbC5yZXBsYWNlKCclVExEUyUnLCByZS5zcmNfdGxkcyk7IH1cblxuICByZS5lbWFpbF9mdXp6eSAgICAgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9lbWFpbF9mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfZnV6enkgICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfZnV6enkpLCAnaScpO1xuICByZS5saW5rX25vX2lwX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX25vX2lwX2Z1enp5KSwgJ2knKTtcbiAgcmUuaG9zdF9mdXp6eV90ZXN0ICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfaG9zdF9mdXp6eV90ZXN0KSwgJ2knKTtcblxuICAvL1xuICAvLyBDb21waWxlIGVhY2ggc2NoZW1hXG4gIC8vXG5cbiAgdmFyIGFsaWFzZXMgPSBbXTtcblxuICBzZWxmLl9fY29tcGlsZWRfXyA9IHt9OyAvLyBSZXNldCBjb21waWxlZCBkYXRhXG5cbiAgZnVuY3Rpb24gc2NoZW1hRXJyb3IobmFtZSwgdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcoTGlua2lmeUl0KSBJbnZhbGlkIHNjaGVtYSBcIicgKyBuYW1lICsgJ1wiOiAnICsgdmFsKTtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNlbGYuX19zY2hlbWFzX18pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsID0gc2VsZi5fX3NjaGVtYXNfX1tuYW1lXTtcblxuICAgIC8vIHNraXAgZGlzYWJsZWQgbWV0aG9kc1xuICAgIGlmICh2YWwgPT09IG51bGwpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSB7IHZhbGlkYXRlOiBudWxsLCBsaW5rOiBudWxsIH07XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXSA9IGNvbXBpbGVkO1xuXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gY3JlYXRlVmFsaWRhdG9yKHZhbC52YWxpZGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IHZhbC52YWxpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbC5ub3JtYWxpemUpKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XG4gICAgICB9IGVsc2UgaWYgKCF2YWwubm9ybWFsaXplKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IGNyZWF0ZU5vcm1hbGl6ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgYWxpYXNlcy5wdXNoKG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgcG9zdHBvbmVkIGFsaWFzZXNcbiAgLy9cblxuICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgaWYgKCFzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0pIHtcbiAgICAgIC8vIFNpbGVudGx5IGZhaWwgb24gbWlzc2VkIHNjaGVtYXMgdG8gYXZvaWQgZXJyb25zIG9uIGRpc2FibGUuXG4gICAgICAvLyBzY2hlbWFFcnJvcihhbGlhcywgc2VsZi5fX3NjaGVtYXNfX1thbGlhc10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS52YWxpZGF0ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLm5vcm1hbGl6ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0ubm9ybWFsaXplO1xuICB9KTtcblxuICAvL1xuICAvLyBGYWtlIHJlY29yZCBmb3IgZ3Vlc3NlZCBsaW5rc1xuICAvL1xuICBzZWxmLl9fY29tcGlsZWRfX1snJ10gPSB7IHZhbGlkYXRlOiBudWxsLCBub3JtYWxpemU6IGNyZWF0ZU5vcm1hbGl6ZXIoKSB9O1xuXG4gIC8vXG4gIC8vIEJ1aWxkIHNjaGVtYSBjb25kaXRpb25cbiAgLy9cbiAgdmFyIHNsaXN0ID0gT2JqZWN0LmtleXMoc2VsZi5fX2NvbXBpbGVkX18pXG4gICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGRpc2FibGVkICYgZmFrZSBzY2hlbWFzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGggPiAwICYmIHNlbGYuX19jb21waWxlZF9fW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChlc2NhcGVSRSlcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbignfCcpO1xuICAvLyAoPyFfKSBjYXVzZSAxLjV4IHNsb3dkb3duXG4gIHNlbGYucmUuc2NoZW1hX3Rlc3QgICA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaScpO1xuICBzZWxmLnJlLnNjaGVtYV9zZWFyY2ggPSBSZWdFeHAoJyhefCg/IV8pKD86Wz48XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2lnJyk7XG5cbiAgc2VsZi5yZS5wcmV0ZXN0ICAgICAgID0gUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNlbGYucmUuc2NoZW1hX3Rlc3Quc291cmNlICsgJyl8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5ob3N0X2Z1enp5X3Rlc3Quc291cmNlICsgJyl8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpJyk7XG5cbiAgLy9cbiAgLy8gQ2xlYW51cFxuICAvL1xuXG4gIHJlc2V0U2NhbkNhY2hlKHNlbGYpO1xufVxuXG4vKipcbiAqIGNsYXNzIE1hdGNoXG4gKlxuICogTWF0Y2ggcmVzdWx0LiBTaW5nbGUgZWxlbWVudCBvZiBhcnJheSwgcmV0dXJuZWQgYnkgW1tMaW5raWZ5SXQjbWF0Y2hdXVxuICoqL1xuZnVuY3Rpb24gTWF0Y2goc2VsZiwgc2hpZnQpIHtcbiAgdmFyIHN0YXJ0ID0gc2VsZi5fX2luZGV4X18sXG4gICAgICBlbmQgICA9IHNlbGYuX19sYXN0X2luZGV4X18sXG4gICAgICB0ZXh0ICA9IHNlbGYuX190ZXh0X2NhY2hlX18uc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgLyoqXG4gICAqIE1hdGNoI3NjaGVtYSAtPiBTdHJpbmdcbiAgICpcbiAgICogUHJlZml4IChwcm90b2NvbCkgZm9yIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMuc2NoZW1hICAgID0gc2VsZi5fX3NjaGVtYV9fLnRvTG93ZXJDYXNlKCk7XG4gIC8qKlxuICAgKiBNYXRjaCNpbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogRmlyc3QgcG9zaXRpb24gb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5pbmRleCAgICAgPSBzdGFydCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjbGFzdEluZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBOZXh0IHBvc2l0aW9uIGFmdGVyIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMubGFzdEluZGV4ID0gZW5kICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNyYXcgLT4gU3RyaW5nXG4gICAqXG4gICAqIE1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMucmF3ICAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3RleHQgLT4gU3RyaW5nXG4gICAqXG4gICAqIE5vdG1hbGl6ZWQgdGV4dCBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnRleHQgICAgICA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN1cmwgLT4gU3RyaW5nXG4gICAqXG4gICAqIE5vcm1hbGl6ZWQgdXJsIG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudXJsICAgICAgID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2goc2VsZiwgc2hpZnQpIHtcbiAgdmFyIG1hdGNoID0gbmV3IE1hdGNoKHNlbGYsIHNoaWZ0KTtcblxuICBzZWxmLl9fY29tcGlsZWRfX1ttYXRjaC5zY2hlbWFdLm5vcm1hbGl6ZShtYXRjaCwgc2VsZik7XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5cbi8qKlxuICogY2xhc3MgTGlua2lmeUl0XG4gKiovXG5cbi8qKlxuICogbmV3IExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKVxuICogLSBzY2hlbWFzIChPYmplY3QpOiBPcHRpb25hbC4gQWRkaXRpb25hbCBzY2hlbWFzIHRvIHZhbGlkYXRlIChwcmVmaXgvdmFsaWRhdG9yKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIENyZWF0ZXMgbmV3IGxpbmtpZmllciBpbnN0YW5jZSB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgc2NoZW1hcy5cbiAqIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YCBrZXl3b3JkIGZvciBjb252ZW5pZW5jZS5cbiAqXG4gKiBCeSBkZWZhdWx0IHVuZGVyc3RhbmRzOlxuICpcbiAqIC0gYGh0dHAocyk6Ly8uLi5gICwgYGZ0cDovLy4uLmAsIGBtYWlsdG86Li4uYCAmIGAvLy4uLmAgbGlua3NcbiAqIC0gXCJmdXp6eVwiIGxpbmtzIGFuZCBlbWFpbHMgKGV4YW1wbGUuY29tLCBmb29AYmFyLmNvbSkuXG4gKlxuICogYHNjaGVtYXNgIGlzIGFuIG9iamVjdCwgd2hlcmUgZWFjaCBrZXkvdmFsdWUgZGVzY3JpYmVzIHByb3RvY29sL3J1bGU6XG4gKlxuICogLSBfX2tleV9fIC0gbGluayBwcmVmaXggKHVzdWFsbHksIHByb3RvY29sIG5hbWUgd2l0aCBgOmAgYXQgdGhlIGVuZCwgYHNreXBlOmBcbiAqICAgZm9yIGV4YW1wbGUpLiBgbGlua2lmeS1pdGAgbWFrZXMgc2h1cmUgdGhhdCBwcmVmaXggaXMgbm90IHByZWNlZWRlZCB3aXRoXG4gKiAgIGFscGhhbnVtZXJpYyBjaGFyIGFuZCBzeW1ib2xzLiBPbmx5IHdoaXRlc3BhY2VzIGFuZCBwdW5jdHVhdGlvbiBhbGxvd2VkLlxuICogLSBfX3ZhbHVlX18gLSBydWxlIHRvIGNoZWNrIHRhaWwgYWZ0ZXIgbGluayBwcmVmaXhcbiAqICAgLSBfU3RyaW5nXyAtIGp1c3QgYWxpYXMgdG8gZXhpc3RpbmcgcnVsZVxuICogICAtIF9PYmplY3RfXG4gKiAgICAgLSBfdmFsaWRhdGVfIC0gdmFsaWRhdG9yIGZ1bmN0aW9uIChzaG91bGQgcmV0dXJuIG1hdGNoZWQgbGVuZ3RoIG9uIHN1Y2Nlc3MpLFxuICogICAgICAgb3IgYFJlZ0V4cGAuXG4gKiAgICAgLSBfbm9ybWFsaXplXyAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSB0ZXh0ICYgdXJsIG9mIG1hdGNoZWQgcmVzdWx0XG4gKiAgICAgICAoZm9yIGV4YW1wbGUsIGZvciBAdHdpdHRlciBtZW50aW9ucykuXG4gKlxuICogYG9wdGlvbnNgOlxuICpcbiAqIC0gX19mdXp6eUxpbmtfXyAtIHJlY29nbmlnZSBVUkwtcyB3aXRob3V0IGBodHRwKHMpOmAgcHJlZml4LiBEZWZhdWx0IGB0cnVlYC5cbiAqIC0gX19mdXp6eUlQX18gLSBhbGxvdyBJUHMgaW4gZnV6enkgbGlua3MgYWJvdmUuIENhbiBjb25mbGljdCB3aXRoIHNvbWUgdGV4dHNcbiAqICAgbGlrZSB2ZXJzaW9uIG51bWJlcnMuIERlZmF1bHQgYGZhbHNlYC5cbiAqIC0gX19mdXp6eUVtYWlsX18gLSByZWNvZ25pemUgZW1haWxzIHdpdGhvdXQgYG1haWx0bzpgIHByZWZpeC5cbiAqXG4gKiovXG5mdW5jdGlvbiBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlua2lmeUl0KSkge1xuICAgIHJldHVybiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKGlzT3B0aW9uc09iaihzY2hlbWFzKSkge1xuICAgICAgb3B0aW9ucyA9IHNjaGVtYXM7XG4gICAgICBzY2hlbWFzID0ge307XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fX29wdHNfXyAgICAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAvLyBDYWNoZSBsYXN0IHRlc3RlZCByZXN1bHQuIFVzZWQgdG8gc2tpcCByZXBlYXRpbmcgc3RlcHMgb24gbmV4dCBgbWF0Y2hgIGNhbGwuXG4gIHRoaXMuX19pbmRleF9fICAgICAgICAgID0gLTE7XG4gIHRoaXMuX19sYXN0X2luZGV4X18gICAgID0gLTE7IC8vIE5leHQgc2NhbiBwb3NpdGlvblxuICB0aGlzLl9fc2NoZW1hX18gICAgICAgICA9ICcnO1xuICB0aGlzLl9fdGV4dF9jYWNoZV9fICAgICA9ICcnO1xuXG4gIHRoaXMuX19zY2hlbWFzX18gICAgICAgID0gYXNzaWduKHt9LCBkZWZhdWx0U2NoZW1hcywgc2NoZW1hcyk7XG4gIHRoaXMuX19jb21waWxlZF9fICAgICAgID0ge307XG5cbiAgdGhpcy5fX3RsZHNfXyAgICAgICAgICAgPSB0bGRzX2RlZmF1bHQ7XG4gIHRoaXMuX190bGRzX3JlcGxhY2VkX18gID0gZmFsc2U7XG5cbiAgdGhpcy5yZSA9IHt9O1xuXG4gIGNvbXBpbGUodGhpcyk7XG59XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I2FkZChzY2hlbWEsIGRlZmluaXRpb24pXG4gKiAtIHNjaGVtYSAoU3RyaW5nKTogcnVsZSBuYW1lIChmaXhlZCBwYXR0ZXJuIHByZWZpeClcbiAqIC0gZGVmaW5pdGlvbiAoU3RyaW5nfFJlZ0V4cHxPYmplY3QpOiBzY2hlbWEgZGVmaW5pdGlvblxuICpcbiAqIEFkZCBuZXcgcnVsZSBkZWZpbml0aW9uLiBTZWUgY29uc3RydWN0b3IgZGVzY3JpcHRpb24gZm9yIGRldGFpbHMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChzY2hlbWEsIGRlZmluaXRpb24pIHtcbiAgdGhpcy5fX3NjaGVtYXNfX1tzY2hlbWFdID0gZGVmaW5pdGlvbjtcbiAgY29tcGlsZSh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNzZXQob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogeyBmdXp6eUxpbmt8ZnV6enlFbWFpbHxmdXp6eUlQOiB0cnVlfGZhbHNlIH1cbiAqXG4gKiBTZXQgcmVjb2duaXRpb24gb3B0aW9ucyBmb3IgbGlua3Mgd2l0aG91dCBzY2hlbWEuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gIHRoaXMuX19vcHRzX18gPSBhc3NpZ24odGhpcy5fX29wdHNfXywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBTZWFyY2hlcyBsaW5raWZpYWJsZSBwYXR0ZXJuIGFuZCByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzIG9yIGBmYWxzZWAgb24gZmFpbC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QodGV4dCkge1xuICAvLyBSZXNldCBzY2FuIGNhY2hlXG4gIHRoaXMuX190ZXh0X2NhY2hlX18gPSB0ZXh0O1xuICB0aGlzLl9faW5kZXhfXyAgICAgID0gLTE7XG5cbiAgaWYgKCF0ZXh0Lmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICB2YXIgbSwgbWwsIG1lLCBsZW4sIHNoaWZ0LCBuZXh0LCByZSwgdGxkX3BvcywgYXRfcG9zO1xuXG4gIC8vIHRyeSB0byBzY2FuIGZvciBsaW5rIHdpdGggc2NoZW1hIC0gdGhhdCdzIHRoZSBtb3N0IHNpbXBsZSBydWxlXG4gIGlmICh0aGlzLnJlLnNjaGVtYV90ZXN0LnRlc3QodGV4dCkpIHtcbiAgICByZSA9IHRoaXMucmUuc2NoZW1hX3NlYXJjaDtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgobSA9IHJlLmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICBsZW4gPSB0aGlzLnRlc3RTY2hlbWFBdCh0ZXh0LCBtWzJdLCByZS5sYXN0SW5kZXgpO1xuICAgICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gbVsyXTtcbiAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IG0uaW5kZXggKyBtWzFdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aCArIGxlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlMaW5rICYmIHRoaXMuX19jb21waWxlZF9fWydodHRwOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBsaW5rc1xuICAgIHRsZF9wb3MgPSB0ZXh0LnNlYXJjaCh0aGlzLnJlLmhvc3RfZnV6enlfdGVzdCk7XG4gICAgaWYgKHRsZF9wb3MgPj0gMCkge1xuICAgICAgLy8gaWYgdGxkIGlzIGxvY2F0ZWQgYWZ0ZXIgZm91bmQgbGluayAtIG5vIG5lZWQgdG8gY2hlY2sgZnV6enkgcGF0dGVyblxuICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCB0bGRfcG9zIDwgdGhpcy5fX2luZGV4X18pIHtcbiAgICAgICAgaWYgKChtbCA9IHRleHQubWF0Y2godGhpcy5fX29wdHNfXy5mdXp6eUlQID8gdGhpcy5yZS5saW5rX2Z1enp5IDogdGhpcy5yZS5saW5rX25vX2lwX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICAgIHNoaWZ0ID0gbWwuaW5kZXggKyBtbFsxXS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHNoaWZ0IDwgdGhpcy5fX2luZGV4X18pIHtcbiAgICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSAnJztcbiAgICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtbC5pbmRleCArIG1sWzBdLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUVtYWlsICYmIHRoaXMuX19jb21waWxlZF9fWydtYWlsdG86J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGVtYWlsc1xuICAgIGF0X3BvcyA9IHRleHQuaW5kZXhPZignQCcpO1xuICAgIGlmIChhdF9wb3MgPj0gMCkge1xuICAgICAgLy8gV2UgY2FuJ3Qgc2tpcCB0aGlzIGNoZWNrLCBiZWNhdXNlIHRoaXMgY2FzZXMgYXJlIHBvc3NpYmxlOlxuICAgICAgLy8gMTkyLjE2OC4xLjFAZ21haWwuY29tLCBteS5pbkBleGFtcGxlLmNvbVxuICAgICAgaWYgKChtZSA9IHRleHQubWF0Y2godGhpcy5yZS5lbWFpbF9mdXp6eSkpICE9PSBudWxsKSB7XG5cbiAgICAgICAgc2hpZnQgPSBtZS5pbmRleCArIG1lWzFdLmxlbmd0aDtcbiAgICAgICAgbmV4dCAgPSBtZS5pbmRleCArIG1lWzBdLmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHNoaWZ0IDwgdGhpcy5fX2luZGV4X18gfHxcbiAgICAgICAgICAgIChzaGlmdCA9PT0gdGhpcy5fX2luZGV4X18gJiYgbmV4dCA+IHRoaXMuX19sYXN0X2luZGV4X18pKSB7XG4gICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICdtYWlsdG86JztcbiAgICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gc2hpZnQ7XG4gICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX2luZGV4X18gPj0gMDtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjcHJldGVzdCh0ZXh0KSAtPiBCb29sZWFuXG4gKlxuICogVmVyeSBxdWljayBjaGVjaywgdGhhdCBjYW4gZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMuIFJldHVybnMgdHJ1ZSBpZiBsaW5rIE1BWSBCRVxuICogY2FuIGV4aXN0cy4gQ2FuIGJlIHVzZWQgZm9yIHNwZWVkIG9wdGltaXphdGlvbiwgd2hlbiB5b3UgbmVlZCB0byBjaGVjayB0aGF0XG4gKiBsaW5rIE5PVCBleGlzdHMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnByZXRlc3QgPSBmdW5jdGlvbiBwcmV0ZXN0KHRleHQpIHtcbiAgcmV0dXJuIHRoaXMucmUucHJldGVzdC50ZXN0KHRleHQpO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0U2NoZW1hQXQodGV4dCwgbmFtZSwgcG9zaXRpb24pIC0+IE51bWJlclxuICogLSB0ZXh0IChTdHJpbmcpOiB0ZXh0IHRvIHNjYW5cbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSAoc2NoZW1hKSBuYW1lXG4gKiAtIHBvc2l0aW9uIChOdW1iZXIpOiB0ZXh0IG9mZnNldCB0byBjaGVjayBmcm9tXG4gKlxuICogU2ltaWxhciB0byBbW0xpbmtpZnlJdCN0ZXN0XV0gYnV0IGNoZWNrcyBvbmx5IHNwZWNpZmljIHByb3RvY29sIHRhaWwgZXhhY3RseVxuICogYXQgZ2l2ZW4gcG9zaXRpb24uIFJldHVybnMgbGVuZ3RoIG9mIGZvdW5kIHBhdHRlcm4gKDAgb24gZmFpbCkuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRlc3RTY2hlbWFBdCA9IGZ1bmN0aW9uIHRlc3RTY2hlbWFBdCh0ZXh0LCBzY2hlbWEsIHBvcykge1xuICAvLyBJZiBub3Qgc3VwcG9ydGVkIHNjaGVtYSBjaGVjayByZXF1ZXN0ZWQgLSB0ZXJtaW5hdGVcbiAgaWYgKCF0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldLnZhbGlkYXRlKHRleHQsIHBvcywgdGhpcyk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I21hdGNoKHRleHQpIC0+IEFycmF5fG51bGxcbiAqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGZvdW5kIGxpbmsgZGVzY3JpcHRpb25zIG9yIGBudWxsYCBvbiBmYWlsLiBXZSBzdHJvbmdseVxuICogcmVjb21tZW5kIHRvIHVzZSBbW0xpbmtpZnlJdCN0ZXN0XV0gZmlyc3QsIGZvciBiZXN0IHNwZWVkLlxuICpcbiAqICMjIyMjIFJlc3VsdCBtYXRjaCBkZXNjcmlwdGlvblxuICpcbiAqIC0gX19zY2hlbWFfXyAtIGxpbmsgc2NoZW1hLCBjYW4gYmUgZW1wdHkgZm9yIGZ1enp5IGxpbmtzLCBvciBgLy9gIGZvclxuICogICBwcm90b2NvbC1uZXV0cmFsICBsaW5rcy5cbiAqIC0gX19pbmRleF9fIC0gb2Zmc2V0IG9mIG1hdGNoZWQgdGV4dFxuICogLSBfX2xhc3RJbmRleF9fIC0gaW5kZXggb2YgbmV4dCBjaGFyIGFmdGVyIG1hdGhjaCBlbmRcbiAqIC0gX19yYXdfXyAtIG1hdGNoZWQgdGV4dFxuICogLSBfX3RleHRfXyAtIG5vcm1hbGl6ZWQgdGV4dFxuICogLSBfX3VybF9fIC0gbGluaywgZ2VuZXJhdGVkIGZyb20gbWF0Y2hlZCB0ZXh0XG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2godGV4dCkge1xuICB2YXIgc2hpZnQgPSAwLCByZXN1bHQgPSBbXTtcblxuICAvLyBUcnkgdG8gdGFrZSBwcmV2aW91cyBlbGVtZW50IGZyb20gY2FjaGUsIGlmIC50ZXN0KCkgY2FsbGVkIGJlZm9yZVxuICBpZiAodGhpcy5fX2luZGV4X18gPj0gMCAmJiB0aGlzLl9fdGV4dF9jYWNoZV9fID09PSB0ZXh0KSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcbiAgICBzaGlmdCA9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICAvLyBDdXQgaGVhZCBpZiBjYWNoZSB3YXMgdXNlZFxuICB2YXIgdGFpbCA9IHNoaWZ0ID8gdGV4dC5zbGljZShzaGlmdCkgOiB0ZXh0O1xuXG4gIC8vIFNjYW4gc3RyaW5nIHVudGlsIGVuZCByZWFjaGVkXG4gIHdoaWxlICh0aGlzLnRlc3QodGFpbCkpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuXG4gICAgdGFpbCA9IHRhaWwuc2xpY2UodGhpcy5fX2xhc3RfaW5kZXhfXyk7XG4gICAgc2hpZnQgKz0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjdGxkcyhsaXN0IFssIGtlZXBPbGRdKSAtPiB0aGlzXG4gKiAtIGxpc3QgKEFycmF5KTogbGlzdCBvZiB0bGRzXG4gKiAtIGtlZXBPbGQgKEJvb2xlYW4pOiBtZXJnZSB3aXRoIGN1cnJlbnQgbGlzdCBpZiBgdHJ1ZWAgKGBmYWxzZWAgYnkgZGVmYXVsdClcbiAqXG4gKiBMb2FkIChvciBtZXJnZSkgbmV3IHRsZHMgbGlzdC4gVGhvc2UgYXJlIHVzZXIgZm9yIGZ1enp5IGxpbmtzICh3aXRob3V0IHByZWZpeClcbiAqIHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcy4gQnkgZGVmYXVsdCB0aGlzIGFsZ29yeXRobSB1c2VkOlxuICpcbiAqIC0gaG9zdG5hbWUgd2l0aCBhbnkgMi1sZXR0ZXIgcm9vdCB6b25lcyBhcmUgb2suXG4gKiAtIGJpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEXG4gKiAgIGFyZSBvay5cbiAqIC0gZW5jb2RlZCAoYHhuLS0uLi5gKSByb290IHpvbmVzIGFyZSBvay5cbiAqXG4gKiBJZiBsaXN0IGlzIHJlcGxhY2VkLCB0aGVuIGV4YWN0IG1hdGNoIGZvciAyLWNoYXJzIHJvb3Qgem9uZXMgd2lsbCBiZSBjaGVja2VkLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50bGRzID0gZnVuY3Rpb24gdGxkcyhsaXN0LCBrZWVwT2xkKSB7XG4gIGxpc3QgPSBBcnJheS5pc0FycmF5KGxpc3QpID8gbGlzdCA6IFsgbGlzdCBdO1xuXG4gIGlmICgha2VlcE9sZCkge1xuICAgIHRoaXMuX190bGRzX18gPSBsaXN0LnNsaWNlKCk7XG4gICAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyA9IHRydWU7XG4gICAgY29tcGlsZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX190bGRzX18gPSB0aGlzLl9fdGxkc19fLmNvbmNhdChsaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaWR4LCBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbCAhPT0gYXJyW2lkeCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldmVyc2UoKTtcblxuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTGlua2lmeUl0I25vcm1hbGl6ZShtYXRjaClcbiAqXG4gKiBEZWZhdWx0IG5vcm1hbGl6ZXIgKGlmIHNjaGVtYSBkb2VzIG5vdCBkZWZpbmUgaXQncyBvd24pLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWF0Y2gpIHtcblxuICAvLyBEbyBtaW5pbWFsIHBvc3NpYmxlIGNoYW5nZXMgYnkgZGVmYXVsdC4gTmVlZCB0byBjb2xsZWN0IGZlZWRiYWNrIHByaW9yXG4gIC8vIHRvIG1vdmUgZm9yd2FyZCBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdC9pc3N1ZXMvMVxuXG4gIGlmICghbWF0Y2guc2NoZW1hKSB7IG1hdGNoLnVybCA9ICdodHRwOi8vJyArIG1hdGNoLnVybDsgfVxuXG4gIGlmIChtYXRjaC5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdChtYXRjaC51cmwpKSB7XG4gICAgbWF0Y2gudXJsID0gJ21haWx0bzonICsgbWF0Y2gudXJsO1xuICB9XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I29uQ29tcGlsZSgpXG4gKlxuICogT3ZlcnJpZGUgdG8gbW9kaWZ5IGJhc2ljIFJlZ0V4cC1zLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5vbkNvbXBpbGUgPSBmdW5jdGlvbiBvbkNvbXBpbGUoKSB7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2lmeUl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbGlua2lmeS1pdC9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciByZSA9IHt9O1xuXG4gIC8vIFVzZSBkaXJlY3QgZXh0cmFjdCBpbnN0ZWFkIG9mIGByZWdlbmVyYXRlYCB0byByZWR1c2UgYnJvd3NlcmlmaWVkIHNpemVcbiAgcmUuc3JjX0FueSA9IHJlcXVpcmUoJ3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfQ2MgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1ogICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1AgICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpLnNvdXJjZTtcblxuICAvLyBcXHB7XFxaXFxQXFxDY1xcQ0Z9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sICsgZm9ybWF0ICsgcHVuY3R1YXRpb24pXG4gIHJlLnNyY19aUENjID0gWyByZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBcXHB7XFxaXFxDY30gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wpXG4gIHJlLnNyY19aQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gRXhwZXJpbWVudGFsLiBMaXN0IG9mIGNoYXJzLCBjb21wbGV0ZWx5IHByb2hpYml0ZWQgaW4gbGlua3NcbiAgLy8gYmVjYXVzZSBjYW4gc2VwYXJhdGUgaXQgZnJvbSBvdGhlciBwYXJ0IG9mIHRleHRcbiAgdmFyIHRleHRfc2VwYXJhdG9ycyA9ICdbPjxcXHVmZjVjXSc7XG5cbiAgLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcbiAgLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxuICAvLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXG4gIHJlLnNyY19wc2V1ZG9fbGV0dGVyICAgICAgID0gJyg/Oig/IScgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArIHJlLnNyY19BbnkgKyAnKSc7XG4gIC8vIFRoZSBzYW1lIGFzIGFib3RoZSBidXQgd2l0aG91dCBbMC05XVxuICAvLyB2YXIgc3JjX3BzZXVkb19sZXR0ZXJfbm9uX2QgPSAnKD86KD8hWzAtOV18JyArIHNyY19aUENjICsgJyknICsgc3JjX0FueSArICcpJztcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHJlLnNyY19pcDQgPVxuXG4gICAgJyg/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPyknO1xuXG4gIC8vIFByb2hpYml0IGFueSBvZiBcIkAvW10oKVwiIGluIHVzZXIvcGFzcyB0byBhdm9pZCB3cm9uZyBkb21haW4gZmV0Y2guXG4gIHJlLnNyY19hdXRoICAgID0gJyg/Oig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbQC9cXFxcW1xcXFxdKCldKS4pK0ApPyc7XG5cbiAgcmUuc3JjX3BvcnQgPVxuXG4gICAgJyg/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpPyc7XG5cbiAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9XG5cbiAgICAnKD89JHwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgcmUuc3JjX1pQQ2MgKyAnKSknO1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtXSkufCcgK1xuICAgICAgICAgICdcXFxcWyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xcXFxcXSkuKSpcXFxcXXwnICtcbiAgICAgICAgICAnXFxcXCgoPzooPyEnICsgcmUuc3JjX1pDYyArICd8WyldKS4pKlxcXFwpfCcgK1xuICAgICAgICAgICdcXFxceyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18JyArXG4gICAgICAgICAgJ1xcXFxcIig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbXCJdKS4pK1xcXFxcInwnICtcbiAgICAgICAgICBcIlxcXFwnKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyddKS4pK1xcXFwnfFwiICtcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKS58JyArICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICAnXFxcXC57MiwzfVthLXpBLVowLTklL118JyArIC8vIGdpdGh1YiBoYXMgLi4uIGluIGNvbW1pdCByYW5nZSBsaW5rcy4gUmVzdHJpY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGVuZ2xpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBlcmNlbnQtZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGFydHMgb2YgZmlsZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgbW9yZSBleGFtcGxlcyBmb3VuZC5cbiAgICAgICAgICAnXFxcXC4oPyEnICsgcmUuc3JjX1pDYyArICd8Wy5dKS58JyArXG4gICAgICAgICAgKG9wdHMgJiYgb3B0c1snLS0tJ10gP1xuICAgICAgICAgICAgJ1xcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXwnIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXG4gICAgICAgICAgOlxuICAgICAgICAgICAgJ1xcXFwtK3wnXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ1xcXFwsKD8hJyArIHJlLnNyY19aQ2MgKyAnKS58JyArICAgICAgLy8gYWxsb3cgYCwsLGAgaW4gcGF0aHNcbiAgICAgICAgICAnXFxcXCEoPyEnICsgcmUuc3JjX1pDYyArICd8WyFdKS58JyArXG4gICAgICAgICAgJ1xcXFw/KD8hJyArIHJlLnNyY19aQ2MgKyAnfFs/XSkuJyArXG4gICAgICAgICcpKycgK1xuICAgICAgJ3xcXFxcLycgK1xuICAgICcpPyc7XG5cbiAgcmUuc3JjX2VtYWlsX25hbWUgPVxuXG4gICAgJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFxcIlxcXFwuYS16QS1aMC05X10rJztcblxuICByZS5zcmNfeG4gPVxuXG4gICAgJ3huLS1bYS16MC05XFxcXC1dezEsNTl9JztcblxuICAvLyBNb3JlIHRvIHJlYWQgYWJvdXQgZG9tYWluIG5hbWVzXG4gIC8vIGh0dHA6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzYzODI2MC9cblxuICByZS5zcmNfZG9tYWluX3Jvb3QgPVxuXG4gICAgLy8gQWxsb3cgbGV0dGVycyAmIGRpZ2l0cyAoaHR0cDovL3Rlc3QxKVxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnezEsNjN9JyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19kb21haW4gPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAgICd8JyArXG4gICAgICAvLyBkb24ndCBhbGxvdyBgLS1gIGluIGRvbWFpbiBuYW1lcywgYmVjYXVzZTpcbiAgICAgIC8vIC0gdGhhdCBjYW4gY29uZmxpY3Qgd2l0aCBtYXJrZG93biAmbWRhc2g7IC8gJm5kYXNoO1xuICAgICAgLy8gLSBub2JvZHkgdXNlIHRob3NlIGFueXdheVxuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcoPzotKD8hLSl8JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyl7MCw2MX0nICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICcpJztcblxuICByZS5zcmNfaG9zdCA9XG5cbiAgICAnKD86JyArXG4gICAgLy8gRG9uJ3QgbmVlZCBJUCBjaGVjaywgYmVjYXVzZSBkaWdpdHMgYXJlIGFscmVhZHkgYWxsb3dlZCBpbiBub3JtYWwgZG9tYWluIG5hbWVzXG4gICAgLy8gICBzcmNfaXA0ICtcbiAgICAvLyAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikqJyArIHJlLnNyY19kb21haW4vKl9yb290Ki8gKyAnKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9mdXp6eSA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfaXA0ICtcbiAgICAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgPVxuXG4gICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknO1xuXG4gIHJlLnNyY19ob3N0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS5zcmNfaG9zdF9wb3J0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE1haW4gcnVsZXNcblxuICAvLyBSdWRlIHRlc3QgZnV6enkgbGlua3MgYnkgaG9zdCwgZm9yIHF1aWNrIGRlbnlcbiAgcmUudHBsX2hvc3RfZnV6enlfdGVzdCA9XG5cbiAgICAnbG9jYWxob3N0fHd3d1xcXFwufFxcXFwuXFxcXGR7MSwzfVxcXFwufCg/OlxcXFwuKD86JVRMRFMlKSg/OicgKyByZS5zcmNfWlBDYyArICd8PnwkKSknO1xuXG4gIHJlLnRwbF9lbWFpbF9mdXp6eSA9XG5cbiAgICAgICcoXnwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xcXFxcKHwnICsgcmUuc3JjX1pDYyArICcpKCcgKyByZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCArICcpJztcblxuICByZS50cGxfbGlua19mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZS50cGxfbGlua19ub19pcF9mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZXR1cm4gcmU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbGlua2lmeS1pdC9saWIvcmUuanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi8nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwiLy8gTGlzdCBvZiB2YWxpZCBodG1sIGJsb2NrcyBuYW1lcywgYWNjb3J0aW5nIHRvIGNvbW1vbm1hcmsgc3BlY1xuLy8gaHR0cDovL2pnbS5naXRodWIuaW8vQ29tbW9uTWFyay9zcGVjLmh0bWwjaHRtbC1ibG9ja3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnYWRkcmVzcycsXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2Jhc2UnLFxuICAnYmFzZWZvbnQnLFxuICAnYmxvY2txdW90ZScsXG4gICdib2R5JyxcbiAgJ2NhcHRpb24nLFxuICAnY2VudGVyJyxcbiAgJ2NvbCcsXG4gICdjb2xncm91cCcsXG4gICdkZCcsXG4gICdkZXRhaWxzJyxcbiAgJ2RpYWxvZycsXG4gICdkaXInLFxuICAnZGl2JyxcbiAgJ2RsJyxcbiAgJ2R0JyxcbiAgJ2ZpZWxkc2V0JyxcbiAgJ2ZpZ2NhcHRpb24nLFxuICAnZmlndXJlJyxcbiAgJ2Zvb3RlcicsXG4gICdmb3JtJyxcbiAgJ2ZyYW1lJyxcbiAgJ2ZyYW1lc2V0JyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWQnLFxuICAnaGVhZGVyJyxcbiAgJ2hyJyxcbiAgJ2h0bWwnLFxuICAnaWZyYW1lJyxcbiAgJ2xlZ2VuZCcsXG4gICdsaScsXG4gICdsaW5rJyxcbiAgJ21haW4nLFxuICAnbWVudScsXG4gICdtZW51aXRlbScsXG4gICdtZXRhJyxcbiAgJ25hdicsXG4gICdub2ZyYW1lcycsXG4gICdvbCcsXG4gICdvcHRncm91cCcsXG4gICdvcHRpb24nLFxuICAncCcsXG4gICdwYXJhbScsXG4gICdwcmUnLFxuICAnc2VjdGlvbicsXG4gICdzb3VyY2UnLFxuICAndGl0bGUnLFxuICAnc3VtbWFyeScsXG4gICd0YWJsZScsXG4gICd0Ym9keScsXG4gICd0ZCcsXG4gICd0Zm9vdCcsXG4gICd0aCcsXG4gICd0aGVhZCcsXG4gICd0aXRsZScsXG4gICd0cicsXG4gICd0cmFjaycsXG4gICd1bCdcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzIiwiLy8gSnVzdCBhIHNob3J0Y3V0IGZvciBidWxrIGV4cG9ydFxuJ3VzZSBzdHJpY3QnO1xuXG5cbmV4cG9ydHMucGFyc2VMaW5rTGFiZWwgICAgICAgPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfbGFiZWwnKTtcbmV4cG9ydHMucGFyc2VMaW5rRGVzdGluYXRpb24gPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfZGVzdGluYXRpb24nKTtcbmV4cG9ydHMucGFyc2VMaW5rVGl0bGUgICAgICAgPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfdGl0bGUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzIiwiLy8gUGFyc2UgbGluayBkZXN0aW5hdGlvblxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgaXNTcGFjZSAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KSB7XG4gIHZhciBjb2RlLCBsZXZlbCxcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4M0MgLyogPCAqLykge1xuICAgIHBvcysrO1xuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNvZGUgPT09IDB4MEEgLyogXFxuICovIHx8IGlzU3BhY2UoY29kZSkpIHsgcmV0dXJuIHJlc3VsdDsgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4M0UgLyogPiAqLykge1xuICAgICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIC8vIG5vIGNsb3NpbmcgJz4nXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIHRoaXMgc2hvdWxkIGJlIC4uLiB9IGVsc2UgeyAuLi4gYnJhbmNoXG5cbiAgbGV2ZWwgPSAwO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyMCkgeyBicmVhazsgfVxuXG4gICAgLy8gYXNjaWkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAweDIwIHx8IGNvZGUgPT09IDB4N0YpIHsgYnJlYWs7IH1cblxuICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjggLyogKCAqLykge1xuICAgICAgbGV2ZWwrKztcbiAgICAgIGlmIChsZXZlbCA+IDEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOSAvKiApICovKSB7XG4gICAgICBsZXZlbC0tO1xuICAgICAgaWYgKGxldmVsIDwgMCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSBwb3MpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQsIHBvcykpO1xuICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgcmVzdWx0LnBvcyA9IHBvcztcbiAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLmpzIiwiLy8gUGFyc2UgbGluayBsYWJlbFxuLy9cbi8vIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGZpcnN0IGNoYXJhY3RlciAoXCJbXCIpIGFscmVhZHkgbWF0Y2hlcztcbi8vIHJldHVybnMgdGhlIGVuZCBvZiB0aGUgbGFiZWxcbi8vXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXJ0LCBkaXNhYmxlTmVzdGVkKSB7XG4gIHZhciBsZXZlbCwgZm91bmQsIG1hcmtlciwgcHJldlBvcyxcbiAgICAgIGxhYmVsRW5kID0gLTEsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3M7XG5cbiAgc3RhdGUucG9zID0gc3RhcnQgKyAxO1xuICBsZXZlbCA9IDE7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IG1heCkge1xuICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsZXZlbC0tO1xuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldlBvcyA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5tZC5pbmxpbmUuc2tpcFRva2VuKHN0YXRlKTtcbiAgICBpZiAobWFya2VyID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIGlmIChwcmV2UG9zID09PSBzdGF0ZS5wb3MgLSAxKSB7XG4gICAgICAgIC8vIGluY3JlYXNlIGxldmVsIGlmIHdlIGZpbmQgdGV4dCBgW2AsIHdoaWNoIGlzIG5vdCBhIHBhcnQgb2YgYW55IHRva2VuXG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKGRpc2FibGVOZXN0ZWQpIHtcbiAgICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvdW5kKSB7XG4gICAgbGFiZWxFbmQgPSBzdGF0ZS5wb3M7XG4gIH1cblxuICAvLyByZXN0b3JlIG9sZCBzdGF0ZVxuICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG5cbiAgcmV0dXJuIGxhYmVsRW5kO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCIvLyBQYXJzZSBsaW5rIHRpdGxlXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSxcbiAgICAgIG1hcmtlcixcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIG1hcmtlciA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHgyMiAvKiBcIiAqLyAmJiBtYXJrZXIgIT09IDB4MjcgLyogJyAqLyAmJiBtYXJrZXIgIT09IDB4MjggLyogKCAqLykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcG9zKys7XG5cbiAgLy8gaWYgb3BlbmluZyBtYXJrZXIgaXMgXCIoXCIsIHN3aXRjaCBpdCB0byBjbG9zaW5nIG1hcmtlciBcIilcIlxuICBpZiAobWFya2VyID09PSAweDI4KSB7IG1hcmtlciA9IDB4Mjk7IH1cblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzIiwiLy8gTWFpbiBwYXJzZXIgY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpO1xudmFyIGhlbHBlcnMgICAgICA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xudmFyIFJlbmRlcmVyICAgICA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcbnZhciBQYXJzZXJDb3JlICAgPSByZXF1aXJlKCcuL3BhcnNlcl9jb3JlJyk7XG52YXIgUGFyc2VyQmxvY2sgID0gcmVxdWlyZSgnLi9wYXJzZXJfYmxvY2snKTtcbnZhciBQYXJzZXJJbmxpbmUgPSByZXF1aXJlKCcuL3BhcnNlcl9pbmxpbmUnKTtcbnZhciBMaW5raWZ5SXQgICAgPSByZXF1aXJlKCdsaW5raWZ5LWl0Jyk7XG52YXIgbWR1cmwgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbnZhciBwdW55Y29kZSAgICAgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5cbnZhciBjb25maWcgPSB7XG4gICdkZWZhdWx0JzogcmVxdWlyZSgnLi9wcmVzZXRzL2RlZmF1bHQnKSxcbiAgemVybzogcmVxdWlyZSgnLi9wcmVzZXRzL3plcm8nKSxcbiAgY29tbW9ubWFyazogcmVxdWlyZSgnLi9wcmVzZXRzL2NvbW1vbm1hcmsnKVxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG4vLyBUaGlzIHZhbGlkYXRvciBjYW4gcHJvaGliaXQgbW9yZSB0aGFuIHJlYWxseSBuZWVkZWQgdG8gcHJldmVudCBYU1MuIEl0J3MgYVxuLy8gdHJhZGVvZmYgdG8ga2VlcCBjb2RlIHNpbXBsZSBhbmQgdG8gYmUgc2VjdXJlIGJ5IGRlZmF1bHQuXG4vL1xuLy8gSWYgeW91IG5lZWQgZGlmZmVyZW50IHNldHVwIC0gb3ZlcnJpZGUgdmFsaWRhdG9yIG1ldGhvZCBhcyB5b3Ugd2lzaC4gT3Jcbi8vIHJlcGxhY2UgaXQgd2l0aCBkdW1teSBmdW5jdGlvbiBhbmQgdXNlIGV4dGVybmFsIHNhbml0aXplci5cbi8vXG5cbnZhciBCQURfUFJPVE9fUkUgPSAvXih2YnNjcmlwdHxqYXZhc2NyaXB0fGZpbGV8ZGF0YSk6LztcbnZhciBHT09EX0RBVEFfUkUgPSAvXmRhdGE6aW1hZ2VcXC8oZ2lmfHBuZ3xqcGVnfHdlYnApOy87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGluayh1cmwpIHtcbiAgLy8gdXJsIHNob3VsZCBiZSBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnQsIGFuZCBleGlzdGluZyBlbnRpdGllcyBhcmUgZGVjb2RlZFxuICB2YXIgc3RyID0gdXJsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBCQURfUFJPVE9fUkUudGVzdChzdHIpID8gKEdPT0RfREFUQV9SRS50ZXN0KHN0cikgPyB0cnVlIDogZmFsc2UpIDogdHJ1ZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgUkVDT0RFX0hPU1ROQU1FX0ZPUiA9IFsgJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86JyBdO1xuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rKHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZHVybC5lbmNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCkpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rVGV4dCh1cmwpIHtcbiAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG5cbiAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXG4gICAgLy9cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBwdW55Y29kZS50b1VuaWNvZGUocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZHVybC5kZWNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCkpO1xufVxuXG5cbi8qKlxuICogY2xhc3MgTWFya2Rvd25JdFxuICpcbiAqIE1haW4gcGFyc2VyL3JlbmRlcmVyIGNsYXNzLlxuICpcbiAqICMjIyMjIFVzYWdlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogLy8gbm9kZS5qcywgXCJjbGFzc2ljXCIgd2F5OlxuICogdmFyIE1hcmtkb3duSXQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpLFxuICogICAgIG1kID0gbmV3IE1hcmtkb3duSXQoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXIoJyMgbWFya2Rvd24taXQgcnVsZXp6IScpO1xuICpcbiAqIC8vIG5vZGUuanMsIHRoZSBzYW1lLCBidXQgd2l0aCBzdWdhcjpcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXIoJyMgbWFya2Rvd24taXQgcnVsZXp6IScpO1xuICpcbiAqIC8vIGJyb3dzZXIgd2l0aG91dCBBTUQsIGFkZGVkIHRvIFwid2luZG93XCIgb24gc2NyaXB0IGxvYWRcbiAqIC8vIE5vdGUsIHRoZXJlIGFyZSBubyBkYXNoLlxuICogdmFyIG1kID0gd2luZG93Lm1hcmtkb3duaXQoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXIoJyMgbWFya2Rvd24taXQgcnVsZXp6IScpO1xuICogYGBgXG4gKlxuICogU2luZ2xlIGxpbmUgcmVuZGVyaW5nLCB3aXRob3V0IHBhcmFncmFwaCB3cmFwOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoJ19fbWFya2Rvd24taXRfXyBydWxlenohJyk7XG4gKiBgYGBcbiAqKi9cblxuLyoqXG4gKiBuZXcgTWFya2Rvd25JdChbcHJlc2V0TmFtZSwgb3B0aW9uc10pXG4gKiAtIHByZXNldE5hbWUgKFN0cmluZyk6IG9wdGlvbmFsLCBgY29tbW9ubWFya2AgLyBgemVyb2BcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KVxuICpcbiAqIENyZWF0ZXMgcGFyc2VyIGluc3RhbnNlIHdpdGggZ2l2ZW4gY29uZmlnLiBDYW4gYmUgY2FsbGVkIHdpdGhvdXQgYG5ld2AuXG4gKlxuICogIyMjIyMgcHJlc2V0TmFtZVxuICpcbiAqIE1hcmtkb3duSXQgcHJvdmlkZXMgbmFtZWQgcHJlc2V0cyBhcyBhIGNvbnZlbmllbmNlIHRvIHF1aWNrbHlcbiAqIGVuYWJsZS9kaXNhYmxlIGFjdGl2ZSBzeW50YXggcnVsZXMgYW5kIG9wdGlvbnMgZm9yIGNvbW1vbiB1c2UgY2FzZXMuXG4gKlxuICogLSBbXCJjb21tb25tYXJrXCJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzKSAtXG4gKiAgIGNvbmZpZ3VyZXMgcGFyc2VyIHRvIHN0cmljdCBbQ29tbW9uTWFya10oaHR0cDovL2NvbW1vbm1hcmsub3JnLykgbW9kZS5cbiAqIC0gW2RlZmF1bHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy9kZWZhdWx0LmpzKSAtXG4gKiAgIHNpbWlsYXIgdG8gR0ZNLCB1c2VkIHdoZW4gbm8gcHJlc2V0IG5hbWUgZ2l2ZW4uIEVuYWJsZXMgYWxsIGF2YWlsYWJsZSBydWxlcyxcbiAqICAgYnV0IHN0aWxsIHdpdGhvdXQgaHRtbCwgdHlwb2dyYXBoZXIgJiBhdXRvbGlua2VyLlxuICogLSBbXCJ6ZXJvXCJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy96ZXJvLmpzKSAtXG4gKiAgIGFsbCBydWxlcyBkaXNhYmxlZC4gVXNlZnVsIHRvIHF1aWNrbHkgc2V0dXAgeW91ciBjb25maWcgdmlhIGAuZW5hYmxlKClgLlxuICogICBGb3IgZXhhbXBsZSwgd2hlbiB5b3UgbmVlZCBvbmx5IGBib2xkYCBhbmQgYGl0YWxpY2AgbWFya3VwIGFuZCBub3RoaW5nIGVsc2UuXG4gKlxuICogIyMjIyMgb3B0aW9uczpcbiAqXG4gKiAtIF9faHRtbF9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBlbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZS4gQmUgY2FyZWZ1bCFcbiAqICAgVGhhdCdzIG5vdCBzYWZlISBZb3UgbWF5IG5lZWQgZXh0ZXJuYWwgc2FuaXRpemVyIHRvIHByb3RlY3Qgb3V0cHV0IGZyb20gWFNTLlxuICogICBJdCdzIGJldHRlciB0byBleHRlbmQgZmVhdHVyZXMgdmlhIHBsdWdpbnMsIGluc3RlYWQgb2YgZW5hYmxpbmcgSFRNTC5cbiAqIC0gX194aHRtbE91dF9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBhZGQgJy8nIHdoZW4gY2xvc2luZyBzaW5nbGUgdGFnc1xuICogICAoYDxiciAvPmApLiBUaGlzIGlzIG5lZWRlZCBvbmx5IGZvciBmdWxsIENvbW1vbk1hcmsgY29tcGF0aWJpbGl0eS4gSW4gcmVhbFxuICogICB3b3JsZCB5b3Ugd2lsbCBuZWVkIEhUTUwgb3V0cHV0LlxuICogLSBfX2JyZWFrc19fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBjb252ZXJ0IGBcXG5gIGluIHBhcmFncmFwaHMgaW50byBgPGJyPmAuXG4gKiAtIF9fbGFuZ1ByZWZpeF9fIC0gYGxhbmd1YWdlLWAuIENTUyBsYW5ndWFnZSBjbGFzcyBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3MuXG4gKiAgIENhbiBiZSB1c2VmdWwgZm9yIGV4dGVybmFsIGhpZ2hsaWdodGVycy5cbiAqIC0gX19saW5raWZ5X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHQgdG8gbGlua3MuXG4gKiAtIF9fdHlwb2dyYXBoZXJfXyAgLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBbc29tZSBsYW5ndWFnZS1uZXV0cmFsXG4gKiAgIHJlcGxhY2VtZW50XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzKSArXG4gKiAgIHF1b3RlcyBiZWF1dGlmaWNhdGlvbiAoc21hcnRxdW90ZXMpLlxuICogLSBfX3F1b3Rlc19fIC0gYOKAnOKAneKAmOKAmWAsIFN0cmluZyBvciBBcnJheS4gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudFxuICogICBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkIGFuZCBzbWFydHF1b3RlcyBvbi4gRm9yIGV4YW1wbGUsIHlvdSBjYW5cbiAqICAgdXNlIGAnwqvCu+KAnuKAnCdgIGZvciBSdXNzaWFuLCBgJ+KAnuKAnOKAmuKAmCdgIGZvciBHZXJtYW4sIGFuZFxuICogICBgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXWAgZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICogLSBfX2hpZ2hsaWdodF9fIC0gYG51bGxgLiBIaWdobGlnaHRlciBmdW5jdGlvbiBmb3IgZmVuY2VkIGNvZGUgYmxvY2tzLlxuICogICBIaWdobGlnaHRlciBgZnVuY3Rpb24gKHN0ciwgbGFuZylgIHNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLiBJdCBjYW4gYWxzb1xuICogICByZXR1cm4gZW1wdHkgc3RyaW5nIGlmIHRoZSBzb3VyY2Ugd2FzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZFxuICogICBleHRlcm5hbHkuIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogLy8gY29tbW9ubWFyayBtb2RlXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCdjb21tb25tYXJrJyk7XG4gKlxuICogLy8gZGVmYXVsdCBtb2RlXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogLy8gZW5hYmxlIGV2ZXJ5dGhpbmdcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0Jykoe1xuICogICBodG1sOiB0cnVlLFxuICogICBsaW5raWZ5OiB0cnVlLFxuICogICB0eXBvZ3JhcGhlcjogdHJ1ZVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAjIyMjIyBTeW50YXggaGlnaGxpZ2h0aW5nXG4gKlxuICogYGBganNcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHN0ciwgbGFuZykge1xuICogICAgIGlmIChsYW5nICYmIGhsanMuZ2V0TGFuZ3VhZ2UobGFuZykpIHtcbiAqICAgICAgIHRyeSB7XG4gKiAgICAgICAgIHJldHVybiBobGpzLmhpZ2hsaWdodChsYW5nLCBzdHIsIHRydWUpLnZhbHVlO1xuICogICAgICAgfSBjYXRjaCAoX18pIHt9XG4gKiAgICAgfVxuICpcbiAqICAgICByZXR1cm4gJyc7IC8vIHVzZSBleHRlcm5hbCBkZWZhdWx0IGVzY2FwaW5nXG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogT3Igd2l0aCBmdWxsIHdyYXBwZXIgb3ZlcnJpZGUgKGlmIHlvdSBuZWVkIGFzc2lnbiBjbGFzcyB0byBgPHByZT5gKTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgaGxqcyA9IHJlcXVpcmUoJ2hpZ2hsaWdodC5qcycpIC8vIGh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuICpcbiAqIC8vIEFjdHVhbCBkZWZhdWx0IHZhbHVlc1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHN0ciwgbGFuZykge1xuICogICAgIGlmIChsYW5nICYmIGhsanMuZ2V0TGFuZ3VhZ2UobGFuZykpIHtcbiAqICAgICAgIHRyeSB7XG4gKiAgICAgICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICtcbiAqICAgICAgICAgICAgICAgIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWUgK1xuICogICAgICAgICAgICAgICAgJzwvY29kZT48L3ByZT4nO1xuICogICAgICAgfSBjYXRjaCAoX18pIHt9XG4gKiAgICAgfVxuICpcbiAqICAgICByZXR1cm4gJzxwcmUgY2xhc3M9XCJobGpzXCI+PGNvZGU+JyArIG1kLnV0aWxzLmVzY2FwZUh0bWwoc3RyKSArICc8L2NvZGU+PC9wcmU+JztcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiovXG5mdW5jdGlvbiBNYXJrZG93bkl0KHByZXNldE5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hcmtkb3duSXQpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93bkl0KHByZXNldE5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKCF1dGlscy5pc1N0cmluZyhwcmVzZXROYW1lKSkge1xuICAgICAgb3B0aW9ucyA9IHByZXNldE5hbWUgfHwge307XG4gICAgICBwcmVzZXROYW1lID0gJ2RlZmF1bHQnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2lubGluZSAtPiBQYXJzZXJJbmxpbmVcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJJbmxpbmVdXS4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuaW5saW5lID0gbmV3IFBhcnNlcklubGluZSgpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2Jsb2NrIC0+IFBhcnNlckJsb2NrXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUGFyc2VyQmxvY2tdXS4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuYmxvY2sgPSBuZXcgUGFyc2VyQmxvY2soKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNjb3JlIC0+IENvcmVcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tDb3JlXV0gY2hhaW4gZXhlY3V0b3IuIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cbiAgICogd3JpdGluZyBwbHVnaW5zLiBGb3Igc2ltcGxlIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0gYW5kXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cbiAgICoqL1xuICB0aGlzLmNvcmUgPSBuZXcgUGFyc2VyQ29yZSgpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3JlbmRlcmVyIC0+IFJlbmRlcmVyXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUmVuZGVyZXJdXS4gVXNlIGl0IHRvIG1vZGlmeSBvdXRwdXQgbG9vay4gT3IgdG8gYWRkIHJlbmRlcmluZ1xuICAgKiBydWxlcyBmb3IgbmV3IHRva2VuIHR5cGVzLCBnZW5lcmF0ZWQgYnkgcGx1Z2lucy5cbiAgICpcbiAgICogIyMjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICpcbiAgICogZnVuY3Rpb24gbXlUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzZWxmKSB7XG4gICAqICAgLy8uLi5cbiAgICogICByZXR1cm4gcmVzdWx0O1xuICAgKiB9O1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlc1snbXlfdG9rZW4nXSA9IG15VG9rZW5cbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbW1JlbmRlcmVyXV0gZG9jcyBhbmQgW3NvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3JlbmRlcmVyLmpzKS5cbiAgICoqL1xuICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbGlua2lmeSAtPiBMaW5raWZ5SXRcbiAgICpcbiAgICogW2xpbmtpZnktaXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0KSBpbnN0YW5jZS5cbiAgICogVXNlZCBieSBbbGlua2lmeV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMpXG4gICAqIHJ1bGUuXG4gICAqKi9cbiAgdGhpcy5saW5raWZ5ID0gbmV3IExpbmtpZnlJdCgpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3ZhbGlkYXRlTGluayh1cmwpIC0+IEJvb2xlYW5cbiAgICpcbiAgICogTGluayB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBDb21tb25NYXJrIGFsbG93cyB0b28gbXVjaCBpbiBsaW5rcy4gQnkgZGVmYXVsdFxuICAgKiB3ZSBkaXNhYmxlIGBqYXZhc2NyaXB0OmAsIGB2YnNjcmlwdDpgLCBgZmlsZTpgIHNjaGVtYXMsIGFuZCBhbG1vc3QgYWxsIGBkYXRhOi4uLmAgc2NoZW1hc1xuICAgKiBleGNlcHQgc29tZSBlbWJlZGRlZCBpbWFnZSB0eXBlcy5cbiAgICpcbiAgICogWW91IGNhbiBjaGFuZ2UgdGhpcyBiZWhhdmlvdXI6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICAgKiBtZC52YWxpZGF0ZUxpbmsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XG4gICAqIGBgYFxuICAgKiovXG4gIHRoaXMudmFsaWRhdGVMaW5rID0gdmFsaWRhdGVMaW5rO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I25vcm1hbGl6ZUxpbmsodXJsKSAtPiBTdHJpbmdcbiAgICpcbiAgICogRnVuY3Rpb24gdXNlZCB0byBlbmNvZGUgbGluayB1cmwgdG8gYSBtYWNoaW5lLXJlYWRhYmxlIGZvcm1hdCxcbiAgICogd2hpY2ggaW5jbHVkZXMgdXJsLWVuY29kaW5nLCBwdW55Y29kZSwgZXRjLlxuICAgKiovXG4gIHRoaXMubm9ybWFsaXplTGluayA9IG5vcm1hbGl6ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGlua1RleHQodXJsKSAtPiBTdHJpbmdcbiAgICpcbiAgICogRnVuY3Rpb24gdXNlZCB0byBkZWNvZGUgbGluayB1cmwgdG8gYSBodW1hbi1yZWFkYWJsZSBmb3JtYXRgXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rVGV4dCA9IG5vcm1hbGl6ZUxpbmtUZXh0O1xuXG5cbiAgLy8gRXhwb3NlIHV0aWxzICYgaGVscGVycyBmb3IgZWFzeSBhY2NlcyBmcm9tIHBsdWdpbnNcblxuICAvKipcbiAgICogTWFya2Rvd25JdCN1dGlscyAtPiB1dGlsc1xuICAgKlxuICAgKiBBc3NvcnRlZCB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZnVsIHRvIHdyaXRlIHBsdWdpbnMuIFNlZSBkZXRhaWxzXG4gICAqIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL2NvbW1vbi91dGlscy5qcykuXG4gICAqKi9cbiAgdGhpcy51dGlscyA9IHV0aWxzO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2hlbHBlcnMgLT4gaGVscGVyc1xuICAgKlxuICAgKiBMaW5rIGNvbXBvbmVudHMgcGFyc2VyIGZ1bmN0aW9ucywgdXNlZnVsIHRvIHdyaXRlIHBsdWdpbnMuIFNlZSBkZXRhaWxzXG4gICAqIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL2hlbHBlcnMpLlxuICAgKiovXG4gIHRoaXMuaGVscGVycyA9IHV0aWxzLmFzc2lnbih7fSwgaGVscGVycyk7XG5cblxuICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgdGhpcy5jb25maWd1cmUocHJlc2V0TmFtZSk7XG5cbiAgaWYgKG9wdGlvbnMpIHsgdGhpcy5zZXQob3B0aW9ucyk7IH1cbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LnNldChvcHRpb25zKVxuICpcbiAqIFNldCBwYXJzZXIgb3B0aW9ucyAoaW4gdGhlIHNhbWUgZm9ybWF0IGFzIGluIGNvbnN0cnVjdG9yKS4gUHJvYmFibHksIHlvdVxuICogd2lsbCBuZXZlciBuZWVkIGl0LCBidXQgeW91IGNhbiBjaGFuZ2Ugb3B0aW9ucyBhZnRlciBjb25zdHJ1Y3RvciBjYWxsLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcbiAqICAgICAgICAgICAgIC5zZXQoeyBodG1sOiB0cnVlLCBicmVha3M6IHRydWUgfSlcbiAqICAgICAgICAgICAgIC5zZXQoeyB0eXBvZ3JhcGhlciwgdHJ1ZSB9KTtcbiAqIGBgYFxuICpcbiAqIF9fTm90ZTpfXyBUbyBhY2hpZXZlIHRoZSBiZXN0IHBvc3NpYmxlIHBlcmZvcm1hbmNlLCBkb24ndCBtb2RpZnkgYVxuICogYG1hcmtkb3duLWl0YCBpbnN0YW5jZSBvcHRpb25zIG9uIHRoZSBmbHkuIElmIHlvdSBuZWVkIG11bHRpcGxlIGNvbmZpZ3VyYXRpb25zXG4gKiBpdCdzIGJlc3QgdG8gY3JlYXRlIG11bHRpcGxlIGluc3RhbmNlcyBhbmQgaW5pdGlhbGl6ZSBlYWNoIHdpdGggc2VwYXJhdGVcbiAqIGNvbmZpZy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHV0aWxzLmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZSwgaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQuY29uZmlndXJlKHByZXNldHMpXG4gKlxuICogQmF0Y2ggbG9hZCBvZiBhbGwgb3B0aW9ucyBhbmQgY29tcGVuZW50IHNldHRpbmdzLiBUaGlzIGlzIGludGVybmFsIG1ldGhvZCxcbiAqIGFuZCB5b3UgcHJvYmFibHkgd2lsbCBub3QgbmVlZCBpdC4gQnV0IGlmIHlvdSB3aXRoIC0gc2VlIGF2YWlsYWJsZSBwcmVzZXRzXG4gKiBhbmQgZGF0YSBzdHJ1Y3R1cmUgW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC90cmVlL21hc3Rlci9saWIvcHJlc2V0cylcbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIHByZXNldHMgaW5zdGVhZCBvZiBkaXJlY3QgY29uZmlnIGxvYWRzLiBUaGF0XG4gKiB3aWxsIGdpdmUgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCBuZXh0IHZlcnNpb25zLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHByZXNldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLCBwcmVzZXROYW1lO1xuXG4gIGlmICh1dGlscy5pc1N0cmluZyhwcmVzZXRzKSkge1xuICAgIHByZXNldE5hbWUgPSBwcmVzZXRzO1xuICAgIHByZXNldHMgPSBjb25maWdbcHJlc2V0TmFtZV07XG4gICAgaWYgKCFwcmVzZXRzKSB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQgXCInICsgcHJlc2V0TmFtZSArICdcIiwgY2hlY2sgbmFtZScpOyB9XG4gIH1cblxuICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCwgY2FuXFwndCBiZSBlbXB0eScpOyB9XG5cbiAgaWYgKHByZXNldHMub3B0aW9ucykgeyBzZWxmLnNldChwcmVzZXRzLm9wdGlvbnMpOyB9XG5cbiAgaWYgKHByZXNldHMuY29tcG9uZW50cykge1xuICAgIE9iamVjdC5rZXlzKHByZXNldHMuY29tcG9uZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlcykge1xuICAgICAgICBzZWxmW25hbWVdLnJ1bGVyLmVuYWJsZU9ubHkocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIyLmVuYWJsZU9ubHkocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZW5hYmxlKGxpc3QsIGlnbm9yZUludmFsaWQpXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IHJ1bGUgbmFtZSBvciBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgbGlzdCBvciBydWxlcy4gSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGZpbmQgYXBwcm9wcmlhdGUgY29tcG9uZW50cyxcbiAqIGNvbnRhaW5pbmcgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgcnVsZSBub3QgZm91bmQsIGFuZCBgaWdub3JlSW52YWxpZGBcbiAqIG5vdCBzZXQgLSB0aHJvd3MgZXhjZXB0aW9uLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcbiAqICAgICAgICAgICAgIC5lbmFibGUoWydzdWInLCAnc3VwJ10pXG4gKiAgICAgICAgICAgICAuZGlzYWJsZSgnc21hcnRxdW90ZXMnKTtcbiAqIGBgYFxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZW5hYmxlKGxpc3QsIHRydWUpKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZW5hYmxlKGxpc3QsIHRydWUpKTtcblxuICB2YXIgbWlzc2VkID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5hbWUpIDwgMDsgfSk7XG5cbiAgaWYgKG1pc3NlZC5sZW5ndGggJiYgIWlnbm9yZUludmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcmtkb3duSXQuIEZhaWxlZCB0byBlbmFibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LmRpc2FibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LmVuYWJsZV1dLCBidXQgdHVybiBzcGVjaWZpZWQgcnVsZXMgb2ZmLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgWyAnY29yZScsICdibG9jaycsICdpbmxpbmUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXNbY2hhaW5dLnJ1bGVyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5kaXNhYmxlKGxpc3QsIHRydWUpKTtcblxuICB2YXIgbWlzc2VkID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5hbWUpIDwgMDsgfSk7XG5cbiAgaWYgKG1pc3NlZC5sZW5ndGggJiYgIWlnbm9yZUludmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcmtkb3duSXQuIEZhaWxlZCB0byBkaXNhYmxlIHVua25vd24gcnVsZShzKTogJyArIG1pc3NlZCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQudXNlKHBsdWdpbiwgcGFyYW1zKVxuICpcbiAqIExvYWQgc3BlY2lmaWVkIHBsdWdpbiB3aXRoIGdpdmVuIHBhcmFtcyBpbnRvIGN1cnJlbnQgcGFyc2VyIGluc3RhbmNlLlxuICogSXQncyBqdXN0IGEgc3VnYXIgdG8gY2FsbCBgcGx1Z2luKG1kLCBwYXJhbXMpYCB3aXRoIGN1cnJpbmcuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBpdGVyYXRvciA9IHJlcXVpcmUoJ21hcmtkb3duLWl0LWZvci1pbmxpbmUnKTtcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnVzZShpdGVyYXRvciwgJ2Zvb19yZXBsYWNlJywgJ3RleHQnLCBmdW5jdGlvbiAodG9rZW5zLCBpZHgpIHtcbiAqICAgICAgICAgICAgICAgdG9rZW5zW2lkeF0uY29udGVudCA9IHRva2Vuc1tpZHhdLmNvbnRlbnQucmVwbGFjZSgvZm9vL2csICdiYXInKTtcbiAqICAgICAgICAgICAgIH0pO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luIC8qLCBwYXJhbXMsIC4uLiAqLykge1xuICB2YXIgYXJncyA9IFsgdGhpcyBdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgcGx1Z2luLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2Uoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBQYXJzZSBpbnB1dCBzdHJpbmcgYW5kIHJldHVybnMgbGlzdCBvZiBibG9jayB0b2tlbnMgKHNwZWNpYWwgdG9rZW4gdHlwZVxuICogXCJpbmxpbmVcIiB3aWxsIGNvbnRhaW4gbGlzdCBvZiBpbmxpbmUgdG9rZW5zKS4gWW91IHNob3VsZCBub3QgY2FsbCB0aGlzXG4gKiBtZXRob2QgZGlyZWN0bHksIHVudGlsIHlvdSB3cml0ZSBjdXN0b20gcmVuZGVyZXIgKGZvciBleGFtcGxlLCB0byBwcm9kdWNlXG4gKiBBU1QpLlxuICpcbiAqIGBlbnZgIGlzIHVzZWQgdG8gcGFzcyBkYXRhIGJldHdlZW4gXCJkaXN0cmlidXRlZFwiIHJ1bGVzIGFuZCByZXR1cm4gYWRkaXRpb25hbFxuICogbWV0YWRhdGEgbGlrZSByZWZlcmVuY2UgaW5mbywgbmVlZGVkIGZvciB0aGUgcmVuZGVyZXIuIEl0IGFsc28gY2FuIGJlIHVzZWQgdG9cbiAqIGluamVjdCBkYXRhIGluIHNwZWNpZmljIGNhc2VzLiBVc3VhbGx5LCB5b3Ugd2lsbCBiZSBvayB0byBwYXNzIGB7fWAsXG4gKiBhbmQgdGhlbiBwYXNzIHVwZGF0ZWQgb2JqZWN0IHRvIHJlbmRlcmVyLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHNob3VsZCBiZSBhIFN0cmluZycpO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudik7XG5cbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXIoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogUmVuZGVyIG1hcmtkb3duIHN0cmluZyBpbnRvIGh0bWwuIEl0IGRvZXMgYWxsIG1hZ2ljIGZvciB5b3UgOikuXG4gKlxuICogYGVudmAgY2FuIGJlIHVzZWQgdG8gaW5qZWN0IGFkZGl0aW9uYWwgbWV0YWRhdGEgKGB7fWAgYnkgZGVmYXVsdCkuXG4gKiBCdXQgeW91IHdpbGwgbm90IG5lZWQgaXQgd2l0aCBoaWdoIHByb2JhYmlsaXR5LiBTZWUgYWxzbyBjb21tZW50XG4gKiBpbiBbW01hcmtkb3duSXQucGFyc2VdXS5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBlbnYgPSBlbnYgfHwge307XG5cbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2Uoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZUlubGluZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFRoZSBzYW1lIGFzIFtbTWFya2Rvd25JdC5wYXJzZV1dIGJ1dCBza2lwIGFsbCBibG9jayBydWxlcy4gSXQgcmV0dXJucyB0aGVcbiAqIGJsb2NrIHRva2VucyBsaXN0IHdpdGggdGhlIHNpbmdsZSBgaW5saW5lYCBlbGVtZW50LCBjb250YWluaW5nIHBhcnNlZCBpbmxpbmVcbiAqIHRva2VucyBpbiBgY2hpbGRyZW5gIHByb3BlcnR5LiBBbHNvIHVwZGF0ZXMgYGVudmAgb2JqZWN0LlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudik7XG5cbiAgc3RhdGUuaW5saW5lTW9kZSA9IHRydWU7XG4gIHRoaXMuY29yZS5wcm9jZXNzKHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xufTtcblxuXG4vKipcbiAqIE1hcmtkb3duSXQucmVuZGVySW5saW5lKHNyYyBbLCBlbnZdKSAtPiBTdHJpbmdcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFNpbWlsYXIgdG8gW1tNYXJrZG93bkl0LnJlbmRlcl1dIGJ1dCBmb3Igc2luZ2xlIHBhcmFncmFwaCBjb250ZW50LiBSZXN1bHRcbiAqIHdpbGwgTk9UIGJlIHdyYXBwZWQgaW50byBgPHA+YCB0YWdzLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZUlubGluZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bkl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJCbG9ja1xuICpcbiAqIEJsb2NrLWxldmVsIHRva2VuaXplci5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbnZhciBfcnVsZXMgPSBbXG4gIC8vIEZpcnN0IDIgcGFyYW1zIC0gcnVsZSBuYW1lICYgc291cmNlLiBTZWNvbmRhcnkgYXJyYXkgLSBsaXN0IG9mIHJ1bGVzLFxuICAvLyB3aGljaCBjYW4gYmUgdGVybWluYXRlZCBieSB0aGlzIG9uZS5cbiAgWyAndGFibGUnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svdGFibGUnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJyBdIF0sXG4gIFsgJ2NvZGUnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2NvZGUnKSBdLFxuICBbICdmZW5jZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9mZW5jZScpLCAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2Jsb2NrcXVvdGUnLCByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUnKSwgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdsaXN0JyBdIF0sXG4gIFsgJ2hyJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hyJyksICAgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnbGlzdCcsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGlzdCcpLCAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncmVmZXJlbmNlJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcmVmZXJlbmNlJykgXSxcbiAgWyAnaGVhZGluZycsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaGVhZGluZycpLCAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnbGhlYWRpbmcnLCAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGhlYWRpbmcnKSBdLFxuICBbICdodG1sX2Jsb2NrJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9odG1sX2Jsb2NrJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdwYXJhZ3JhcGgnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9wYXJhZ3JhcGgnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlckJsb2NrKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlckJsb2NrKCkge1xuICAvKipcbiAgICogUGFyc2VyQmxvY2sjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgYmxvY2sgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdLCB7IGFsdDogKF9ydWxlc1tpXVsyXSB8fCBbXSkuc2xpY2UoKSB9KTtcbiAgfVxufVxuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJCbG9jay5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbGluZSA9IHN0YXJ0TGluZSxcbiAgICAgIGhhc0VtcHR5TGluZXMgPSBmYWxzZSxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKGxpbmUgPCBlbmRMaW5lKSB7XG4gICAgc3RhdGUubGluZSA9IGxpbmUgPSBzdGF0ZS5za2lwRW1wdHlMaW5lcyhsaW5lKTtcbiAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBUZXJtaW5hdGlvbiBjb25kaXRpb24gZm9yIG5lc3RlZCBjYWxscy5cbiAgICAvLyBOZXN0ZWQgY2FsbHMgY3VycmVudGx5IHVzZWQgZm9yIGJsb2NrcXVvdGVzICYgbGlzdHNcbiAgICBpZiAoc3RhdGUuc0NvdW50W2xpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBJZiBuZXN0aW5nIGxldmVsIGV4Y2VlZGVkIC0gc2tpcCB0YWlsIHRvIHRoZSBlbmQuIFRoYXQncyBub3Qgb3JkaW5hcnlcbiAgICAvLyBzaXR1YXRpb24gYW5kIHdlIHNob3VsZCBub3QgY2FyZSBhYm91dCBjb250ZW50LlxuICAgIGlmIChzdGF0ZS5sZXZlbCA+PSBtYXhOZXN0aW5nKSB7XG4gICAgICBzdGF0ZS5saW5lID0gZW5kTGluZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUubGluZWBcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlLnRpZ2h0IGlmZiB3ZSBoYWQgYW4gZW1wdHkgbGluZSBiZWZvcmUgY3VycmVudCB0YWdcbiAgICAvLyBpLmUuIGxhdGVzdCBlbXB0eSBsaW5lIHNob3VsZCBub3QgY291bnRcbiAgICBzdGF0ZS50aWdodCA9ICFoYXNFbXB0eUxpbmVzO1xuXG4gICAgLy8gcGFyYWdyYXBoIG1pZ2h0IFwiZWF0XCIgb25lIG5ld2xpbmUgYWZ0ZXIgaXQgaW4gbmVzdGVkIGxpc3RzXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsaW5lID0gc3RhdGUubGluZTtcblxuICAgIGlmIChsaW5lIDwgZW5kTGluZSAmJiBzdGF0ZS5pc0VtcHR5KGxpbmUpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICAgIGxpbmUrKztcbiAgICAgIHN0YXRlLmxpbmUgPSBsaW5lO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlckJsb2NrLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGJsb2NrIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXG4gKiovXG5QYXJzZXJCbG9jay5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3JjKSB7IHJldHVybjsgfVxuXG4gIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUsIHN0YXRlLmxpbmUsIHN0YXRlLmxpbmVNYXgpO1xufTtcblxuXG5QYXJzZXJCbG9jay5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIENvcmVcbiAqXG4gKiBUb3AtbGV2ZWwgcnVsZXMgZXhlY3V0b3IuIEdsdWVzIGJsb2NrL2lubGluZSBwYXJzZXJzIGFuZCBkb2VzIGludGVybWVkaWF0ZVxuICogdHJhbnNmb3JtYXRpb25zLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgWyAnbm9ybWFsaXplJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbm9ybWFsaXplJykgICAgICBdLFxuICBbICdibG9jaycsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ibG9jaycpICAgICAgICAgIF0sXG4gIFsgJ2lubGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2lubGluZScpICAgICAgICAgXSxcbiAgWyAnbGlua2lmeScsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbGlua2lmeScpICAgICAgICBdLFxuICBbICdyZXBsYWNlbWVudHMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9yZXBsYWNlbWVudHMnKSAgIF0sXG4gIFsgJ3NtYXJ0cXVvdGVzJywgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzJykgICAgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBDb3JlKClcbiAqKi9cbmZ1bmN0aW9uIENvcmUoKSB7XG4gIC8qKlxuICAgKiBDb3JlI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGNvcmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ29yZS5wcm9jZXNzKHN0YXRlKVxuICpcbiAqIEV4ZWN1dGVzIGNvcmUgY2hhaW4gcnVsZXMuXG4gKiovXG5Db3JlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBpLCBsLCBydWxlcztcblxuICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cbkNvcmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19jb3JlL3N0YXRlX2NvcmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2NvcmUuanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIFBhcnNlcklubGluZVxuICpcbiAqIFRva2VuaXplcyBwYXJhZ3JhcGggY29udGVudC5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQYXJzZXIgcnVsZXNcblxudmFyIF9ydWxlcyA9IFtcbiAgWyAndGV4dCcsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dCcpIF0sXG4gIFsgJ25ld2xpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL25ld2xpbmUnKSBdLFxuICBbICdlc2NhcGUnLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lc2NhcGUnKSBdLFxuICBbICdiYWNrdGlja3MnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWNrdGlja3MnKSBdLFxuICBbICdzdHJpa2V0aHJvdWdoJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoJykudG9rZW5pemUgXSxcbiAgWyAnZW1waGFzaXMnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW1waGFzaXMnKS50b2tlbml6ZSBdLFxuICBbICdsaW5rJywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9saW5rJykgXSxcbiAgWyAnaW1hZ2UnLCAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaW1hZ2UnKSBdLFxuICBbICdhdXRvbGluaycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9hdXRvbGluaycpIF0sXG4gIFsgJ2h0bWxfaW5saW5lJywgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lJykgXSxcbiAgWyAnZW50aXR5JywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW50aXR5JykgXVxuXTtcblxudmFyIF9ydWxlczIgPSBbXG4gIFsgJ2JhbGFuY2VfcGFpcnMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMnKSBdLFxuICBbICdzdHJpa2V0aHJvdWdoJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoJykucG9zdFByb2Nlc3MgXSxcbiAgWyAnZW1waGFzaXMnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW1waGFzaXMnKS5wb3N0UHJvY2VzcyBdLFxuICBbICd0ZXh0X2NvbGxhcHNlJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlJykgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBQYXJzZXJJbmxpbmUoKVxuICoqL1xuZnVuY3Rpb24gUGFyc2VySW5saW5lKCkge1xuICB2YXIgaTtcblxuICAvKipcbiAgICogUGFyc2VySW5saW5lI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGlubGluZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VySW5saW5lI3J1bGVyMiAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIFNlY29uZCBydWxlciB1c2VkIGZvciBwb3N0LXByb2Nlc3NpbmdcbiAgICogKGUuZy4gaW4gZW1waGFzaXMtbGlrZSBydWxlcykuXG4gICAqKi9cbiAgdGhpcy5ydWxlcjIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgX3J1bGVzMi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIyLnB1c2goX3J1bGVzMltpXVswXSwgX3J1bGVzMltpXVsxXSk7XG4gIH1cbn1cblxuXG4vLyBTa2lwIHNpbmdsZSB0b2tlbiBieSBydW5uaW5nIGFsbCBydWxlcyBpbiB2YWxpZGF0aW9uIG1vZGU7XG4vLyByZXR1cm5zIGB0cnVlYCBpZiBhbnkgcnVsZSByZXBvcnRlZCBzdWNjZXNzXG4vL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5za2lwVG9rZW4gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLCBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZyxcbiAgICAgIGNhY2hlID0gc3RhdGUuY2FjaGU7XG5cblxuICBpZiAodHlwZW9mIGNhY2hlW3Bvc10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUucG9zID0gY2FjaGVbcG9zXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBJbmNyZW1lbnQgc3RhdGUubGV2ZWwgYW5kIGRlY3JlbWVudCBpdCBsYXRlciB0byBsaW1pdCByZWN1cnNpb24uXG4gICAgICAvLyBJdCdzIGhhcm1sZXNzIHRvIGRvIGhlcmUsIGJlY2F1c2Ugbm8gdG9rZW5zIGFyZSBjcmVhdGVkLiBCdXQgaWRlYWxseSxcbiAgICAgIC8vIHdlJ2QgbmVlZCBhIHNlcGFyYXRlIHByaXZhdGUgc3RhdGUgdmFyaWFibGUgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgIC8vXG4gICAgICBzdGF0ZS5sZXZlbCsrO1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgdHJ1ZSk7XG4gICAgICBzdGF0ZS5sZXZlbC0tO1xuXG4gICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVG9vIG11Y2ggbmVzdGluZywganVzdCBza2lwIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmFncmFwaC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IHRoaXMgd2lsbCBjYXVzZSBsaW5rcyB0byBiZWhhdmUgaW5jb3JyZWN0bHkgaW4gdGhlIGZvbGxvd2luZyBjYXNlLFxuICAgIC8vICAgICAgIHdoZW4gYW4gYW1vdW50IG9mIGBbYCBpcyBleGFjdGx5IGVxdWFsIHRvIGBtYXhOZXN0aW5nICsgMWA6XG4gICAgLy9cbiAgICAvLyAgICAgICBbW1tbW1tbW1tbW1tbW1tbW1tbW1tmb29dKClcbiAgICAvL1xuICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIHdvcmthcm91bmQgd2hlbiBDTSBzdGFuZGFyZCB3aWxsIGFsbG93IG5lc3RlZCBsaW5rc1xuICAgIC8vICAgICAgICh3ZSBjYW4gcmVwbGFjZSBpdCBieSBwcmV2ZW50aW5nIGxpbmtzIGZyb20gYmVpbmcgcGFyc2VkIGluXG4gICAgLy8gICAgICAgdmFsaWRhdGlvbiBtb2RlKVxuICAgIC8vXG4gICAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4O1xuICB9XG5cbiAgaWYgKCFvaykgeyBzdGF0ZS5wb3MrKzsgfVxuICBjYWNoZVtwb3NdID0gc3RhdGUucG9zO1xufTtcblxuXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXG4vL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgZW5kID0gc3RhdGUucG9zTWF4LFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgZW5kKSB7XG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCBydWxlIHNob3VsZDpcbiAgICAvL1xuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5wb3NgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2spIHtcbiAgICAgIGlmIChzdGF0ZS5wb3MgPj0gZW5kKSB7IGJyZWFrOyB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1tzdGF0ZS5wb3MrK107XG4gIH1cblxuICBpZiAoc3RhdGUucGVuZGluZykge1xuICAgIHN0YXRlLnB1c2hQZW5kaW5nKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXJzZXJJbmxpbmUucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggaW5saW5lIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXG4gKiovXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHZhciBpLCBydWxlcywgbGVuO1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzdHIsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSk7XG5cbiAgcnVsZXMgPSB0aGlzLnJ1bGVyMi5nZXRSdWxlcygnJyk7XG4gIGxlbiA9IHJ1bGVzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cblxuUGFyc2VySW5saW5lLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VySW5saW5lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9pbmxpbmUuanMiLCIvLyBDb21tb25tYXJrIGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIHRydWUsICAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIHRydWUsICAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAnY29kZScsXG4gICAgICAgICdmZW5jZScsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2hyJyxcbiAgICAgICAgJ2h0bWxfYmxvY2snLFxuICAgICAgICAnbGhlYWRpbmcnLFxuICAgICAgICAnbGlzdCcsXG4gICAgICAgICdyZWZlcmVuY2UnLFxuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdhdXRvbGluaycsXG4gICAgICAgICdiYWNrdGlja3MnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZW50aXR5JyxcbiAgICAgICAgJ2VzY2FwZScsXG4gICAgICAgICdodG1sX2lubGluZScsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICdsaW5rJyxcbiAgICAgICAgJ25ld2xpbmUnLFxuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzIiwiLy8gbWFya2Rvd24taXQgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgZmFsc2UsICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDEwMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHt9LFxuICAgIGJsb2NrOiB7fSxcbiAgICBpbmxpbmU6IHt9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9kZWZhdWx0LmpzIiwiLy8gXCJaZXJvXCIgcHJlc2V0LCB3aXRoIG5vdGhpbmcgZW5hYmxlZC4gVXNlZnVsIGZvciBtYW51YWwgY29uZmlndXJpbmcgb2Ygc2ltcGxlXG4vLyBtb2Rlcy4gRm9yIGV4YW1wbGUsIHRvIHBhcnNlIGJvbGQvaXRhbGljIG9ubHkuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgZmFsc2UsICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL3plcm8uanMiLCIvKipcbiAqIGNsYXNzIFJlbmRlcmVyXG4gKlxuICogR2VuZXJhdGVzIEhUTUwgZnJvbSBwYXJzZWQgdG9rZW4gc3RyZWFtLiBFYWNoIGluc3RhbmNlIGhhcyBpbmRlcGVuZGVudFxuICogY29weSBvZiBydWxlcy4gVGhvc2UgY2FuIGJlIHJld3JpdHRlbiB3aXRoIGVhc2UuIEFsc28sIHlvdSBjYW4gYWRkIG5ld1xuICogcnVsZXMgaWYgeW91IGNyZWF0ZSBwbHVnaW4gYW5kIGFkZHMgbmV3IHRva2VuIHR5cGVzLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhc3NpZ24gICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmFzc2lnbjtcbnZhciB1bmVzY2FwZUFsbCAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xudmFyIGVzY2FwZUh0bWwgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuZXNjYXBlSHRtbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZGVmYXVsdF9ydWxlcyA9IHt9O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+Jztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8cHJlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPjxjb2RlPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5mZW5jZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF0sXG4gICAgICBpbmZvID0gdG9rZW4uaW5mbyA/IHVuZXNjYXBlQWxsKHRva2VuLmluZm8pLnRyaW0oKSA6ICcnLFxuICAgICAgbGFuZ05hbWUgPSAnJyxcbiAgICAgIGhpZ2hsaWdodGVkLCBpLCB0bXBBdHRycywgdG1wVG9rZW47XG5cbiAgaWYgKGluZm8pIHtcbiAgICBsYW5nTmFtZSA9IGluZm8uc3BsaXQoL1xccysvZylbMF07XG4gIH1cblxuICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICBoaWdobGlnaHRlZCA9IG9wdGlvbnMuaGlnaGxpZ2h0KHRva2VuLmNvbnRlbnQsIGxhbmdOYW1lKSB8fCBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodGVkID0gZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfVxuXG4gIGlmIChoaWdobGlnaHRlZC5pbmRleE9mKCc8cHJlJykgPT09IDApIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgKyAnXFxuJztcbiAgfVxuXG4gIC8vIElmIGxhbmd1YWdlIGV4aXN0cywgaW5qZWN0IGNsYXNzIGdlbnRseSwgd2l0aG91dCBtdWRvZnlpbmcgb3JpZ2luYWwgdG9rZW4uXG4gIC8vIE1heSBiZSwgb25lIGRheSB3ZSB3aWxsIGFkZCAuY2xvbmUoKSBmb3IgdG9rZW4gYW5kIHNpbXBsaWZ5IHRoaXMgcGFydCwgYnV0XG4gIC8vIG5vdyB3ZSBwcmVmZXIgdG8ga2VlcCB0aGluZ3MgbG9jYWwuXG4gIGlmIChpbmZvKSB7XG4gICAgaSAgICAgICAgPSB0b2tlbi5hdHRySW5kZXgoJ2NsYXNzJyk7XG4gICAgdG1wQXR0cnMgPSB0b2tlbi5hdHRycyA/IHRva2VuLmF0dHJzLnNsaWNlKCkgOiBbXTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgdG1wQXR0cnMucHVzaChbICdjbGFzcycsIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lIF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXBBdHRyc1tpXVsxXSArPSAnICcgKyBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZTtcbiAgICB9XG5cbiAgICAvLyBGYWtlIHRva2VuIGp1c3QgdG8gcmVuZGVyIGF0dHJpYnV0ZXNcbiAgICB0bXBUb2tlbiA9IHtcbiAgICAgIGF0dHJzOiB0bXBBdHRyc1xuICAgIH07XG5cbiAgICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0bXBUb2tlbikgKyAnPidcbiAgICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gIH1cblxuXG4gIHJldHVybiAgJzxwcmU+PGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+J1xuICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmltYWdlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBcImFsdFwiIGF0dHIgTVVTVCBiZSBzZXQsIGV2ZW4gaWYgZW1wdHkuIEJlY2F1c2UgaXQncyBtYW5kYXRvcnkgYW5kXG4gIC8vIHNob3VsZCBiZSBwbGFjZWQgb24gcHJvcGVyIHBvc2l0aW9uIGZvciB0ZXN0cy5cbiAgLy9cbiAgLy8gUmVwbGFjZSBjb250ZW50IHdpdGggYWN0dWFsIHZhbHVlXG5cbiAgdG9rZW4uYXR0cnNbdG9rZW4uYXR0ckluZGV4KCdhbHQnKV1bMV0gPVxuICAgIHNsZi5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW4uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG5cbiAgcmV0dXJuIHNsZi5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucyk7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaGFyZGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJztcbn07XG5kZWZhdWx0X3J1bGVzLnNvZnRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLmJyZWFrcyA/IChvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbicpIDogJ1xcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMudGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmh0bWxfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5kZWZhdWx0X3J1bGVzLmh0bWxfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuXG5cbi8qKlxuICogbmV3IFJlbmRlcmVyKClcbiAqXG4gKiBDcmVhdGVzIG5ldyBbW1JlbmRlcmVyXV0gaW5zdGFuY2UgYW5kIGZpbGwgW1tSZW5kZXJlciNydWxlc11dIHdpdGggZGVmYXVsdHMuXG4gKiovXG5mdW5jdGlvbiBSZW5kZXJlcigpIHtcblxuICAvKipcbiAgICogUmVuZGVyZXIjcnVsZXMgLT4gT2JqZWN0XG4gICAqXG4gICAqIENvbnRhaW5zIHJlbmRlciBydWxlcyBmb3IgdG9rZW5zLiBDYW4gYmUgdXBkYXRlZCBhbmQgZXh0ZW5kZWQuXG4gICAqXG4gICAqICMjIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19vcGVuICA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8Yj4nOyB9O1xuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfY2xvc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPC9iPic7IH07XG4gICAqXG4gICAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoLi4uKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEVhY2ggcnVsZSBpcyBjYWxsZWQgYXMgaW5kZXBlbmRlZCBzdGF0aWMgZnVuY3Rpb24gd2l0aCBmaXhlZCBzaWduYXR1cmU6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogZnVuY3Rpb24gbXlfdG9rZW5fcmVuZGVyKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHJlbmRlcmVyKSB7XG4gICAqICAgLy8gLi4uXG4gICAqICAgcmV0dXJuIHJlbmRlcmVkSFRNTDtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5qcylcbiAgICogZm9yIG1vcmUgZGV0YWlscyBhbmQgZXhhbXBsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlcyA9IGFzc2lnbih7fSwgZGVmYXVsdF9ydWxlcyk7XG59XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJBdHRycyh0b2tlbikgLT4gU3RyaW5nXG4gKlxuICogUmVuZGVyIHRva2VuIGF0dHJpYnV0ZXMgdG8gc3RyaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckF0dHJzID0gZnVuY3Rpb24gcmVuZGVyQXR0cnModG9rZW4pIHtcbiAgdmFyIGksIGwsIHJlc3VsdDtcblxuICBpZiAoIXRva2VuLmF0dHJzKSB7IHJldHVybiAnJzsgfVxuXG4gIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAoaSA9IDAsIGwgPSB0b2tlbi5hdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByZXN1bHQgKz0gJyAnICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVswXSkgKyAnPVwiJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMV0pICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvZiB0b2tlbnNcbiAqIC0gaWR4IChOdW1iZWQpOiB0b2tlbiBpbmRleCB0byByZW5kZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICpcbiAqIERlZmF1bHQgdG9rZW4gcmVuZGVyZXIuIENhbiBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGZ1bmN0aW9uXG4gKiBpbiBbW1JlbmRlcmVyI3J1bGVzXV0uXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVG9rZW4gPSBmdW5jdGlvbiByZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykge1xuICB2YXIgbmV4dFRva2VuLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBuZWVkTGYgPSBmYWxzZSxcbiAgICAgIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gVGlnaHQgbGlzdCBwYXJhZ3JhcGhzXG4gIGlmICh0b2tlbi5oaWRkZW4pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyBJbnNlcnQgYSBuZXdsaW5lIGJldHdlZW4gaGlkZGVuIHBhcmFncmFwaCBhbmQgc3Vic2VxdWVudCBvcGVuaW5nXG4gIC8vIGJsb2NrLWxldmVsIHRhZy5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIGhlcmUgd2Ugc2hvdWxkIGluc2VydCBhIG5ld2xpbmUgYmVmb3JlIGJsb2NrcXVvdGU6XG4gIC8vICAtIGFcbiAgLy8gICAgPlxuICAvL1xuICBpZiAodG9rZW4uYmxvY2sgJiYgdG9rZW4ubmVzdGluZyAhPT0gLTEgJiYgaWR4ICYmIHRva2Vuc1tpZHggLSAxXS5oaWRkZW4pIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBBZGQgdG9rZW4gbmFtZSwgZS5nLiBgPGltZ2BcbiAgcmVzdWx0ICs9ICh0b2tlbi5uZXN0aW5nID09PSAtMSA/ICc8LycgOiAnPCcpICsgdG9rZW4udGFnO1xuXG4gIC8vIEVuY29kZSBhdHRyaWJ1dGVzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiYFxuICByZXN1bHQgKz0gdGhpcy5yZW5kZXJBdHRycyh0b2tlbik7XG5cbiAgLy8gQWRkIGEgc2xhc2ggZm9yIHNlbGYtY2xvc2luZyB0YWdzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiIC9gXG4gIGlmICh0b2tlbi5uZXN0aW5nID09PSAwICYmIG9wdGlvbnMueGh0bWxPdXQpIHtcbiAgICByZXN1bHQgKz0gJyAvJztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGEgbmV3bGluZSBhZnRlciB0aGlzIHRhZ1xuICBpZiAodG9rZW4uYmxvY2spIHtcbiAgICBuZWVkTGYgPSB0cnVlO1xuXG4gICAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDEpIHtcbiAgICAgIGlmIChpZHggKyAxIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBuZXh0VG9rZW4gPSB0b2tlbnNbaWR4ICsgMV07XG5cbiAgICAgICAgaWYgKG5leHRUb2tlbi50eXBlID09PSAnaW5saW5lJyB8fCBuZXh0VG9rZW4uaGlkZGVuKSB7XG4gICAgICAgICAgLy8gQmxvY2stbGV2ZWwgdGFnIGNvbnRhaW5pbmcgYW4gaW5saW5lIHRhZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFRva2VuLm5lc3RpbmcgPT09IC0xICYmIG5leHRUb2tlbi50YWcgPT09IHRva2VuLnRhZykge1xuICAgICAgICAgIC8vIE9wZW5pbmcgdGFnICsgY2xvc2luZyB0YWcgb2YgdGhlIHNhbWUgdHlwZS4gRS5nLiBgPGxpPjwvbGk+YC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ICs9IG5lZWRMZiA/ICc+XFxuJyA6ICc+JztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZSh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogVGhlIHNhbWUgYXMgW1tSZW5kZXJlci5yZW5kZXJdXSwgYnV0IGZvciBzaW5nbGUgdG9rZW4gb2YgYGlubGluZWAgdHlwZS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHR5cGUsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFNwZWNpYWwga2x1ZGdlIGZvciBpbWFnZSBgYWx0YCBhdHRyaWJ1dGVzIHRvIGNvbmZvcm0gQ29tbW9uTWFyayBzcGVjLlxuICogRG9uJ3QgdHJ5IHRvIHVzZSBpdCEgU3BlYyByZXF1aXJlcyB0byBzaG93IGBhbHRgIGNvbnRlbnQgd2l0aCBzdHJpcHBlZCBtYXJrdXAsXG4gKiBpbnN0ZWFkIG9mIHNpbXBsZSBlc2NhcGluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmVBc1RleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzdWx0ICs9IHRva2Vuc1tpXS5jb250ZW50O1xuICAgIH0gZWxzZSBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXIodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRha2VzIHRva2VuIHN0cmVhbSBhbmQgZ2VuZXJhdGVzIEhUTUwuIFByb2JhYmx5LCB5b3Ugd2lsbCBuZXZlciBuZWVkIHRvIGNhbGxcbiAqIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgaSwgbGVuLCB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmUodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3Rva2Vuc1tpXS50eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qcyIsIi8vIEJsb2NrIHF1b3Rlc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBhZGp1c3RUYWIsXG4gICAgICBjaCxcbiAgICAgIGksXG4gICAgICBpbml0aWFsLFxuICAgICAgaXNPdXRkZW50ZWQsXG4gICAgICBsLFxuICAgICAgbGFzdExpbmVFbXB0eSxcbiAgICAgIGxpbmVzLFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRCTWFya3MsXG4gICAgICBvbGRCU0NvdW50LFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFNDb3VudCxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0b2tlbixcbiAgICAgIG9sZExpbmVNYXggPSBzdGF0ZS5saW5lTWF4LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNoZWNrIHRoZSBibG9jayBxdW90ZSBtYXJrZXJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gd2Uga25vdyB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgYSB2YWxpZCBibG9ja3F1b3RlLFxuICAvLyBzbyBubyBwb2ludCB0cnlpbmcgdG8gZmluZCB0aGUgZW5kIG9mIGl0IGluIHNpbGVudCBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBza2lwIHNwYWNlcyBhZnRlciBcIj5cIiBhbmQgcmUtY2FsY3VsYXRlIG9mZnNldFxuICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyBwb3MgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgLy8gJyA+ICAgdGVzdCAnXG4gICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgIHBvcysrO1xuICAgIGluaXRpYWwrKztcbiAgICBvZmZzZXQrKztcbiAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgaWYgKChzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgLy8gJyAgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICBwb3MrKztcbiAgICAgIGluaXRpYWwrKztcbiAgICAgIG9mZnNldCsrO1xuICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgIC8vICAgICAgICAgdG8gbWFrZSBleHRyYSBzcGFjZSBhcHBlYXJcbiAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgfVxuXG4gIG9sZEJNYXJrcyA9IFsgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gPSBwb3M7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIG9sZEJTQ291bnQgPSBbIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICBvbGRTQ291bnQgPSBbIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICBvbGRUU2hpZnQgPSBbIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2Jsb2NrcXVvdGUnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdibG9ja3F1b3RlJztcblxuICAvLyBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgYmxvY2tcbiAgLy9cbiAgLy8gQmxvY2sgZW5kcyB3aXRoIGVpdGhlcjpcbiAgLy8gIDEuIGFuIGVtcHR5IGxpbmUgb3V0c2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vXG4gIC8vICAgICBgYGBcbiAgLy8gIDIuIGFuIGVtcHR5IGxpbmUgaW5zaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+XG4gIC8vICAgICB0ZXN0XG4gIC8vICAgICBgYGBcbiAgLy8gIDMuIGFub3RoZXIgdGFnOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy8gICAgICAtIC0gLVxuICAvLyAgICAgYGBgXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAxOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAvLyBjaGVjayBpZiBpdCdzIG91dGRlbnRlZCwgaS5lLiBpdCdzIGluc2lkZSBsaXN0IGl0ZW0gYW5kIGluZGVudGVkXG4gICAgLy8gbGVzcyB0aGFuIHNhaWQgbGlzdCBpdGVtOlxuICAgIC8vXG4gICAgLy8gYGBgXG4gICAgLy8gMS4gYW55dGhpbmdcbiAgICAvLyAgICA+IGN1cnJlbnQgYmxvY2txdW90ZVxuICAgIC8vIDIuIGNoZWNraW5nIHRoaXMgbGluZVxuICAgIC8vIGBgYFxuICAgIGlzT3V0ZGVudGVkID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudDtcblxuICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgLy8gQ2FzZSAxOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGlzIGxpbmUgaXMgZW1wdHkuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspID09PSAweDNFLyogPiAqLyAmJiAhaXNPdXRkZW50ZWQpIHtcbiAgICAgIC8vIFRoaXMgbGluZSBpcyBpbnNpZGUgdGhlIGJsb2NrcXVvdGUuXG5cbiAgICAgIC8vIHNraXAgc3BhY2VzIGFmdGVyIFwiPlwiIGFuZCByZS1jYWxjdWxhdGUgb2Zmc2V0XG4gICAgICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIHBvcyAtIChzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG5cbiAgICAgIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjAgLyogc3BhY2UgKi8pIHtcbiAgICAgICAgLy8gJyA+ICAgdGVzdCAnXG4gICAgICAgIC8vICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZTpcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGluaXRpYWwrKztcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG5cbiAgICAgICAgaWYgKChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSArIG9mZnNldCkgJSA0ID09PSAzKSB7XG4gICAgICAgICAgLy8gJyAgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGluaXRpYWwrKztcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICsgc2hpZnQgYnNDb3VudCBzbGlnaHRseVxuICAgICAgICAgIC8vICAgICAgICAgdG8gbWFrZSBleHRyYSBzcGFjZSBhcHBlYXJcbiAgICAgICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuYk1hcmtzW25leHRMaW5lXSA9IHBvcztcblxuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4O1xuXG4gICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgMSArIChzcGFjZUFmdGVyTWFya2VyID8gMSA6IDApO1xuXG4gICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsO1xuXG4gICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ2FzZSAyOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGUgbGFzdCBsaW5lIHdhcyBlbXB0eS5cbiAgICBpZiAobGFzdExpbmVFbXB0eSkgeyBicmVhazsgfVxuXG4gICAgLy8gQ2FzZSAzOiBhbm90aGVyIHRhZyBmb3VuZC5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgIC8vIFF1aXJrIHRvIGVuZm9yY2UgXCJoYXJkIHRlcm1pbmF0aW9uIG1vZGVcIiBmb3IgcGFyYWdyYXBocztcbiAgICAgIC8vIG5vcm1hbGx5IGlmIHlvdSBjYWxsIGB0b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSlgLFxuICAgICAgLy8gcGFyYWdyYXBocyB3aWxsIGxvb2sgYmVsb3cgbmV4dExpbmUgZm9yIHBhcmFncmFwaCBjb250aW51YXRpb24sXG4gICAgICAvLyBidXQgaWYgYmxvY2txdW90ZSBpcyB0ZXJtaW5hdGVkIGJ5IGFub3RoZXIgdGFnLCB0aGV5IHNob3VsZG4ndFxuICAgICAgc3RhdGUubGluZU1heCA9IG5leHRMaW5lO1xuXG4gICAgICBpZiAoc3RhdGUuYmxrSW5kZW50ICE9PSAwKSB7XG4gICAgICAgIC8vIHN0YXRlLmJsa0luZGVudCB3YXMgbm9uLXplcm8sIHdlIG5vdyBzZXQgaXQgdG8gemVybyxcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgYWxsIG9mZnNldHMgdG8gYXBwZWFyIGFzXG4gICAgICAgIC8vIGlmIGluZGVudCB3YXNuJ3QgY2hhbmdlZFxuICAgICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC09IHN0YXRlLmJsa0luZGVudDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlzT3V0ZGVudGVkKSBicmVhaztcblxuICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG5cbiAgICAvLyBBIG5lZ2F0aXZlIGluZGVudGF0aW9uIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAvL1xuICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSAtMTtcbiAgfVxuXG4gIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgc3RhdGUuYmxrSW5kZW50ID0gMDtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX29wZW4nLCAnYmxvY2txdW90ZScsIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG4gIHRva2VuLm1hcCAgICA9IGxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSk7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9jbG9zZScsICdibG9ja3F1b3RlJywgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG5cbiAgc3RhdGUubGluZU1heCA9IG9sZExpbmVNYXg7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XG5cbiAgLy8gUmVzdG9yZSBvcmlnaW5hbCB0U2hpZnQ7IHRoaXMgbWlnaHQgbm90IGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgcGFyc2VyXG4gIC8vIGhhcyBhbHJlYWR5IGJlZW4gaGVyZSwgYnV0IGp1c3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBkbyB0aGF0LlxuICBmb3IgKGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldO1xuICAgIHN0YXRlLnRTaGlmdFtpICsgc3RhcnRMaW5lXSA9IG9sZFRTaGlmdFtpXTtcbiAgICBzdGF0ZS5zQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRTQ291bnRbaV07XG4gICAgc3RhdGUuYnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZEJTQ291bnRbaV07XG4gIH1cbiAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9ibG9ja3F1b3RlLmpzIiwiLy8gQ29kZSBibG9jayAoNCBzcGFjZXMgcGFkZGVkKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2RlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIG5leHRMaW5lLCBsYXN0LCB0b2tlbjtcblxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPCA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhc3QgPSBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xuICAgIGlmIChzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBsYXN0ID0gbmV4dExpbmU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbGFzdDtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnY29kZV9ibG9jaycsICdjb2RlJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIGxhc3QsIDQgKyBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIi8vIGZlbmNlcyAoYGBgIGxhbmcsIH5+fiBsYW5nKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG1hcmtlciwgbGVuLCBwYXJhbXMsIG5leHRMaW5lLCBtZW0sIHRva2VuLCBtYXJrdXAsXG4gICAgICBoYXZlRW5kTWFya2VyID0gZmFsc2UsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDMgPiBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLyAmJiBtYXJrZXIgIT09IDB4NjAgLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHNjYW4gbWFya2VyIGxlbmd0aFxuICBtZW0gPSBwb3M7XG4gIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgbGVuID0gcG9zIC0gbWVtO1xuXG4gIGlmIChsZW4gPCAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmt1cCA9IHN0YXRlLnNyYy5zbGljZShtZW0sIHBvcyk7XG4gIHBhcmFtcyA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgaWYgKHBhcmFtcy5pbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSkgPj0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW5jZSBzdGFydCBpcyBmb3VuZCwgd2UgY2FuIHJlcG9ydCBzdWNjZXNzIGhlcmUgaW4gdmFsaWRhdGlvbiBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBzZWFyY2ggZW5kIG9mIGJsb2NrXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuXG4gIGZvciAoOzspIHtcbiAgICBuZXh0TGluZSsrO1xuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7XG4gICAgICAvLyB1bmNsb3NlZCBibG9jayBzaG91bGQgYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgZG9jdW1lbnQuXG4gICAgICAvLyBhbHNvIGJsb2NrIHNlZW1zIHRvIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIHBhcmVudFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zID0gbWVtID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgLy8gbm9uLWVtcHR5IGxpbmUgd2l0aCBuZWdhdGl2ZSBpbmRlbnQgc2hvdWxkIHN0b3AgdGhlIGxpc3Q6XG4gICAgICAvLyAtIGBgYFxuICAgICAgLy8gIHRlc3RcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBtYXJrZXIpIHsgY29udGludWU7IH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIC8vIGNsb3NpbmcgZmVuY2Ugc2hvdWxkIGJlIGluZGVudGVkIGxlc3MgdGhhbiA0IHNwYWNlc1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICAgIC8vIGNsb3NpbmcgY29kZSBmZW5jZSBtdXN0IGJlIGF0IGxlYXN0IGFzIGxvbmcgYXMgdGhlIG9wZW5pbmcgb25lXG4gICAgaWYgKHBvcyAtIG1lbSA8IGxlbikgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRhaWwgaGFzIHNwYWNlcyBvbmx5XG4gICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgaWYgKHBvcyA8IG1heCkgeyBjb250aW51ZTsgfVxuXG4gICAgaGF2ZUVuZE1hcmtlciA9IHRydWU7XG4gICAgLy8gZm91bmQhXG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBJZiBhIGZlbmNlIGhhcyBoZWFkaW5nIHNwYWNlcywgdGhleSBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGl0cyBpbm5lciBibG9ja1xuICBsZW4gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAoaGF2ZUVuZE1hcmtlciA/IDEgOiAwKTtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnZmVuY2UnLCAnY29kZScsIDApO1xuICB0b2tlbi5pbmZvICAgID0gcGFyYW1zO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lICsgMSwgbmV4dExpbmUsIGxlbiwgdHJ1ZSk7XG4gIHRva2VuLm1hcmt1cCAgPSBtYXJrdXA7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIi8vIGhlYWRpbmcgKCMsICMjLCAuLi4pXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsZXZlbCwgdG1wLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCAgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHgyMy8qICMgKi8gfHwgcG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjb3VudCBoZWFkaW5nIGxldmVsXG4gIGxldmVsID0gMTtcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIHdoaWxlIChjaCA9PT0gMHgyMy8qICMgKi8gJiYgcG9zIDwgbWF4ICYmIGxldmVsIDw9IDYpIHtcbiAgICBsZXZlbCsrO1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB9XG5cbiAgaWYgKGxldmVsID4gNiB8fCAocG9zIDwgbWF4ICYmICFpc1NwYWNlKGNoKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIExldCdzIGN1dCB0YWlscyBsaWtlICcgICAgIyMjICAnIGZyb20gdGhlIGVuZCBvZiBzdHJpbmdcblxuICBtYXggPSBzdGF0ZS5za2lwU3BhY2VzQmFjayhtYXgsIHBvcyk7XG4gIHRtcCA9IHN0YXRlLnNraXBDaGFyc0JhY2sobWF4LCAweDIzLCBwb3MpOyAvLyAjXG4gIGlmICh0bXAgPiBwb3MgJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdCh0bXAgLSAxKSkpIHtcbiAgICBtYXggPSB0bXA7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS50cmltKCk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaGVhZGluZy5qcyIsIi8vIEhvcml6b250YWwgcnVsZVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhyKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBjbnQsIGNoLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgLy8gQ2hlY2sgaHIgbWFya2VyXG4gIGlmIChtYXJrZXIgIT09IDB4MkEvKiAqICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkQvKiAtICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4NUYvKiBfICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbWFya2VycyBjYW4gYmUgbWl4ZWQgd2l0aCBzcGFjZXMsIGJ1dCB0aGVyZSBzaG91bGQgYmUgYXQgbGVhc3QgMyBvZiB0aGVtXG5cbiAgY250ID0gMTtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAgIGlmIChjaCAhPT0gbWFya2VyICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoY2ggPT09IG1hcmtlcikgeyBjbnQrKzsgfVxuICB9XG5cbiAgaWYgKGNudCA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hyJywgJ2hyJywgMCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLm1hcmt1cCA9IEFycmF5KGNudCArIDEpLmpvaW4oU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHIuanMiLCIvLyBIVE1MIGJsb2NrXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYmxvY2tfbmFtZXMgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9ibG9ja3MnKTtcbnZhciBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX09QRU5fQ0xPU0VfVEFHX1JFO1xuXG4vLyBBbiBhcnJheSBvZiBvcGVuaW5nIGFuZCBjb3JyZXNwb25kaW5nIGNsb3Npbmcgc2VxdWVuY2VzIGZvciBodG1sIHRhZ3MsXG4vLyBsYXN0IGFyZ3VtZW50IGRlZmluZXMgd2hldGhlciBpdCBjYW4gdGVybWluYXRlIGEgcGFyYWdyYXBoIG9yIG5vdFxuLy9cbnZhciBIVE1MX1NFUVVFTkNFUyA9IFtcbiAgWyAvXjwoc2NyaXB0fHByZXxzdHlsZSkoPz0oXFxzfD58JCkpL2ksIC88XFwvKHNjcmlwdHxwcmV8c3R5bGUpPi9pLCB0cnVlIF0sXG4gIFsgL148IS0tLywgICAgICAgIC8tLT4vLCAgIHRydWUgXSxcbiAgWyAvXjxcXD8vLCAgICAgICAgIC9cXD8+LywgICB0cnVlIF0sXG4gIFsgL148IVtBLVpdLywgICAgIC8+LywgICAgIHRydWUgXSxcbiAgWyAvXjwhXFxbQ0RBVEFcXFsvLCAvXFxdXFxdPi8sIHRydWUgXSxcbiAgWyBuZXcgUmVnRXhwKCdePC8/KCcgKyBibG9ja19uYW1lcy5qb2luKCd8JykgKyAnKSg/PShcXFxcc3wvPz58JCkpJywgJ2knKSwgL14kLywgdHJ1ZSBdLFxuICBbIG5ldyBSZWdFeHAoSFRNTF9PUEVOX0NMT1NFX1RBR19SRS5zb3VyY2UgKyAnXFxcXHMqJCcpLCAgL14kLywgZmFsc2UgXVxuXTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfYmxvY2soc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBpLCBuZXh0TGluZSwgdG9rZW4sIGxpbmVUZXh0LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzBdLnRlc3QobGluZVRleHQpKSB7IGJyZWFrOyB9XG4gIH1cblxuICBpZiAoaSA9PT0gSFRNTF9TRVFVRU5DRVMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHtcbiAgICAvLyB0cnVlIGlmIHRoaXMgc2VxdWVuY2UgY2FuIGJlIGEgdGVybWluYXRvciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgcmV0dXJuIEhUTUxfU0VRVUVOQ0VTW2ldWzJdO1xuICB9XG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIC8vIElmIHdlIGFyZSBoZXJlIC0gd2UgZGV0ZWN0ZWQgSFRNTCBibG9jay5cbiAgLy8gTGV0J3Mgcm9sbCBkb3duIHRpbGwgYmxvY2sgZW5kLlxuICBpZiAoIUhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuICAgICAgbGluZVRleHQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gICAgICBpZiAoSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICAgICAgaWYgKGxpbmVUZXh0Lmxlbmd0aCAhPT0gMCkgeyBuZXh0TGluZSsrOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9ibG9jaycsICcnLCAwKTtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBuZXh0TGluZSBdO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHRtbF9ibG9jay5qcyIsIi8vIGxoZWFkaW5nICgtLS0sID09PSlcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgcG9zLCBtYXgsIGxldmVsLCBtYXJrZXIsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsIG9sZFBhcmVudFR5cGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyk7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJzsgLy8gdXNlIHBhcmFncmFwaCB0byBtYXRjaCB0ZXJtaW5hdG9yUnVsZXNcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy9cbiAgICAvLyBDaGVjayBmb3IgdW5kZXJsaW5lIGluIHNldGV4dCBoZWFkZXJcbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gMHgyRC8qIC0gKi8gfHwgbWFya2VyID09PSAweDNELyogPSAqLykge1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgICAgICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgICAgICAgIGxldmVsID0gKG1hcmtlciA9PT0gMHgzRC8qID0gKi8gPyAxIDogMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBpZiAoIWxldmVsKSB7XG4gICAgLy8gRGlkbid0IGZpbmQgdmFsaWQgdW5kZXJsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSAtIDEgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qcyIsIi8vIExpc3RzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbi8vIFNlYXJjaCBgWy0rKl1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFydGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICB2YXIgbWFya2VyLCBwb3MsIG1heCwgY2g7XG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAvLyBDaGVjayBidWxsZXRcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyQi8qICsgKi8pIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgLXRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zO1xufVxuXG4vLyBTZWFyY2ggYFxcZCtbLildW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhcnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIHBvcyA9IHN0YXJ0LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMiBjaGFycyAoZGlnaXQgKyBkb3QpXG4gIGlmIChwb3MgKyAxID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICBpZiAoY2ggPCAweDMwLyogMCAqLyB8fCBjaCA+IDB4MzkvKiA5ICovKSB7IHJldHVybiAtMTsgfVxuXG4gIGZvciAoOzspIHtcbiAgICAvLyBFT0wgLT4gZmFpbFxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgICBpZiAoY2ggPj0gMHgzMC8qIDAgKi8gJiYgY2ggPD0gMHgzOS8qIDkgKi8pIHtcblxuICAgICAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgbm8gbW9yZSB0aGFuIDkgZGlnaXRzXG4gICAgICAvLyAocHJldmVudHMgaW50ZWdlciBvdmVyZmxvdyBpbiBicm93c2VycylcbiAgICAgIGlmIChwb3MgLSBzdGFydCA+PSAxMCkgeyByZXR1cm4gLTE7IH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZm91bmQgdmFsaWQgbWFya2VyXG4gICAgaWYgKGNoID09PSAweDI5LyogKSAqLyB8fCBjaCA9PT0gMHgyZS8qIC4gKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgIC8vIFwiIDEudGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBpZHgpIHtcbiAgdmFyIGksIGwsXG4gICAgICBsZXZlbCA9IHN0YXRlLmxldmVsICsgMjtcblxuICBmb3IgKGkgPSBpZHggKyAyLCBsID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGUudG9rZW5zW2ldLmxldmVsID09PSBsZXZlbCAmJiBzdGF0ZS50b2tlbnNbaV0udHlwZSA9PT0gJ3BhcmFncmFwaF9vcGVuJykge1xuICAgICAgc3RhdGUudG9rZW5zW2kgKyAyXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgc3RhdGUudG9rZW5zW2ldLmhpZGRlbiA9IHRydWU7XG4gICAgICBpICs9IDI7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0KHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjb250ZW50U3RhcnQsXG4gICAgICBpLFxuICAgICAgaW5kZW50LFxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIsXG4gICAgICBpbml0aWFsLFxuICAgICAgaXNPcmRlcmVkLFxuICAgICAgaXRlbUxpbmVzLFxuICAgICAgbCxcbiAgICAgIGxpc3RMaW5lcyxcbiAgICAgIGxpc3RUb2tJZHgsXG4gICAgICBtYXJrZXJDaGFyQ29kZSxcbiAgICAgIG1hcmtlclZhbHVlLFxuICAgICAgbWF4LFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRJbmRlbnQsXG4gICAgICBvbGRMSW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIG9sZFRpZ2h0LFxuICAgICAgcG9zLFxuICAgICAgcG9zQWZ0ZXJNYXJrZXIsXG4gICAgICBwcmV2RW1wdHlFbmQsXG4gICAgICBzdGFydCxcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRva2VuLFxuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IGZhbHNlLFxuICAgICAgdGlnaHQgPSB0cnVlO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGxpbWl0IGNvbmRpdGlvbnMgd2hlbiBsaXN0IGNhbiBpbnRlcnJ1cHRcbiAgLy8gYSBwYXJhZ3JhcGggKHZhbGlkYXRpb24gbW9kZSBvbmx5KVxuICBpZiAoc2lsZW50ICYmIHN0YXRlLnBhcmVudFR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgLy8gTmV4dCBsaXN0IGl0ZW0gc2hvdWxkIHN0aWxsIHRlcm1pbmF0ZSBwcmV2aW91cyBsaXN0IGl0ZW07XG4gICAgLy9cbiAgICAvLyBUaGlzIGNvZGUgY2FuIGZhaWwgaWYgcGx1Z2lucyB1c2UgYmxrSW5kZW50IGFzIHdlbGwgYXMgbGlzdHMsXG4gICAgLy8gYnV0IEkgaG9wZSB0aGUgc3BlYyBnZXRzIGZpeGVkIGxvbmcgYmVmb3JlIHRoYXQgaGFwcGVucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA+PSBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIGlzVGVybWluYXRpbmdQYXJhZ3JhcGggPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIERldGVjdCBsaXN0IHR5cGUgYW5kIHBvc2l0aW9uIGFmdGVyIG1hcmtlclxuICBpZiAoKHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gdHJ1ZTtcbiAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgbWFya2VyVmFsdWUgPSBOdW1iZXIoc3RhdGUuc3JjLnN1YnN0cihzdGFydCwgcG9zQWZ0ZXJNYXJrZXIgLSBzdGFydCAtIDEpKTtcblxuICAgIC8vIElmIHdlJ3JlIHN0YXJ0aW5nIGEgbmV3IG9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAgIC8vIGEgcGFyYWdyYXBoLCBpdCBzaG91bGQgc3RhcnQgd2l0aCAxLlxuICAgIGlmIChpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoICYmIG1hcmtlclZhbHVlICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgfSBlbHNlIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSkgPj0gMCkge1xuICAgIGlzT3JkZXJlZCA9IGZhbHNlO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgdW5vcmRlcmVkIGxpc3QgcmlnaHQgYWZ0ZXJcbiAgLy8gYSBwYXJhZ3JhcGgsIGZpcnN0IGxpbmUgc2hvdWxkIG5vdCBiZSBlbXB0eS5cbiAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGgpIHtcbiAgICBpZiAoc3RhdGUuc2tpcFNwYWNlcyhwb3NBZnRlck1hcmtlcikgPj0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFdlIHNob3VsZCB0ZXJtaW5hdGUgbGlzdCBvbiBzdHlsZSBjaGFuZ2UuIFJlbWVtYmVyIGZpcnN0IG9uZSB0byBjb21wYXJlLlxuICBtYXJrZXJDaGFyQ29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSk7XG5cbiAgLy8gRm9yIHZhbGlkYXRpb24gbW9kZSB3ZSBjYW4gdGVybWluYXRlIGltbWVkaWF0ZWx5XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBTdGFydCBsaXN0XG4gIGxpc3RUb2tJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuXG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9vcGVuJywgJ29sJywgMSk7XG4gICAgaWYgKG1hcmtlclZhbHVlICE9PSAxKSB7XG4gICAgICB0b2tlbi5hdHRycyA9IFsgWyAnc3RhcnQnLCBtYXJrZXJWYWx1ZSBdIF07XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gICAgICAgPSBzdGF0ZS5wdXNoKCdidWxsZXRfbGlzdF9vcGVuJywgJ3VsJywgMSk7XG4gIH1cblxuICB0b2tlbi5tYXAgICAgPSBsaXN0TGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICAvL1xuICAvLyBJdGVyYXRlIGxpc3QgaXRlbXNcbiAgLy9cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcbiAgcHJldkVtcHR5RW5kID0gZmFsc2U7XG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdsaXN0Jyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnbGlzdCc7XG5cbiAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xuICAgIHBvcyA9IHBvc0FmdGVyTWFya2VyO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIHBvc0FmdGVyTWFya2VyIC0gKHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0pO1xuXG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIGNvbnRlbnRTdGFydCA9IHBvcztcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4KSB7XG4gICAgICAvLyB0cmltbWluZyBzcGFjZSBpbiBcIi0gICAgXFxuICAzXCIgY2FzZSwgaW5kZW50IGlzIDEgaGVyZVxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRlbnRBZnRlck1hcmtlciA9IG9mZnNldCAtIGluaXRpYWw7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gNCBzcGFjZXMsIHRoZSBpbmRlbnQgaXMgMVxuICAgIC8vICh0aGUgcmVzdCBpcyBqdXN0IGluZGVudGVkIGNvZGUgYmxvY2spXG4gICAgaWYgKGluZGVudEFmdGVyTWFya2VyID4gNCkgeyBpbmRlbnRBZnRlck1hcmtlciA9IDE7IH1cblxuICAgIC8vIFwiICAtICB0ZXN0XCJcbiAgICAvLyAgXl5eXl4gLSBjYWxjdWxhdGluZyB0b3RhbCBsZW5ndGggb2YgdGhpcyB0aGluZ1xuICAgIGluZGVudCA9IGluaXRpYWwgKyBpbmRlbnRBZnRlck1hcmtlcjtcblxuICAgIC8vIFJ1biBzdWJwYXJzZXIgJiB3cml0ZSB0b2tlbnNcbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fb3BlbicsICdsaScsIDEpO1xuICAgIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuICAgIHRva2VuLm1hcCAgICA9IGl0ZW1MaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgb2xkVGlnaHQgPSBzdGF0ZS50aWdodDtcbiAgICBvbGRUU2hpZnQgPSBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBvbGRMSW5kZW50ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG4gICAgc3RhdGUuYmxrSW5kZW50ID0gaW5kZW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gdHJ1ZTtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IGNvbnRlbnRTdGFydCAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2Zmc2V0O1xuXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXggJiYgc3RhdGUuaXNFbXB0eShzdGFydExpbmUgKyAxKSkge1xuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgdGhpcyBjYXNlXG4gICAgICAvLyAobGlzdCBpdGVtIGlzIGVtcHR5LCBsaXN0IHRlcm1pbmF0ZXMgYmVmb3JlIFwiZm9vXCIpOlxuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIC8vICAgLVxuICAgICAgLy9cbiAgICAgIC8vICAgICBmb29cbiAgICAgIC8vIH5+fn5+fn5+XG4gICAgICBzdGF0ZS5saW5lID0gTWF0aC5taW4oc3RhdGUubGluZSArIDIsIGVuZExpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhbnkgb2YgbGlzdCBpdGVtIGlzIHRpZ2h0LCBtYXJrIGxpc3QgYXMgdGlnaHRcbiAgICBpZiAoIXN0YXRlLnRpZ2h0IHx8IHByZXZFbXB0eUVuZCkge1xuICAgICAgdGlnaHQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gSXRlbSBiZWNvbWUgbG9vc2UgaWYgZmluaXNoIHdpdGggZW1wdHkgbGluZSxcbiAgICAvLyBidXQgd2Ugc2hvdWxkIGZpbHRlciBsYXN0IGVsZW1lbnQsIGJlY2F1c2UgaXQgbWVhbnMgbGlzdCBmaW5pc2hcbiAgICBwcmV2RW1wdHlFbmQgPSAoc3RhdGUubGluZSAtIHN0YXJ0TGluZSkgPiAxICYmIHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpO1xuXG4gICAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gb2xkVFNoaWZ0O1xuICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2xkTEluZGVudDtcbiAgICBzdGF0ZS50aWdodCA9IG9sZFRpZ2h0O1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX2Nsb3NlJywgJ2xpJywgLTEpO1xuICAgIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gICAgbmV4dExpbmUgPSBzdGFydExpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGl0ZW1MaW5lc1sxXSA9IG5leHRMaW5lO1xuICAgIGNvbnRlbnRTdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuXG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHsgYnJlYWs7IH1cblxuICAgIC8vXG4gICAgLy8gVHJ5IHRvIGNoZWNrIGlmIGxpc3QgaXMgdGVybWluYXRlZCBvciBjb250aW51ZWQuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiB0ZXJtaW5hdGluZyBibG9jayBmb3VuZFxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cblxuICAgIC8vIGZhaWwgaWYgbGlzdCBoYXMgYW5vdGhlciB0eXBlXG4gICAgaWYgKGlzT3JkZXJlZCkge1xuICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChtYXJrZXJDaGFyQ29kZSAhPT0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKSkgeyBicmVhazsgfVxuICB9XG5cbiAgLy8gRmluaWxpemUgbGlzdFxuICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdvcmRlcmVkX2xpc3RfY2xvc2UnLCAnb2wnLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdidWxsZXRfbGlzdF9jbG9zZScsICd1bCcsIC0xKTtcbiAgfVxuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICBsaXN0TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIC8vIG1hcmsgcGFyYWdyYXBocyB0aWdodCBpZiBuZWVkZWRcbiAgaWYgKHRpZ2h0KSB7XG4gICAgbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgbGlzdFRva0lkeCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIi8vIFBhcmFncmFwaFxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3RhdGUsIHN0YXJ0TGluZS8qLCBlbmRMaW5lKi8pIHtcbiAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIG9sZFBhcmVudFR5cGUsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyksXG4gICAgICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnO1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9vcGVuJywgJ3AnLCAxKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9jbG9zZScsICdwJywgLTEpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanMiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZmVyZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBfZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGRlc3RFbmRQb3MsXG4gICAgICBkZXN0RW5kTGluZU5vLFxuICAgICAgZW5kTGluZSxcbiAgICAgIGhyZWYsXG4gICAgICBpLFxuICAgICAgbCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgcmVzLFxuICAgICAgc3RhcnQsXG4gICAgICBzdHIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0aXRsZSxcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2ltcGxlIGNoZWNrIHRvIHF1aWNrbHkgaW50ZXJydXB0IHNjYW4gb24gW2xpbmtdKHVybCkgYXQgdGhlIHN0YXJ0IG9mIGxpbmUuXG4gIC8vIENhbiBiZSB1c2VmdWwgb24gcHJhY3RpY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9pc3N1ZXMvNTRcbiAgd2hpbGUgKCsrcG9zIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUQgLyogXSAqLyAmJlxuICAgICAgICBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgLSAxKSAhPT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBpZiAocG9zICsgMSA9PT0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3JlZmVyZW5jZScpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3JlZmVyZW5jZSc7XG5cbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBzdHIgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG4gIG1heCA9IHN0ci5sZW5ndGg7XG5cbiAgZm9yIChwb3MgPSAxOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsYWJlbEVuZCA9IHBvcztcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MEEgLyogXFxuICovKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8pIHtcbiAgICAgIHBvcysrO1xuICAgICAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhYmVsRW5kIDwgMCB8fCBzdHIuY2hhckNvZGVBdChsYWJlbEVuZCArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgIF5eXiBza2lwIG9wdGlvbmFsIHdoaXRlc3BhY2UgaGVyZVxuICBmb3IgKHBvcyA9IGxhYmVsRW5kICsgMjsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgXl5eXl5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAoIXJlcy5vaykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gcmVzLnBvcztcbiAgbGluZXMgKz0gcmVzLmxpbmVzO1xuXG4gIC8vIHNhdmUgY3Vyc29yIHN0YXRlLCB3ZSBjb3VsZCByZXF1aXJlIHRvIHJvbGxiYWNrIGxhdGVyXG4gIGRlc3RFbmRQb3MgPSBwb3M7XG4gIGRlc3RFbmRMaW5lTm8gPSBsaW5lcztcblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgXl5eIHNraXBwaW5nIHRob3NlIHNwYWNlc1xuICBzdGFydCA9IHBvcztcbiAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCk7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgcG9zID0gcmVzLnBvcztcbiAgICBsaW5lcyArPSByZXMubGluZXM7XG4gIH0gZWxzZSB7XG4gICAgdGl0bGUgPSAnJztcbiAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgfVxuXG4gIC8vIHNraXAgdHJhaWxpbmcgc3BhY2VzIHVudGlsIHRoZSByZXN0IG9mIHRoZSBsaW5lXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgYWZ0ZXIgdGl0bGUsXG4gICAgICAvLyBidXQgaXQgY291bGQgc3RpbGwgYmUgYSB2YWxpZCByZWZlcmVuY2UgaWYgd2Ugcm9sbCBiYWNrXG4gICAgICB0aXRsZSA9ICcnO1xuICAgICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHN0ci5zbGljZSgxLCBsYWJlbEVuZCkpO1xuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gQ29tbW9uTWFyayAwLjIwIGRpc2FsbG93cyBlbXB0eSBsYWJlbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBSZWZlcmVuY2UgY2FuIG5vdCB0ZXJtaW5hdGUgYW55dGhpbmcuIFRoaXMgY2hlY2sgaXMgZm9yIHNhZmV0eSBvbmx5LlxuICAvKmlzdGFuYnVsIGlnbm9yZSBpZiovXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzID0ge307XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID0geyB0aXRsZTogdGl0bGUsIGhyZWY6IGhyZWYgfTtcbiAgfVxuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyBsaW5lcyArIDE7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanMiLCIvLyBQYXJzZXIgc3RhdGUgY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbmZ1bmN0aW9uIFN0YXRlQmxvY2soc3JjLCBtZCwgZW52LCB0b2tlbnMpIHtcbiAgdmFyIGNoLCBzLCBzdGFydCwgcG9zLCBsZW4sIGluZGVudCwgb2Zmc2V0LCBpbmRlbnRfZm91bmQ7XG5cbiAgdGhpcy5zcmMgPSBzcmM7XG5cbiAgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2VcbiAgdGhpcy5tZCAgICAgPSBtZDtcblxuICB0aGlzLmVudiA9IGVudjtcblxuICAvL1xuICAvLyBJbnRlcm5hbCBzdGF0ZSB2YXJ0aWFibGVzXG4gIC8vXG5cbiAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG5cbiAgdGhpcy5iTWFya3MgPSBbXTsgIC8vIGxpbmUgYmVnaW4gb2Zmc2V0cyBmb3IgZmFzdCBqdW1wc1xuICB0aGlzLmVNYXJrcyA9IFtdOyAgLy8gbGluZSBlbmQgb2Zmc2V0cyBmb3IgZmFzdCBqdW1wc1xuICB0aGlzLnRTaGlmdCA9IFtdOyAgLy8gb2Zmc2V0cyBvZiB0aGUgZmlyc3Qgbm9uLXNwYWNlIGNoYXJhY3RlcnMgKHRhYnMgbm90IGV4cGFuZGVkKVxuICB0aGlzLnNDb3VudCA9IFtdOyAgLy8gaW5kZW50cyBmb3IgZWFjaCBsaW5lICh0YWJzIGV4cGFuZGVkKVxuXG4gIC8vIEFuIGFtb3VudCBvZiB2aXJ0dWFsIHNwYWNlcyAodGFicyBleHBhbmRlZCkgYmV0d2VlbiBiZWdpbm5pbmdcbiAgLy8gb2YgZWFjaCBsaW5lIChiTWFya3MpIGFuZCByZWFsIGJlZ2lubmluZyBvZiB0aGF0IGxpbmUuXG4gIC8vXG4gIC8vIEl0IGV4aXN0cyBvbmx5IGFzIGEgaGFjayBiZWNhdXNlIGJsb2NrcXVvdGVzIG92ZXJyaWRlIGJNYXJrc1xuICAvLyBsb3NpbmcgaW5mb3JtYXRpb24gaW4gdGhlIHByb2Nlc3MuXG4gIC8vXG4gIC8vIEl0J3MgdXNlZCBvbmx5IHdoZW4gZXhwYW5kaW5nIHRhYnMsIHlvdSBjYW4gdGhpbmsgYWJvdXQgaXQgYXNcbiAgLy8gYW4gaW5pdGlhbCB0YWIgbGVuZ3RoLCBlLmcuIGJzQ291bnQ9MjEgYXBwbGllZCB0byBzdHJpbmcgYFxcdDEyM2BcbiAgLy8gbWVhbnMgZmlyc3QgdGFiIHNob3VsZCBiZSBleHBhbmRlZCB0byA0LTIxJTQgPT09IDMgc3BhY2VzLlxuICAvL1xuICB0aGlzLmJzQ291bnQgPSBbXTtcblxuICAvLyBibG9jayBwYXJzZXIgdmFyaWFibGVzXG4gIHRoaXMuYmxrSW5kZW50ICA9IDA7IC8vIHJlcXVpcmVkIGJsb2NrIGNvbnRlbnQgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIChmb3IgZXhhbXBsZSwgaWYgd2UgYXJlIGluIGxpc3QpXG4gIHRoaXMubGluZSAgICAgICA9IDA7IC8vIGxpbmUgaW5kZXggaW4gc3JjXG4gIHRoaXMubGluZU1heCAgICA9IDA7IC8vIGxpbmVzIGNvdW50XG4gIHRoaXMudGlnaHQgICAgICA9IGZhbHNlOyAgLy8gbG9vc2UvdGlnaHQgbW9kZSBmb3IgbGlzdHNcbiAgdGhpcy5kZEluZGVudCAgID0gLTE7IC8vIGluZGVudCBvZiB0aGUgY3VycmVudCBkZCBibG9jayAoLTEgaWYgdGhlcmUgaXNuJ3QgYW55KVxuXG4gIC8vIGNhbiBiZSAnYmxvY2txdW90ZScsICdsaXN0JywgJ3Jvb3QnLCAncGFyYWdyYXBoJyBvciAncmVmZXJlbmNlJ1xuICAvLyB1c2VkIGluIGxpc3RzIHRvIGRldGVybWluZSBpZiB0aGV5IGludGVycnVwdCBhIHBhcmFncmFwaFxuICB0aGlzLnBhcmVudFR5cGUgPSAncm9vdCc7XG5cbiAgdGhpcy5sZXZlbCA9IDA7XG5cbiAgLy8gcmVuZGVyZXJcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICAvLyBDcmVhdGUgY2FjaGVzXG4gIC8vIEdlbmVyYXRlIG1hcmtlcnMuXG4gIHMgPSB0aGlzLnNyYztcbiAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG5cbiAgZm9yIChzdGFydCA9IHBvcyA9IGluZGVudCA9IG9mZnNldCA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47IHBvcysrKSB7XG4gICAgY2ggPSBzLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaW5kZW50X2ZvdW5kKSB7XG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaW5kZW50Kys7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQgLSBvZmZzZXQgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50X2ZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEgfHwgcG9zID09PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoY2ggIT09IDB4MEEpIHsgcG9zKys7IH1cbiAgICAgIHRoaXMuYk1hcmtzLnB1c2goc3RhcnQpO1xuICAgICAgdGhpcy5lTWFya3MucHVzaChwb3MpO1xuICAgICAgdGhpcy50U2hpZnQucHVzaChpbmRlbnQpO1xuICAgICAgdGhpcy5zQ291bnQucHVzaChvZmZzZXQpO1xuICAgICAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBmYWtlIGVudHJ5IHRvIHNpbXBsaWZ5IGNhY2hlIGJvdW5kcyBjaGVja3NcbiAgdGhpcy5iTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMuZU1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLnRTaGlmdC5wdXNoKDApO1xuICB0aGlzLnNDb3VudC5wdXNoKDApO1xuICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxOyAvLyBkb24ndCBjb3VudCBsYXN0IGZha2UgbGluZVxufVxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy9cblN0YXRlQmxvY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuICB0b2tlbi5ibG9jayA9IHRydWU7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB7IHRoaXMubGV2ZWwtLTsgfVxuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gIGlmIChuZXN0aW5nID4gMCkgeyB0aGlzLmxldmVsKys7IH1cblxuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuU3RhdGVCbG9jay5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkobGluZSkge1xuICByZXR1cm4gdGhpcy5iTWFya3NbbGluZV0gKyB0aGlzLnRTaGlmdFtsaW5lXSA+PSB0aGlzLmVNYXJrc1tsaW5lXTtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBFbXB0eUxpbmVzID0gZnVuY3Rpb24gc2tpcEVtcHR5TGluZXMoZnJvbSkge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLmxpbmVNYXg7IGZyb20gPCBtYXg7IGZyb20rKykge1xuICAgIGlmICh0aGlzLmJNYXJrc1tmcm9tXSArIHRoaXMudFNoaWZ0W2Zyb21dIDwgdGhpcy5lTWFya3NbZnJvbV0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbTtcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzID0gZnVuY3Rpb24gc2tpcFNwYWNlcyhwb3MpIHtcbiAgdmFyIGNoO1xuXG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBzcGFjZXMgZnJvbSBnaXZlbiBwb3NpdGlvbiBpbiByZXZlcnNlLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlc0JhY2sgPSBmdW5jdGlvbiBza2lwU3BhY2VzQmFjayhwb3MsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zOyB9XG5cbiAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgIGlmICghaXNTcGFjZSh0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkpIHsgcmV0dXJuIHBvcyArIDE7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIGZyb20gZ2l2ZW4gcG9zaXRpb25cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFycyA9IGZ1bmN0aW9uIHNraXBDaGFycyhwb3MsIGNvZGUpIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgaWYgKHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gY29kZSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgcmV2ZXJzZSBmcm9tIGdpdmVuIHBvc2l0aW9uIC0gMVxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzQmFjayA9IGZ1bmN0aW9uIHNraXBDaGFyc0JhY2socG9zLCBjb2RlLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoY29kZSAhPT0gdGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpIHsgcmV0dXJuIHBvcyArIDE7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gY3V0IGxpbmVzIHJhbmdlIGZyb20gc291cmNlLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyhiZWdpbiwgZW5kLCBpbmRlbnQsIGtlZXBMYXN0TEYpIHtcbiAgdmFyIGksIGxpbmVJbmRlbnQsIGNoLCBmaXJzdCwgbGFzdCwgcXVldWUsIGxpbmVTdGFydCxcbiAgICAgIGxpbmUgPSBiZWdpbjtcblxuICBpZiAoYmVnaW4gPj0gZW5kKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcXVldWUgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pO1xuXG4gIGZvciAoaSA9IDA7IGxpbmUgPCBlbmQ7IGxpbmUrKywgaSsrKSB7XG4gICAgbGluZUluZGVudCA9IDA7XG4gICAgbGluZVN0YXJ0ID0gZmlyc3QgPSB0aGlzLmJNYXJrc1tsaW5lXTtcblxuICAgIGlmIChsaW5lICsgMSA8IGVuZCB8fCBrZWVwTGFzdExGKSB7XG4gICAgICAvLyBObyBuZWVkIGZvciBib3VuZHMgY2hlY2sgYmVjYXVzZSB3ZSBoYXZlIGZha2UgZW50cnkgb24gdGFpbC5cbiAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXTtcbiAgICB9XG5cbiAgICB3aGlsZSAoZmlyc3QgPCBsYXN0ICYmIGxpbmVJbmRlbnQgPCBpbmRlbnQpIHtcbiAgICAgIGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChmaXJzdCk7XG5cbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBsaW5lSW5kZW50ICs9IDQgLSAobGluZUluZGVudCArIHRoaXMuYnNDb3VudFtsaW5lXSkgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVJbmRlbnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaXJzdCAtIGxpbmVTdGFydCA8IHRoaXMudFNoaWZ0W2xpbmVdKSB7XG4gICAgICAgIC8vIHBhdGNoZWQgdFNoaWZ0IG1hc2tlZCBjaGFyYWN0ZXJzIHRvIGxvb2sgbGlrZSBzcGFjZXMgKGJsb2NrcXVvdGVzLCBsaXN0IG1hcmtlcnMpXG4gICAgICAgIGxpbmVJbmRlbnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmaXJzdCsrO1xuICAgIH1cblxuICAgIGlmIChsaW5lSW5kZW50ID4gaW5kZW50KSB7XG4gICAgICAvLyBwYXJ0aWFsbHkgZXhwYW5kaW5nIHRhYnMgaW4gY29kZSBibG9ja3MsIGUuZyAnXFx0XFx0Zm9vYmFyJ1xuICAgICAgLy8gd2l0aCBpbmRlbnQ9MiBiZWNvbWVzICcgIFxcdGZvb2JhcidcbiAgICAgIHF1ZXVlW2ldID0gbmV3IEFycmF5KGxpbmVJbmRlbnQgLSBpbmRlbnQgKyAxKS5qb2luKCcgJykgKyB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlW2ldID0gdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBxdWV1ZS5qb2luKCcnKTtcbn07XG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlQmxvY2sucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUJsb2NrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwiLy8gR0ZNIHRhYmxlLCBub24tc3RhbmRhcmRcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gZ2V0TGluZShzdGF0ZSwgbGluZSkge1xuICB2YXIgcG9zID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUuYmxrSW5kZW50LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW2xpbmVdO1xuXG4gIHJldHVybiBzdGF0ZS5zcmMuc3Vic3RyKHBvcywgbWF4IC0gcG9zKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZFNwbGl0KHN0cikge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBwb3MgPSAwLFxuICAgICAgbWF4ID0gc3RyLmxlbmd0aCxcbiAgICAgIGNoLFxuICAgICAgZXNjYXBlcyA9IDAsXG4gICAgICBsYXN0UG9zID0gMCxcbiAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZSxcbiAgICAgIGxhc3RCYWNrVGljayA9IDA7XG5cbiAgY2ggID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgaWYgKGNoID09PSAweDYwLyogYCAqLykge1xuICAgICAgaWYgKGJhY2tUaWNrZWQpIHtcbiAgICAgICAgLy8gbWFrZSBcXGAgY2xvc2UgY29kZSBzZXF1ZW5jZSwgYnV0IG5vdCBvcGVuIGl0O1xuICAgICAgICAvLyB0aGUgcmVhc29uIGlzOiBgXFxgIGlzIGNvcnJlY3QgY29kZSBibG9ja1xuICAgICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlcyAlIDIgPT09IDApIHtcbiAgICAgICAgYmFja1RpY2tlZCA9IHRydWU7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDdjLyogfCAqLyAmJiAoZXNjYXBlcyAlIDIgPT09IDApICYmICFiYWNrVGlja2VkKSB7XG4gICAgICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIHBvcykpO1xuICAgICAgbGFzdFBvcyA9IHBvcyArIDE7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDVjLyogXFwgKi8pIHtcbiAgICAgIGVzY2FwZXMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgZXNjYXBlcyA9IDA7XG4gICAgfVxuXG4gICAgcG9zKys7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgYW4gdW4tY2xvc2VkIGJhY2t0aWNrLCBnbyBiYWNrIHRvIGp1c3QgYWZ0ZXJcbiAgICAvLyB0aGUgbGFzdCBiYWNrdGljaywgYnV0IGFzIGlmIGl0IHdhcyBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAgICBpZiAocG9zID09PSBtYXggJiYgYmFja1RpY2tlZCkge1xuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlO1xuICAgICAgcG9zID0gbGFzdEJhY2tUaWNrICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gIH1cblxuICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MpKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGFibGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGluZVRleHQsIHBvcywgaSwgbmV4dExpbmUsIGNvbHVtbnMsIGNvbHVtbkNvdW50LCB0b2tlbixcbiAgICAgIGFsaWducywgdCwgdGFibGVMaW5lcywgdGJvZHlMaW5lcztcblxuICAvLyBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0d28gbGluZXNcbiAgaWYgKHN0YXJ0TGluZSArIDIgPiBlbmRMaW5lKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc2Vjb25kIGxpbmUgc2hvdWxkIGJlICd8JywgJy0nLCAnOicsXG4gIC8vIGFuZCBubyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBhbGxvd2VkIGJ1dCBzcGFjZXM7XG4gIC8vIGJhc2ljYWxseSwgdGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiAvXlstOnxdWy06fFxcc10qJC8gcmVnZXhwXG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUgKyAxKTtcblxuICBjb2x1bW5zID0gbGluZVRleHQuc3BsaXQoJ3wnKTtcbiAgYWxpZ25zID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdCA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIGlmICghdCkge1xuICAgICAgLy8gYWxsb3cgZW1wdHkgY29sdW1ucyBiZWZvcmUgYW5kIGFmdGVyIHRhYmxlLCBidXQgbm90IGluIGJldHdlZW4gY29sdW1ucztcbiAgICAgIC8vIGUuZy4gYWxsb3cgYCB8LS0tfCBgLCBkaXNhbGxvdyBgIC0tLXx8LS0tIGBcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGNvbHVtbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eOj8tKzo/JC8udGVzdCh0KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSkgPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBhbGlnbnMucHVzaCh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovID8gJ2NlbnRlcicgOiAncmlnaHQnKTtcbiAgICB9IGVsc2UgaWYgKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKCdsZWZ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWducy5wdXNoKCcnKTtcbiAgICB9XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSkudHJpbSgpO1xuICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgLy8gaGVhZGVyIHJvdyB3aWxsIGRlZmluZSBhbiBhbW91bnQgb2YgY29sdW1ucyBpbiB0aGUgZW50aXJlIHRhYmxlLFxuICAvLyBhbmQgYWxpZ24gcm93IHNob3VsZG4ndCBiZSBzbWFsbGVyIHRoYW4gdGhhdCAodGhlIHJlc3Qgb2YgdGhlIHJvd3MgY2FuKVxuICBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoO1xuICBpZiAoY29sdW1uQ291bnQgPiBhbGlnbnMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0YWJsZV9vcGVuJywgJ3RhYmxlJywgMSk7XG4gIHRva2VuLm1hcCA9IHRhYmxlTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX29wZW4nLCAndGhlYWQnLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gIHRva2VuLm1hcCA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG5cbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX29wZW4nLCAndGgnLCAxKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgIH1cblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX2Nsb3NlJywgJ3RoJywgLTEpO1xuICB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX2Nsb3NlJywgJ3RoZWFkJywgLTEpO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3Rib2R5X29wZW4nLCAndGJvZHknLCAxKTtcbiAgdG9rZW4ubWFwID0gdGJvZHlMaW5lcyA9IFsgc3RhcnRMaW5lICsgMiwgMCBdO1xuXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAyOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBuZXh0TGluZSkudHJpbSgpO1xuICAgIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IGJyZWFrOyB9XG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyBicmVhazsgfVxuICAgIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9vcGVuJywgJ3RkJywgMSk7XG4gICAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0gPyBjb2x1bW5zW2ldLnRyaW0oKSA6ICcnO1xuICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9jbG9zZScsICd0ZCcsIC0xKTtcbiAgICB9XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgfVxuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3Rib2R5X2Nsb3NlJywgJ3Rib2R5JywgLTEpO1xuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RhYmxlX2Nsb3NlJywgJ3RhYmxlJywgLTEpO1xuXG4gIHRhYmxlTGluZXNbMV0gPSB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2soc3RhdGUpIHtcbiAgdmFyIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYztcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgMCwgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLm1kLmJsb2NrLnBhcnNlKHN0YXRlLnNyYywgc3RhdGUubWQsIHN0YXRlLmVudiwgc3RhdGUudG9rZW5zKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2Jsb2NrLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zLCB0b2ssIGksIGw7XG5cbiAgLy8gUGFyc2UgaW5saW5lc1xuICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRvayA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UodG9rLmNvbnRlbnQsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHRvay5jaGlsZHJlbik7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvaW5saW5lLmpzIiwiLy8gUmVwbGFjZSBsaW5rLWxpa2UgdGV4dHMgd2l0aCBsaW5rIG5vZGVzLlxuLy9cbi8vIEN1cnJlbnRseSByZXN0cmljdGVkIGJ5IGBtZC52YWxpZGF0ZUxpbmsoKWAgdG8gaHR0cC9odHRwcy9mdHBcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGFycmF5UmVwbGFjZUF0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuYXJyYXlSZXBsYWNlQXQ7XG5cblxuZnVuY3Rpb24gaXNMaW5rT3BlbihzdHIpIHtcbiAgcmV0dXJuIC9ePGFbPlxcc10vaS50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc0xpbmtDbG9zZShzdHIpIHtcbiAgcmV0dXJuIC9ePFxcL2FcXHMqPi9pLnRlc3Qoc3RyKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmtpZnkoc3RhdGUpIHtcbiAgdmFyIGksIGosIGwsIHRva2VucywgdG9rZW4sIGN1cnJlbnRUb2tlbiwgbm9kZXMsIGxuLCB0ZXh0LCBwb3MsIGxhc3RQb3MsXG4gICAgICBsZXZlbCwgaHRtbExpbmtMZXZlbCwgdXJsLCBmdWxsVXJsLCB1cmxUZXh0LFxuICAgICAgYmxvY2tUb2tlbnMgPSBzdGF0ZS50b2tlbnMsXG4gICAgICBsaW5rcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMubGlua2lmeSkgeyByZXR1cm47IH1cblxuICBmb3IgKGogPSAwLCBsID0gYmxvY2tUb2tlbnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgaWYgKGJsb2NrVG9rZW5zW2pdLnR5cGUgIT09ICdpbmxpbmUnIHx8XG4gICAgICAgICFzdGF0ZS5tZC5saW5raWZ5LnByZXRlc3QoYmxvY2tUb2tlbnNbal0uY29udGVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRva2VucyA9IGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuO1xuXG4gICAgaHRtbExpbmtMZXZlbCA9IDA7XG5cbiAgICAvLyBXZSBzY2FuIGZyb20gdGhlIGVuZCwgdG8ga2VlcCBwb3NpdGlvbiB3aGVuIG5ldyB0YWdzIGFkZGVkLlxuICAgIC8vIFVzZSByZXZlcnNlZCBsb2dpYyBpbiBsaW5rcyBzdGFydC9lbmQgbWF0Y2hcbiAgICBmb3IgKGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGN1cnJlbnRUb2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgLy8gU2tpcCBjb250ZW50IG9mIG1hcmtkb3duIGxpbmtzXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJykge1xuICAgICAgICBpLS07XG4gICAgICAgIHdoaWxlICh0b2tlbnNbaV0ubGV2ZWwgIT09IGN1cnJlbnRUb2tlbi5sZXZlbCAmJiB0b2tlbnNbaV0udHlwZSAhPT0gJ2xpbmtfb3BlbicpIHtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBodG1sIHRhZyBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnaHRtbF9pbmxpbmUnKSB7XG4gICAgICAgIGlmIChpc0xpbmtPcGVuKGN1cnJlbnRUb2tlbi5jb250ZW50KSAmJiBodG1sTGlua0xldmVsID4gMCkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaW5rQ2xvc2UoY3VycmVudFRva2VuLmNvbnRlbnQpKSB7XG4gICAgICAgICAgaHRtbExpbmtMZXZlbCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaHRtbExpbmtMZXZlbCA+IDApIHsgY29udGludWU7IH1cblxuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAndGV4dCcgJiYgc3RhdGUubWQubGlua2lmeS50ZXN0KGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuXG4gICAgICAgIHRleHQgPSBjdXJyZW50VG9rZW4uY29udGVudDtcbiAgICAgICAgbGlua3MgPSBzdGF0ZS5tZC5saW5raWZ5Lm1hdGNoKHRleHQpO1xuXG4gICAgICAgIC8vIE5vdyBzcGxpdCBzdHJpbmcgdG8gbm9kZXNcbiAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgbGV2ZWwgPSBjdXJyZW50VG9rZW4ubGV2ZWw7XG4gICAgICAgIGxhc3RQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobG4gPSAwOyBsbiA8IGxpbmtzLmxlbmd0aDsgbG4rKykge1xuXG4gICAgICAgICAgdXJsID0gbGlua3NbbG5dLnVybDtcbiAgICAgICAgICBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluayh1cmwpO1xuICAgICAgICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB1cmxUZXh0ID0gbGlua3NbbG5dLnRleHQ7XG5cbiAgICAgICAgICAvLyBMaW5raWZpZXIgbWlnaHQgc2VuZCByYXcgaG9zdG5hbWVzIGxpa2UgXCJleGFtcGxlLmNvbVwiLCB3aGVyZSB1cmxcbiAgICAgICAgICAvLyBzdGFydHMgd2l0aCBkb21haW4gbmFtZS4gU28gd2UgcHJlcGVuZCBodHRwOi8vIGluIHRob3NlIGNhc2VzLFxuICAgICAgICAgIC8vIGFuZCByZW1vdmUgaXQgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmICghbGlua3NbbG5dLnNjaGVtYSkge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KCdodHRwOi8vJyArIHVybFRleHQpLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sICcnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmtzW2xuXS5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdCh1cmxUZXh0KSkge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KCdtYWlsdG86JyArIHVybFRleHQpLnJlcGxhY2UoL15tYWlsdG86LywgJycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsVGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9zID0gbGlua3NbbG5dLmluZGV4O1xuXG4gICAgICAgICAgaWYgKHBvcyA+IGxhc3RQb3MpIHtcbiAgICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dC5zbGljZShsYXN0UG9zLCBwb3MpO1xuICAgICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsKys7XG4gICAgICAgICAgdG9rZW4ubWFya3VwICA9ICdsaW5raWZ5JztcbiAgICAgICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdXJsVGV4dDtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IC0tbGV2ZWw7XG4gICAgICAgICAgdG9rZW4ubWFya3VwICA9ICdsaW5raWZ5JztcbiAgICAgICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgbGFzdFBvcyA9IGxpbmtzW2xuXS5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQb3MgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcyk7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjZSBjdXJyZW50IG5vZGVcbiAgICAgICAgYmxvY2tUb2tlbnNbal0uY2hpbGRyZW4gPSB0b2tlbnMgPSBhcnJheVJlcGxhY2VBdCh0b2tlbnMsIGksIG5vZGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzIiwiLy8gTm9ybWFsaXplIGlucHV0IHN0cmluZ1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIE5FV0xJTkVTX1JFICA9IC9cXHJbXFxuXFx1MDA4NV0/fFtcXHUyNDI0XFx1MjAyOFxcdTAwODVdL2c7XG52YXIgTlVMTF9SRSAgICAgID0gL1xcdTAwMDAvZztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgc3RyO1xuXG4gIC8vIE5vcm1hbGl6ZSBuZXdsaW5lc1xuICBzdHIgPSBzdGF0ZS5zcmMucmVwbGFjZShORVdMSU5FU19SRSwgJ1xcbicpO1xuXG4gIC8vIFJlcGxhY2UgTlVMTCBjaGFyYWN0ZXJzXG4gIHN0ciA9IHN0ci5yZXBsYWNlKE5VTExfUkUsICdcXHVGRkZEJyk7XG5cbiAgc3RhdGUuc3JjID0gc3RyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL25vcm1hbGl6ZS5qcyIsIi8vIFNpbXBsZSB0eXBvZ3JhcGh5YyByZXBsYWNlbWVudHNcbi8vXG4vLyAoYykgKEMpIOKGkiDCqVxuLy8gKHRtKSAoVE0pIOKGkiDihKJcbi8vIChyKSAoUikg4oaSIMKuXG4vLyArLSDihpIgwrFcbi8vIChwKSAoUCkgLT4gwqdcbi8vIC4uLiDihpIg4oCmIChhbHNvID8uLi4uIOKGkiA/Li4sICEuLi4uIOKGkiAhLi4pXG4vLyA/Pz8/Pz8/PyDihpIgPz8/LCAhISEhISDihpIgISEhLCBgLCxgIOKGkiBgLGBcbi8vIC0tIOKGkiAmbmRhc2g7LCAtLS0g4oaSICZtZGFzaDtcbi8vXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRPRE86XG4vLyAtIGZyYWN0aW9uYWxzIDEvMiwgMS80LCAzLzQgLT4gwr0sIMK8LCDCvlxuLy8gLSBtaWx0aXBsaWNhdGlvbiAyIHggNCAtPiAyIMOXIDRcblxudmFyIFJBUkVfUkUgPSAvXFwrLXxcXC5cXC58XFw/XFw/XFw/XFw/fCEhISF8LCx8LS0vO1xuXG4vLyBXb3JrYXJvdW5kIGZvciBwaGFudG9tanMgLSBuZWVkIHJlZ2V4IHdpdGhvdXQgL2cgZmxhZyxcbi8vIG9yIHJvb3QgY2hlY2sgd2lsbCBmYWlsIGV2ZXJ5IHNlY29uZCB0aW1lXG52YXIgU0NPUEVEX0FCQlJfVEVTVF9SRSA9IC9cXCgoY3x0bXxyfHApXFwpL2k7XG5cbnZhciBTQ09QRURfQUJCUl9SRSA9IC9cXCgoY3x0bXxyfHApXFwpL2lnO1xudmFyIFNDT1BFRF9BQkJSID0ge1xuICBjOiAnwqknLFxuICByOiAnwq4nLFxuICBwOiAnwqcnLFxuICB0bTogJ+KEoidcbn07XG5cbmZ1bmN0aW9uIHJlcGxhY2VGbihtYXRjaCwgbmFtZSkge1xuICByZXR1cm4gU0NPUEVEX0FCQlJbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9zY29wZWQoaW5saW5lVG9rZW5zKSB7XG4gIHZhciBpLCB0b2tlbiwgaW5zaWRlX2F1dG9saW5rID0gMDtcblxuICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnQucmVwbGFjZShTQ09QRURfQUJCUl9SRSwgcmVwbGFjZUZuKTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfb3BlbicgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmstLTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rKys7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VfcmFyZShpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICBpZiAoUkFSRV9SRS50ZXN0KHRva2VuLmNvbnRlbnQpKSB7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCstL2csICfCsScpXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLCAuLi4sIC4uLi4uLi4gLT4g4oCmXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCA/Li4uLi4gJiAhLi4uLi4gLT4gPy4uICYgIS4uXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXC57Mix9L2csICfigKYnKS5yZXBsYWNlKC8oWz8hXSnigKYvZywgJyQxLi4nKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKFs/IV0pezQsfS9nLCAnJDEkMSQxJykucmVwbGFjZSgvLHsyLH0vZywgJywnKVxuICAgICAgICAgICAgICAgICAgICAvLyBlbS1kYXNoXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1dKS0tLShbXi1dfCQpL21nLCAnJDFcXHUyMDE0JDInKVxuICAgICAgICAgICAgICAgICAgICAvLyBlbi1kYXNoXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxcXHMpLS0oXFxzfCQpL21nLCAnJDFcXHUyMDEzJDInKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXFxzXSktLShbXi1cXHNdfCQpL21nLCAnJDFcXHUyMDEzJDInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfb3BlbicgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmstLTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rKys7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gIHZhciBibGtJZHg7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLnR5cG9ncmFwaGVyKSB7IHJldHVybjsgfVxuXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tibGtJZHhdLnR5cGUgIT09ICdpbmxpbmUnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoU0NPUEVEX0FCQlJfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICByZXBsYWNlX3Njb3BlZChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgaWYgKFJBUkVfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9yYXJlKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcyIsIi8vIENvbnZlcnQgc3RyYWlnaHQgcXVvdGF0aW9uIG1hcmtzIHRvIHR5cG9ncmFwaGljIG9uZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxudmFyIFFVT1RFX1RFU1RfUkUgPSAvWydcIl0vO1xudmFyIFFVT1RFX1JFID0gL1snXCJdL2c7XG52YXIgQVBPU1RST1BIRSA9ICdcXHUyMDE5JzsgLyog4oCZICovXG5cblxuZnVuY3Rpb24gcmVwbGFjZUF0KHN0ciwgaW5kZXgsIGNoKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIGluZGV4KSArIGNoICsgc3RyLnN1YnN0cihpbmRleCArIDEpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzX2lubGluZXModG9rZW5zLCBzdGF0ZSkge1xuICB2YXIgaSwgdG9rZW4sIHRleHQsIHQsIHBvcywgbWF4LCB0aGlzTGV2ZWwsIGl0ZW0sIGxhc3RDaGFyLCBuZXh0Q2hhcixcbiAgICAgIGlzTGFzdFB1bmN0Q2hhciwgaXNOZXh0UHVuY3RDaGFyLCBpc0xhc3RXaGl0ZVNwYWNlLCBpc05leHRXaGl0ZVNwYWNlLFxuICAgICAgY2FuT3BlbiwgY2FuQ2xvc2UsIGosIGlzU2luZ2xlLCBzdGFjaywgb3BlblF1b3RlLCBjbG9zZVF1b3RlO1xuXG4gIHN0YWNrID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgdGhpc0xldmVsID0gdG9rZW5zW2ldLmxldmVsO1xuXG4gICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8PSB0aGlzTGV2ZWwpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgc3RhY2subGVuZ3RoID0gaiArIDE7XG5cbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcbiAgICBwb3MgPSAwO1xuICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgLyplc2xpbnQgbm8tbGFiZWxzOjAsYmxvY2stc2NvcGVkLXZhcjowKi9cbiAgICBPVVRFUjpcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBRVU9URV9SRS5sYXN0SW5kZXggPSBwb3M7XG4gICAgICB0ID0gUVVPVEVfUkUuZXhlYyh0ZXh0KTtcbiAgICAgIGlmICghdCkgeyBicmVhazsgfVxuXG4gICAgICBjYW5PcGVuID0gY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgcG9zID0gdC5pbmRleCArIDE7XG4gICAgICBpc1NpbmdsZSA9ICh0WzBdID09PSBcIidcIik7XG5cbiAgICAgIC8vIEZpbmQgcHJldmlvdXMgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBsYXN0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmICh0LmluZGV4IC0gMSA+PSAwKSB7XG4gICAgICAgIGxhc3RDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHQuaW5kZXggLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBsYXN0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQodG9rZW5zW2pdLmNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbmV4dENoYXIgPSAweDIwO1xuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG5leHRDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBuZXh0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgICAgIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgICAgIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dENoYXIgPT09IDB4MjIgLyogXCIgKi8gJiYgdFswXSA9PT0gJ1wiJykge1xuICAgICAgICBpZiAobGFzdENoYXIgPj0gMHgzMCAvKiAwICovICYmIGxhc3RDaGFyIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogMVwiXCIgLSBjb3VudCBmaXJzdCBxdW90ZSBhcyBhbiBpbmNoXG4gICAgICAgICAgY2FuQ2xvc2UgPSBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4gJiYgY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdHJlYXQgdGhpcyBhcyB0aGUgbWlkZGxlIG9mIHRoZSB3b3JkXG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgY2FuQ2xvc2UgPSBpc05leHRQdW5jdENoYXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2FuT3BlbiAmJiAhY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gbWlkZGxlIG9mIHdvcmRcbiAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbkNsb3NlKSB7XG4gICAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBjbG9zaW5nIHF1b3RlLCByZXdpbmQgdGhlIHN0YWNrIHRvIGdldCBhIG1hdGNoXG4gICAgICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuICAgICAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgICAgICAgIGlmIChpdGVtLnNpbmdsZSA9PT0gaXNTaW5nbGUgJiYgc3RhY2tbal0ubGV2ZWwgPT09IHRoaXNMZXZlbCkge1xuICAgICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuXG4gICAgICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMl07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1szXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzBdO1xuICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdG9rZW4uY29udGVudCAqYmVmb3JlKiB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UsIGlmIHRoZXkgYXJlIHBvaW50aW5nIGF0IHRoZSBzYW1lIHRva2VuLCByZXBsYWNlQXRcbiAgICAgICAgICAgIC8vIGNvdWxkIG1lc3MgdXAgaW5kaWNlcyB3aGVuIHF1b3RlIGxlbmd0aCAhPSAxXG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIGNsb3NlUXVvdGUpO1xuICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQgPSByZXBsYWNlQXQoXG4gICAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LCBpdGVtLnBvcywgb3BlblF1b3RlKTtcblxuICAgICAgICAgICAgcG9zICs9IGNsb3NlUXVvdGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChpdGVtLnRva2VuID09PSBpKSB7IHBvcyArPSBvcGVuUXVvdGUubGVuZ3RoIC0gMTsgfVxuXG4gICAgICAgICAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcbiAgICAgICAgICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggPSBqO1xuICAgICAgICAgICAgY29udGludWUgT1VURVI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5PcGVuKSB7XG4gICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgIHRva2VuOiBpLFxuICAgICAgICAgIHBvczogdC5pbmRleCxcbiAgICAgICAgICBzaW5nbGU6IGlzU2luZ2xlLFxuICAgICAgICAgIGxldmVsOiB0aGlzTGV2ZWxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbkNsb3NlICYmIGlzU2luZ2xlKSB7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzbWFydHF1b3RlcyhzdGF0ZSkge1xuICAvKmVzbGludCBtYXgtZGVwdGg6MCovXG4gIHZhciBibGtJZHg7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLnR5cG9ncmFwaGVyKSB7IHJldHVybjsgfVxuXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tibGtJZHhdLnR5cGUgIT09ICdpbmxpbmUnIHx8XG4gICAgICAgICFRVU9URV9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb2Nlc3NfaW5saW5lcyhzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbiwgc3RhdGUpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCIvLyBDb3JlIHN0YXRlIG9iamVjdFxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcblxuXG5mdW5jdGlvbiBTdGF0ZUNvcmUoc3JjLCBtZCwgZW52KSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy5pbmxpbmVNb2RlID0gZmFsc2U7XG4gIHRoaXMubWQgPSBtZDsgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2Vcbn1cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBjb3JlIHJ1bGVzXG5TdGF0ZUNvcmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUNvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzIiwiLy8gUHJvY2VzcyBhdXRvbGlua3MgJzxwcm90b2NvbDouLi4+J1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyplc2xpbnQgbWF4LWxlbjowKi9cbnZhciBFTUFJTF9SRSAgICA9IC9ePChbYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqKT4vO1xudmFyIEFVVE9MSU5LX1JFID0gL148KFthLXpBLVpdW2EtekEtWjAtOSsuXFwtXXsxLDMxfSk6KFtePD5cXHgwMC1cXHgyMF0qKT4vO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXV0b2xpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgdGFpbCwgbGlua01hdGNoLCBlbWFpbE1hdGNoLCB1cmwsIGZ1bGxVcmwsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICB0YWlsID0gc3RhdGUuc3JjLnNsaWNlKHBvcyk7XG5cbiAgaWYgKHRhaWwuaW5kZXhPZignPicpIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoQVVUT0xJTktfUkUudGVzdCh0YWlsKSkge1xuICAgIGxpbmtNYXRjaCA9IHRhaWwubWF0Y2goQVVUT0xJTktfUkUpO1xuXG4gICAgdXJsID0gbGlua01hdGNoWzBdLnNsaWNlKDEsIC0xKTtcbiAgICBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluayh1cmwpO1xuICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgdG9rZW4ubWFya3VwICA9ICdhdXRvbGluayc7XG4gICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmwpO1xuXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgdG9rZW4ubWFya3VwICA9ICdhdXRvbGluayc7XG4gICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIHN0YXRlLnBvcyArPSBsaW5rTWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKEVNQUlMX1JFLnRlc3QodGFpbCkpIHtcbiAgICBlbWFpbE1hdGNoID0gdGFpbC5tYXRjaChFTUFJTF9SRSk7XG5cbiAgICB1cmwgPSBlbWFpbE1hdGNoWzBdLnNsaWNlKDEsIC0xKTtcbiAgICBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluaygnbWFpbHRvOicgKyB1cmwpO1xuICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgdG9rZW4ubWFya3VwICA9ICdhdXRvbGluayc7XG4gICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmwpO1xuXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgdG9rZW4ubWFya3VwICA9ICdhdXRvbGluayc7XG4gICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIHN0YXRlLnBvcyArPSBlbWFpbE1hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2F1dG9saW5rLmpzIiwiLy8gUGFyc2UgYmFja3RpY2tzXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYWNrdGljayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBzdGFydCwgbWF4LCBtYXJrZXIsIG1hdGNoU3RhcnQsIG1hdGNoRW5kLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4NjAvKiBgICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gcG9zO1xuICBwb3MrKztcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg2MC8qIGAgKi8pIHsgcG9zKys7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7XG5cbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xuXG4gIHdoaWxlICgobWF0Y2hTdGFydCA9IHN0YXRlLnNyYy5pbmRleE9mKCdgJywgbWF0Y2hFbmQpKSAhPT0gLTEpIHtcbiAgICBtYXRjaEVuZCA9IG1hdGNoU3RhcnQgKyAxO1xuXG4gICAgd2hpbGUgKG1hdGNoRW5kIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KG1hdGNoRW5kKSA9PT0gMHg2MC8qIGAgKi8pIHsgbWF0Y2hFbmQrKzsgfVxuXG4gICAgaWYgKG1hdGNoRW5kIC0gbWF0Y2hTdGFydCA9PT0gbWFya2VyLmxlbmd0aCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfaW5saW5lJywgJ2NvZGUnLCAwKTtcbiAgICAgICAgdG9rZW4ubWFya3VwICA9IG1hcmtlcjtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1hdGNoU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyBcXG5dKy9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gbWF0Y2hFbmQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjsgfVxuICBzdGF0ZS5wb3MgKz0gbWFya2VyLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWNrdGlja3MuanMiLCIvLyBGb3IgZWFjaCBvcGVuaW5nIGVtcGhhc2lzLWxpa2UgbWFya2VyIGZpbmQgYSBtYXRjaGluZyBjbG9zaW5nIG9uZVxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmtfcGFpcnMoc3RhdGUpIHtcbiAgdmFyIGksIGosIGxhc3REZWxpbSwgY3VyckRlbGltLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBsYXN0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKCFsYXN0RGVsaW0uY2xvc2UpIHsgY29udGludWU7IH1cblxuICAgIGogPSBpIC0gbGFzdERlbGltLmp1bXAgLSAxO1xuXG4gICAgd2hpbGUgKGogPj0gMCkge1xuICAgICAgY3VyckRlbGltID0gZGVsaW1pdGVyc1tqXTtcblxuICAgICAgaWYgKGN1cnJEZWxpbS5vcGVuICYmXG4gICAgICAgICAgY3VyckRlbGltLm1hcmtlciA9PT0gbGFzdERlbGltLm1hcmtlciAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5lbmQgPCAwICYmXG4gICAgICAgICAgY3VyckRlbGltLmxldmVsID09PSBsYXN0RGVsaW0ubGV2ZWwpIHtcblxuICAgICAgICAvLyB0eXBlb2ZzIGFyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHBsdWdpbnNcbiAgICAgICAgdmFyIG9kZF9tYXRjaCA9IChjdXJyRGVsaW0uY2xvc2UgfHwgbGFzdERlbGltLm9wZW4pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY3VyckRlbGltLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBsYXN0RGVsaW0ubGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnJEZWxpbS5sZW5ndGggKyBsYXN0RGVsaW0ubGVuZ3RoKSAlIDMgPT09IDA7XG5cbiAgICAgICAgaWYgKCFvZGRfbWF0Y2gpIHtcbiAgICAgICAgICBsYXN0RGVsaW0uanVtcCA9IGkgLSBqO1xuICAgICAgICAgIGxhc3REZWxpbS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgY3VyckRlbGltLmVuZCAgPSBpO1xuICAgICAgICAgIGN1cnJEZWxpbS5qdW1wID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBqIC09IGN1cnJEZWxpbS5qdW1wICsgMTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanMiLCIvLyBQcm9jZXNzIGh0bWwgZW50aXR5IC0gJiMxMjM7LCAmI3hBRjssICZxdW90OywgLi4uXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVudGl0aWVzICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL2VudGl0aWVzJyk7XG52YXIgaGFzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5oYXM7XG52YXIgaXNWYWxpZEVudGl0eUNvZGUgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1ZhbGlkRW50aXR5Q29kZTtcbnZhciBmcm9tQ29kZVBvaW50ICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmZyb21Db2RlUG9pbnQ7XG5cblxudmFyIERJR0lUQUxfUkUgPSAvXiYjKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKTsvaTtcbnZhciBOQU1FRF9SRSAgID0gL14mKFthLXpdW2EtejAtOV17MSwzMX0pOy9pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW50aXR5KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBjb2RlLCBtYXRjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjYvKiAmICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAxIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMyAvKiAjICovKSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKERJR0lUQUxfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgY29kZSA9IG1hdGNoWzFdWzBdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/IHBhcnNlSW50KG1hdGNoWzFdLnNsaWNlKDEpLCAxNikgOiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gaXNWYWxpZEVudGl0eUNvZGUoY29kZSkgPyBmcm9tQ29kZVBvaW50KGNvZGUpIDogZnJvbUNvZGVQb2ludCgweEZGRkQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKE5BTUVEX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoaGFzKGVudGl0aWVzLCBtYXRjaFsxXSkpIHtcbiAgICAgICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IGVudGl0aWVzW21hdGNoWzFdXTsgfVxuICAgICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICcmJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCIvLyBQcm9jZWVzcyBlc2NhcGVkIGNoYXJzIGFuZCBoYXJkYnJlYWtzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG52YXIgRVNDQVBFRCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7IEVTQ0FQRUQucHVzaCgwKTsgfVxuXG4nXFxcXCFcIiMkJSZcXCcoKSorLC4vOjs8PT4/QFtdXl9ge3x9fi0nXG4gIC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2gpIHsgRVNDQVBFRFtjaC5jaGFyQ29kZUF0KDApXSA9IDE7IH0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXNjYXBlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qy8qIFxcICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcysrO1xuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggPCAyNTYgJiYgRVNDQVBFRFtjaF0gIT09IDApIHtcbiAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3Bvc107IH1cbiAgICAgIHN0YXRlLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wdXNoKCdoYXJkYnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgICAvLyBza2lwIGxlYWRpbmcgd2hpdGVzcGFjZXMgZnJvbSBuZXh0IGxpbmVcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICdcXFxcJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCIvLyBQcm9jZXNzIGh0bWwgdGFnc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX1RBR19SRTtcblxuXG5mdW5jdGlvbiBpc0xldHRlcihjaCkge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICB2YXIgbGMgPSBjaCB8IDB4MjA7IC8vIHRvIGxvd2VyIGNhc2VcbiAgcmV0dXJuIChsYyA+PSAweDYxLyogYSAqLykgJiYgKGxjIDw9IDB4N2EvKiB6ICovKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfaW5saW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBtYXRjaCwgbWF4LCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBDaGVjayBzdGFydFxuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLyB8fFxuICAgICAgcG9zICsgMiA+PSBtYXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBRdWljayBmYWlsIG9uIHNlY29uZCBjaGFyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8gJiZcbiAgICAgIGNoICE9PSAweDNGLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4MkYvKiAvICovICYmXG4gICAgICAhaXNMZXR0ZXIoY2gpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChIVE1MX1RBR19SRSk7XG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9pbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIG1hdGNoWzBdLmxlbmd0aCk7XG4gIH1cbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9odG1sX2lubGluZS5qcyIsIi8vIFByb2Nlc3MgIVtpbWFnZV0oPHNyYz4gXCJ0aXRsZVwiKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbWFnZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBhdHRycyxcbiAgICAgIGNvZGUsXG4gICAgICBjb250ZW50LFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIGxhYmVsU3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZWYsXG4gICAgICByZXMsXG4gICAgICB0aXRsZSxcbiAgICAgIHRva2VuLFxuICAgICAgdG9rZW5zLFxuICAgICAgc3RhcnQsXG4gICAgICBocmVmID0gJycsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgIT09IDB4MjEvKiAhICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zICsgMSkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAyO1xuICBsYWJlbEVuZCA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXRlLnBvcyArIDEsIGZhbHNlKTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHBvcysrO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2luZyBsaW5rIHRpdGxlXG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgICBwb3MgPSByZXMucG9zO1xuXG4gICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGUgPSAnJztcbiAgICB9XG5cbiAgICBpZiAocG9zID49IG1heCB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI5LyogKSAqLykge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwb3MrKztcbiAgfSBlbHNlIHtcbiAgICAvL1xuICAgIC8vIExpbmsgcmVmZXJlbmNlXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgIHBvcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHBvcyk7XG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcysrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgIH1cblxuICAgIC8vIGNvdmVycyBsYWJlbCA9PT0gJycgYW5kIGxhYmVsID09PSB1bmRlZmluZWRcbiAgICAvLyAoY29sbGFwc2VkIHJlZmVyZW5jZSBsaW5rIGFuZCBzaG9ydGN1dCByZWZlcmVuY2UgbGluayByZXNwZWN0aXZlbHkpXG4gICAgaWYgKCFsYWJlbCkgeyBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7IH1cblxuICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xuICAgIGlmICghcmVmKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhyZWYgPSByZWYuaHJlZjtcbiAgICB0aXRsZSA9IHJlZi50aXRsZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIGZvdW5kIHRoZSBlbmQgb2YgdGhlIGxpbmssIGFuZCBrbm93IGZvciBhIGZhY3QgaXQncyBhIHZhbGlkIGxpbms7XG4gIC8vIHNvIGFsbCB0aGF0J3MgbGVmdCB0byBkbyBpcyB0byBjYWxsIHRva2VuaXplci5cbiAgLy9cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBjb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTtcblxuICAgIHN0YXRlLm1kLmlubGluZS5wYXJzZShcbiAgICAgIGNvbnRlbnQsXG4gICAgICBzdGF0ZS5tZCxcbiAgICAgIHN0YXRlLmVudixcbiAgICAgIHRva2VucyA9IFtdXG4gICAgKTtcblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW1hZ2UnLCAnaW1nJywgMCk7XG4gICAgdG9rZW4uYXR0cnMgICAgPSBhdHRycyA9IFsgWyAnc3JjJywgaHJlZiBdLCBbICdhbHQnLCAnJyBdIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSB0b2tlbnM7XG4gICAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuXG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBhdHRycy5wdXNoKFsgJ3RpdGxlJywgdGl0bGUgXSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaW1hZ2UuanMiLCIvLyBQcm9jZXNzIFtsaW5rXSg8dG8+IFwic3R1ZmZcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBhdHRycyxcbiAgICAgIGNvZGUsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlcyxcbiAgICAgIHJlZixcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICBocmVmID0gJycsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDE7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zLCB0cnVlKTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIG1pZ2h0IGhhdmUgZm91bmQgYSB2YWxpZCBzaG9ydGN1dCBsaW5rLCBkaXNhYmxlIHJlZmVyZW5jZSBwYXJzaW5nXG4gICAgcGFyc2VSZWZlcmVuY2UgPSBmYWxzZTtcblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHBvcysrO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2luZyBsaW5rIHRpdGxlXG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgICBwb3MgPSByZXMucG9zO1xuXG4gICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGUgPSAnJztcbiAgICB9XG5cbiAgICBpZiAocG9zID49IG1heCB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI5LyogKSAqLykge1xuICAgICAgLy8gcGFyc2luZyBhIHZhbGlkIHNob3J0Y3V0IGxpbmsgZmFpbGVkLCBmYWxsYmFjayB0byByZWZlcmVuY2VcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocGFyc2VSZWZlcmVuY2UpIHtcbiAgICAvL1xuICAgIC8vIExpbmsgcmVmZXJlbmNlXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgIHBvcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHBvcyk7XG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcysrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgIH1cblxuICAgIC8vIGNvdmVycyBsYWJlbCA9PT0gJycgYW5kIGxhYmVsID09PSB1bmRlZmluZWRcbiAgICAvLyAoY29sbGFwc2VkIHJlZmVyZW5jZSBsaW5rIGFuZCBzaG9ydGN1dCByZWZlcmVuY2UgbGluayByZXNwZWN0aXZlbHkpXG4gICAgaWYgKCFsYWJlbCkgeyBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7IH1cblxuICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xuICAgIGlmICghcmVmKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhyZWYgPSByZWYuaHJlZjtcbiAgICB0aXRsZSA9IHJlZi50aXRsZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIGZvdW5kIHRoZSBlbmQgb2YgdGhlIGxpbmssIGFuZCBrbm93IGZvciBhIGZhY3QgaXQncyBhIHZhbGlkIGxpbms7XG4gIC8vIHNvIGFsbCB0aGF0J3MgbGVmdCB0byBkbyBpcyB0byBjYWxsIHRva2VuaXplci5cbiAgLy9cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBzdGF0ZS5wb3MgPSBsYWJlbFN0YXJ0O1xuICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICB0b2tlbi5hdHRycyAgPSBhdHRycyA9IFsgWyAnaHJlZicsIGhyZWYgXSBdO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cblxuICAgIHN0YXRlLm1kLmlubGluZS50b2tlbml6ZShzdGF0ZSk7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9saW5rLmpzIiwiLy8gUHJvY2Vlc3MgJ1xcbidcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBuZXdsaW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBtYXgsIG1heCwgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDBBLyogXFxuICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBtYXggPSBzdGF0ZS5wZW5kaW5nLmxlbmd0aCAtIDE7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICAvLyAnICBcXG4nIC0+IGhhcmRicmVha1xuICAvLyBMb29rdXAgaW4gcGVuZGluZyBjaGFycyBpcyBiYWQgcHJhY3RpY2UhIERvbid0IGNvcHkgdG8gb3RoZXIgcnVsZXMhXG4gIC8vIFBlbmRpbmcgc3RyaW5nIGlzIHN0b3JlZCBpbiBjb25jYXQgbW9kZSwgaW5kZXhlZCBsb29rdXBzIHdpbGwgY2F1c2VcbiAgLy8gY29udmVydGlvbiB0byBmbGF0IG1vZGUuXG4gIGlmICghc2lsZW50KSB7XG4gICAgaWYgKHBtYXggPj0gMCAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCkgPT09IDB4MjApIHtcbiAgICAgIGlmIChwbWF4ID49IDEgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXggLSAxKSA9PT0gMHgyMCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5yZXBsYWNlKC8gKyQvLCAnJyk7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICB9XG4gIH1cblxuICBwb3MrKztcblxuICAvLyBza2lwIGhlYWRpbmcgc3BhY2VzIGZvciBuZXh0IGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7IHBvcysrOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUuanMiLCIvLyBJbmxpbmUgcGFyc2VyIHN0YXRlXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgVG9rZW4gICAgICAgICAgPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxuXG5mdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMubWQgPSBtZDtcbiAgdGhpcy50b2tlbnMgPSBvdXRUb2tlbnM7XG5cbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLnBvc01heCA9IHRoaXMuc3JjLmxlbmd0aDtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICB0aGlzLnBlbmRpbmdMZXZlbCA9IDA7XG5cbiAgdGhpcy5jYWNoZSA9IHt9OyAgICAgICAgLy8gU3RvcmVzIHsgc3RhcnQ6IGVuZCB9IHBhaXJzLiBVc2VmdWwgZm9yIGJhY2t0cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6YXRpb24gb2YgcGFpcnMgcGFyc2UgKGVtcGhhc2lzLCBzdHJpa2VzKS5cblxuICB0aGlzLmRlbGltaXRlcnMgPSBbXTsgICAvLyBFbXBoYXNpcy1saWtlIGRlbGltaXRlcnNcbn1cblxuXG4vLyBGbHVzaCBwZW5kaW5nIHRleHRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbigndGV4dCcsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHRoaXMucGVuZGluZztcbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLnBlbmRpbmdMZXZlbDtcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vLyBJZiBwZW5kaW5nIHRleHQgZXhpc3RzIC0gZmx1c2ggaXQgYXMgdGV4dCB0b2tlblxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgdGhpcy5wdXNoUGVuZGluZygpO1xuICB9XG5cbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB7IHRoaXMubGV2ZWwtLTsgfVxuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gIGlmIChuZXN0aW5nID4gMCkgeyB0aGlzLmxldmVsKys7IH1cblxuICB0aGlzLnBlbmRpbmdMZXZlbCA9IHRoaXMubGV2ZWw7XG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBlbXBoYXNpcy1saWtlIG1hcmtlcnMsIGFuZCBkZXRlcm1pbmUgd2hldGhlclxuLy8gaXQgY2FuIHN0YXJ0IGFuIGVtcGhhc2lzIHNlcXVlbmNlIG9yIGVuZCBhbiBlbXBoYXNpcyBzZXF1ZW5jZS5cbi8vXG4vLyAgLSBzdGFydCAtIHBvc2l0aW9uIHRvIHNjYW4gZnJvbSAoaXQgc2hvdWxkIHBvaW50IGF0IGEgdmFsaWQgbWFya2VyKTtcbi8vICAtIGNhblNwbGl0V29yZCAtIGRldGVybWluZSBpZiB0aGVzZSBtYXJrZXJzIGNhbiBiZSBmb3VuZCBpbnNpZGUgYSB3b3JkXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnNjYW5EZWxpbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGNhblNwbGl0V29yZCkge1xuICB2YXIgcG9zID0gc3RhcnQsIGxhc3RDaGFyLCBuZXh0Q2hhciwgY291bnQsIGNhbl9vcGVuLCBjYW5fY2xvc2UsXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlLCBpc0xhc3RQdW5jdENoYXIsXG4gICAgICBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsXG4gICAgICBsZWZ0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIG1heCA9IHRoaXMucG9zTWF4LFxuICAgICAgbWFya2VyID0gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgLy8gdHJlYXQgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDB4MjA7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKzsgfVxuXG4gIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG5cbiAgLy8gdHJlYXQgZW5kIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA6IDB4MjA7XG5cbiAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNhblNwbGl0V29yZCkge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmcgICYmICghcmlnaHRfZmxhbmtpbmcgfHwgaXNMYXN0UHVuY3RDaGFyKTtcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZyAmJiAoIWxlZnRfZmxhbmtpbmcgIHx8IGlzTmV4dFB1bmN0Q2hhcik7XG4gIH0gZWxzZSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZztcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2FuX29wZW46ICBjYW5fb3BlbixcbiAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSxcbiAgICBsZW5ndGg6ICAgIGNvdW50XG4gIH07XG59O1xuXG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlSW5saW5lLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVJbmxpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZS5qcyIsIi8vIFNraXAgdGV4dCBjaGFyYWN0ZXJzIGZvciB0ZXh0IHRva2VuLCBwbGFjZSB0aG9zZSB0byBwZW5kaW5nIGJ1ZmZlclxuLy8gYW5kIGluY3JlbWVudCBjdXJyZW50IHBvc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gUnVsZSB0byBza2lwIHB1cmUgdGV4dFxuLy8gJ3t9JCVAfis9OicgcmVzZXJ2ZWQgZm9yIGV4dGVudGlvbnNcblxuLy8gISwgXCIsICMsICQsICUsICYsICcsICgsICksICosICssICwsIC0sIC4sIC8sIDosIDssIDwsID0sID4sID8sIEAsIFssIFxcLCBdLCBeLCBfLCBgLCB7LCB8LCB9LCBvciB+XG5cbi8vICEhISEgRG9uJ3QgY29uZnVzZSB3aXRoIFwiTWFya2Rvd24gQVNDSUkgUHVuY3R1YXRpb25cIiBjaGFyc1xuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG5mdW5jdGlvbiBpc1Rlcm1pbmF0b3JDaGFyKGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MEEvKiBcXG4gKi86XG4gICAgY2FzZSAweDIxLyogISAqLzpcbiAgICBjYXNlIDB4MjMvKiAjICovOlxuICAgIGNhc2UgMHgyNC8qICQgKi86XG4gICAgY2FzZSAweDI1LyogJSAqLzpcbiAgICBjYXNlIDB4MjYvKiAmICovOlxuICAgIGNhc2UgMHgyQS8qICogKi86XG4gICAgY2FzZSAweDJCLyogKyAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgzQS8qIDogKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0QvKiB9ICovOlxuICAgIGNhc2UgMHg3RS8qIH4gKi86XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLnBvc01heCAmJiAhaXNUZXJtaW5hdG9yQ2hhcihzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkge1xuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBvcyA9PT0gc3RhdGUucG9zKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHN0YXRlLnBvcywgcG9zKTsgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9uLCBmb3IgbWVtb3J5LlxuLy9cbi8vIEl0IGNvc3RzIDEwJSBvZiBwZXJmb3JtYW5jZSwgYnV0IGFsbG93cyBleHRlbmQgdGVybWluYXRvcnMgbGlzdCwgaWYgcGxhY2UgaXRcbi8vIHRvIGBQYXJjZXJJbmxpbmVgIHByb3BlcnR5LiBQcm9iYWJseSwgd2lsbCBzd2l0Y2ggdG8gaXQgc29tZXRpbWUsIHN1Y2hcbi8vIGZsZXhpYmlsaXR5IHJlcXVpcmVkLlxuXG4vKlxudmFyIFRFUk1JTkFUT1JfUkUgPSAvW1xcbiEjJCUmKitcXC06PD0+QFtcXFxcXFxdXl9ge31+XS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBpZHggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5zZWFyY2goVEVSTUlOQVRPUl9SRSk7XG5cbiAgLy8gZmlyc3QgY2hhciBpcyB0ZXJtaW5hdG9yIC0+IGVtcHR5IHRleHRcbiAgaWYgKGlkeCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBubyB0ZXJtaW5hdG9yIC0+IHRleHQgdGlsbCBlbmQgb2Ygc3RyaW5nXG4gIGlmIChpZHggPCAwKSB7XG4gICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTsgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnNyYy5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIGlkeCk7IH1cblxuICBzdGF0ZS5wb3MgKz0gaWR4O1xuXG4gIHJldHVybiB0cnVlO1xufTsqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwiLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyBpbnRvIG9uZSwgYW5kIHJlLWNhbGN1bGF0ZSBhbGwgdG9rZW4gbGV2ZWxzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dF9jb2xsYXBzZShzdGF0ZSkge1xuICB2YXIgY3VyciwgbGFzdCxcbiAgICAgIGxldmVsID0gMCxcbiAgICAgIHRva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIG1heCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgZm9yIChjdXJyID0gbGFzdCA9IDA7IGN1cnIgPCBtYXg7IGN1cnIrKykge1xuICAgIC8vIHJlLWNhbGN1bGF0ZSBsZXZlbHNcbiAgICBsZXZlbCArPSB0b2tlbnNbY3Vycl0ubmVzdGluZztcbiAgICB0b2tlbnNbY3Vycl0ubGV2ZWwgPSBsZXZlbDtcblxuICAgIGlmICh0b2tlbnNbY3Vycl0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIGN1cnIgKyAxIDwgbWF4ICYmXG4gICAgICAgIHRva2Vuc1tjdXJyICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG5cbiAgICAgIC8vIGNvbGxhcHNlIHR3byBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQgPSB0b2tlbnNbY3Vycl0uY29udGVudCArIHRva2Vuc1tjdXJyICsgMV0uY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnIgIT09IGxhc3QpIHsgdG9rZW5zW2xhc3RdID0gdG9rZW5zW2N1cnJdOyB9XG5cbiAgICAgIGxhc3QrKztcbiAgICB9XG4gIH1cblxuICBpZiAoY3VyciAhPT0gbGFzdCkge1xuICAgIHRva2Vucy5sZW5ndGggPSBsYXN0O1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG52YXIgZGVjb2RlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGNhY2hlLnB1c2goY2gpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IGV4Y2x1ZGUuY2hhckNvZGVBdChpKTtcbiAgICBjYWNoZVtjaF0gPSAnJScgKyAoJzAnICsgY2gudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBEZWNvZGUgcGVyY2VudC1lbmNvZGVkIHN0cmluZy5cbi8vXG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBleGNsdWRlKSB7XG4gIHZhciBjYWNoZTtcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgZXhjbHVkZSA9IGRlY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBjYWNoZSA9IGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKCVbYS1mMC05XXsyfSkrL2dpLCBmdW5jdGlvbihzZXEpIHtcbiAgICB2YXIgaSwgbCwgYjEsIGIyLCBiMywgYjQsIGNocixcbiAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gc2VxLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgYjEgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEsIGkgKyAzKSwgMTYpO1xuXG4gICAgICBpZiAoYjEgPCAweDgwKSB7XG4gICAgICAgIHJlc3VsdCArPSBjYWNoZVtiMV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhFMCkgPT09IDB4QzAgJiYgKGkgKyAzIDwgbCkpIHtcbiAgICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgNikgJiAweDdDMCkgfCAoYjIgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjApID09PSAweEUwICYmIChpICsgNiA8IGwpKSB7XG4gICAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTIpICYgMHhGMDAwKSB8ICgoYjIgPDwgNikgJiAweEZDMCkgfCAoYjMgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwMCB8fCAoY2hyID49IDB4RDgwMCAmJiBjaHIgPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGOCkgPT09IDB4RjAgJiYgKGkgKyA5IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMTEweHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG4gICAgICAgIGI0ID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxMCwgaSArIDEyKSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjQgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTgpICYgMHgxQzAwMDApIHwgKChiMiA8PCAxMikgJiAweDNGMDAwKSB8ICgoYjMgPDwgNikgJiAweEZDMCkgfCAoYjQgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDEwMDAwIHx8IGNociA+IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArIChjaHIgPj4gMTApLCAweERDMDAgKyAoY2hyICYgMHgzRkYpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkJztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cblxuXG5kZWNvZGUuZGVmYXVsdENoYXJzICAgPSAnOy8/OkAmPSskLCMnO1xuZGVjb2RlLmNvbXBvbmVudENoYXJzID0gJyc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9kZWNvZGUuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICB2YXIgaSwgbCwgY29kZSwgbmV4dENvZGUsIGNhY2hlLFxuICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XG4gICAgZXhjbHVkZSA9IGVuY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgaWYgKG5leHRDb2RlID49IDB4REMwMCAmJiBuZXh0Q29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZW5jb2RlLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L21kdXJsL2VuY29kZS5qcyIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ybWF0KHVybCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgcmVzdWx0ICs9IHVybC5wcm90b2NvbCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zbGFzaGVzID8gJy8vJyA6ICcnO1xuICByZXN1bHQgKz0gdXJsLmF1dGggPyB1cmwuYXV0aCArICdAJyA6ICcnO1xuXG4gIGlmICh1cmwuaG9zdG5hbWUgJiYgdXJsLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAvLyBpcHY2IGFkZHJlc3NcbiAgICByZXN1bHQgKz0gJ1snICsgdXJsLmhvc3RuYW1lICsgJ10nO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSB1cmwuaG9zdG5hbWUgfHwgJyc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLnBvcnQgPyAnOicgKyB1cmwucG9ydCA6ICcnO1xuICByZXN1bHQgKz0gdXJsLnBhdGhuYW1lIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNlYXJjaCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5oYXNoIHx8ICcnO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vbWR1cmwvZm9ybWF0LmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy9cbi8vIENoYW5nZXMgZnJvbSBqb3llbnQvbm9kZTpcbi8vXG4vLyAxLiBObyBsZWFkaW5nIHNsYXNoIGluIHBhdGhzLFxuLy8gICAgZS5nLiBpbiBgdXJsLnBhcnNlKCdodHRwOi8vZm9vP2JhcicpYCBwYXRobmFtZSBpcyBgYCwgbm90IGAvYFxuLy9cbi8vIDIuIEJhY2tzbGFzaGVzIGFyZSBub3QgcmVwbGFjZWQgd2l0aCBzbGFzaGVzLFxuLy8gICAgc28gYGh0dHA6XFxcXGV4YW1wbGUub3JnXFxgIGlzIHRyZWF0ZWQgbGlrZSBhIHJlbGF0aXZlIHBhdGhcbi8vXG4vLyAzLiBUcmFpbGluZyBjb2xvbiBpcyB0cmVhdGVkIGxpa2UgYSBwYXJ0IG9mIHRoZSBwYXRoLFxuLy8gICAgaS5lLiBpbiBgaHR0cDovL2V4YW1wbGUub3JnOmZvb2AgcGF0aG5hbWUgaXMgYDpmb29gXG4vL1xuLy8gNC4gTm90aGluZyBpcyBVUkwtZW5jb2RlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdCxcbi8vICAgIChpbiBqb3llbnQvbm9kZSBzb21lIGNoYXJzIGluIGF1dGggYW5kIHBhdGhzIGFyZSBlbmNvZGVkKVxuLy9cbi8vIDUuIGB1cmwucGFyc2UoKWAgZG9lcyBub3QgaGF2ZSBgcGFyc2VRdWVyeVN0cmluZ2AgYXJndW1lbnRcbi8vXG4vLyA2LiBSZW1vdmVkIGV4dHJhbmVvdXMgcmVzdWx0IHByb3BlcnRpZXM6IGBob3N0YCwgYHBhdGhgLCBgcXVlcnlgLCBldGMuLFxuLy8gICAgd2hpY2ggY2FuIGJlIGNvbnN0cnVjdGVkIHVzaW5nIG90aGVyIHBhcnRzIG9mIHRoZSB1cmwuXG4vL1xuXG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbICc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0JyBdLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbICd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCcgXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWyAnXFwnJyBdLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyAnJScsICcvJywgJz8nLCAnOycsICcjJyBdLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbICcvJywgJz8nLCAnIycgXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNjcmlwdC11cmwgKi9cbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1zY3JpcHQtdXJsICovXG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHsgcmV0dXJuIHVybDsgfVxuXG4gIHZhciB1ID0gbmV3IFVybCgpO1xuICB1LnBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgdmFyIGksIGwsIGxvd2VyUHJvdG8sIGhlYywgc2xhc2hlcyxcbiAgICAgIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gcHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHJlc3RbaG9zdEVuZCAtIDFdID09PSAnOicpIHsgaG9zdEVuZC0tOyB9XG4gICAgdmFyIGhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdChob3N0KTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH1cblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfVxuICBpZiAocmVzdCkgeyB0aGlzLnBhdGhuYW1lID0gcmVzdDsgfVxuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKGhvc3QpIHtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHsgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7IH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXJsUGFyc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9tZHVybC9wYXJzZS5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vcHVueWNvZGUvcHVueWNvZGUuanMiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qcyIsInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUwOEUyXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkJdfFxcdUQ4MDRcXHVEQ0JEfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFueSA9IHJlcXVpcmUoJy4vcHJvcGVydGllcy9BbnkvcmVnZXgnKTtcbmV4cG9ydHMuQ2MgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NjL3JlZ2V4Jyk7XG5leHBvcnRzLkNmICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DZi9yZWdleCcpO1xuZXhwb3J0cy5QICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuZXhwb3J0cy5aICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvWi9yZWdleCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2Jva3Uvd29yay9tdHd0a21hbi5naXRodWIuaW8vYmxvZ19tYW5hZ2VyL2Jsb2dfbWFuYWdlci9zdGF0aWNzL2pzL34vdWMubWljcm8vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLl8yWXJLRW1ydVNYcS1MWThIVDlnamNBe3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7aGVpZ2h0OmNhbGMoMTAwJSAtIDIzMHB4KX0uXzNMNU5FQjg0S3hQZmx4Qlp2ZXlzZGR7dGV4dC1hbGlnbjpyaWdodDttYXJnaW4tdG9wOjE1cHh9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwiZWRpdG9yV3JhcFwiOiBcIl8yWXJLRW1ydVNYcS1MWThIVDlnamNBXCIsXG5cdFwic2F2ZUJ1dHRvblwiOiBcIl8zTDVORUI4NEt4UGZseEJadmV5c2RkXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9jc3MtbG9hZGVyP3tcIm1vZHVsZXNcIjp0cnVlLFwibWluaW1pemVcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZX0hLi9zdHlsZXMuY3NzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuWmVXM0hJd2FfQldJR1cweVpKaTVHe3dpZHRoOjEwMCU7Zm9udC1zaXplOjI0cHQ7cGFkZGluZy1sZWZ0OjEwcHh9LkFBTUVOY25kbW8tbzdJamp6UUhSWSwuWmNzYVp2Y29mMHR4V2RlcWlrQ0dae3dpZHRoOjEwMCU7Zm9udC1zaXplOjE4cHQ7cGFkZGluZy1sZWZ0OjEwcHh9Ll8xb3Vhc2o2NDZNN2k5b0t3LTBRXzU1e3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7aGVpZ2h0OmNhbGMoMTAwJSAtIDIzMHB4KX0uXzJNTFdSOFdfcEhmTkJrQm1wMG5pMDh7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7YmFja2dyb3VuZDojZmNmY2ZjO3BhZGRpbmc6MTBweDtvdmVyZmxvdzphdXRvO2hlaWdodDoxMDAlfS5HSllvblNITE9YWkpoUFNVd1pkdmJ7bGVmdDowfS51X1JTeXZCTEQ3YjBaMTJocEs4RDR7bGVmdDo1MCU7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5fMmdBdGdtOW9BRE9yWll0MXVkbWNKUnt0ZXh0LWFsaWduOnJpZ2h0O21hcmdpbi10b3A6MTVweH0uXzNOQmJJcjRXbEh5VVFjMjlZVzZiU1h7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtyZXNpemU6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiNmY2ZjZmM7Ym9yZGVyOm5vbmU7Zm9udC1zaXplOjEwcHR9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwidGl0bGVcIjogXCJaZVczSEl3YV9CV0lHVzB5WkppNUdcIixcblx0XCJ0YWdzXCI6IFwiWmNzYVp2Y29mMHR4V2RlcWlrQ0daXCIsXG5cdFwic2x1Z1wiOiBcIkFBTUVOY25kbW8tbzdJamp6UUhSWVwiLFxuXHRcImVkaXRvcldyYXBcIjogXCJfMW91YXNqNjQ2TTdpOW9Ldy0wUV81NVwiLFxuXHRcImVkaXRvclwiOiBcIl8yTUxXUjhXX3BIZk5Ca0JtcDBuaTA4XCIsXG5cdFwiZWRpdG9yTGVmdFNpZGVcIjogXCJHSllvblNITE9YWkpoUFNVd1pkdmJcIixcblx0XCJlZGl0b3JSaWdodFNpZGVcIjogXCJ1X1JTeXZCTEQ3YjBaMTJocEs4RDRcIixcblx0XCJzYXZlQnV0dG9uXCI6IFwiXzJnQXRnbTlvQURPclpZdDF1ZG1jSlJcIixcblx0XCJ0ZXh0YXJlYVwiOiBcIl8zTkJiSXI0V2xIeVVRYzI5WVc2YlNYXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvYm9rdS93b3JrL210d3RrbWFuLmdpdGh1Yi5pby9ibG9nX21hbmFnZXIvYmxvZ19tYW5hZ2VyL3N0YXRpY3MvanMvfi9jc3MtbG9hZGVyP3tcIm1vZHVsZXNcIjp0cnVlLFwibWluaW1pemVcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZX0hLi4vbGlicy9jb21wb25lbnRzL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcIkFhY3V0ZVwiOiBcIsOBXCIsXG5cdFwiYWFjdXRlXCI6IFwiw6FcIixcblx0XCJBYnJldmVcIjogXCLEglwiLFxuXHRcImFicmV2ZVwiOiBcIsSDXCIsXG5cdFwiYWNcIjogXCLiiL5cIixcblx0XCJhY2RcIjogXCLiiL9cIixcblx0XCJhY0VcIjogXCLiiL7Ms1wiLFxuXHRcIkFjaXJjXCI6IFwiw4JcIixcblx0XCJhY2lyY1wiOiBcIsOiXCIsXG5cdFwiYWN1dGVcIjogXCLCtFwiLFxuXHRcIkFjeVwiOiBcItCQXCIsXG5cdFwiYWN5XCI6IFwi0LBcIixcblx0XCJBRWxpZ1wiOiBcIsOGXCIsXG5cdFwiYWVsaWdcIjogXCLDplwiLFxuXHRcImFmXCI6IFwi4oGhXCIsXG5cdFwiQWZyXCI6IFwi8J2UhFwiLFxuXHRcImFmclwiOiBcIvCdlJ5cIixcblx0XCJBZ3JhdmVcIjogXCLDgFwiLFxuXHRcImFncmF2ZVwiOiBcIsOgXCIsXG5cdFwiYWxlZnN5bVwiOiBcIuKEtVwiLFxuXHRcImFsZXBoXCI6IFwi4oS1XCIsXG5cdFwiQWxwaGFcIjogXCLOkVwiLFxuXHRcImFscGhhXCI6IFwizrFcIixcblx0XCJBbWFjclwiOiBcIsSAXCIsXG5cdFwiYW1hY3JcIjogXCLEgVwiLFxuXHRcImFtYWxnXCI6IFwi4qi/XCIsXG5cdFwiYW1wXCI6IFwiJlwiLFxuXHRcIkFNUFwiOiBcIiZcIixcblx0XCJhbmRhbmRcIjogXCLiqZVcIixcblx0XCJBbmRcIjogXCLiqZNcIixcblx0XCJhbmRcIjogXCLiiKdcIixcblx0XCJhbmRkXCI6IFwi4qmcXCIsXG5cdFwiYW5kc2xvcGVcIjogXCLiqZhcIixcblx0XCJhbmR2XCI6IFwi4qmaXCIsXG5cdFwiYW5nXCI6IFwi4oigXCIsXG5cdFwiYW5nZVwiOiBcIuKmpFwiLFxuXHRcImFuZ2xlXCI6IFwi4oigXCIsXG5cdFwiYW5nbXNkYWFcIjogXCLipqhcIixcblx0XCJhbmdtc2RhYlwiOiBcIuKmqVwiLFxuXHRcImFuZ21zZGFjXCI6IFwi4qaqXCIsXG5cdFwiYW5nbXNkYWRcIjogXCLipqtcIixcblx0XCJhbmdtc2RhZVwiOiBcIuKmrFwiLFxuXHRcImFuZ21zZGFmXCI6IFwi4qatXCIsXG5cdFwiYW5nbXNkYWdcIjogXCLipq5cIixcblx0XCJhbmdtc2RhaFwiOiBcIuKmr1wiLFxuXHRcImFuZ21zZFwiOiBcIuKIoVwiLFxuXHRcImFuZ3J0XCI6IFwi4oifXCIsXG5cdFwiYW5ncnR2YlwiOiBcIuKKvlwiLFxuXHRcImFuZ3J0dmJkXCI6IFwi4qadXCIsXG5cdFwiYW5nc3BoXCI6IFwi4oiiXCIsXG5cdFwiYW5nc3RcIjogXCLDhVwiLFxuXHRcImFuZ3phcnJcIjogXCLijbxcIixcblx0XCJBb2dvblwiOiBcIsSEXCIsXG5cdFwiYW9nb25cIjogXCLEhVwiLFxuXHRcIkFvcGZcIjogXCLwnZS4XCIsXG5cdFwiYW9wZlwiOiBcIvCdlZJcIixcblx0XCJhcGFjaXJcIjogXCLiqa9cIixcblx0XCJhcFwiOiBcIuKJiFwiLFxuXHRcImFwRVwiOiBcIuKpsFwiLFxuXHRcImFwZVwiOiBcIuKJilwiLFxuXHRcImFwaWRcIjogXCLiiYtcIixcblx0XCJhcG9zXCI6IFwiJ1wiLFxuXHRcIkFwcGx5RnVuY3Rpb25cIjogXCLigaFcIixcblx0XCJhcHByb3hcIjogXCLiiYhcIixcblx0XCJhcHByb3hlcVwiOiBcIuKJilwiLFxuXHRcIkFyaW5nXCI6IFwiw4VcIixcblx0XCJhcmluZ1wiOiBcIsOlXCIsXG5cdFwiQXNjclwiOiBcIvCdkpxcIixcblx0XCJhc2NyXCI6IFwi8J2StlwiLFxuXHRcIkFzc2lnblwiOiBcIuKJlFwiLFxuXHRcImFzdFwiOiBcIipcIixcblx0XCJhc3ltcFwiOiBcIuKJiFwiLFxuXHRcImFzeW1wZXFcIjogXCLiiY1cIixcblx0XCJBdGlsZGVcIjogXCLDg1wiLFxuXHRcImF0aWxkZVwiOiBcIsOjXCIsXG5cdFwiQXVtbFwiOiBcIsOEXCIsXG5cdFwiYXVtbFwiOiBcIsOkXCIsXG5cdFwiYXdjb25pbnRcIjogXCLiiLNcIixcblx0XCJhd2ludFwiOiBcIuKokVwiLFxuXHRcImJhY2tjb25nXCI6IFwi4omMXCIsXG5cdFwiYmFja2Vwc2lsb25cIjogXCLPtlwiLFxuXHRcImJhY2twcmltZVwiOiBcIuKAtVwiLFxuXHRcImJhY2tzaW1cIjogXCLiiL1cIixcblx0XCJiYWNrc2ltZXFcIjogXCLii41cIixcblx0XCJCYWNrc2xhc2hcIjogXCLiiJZcIixcblx0XCJCYXJ2XCI6IFwi4qunXCIsXG5cdFwiYmFydmVlXCI6IFwi4oq9XCIsXG5cdFwiYmFyd2VkXCI6IFwi4oyFXCIsXG5cdFwiQmFyd2VkXCI6IFwi4oyGXCIsXG5cdFwiYmFyd2VkZ2VcIjogXCLijIVcIixcblx0XCJiYnJrXCI6IFwi4o61XCIsXG5cdFwiYmJya3RicmtcIjogXCLijrZcIixcblx0XCJiY29uZ1wiOiBcIuKJjFwiLFxuXHRcIkJjeVwiOiBcItCRXCIsXG5cdFwiYmN5XCI6IFwi0LFcIixcblx0XCJiZHF1b1wiOiBcIuKAnlwiLFxuXHRcImJlY2F1c1wiOiBcIuKItVwiLFxuXHRcImJlY2F1c2VcIjogXCLiiLVcIixcblx0XCJCZWNhdXNlXCI6IFwi4oi1XCIsXG5cdFwiYmVtcHR5dlwiOiBcIuKmsFwiLFxuXHRcImJlcHNpXCI6IFwiz7ZcIixcblx0XCJiZXJub3VcIjogXCLihKxcIixcblx0XCJCZXJub3VsbGlzXCI6IFwi4oSsXCIsXG5cdFwiQmV0YVwiOiBcIs6SXCIsXG5cdFwiYmV0YVwiOiBcIs6yXCIsXG5cdFwiYmV0aFwiOiBcIuKEtlwiLFxuXHRcImJldHdlZW5cIjogXCLiiaxcIixcblx0XCJCZnJcIjogXCLwnZSFXCIsXG5cdFwiYmZyXCI6IFwi8J2Un1wiLFxuXHRcImJpZ2NhcFwiOiBcIuKLglwiLFxuXHRcImJpZ2NpcmNcIjogXCLil69cIixcblx0XCJiaWdjdXBcIjogXCLii4NcIixcblx0XCJiaWdvZG90XCI6IFwi4qiAXCIsXG5cdFwiYmlnb3BsdXNcIjogXCLiqIFcIixcblx0XCJiaWdvdGltZXNcIjogXCLiqIJcIixcblx0XCJiaWdzcWN1cFwiOiBcIuKohlwiLFxuXHRcImJpZ3N0YXJcIjogXCLimIVcIixcblx0XCJiaWd0cmlhbmdsZWRvd25cIjogXCLilr1cIixcblx0XCJiaWd0cmlhbmdsZXVwXCI6IFwi4pazXCIsXG5cdFwiYmlndXBsdXNcIjogXCLiqIRcIixcblx0XCJiaWd2ZWVcIjogXCLii4FcIixcblx0XCJiaWd3ZWRnZVwiOiBcIuKLgFwiLFxuXHRcImJrYXJvd1wiOiBcIuKkjVwiLFxuXHRcImJsYWNrbG96ZW5nZVwiOiBcIuKnq1wiLFxuXHRcImJsYWNrc3F1YXJlXCI6IFwi4paqXCIsXG5cdFwiYmxhY2t0cmlhbmdsZVwiOiBcIuKWtFwiLFxuXHRcImJsYWNrdHJpYW5nbGVkb3duXCI6IFwi4pa+XCIsXG5cdFwiYmxhY2t0cmlhbmdsZWxlZnRcIjogXCLil4JcIixcblx0XCJibGFja3RyaWFuZ2xlcmlnaHRcIjogXCLilrhcIixcblx0XCJibGFua1wiOiBcIuKQo1wiLFxuXHRcImJsazEyXCI6IFwi4paSXCIsXG5cdFwiYmxrMTRcIjogXCLilpFcIixcblx0XCJibGszNFwiOiBcIuKWk1wiLFxuXHRcImJsb2NrXCI6IFwi4paIXCIsXG5cdFwiYm5lXCI6IFwiPeKDpVwiLFxuXHRcImJuZXF1aXZcIjogXCLiiaHig6VcIixcblx0XCJiTm90XCI6IFwi4qutXCIsXG5cdFwiYm5vdFwiOiBcIuKMkFwiLFxuXHRcIkJvcGZcIjogXCLwnZS5XCIsXG5cdFwiYm9wZlwiOiBcIvCdlZNcIixcblx0XCJib3RcIjogXCLiiqVcIixcblx0XCJib3R0b21cIjogXCLiiqVcIixcblx0XCJib3d0aWVcIjogXCLii4hcIixcblx0XCJib3hib3hcIjogXCLip4lcIixcblx0XCJib3hkbFwiOiBcIuKUkFwiLFxuXHRcImJveGRMXCI6IFwi4pWVXCIsXG5cdFwiYm94RGxcIjogXCLilZZcIixcblx0XCJib3hETFwiOiBcIuKVl1wiLFxuXHRcImJveGRyXCI6IFwi4pSMXCIsXG5cdFwiYm94ZFJcIjogXCLilZJcIixcblx0XCJib3hEclwiOiBcIuKVk1wiLFxuXHRcImJveERSXCI6IFwi4pWUXCIsXG5cdFwiYm94aFwiOiBcIuKUgFwiLFxuXHRcImJveEhcIjogXCLilZBcIixcblx0XCJib3hoZFwiOiBcIuKUrFwiLFxuXHRcImJveEhkXCI6IFwi4pWkXCIsXG5cdFwiYm94aERcIjogXCLilaVcIixcblx0XCJib3hIRFwiOiBcIuKVplwiLFxuXHRcImJveGh1XCI6IFwi4pS0XCIsXG5cdFwiYm94SHVcIjogXCLiladcIixcblx0XCJib3hoVVwiOiBcIuKVqFwiLFxuXHRcImJveEhVXCI6IFwi4pWpXCIsXG5cdFwiYm94bWludXNcIjogXCLiip9cIixcblx0XCJib3hwbHVzXCI6IFwi4oqeXCIsXG5cdFwiYm94dGltZXNcIjogXCLiiqBcIixcblx0XCJib3h1bFwiOiBcIuKUmFwiLFxuXHRcImJveHVMXCI6IFwi4pWbXCIsXG5cdFwiYm94VWxcIjogXCLilZxcIixcblx0XCJib3hVTFwiOiBcIuKVnVwiLFxuXHRcImJveHVyXCI6IFwi4pSUXCIsXG5cdFwiYm94dVJcIjogXCLilZhcIixcblx0XCJib3hVclwiOiBcIuKVmVwiLFxuXHRcImJveFVSXCI6IFwi4pWaXCIsXG5cdFwiYm94dlwiOiBcIuKUglwiLFxuXHRcImJveFZcIjogXCLilZFcIixcblx0XCJib3h2aFwiOiBcIuKUvFwiLFxuXHRcImJveHZIXCI6IFwi4pWqXCIsXG5cdFwiYm94VmhcIjogXCLilatcIixcblx0XCJib3hWSFwiOiBcIuKVrFwiLFxuXHRcImJveHZsXCI6IFwi4pSkXCIsXG5cdFwiYm94dkxcIjogXCLilaFcIixcblx0XCJib3hWbFwiOiBcIuKVolwiLFxuXHRcImJveFZMXCI6IFwi4pWjXCIsXG5cdFwiYm94dnJcIjogXCLilJxcIixcblx0XCJib3h2UlwiOiBcIuKVnlwiLFxuXHRcImJveFZyXCI6IFwi4pWfXCIsXG5cdFwiYm94VlJcIjogXCLilaBcIixcblx0XCJicHJpbWVcIjogXCLigLVcIixcblx0XCJicmV2ZVwiOiBcIsuYXCIsXG5cdFwiQnJldmVcIjogXCLLmFwiLFxuXHRcImJydmJhclwiOiBcIsKmXCIsXG5cdFwiYnNjclwiOiBcIvCdkrdcIixcblx0XCJCc2NyXCI6IFwi4oSsXCIsXG5cdFwiYnNlbWlcIjogXCLigY9cIixcblx0XCJic2ltXCI6IFwi4oi9XCIsXG5cdFwiYnNpbWVcIjogXCLii41cIixcblx0XCJic29sYlwiOiBcIuKnhVwiLFxuXHRcImJzb2xcIjogXCJcXFxcXCIsXG5cdFwiYnNvbGhzdWJcIjogXCLin4hcIixcblx0XCJidWxsXCI6IFwi4oCiXCIsXG5cdFwiYnVsbGV0XCI6IFwi4oCiXCIsXG5cdFwiYnVtcFwiOiBcIuKJjlwiLFxuXHRcImJ1bXBFXCI6IFwi4qquXCIsXG5cdFwiYnVtcGVcIjogXCLiiY9cIixcblx0XCJCdW1wZXFcIjogXCLiiY5cIixcblx0XCJidW1wZXFcIjogXCLiiY9cIixcblx0XCJDYWN1dGVcIjogXCLEhlwiLFxuXHRcImNhY3V0ZVwiOiBcIsSHXCIsXG5cdFwiY2FwYW5kXCI6IFwi4qmEXCIsXG5cdFwiY2FwYnJjdXBcIjogXCLiqYlcIixcblx0XCJjYXBjYXBcIjogXCLiqYtcIixcblx0XCJjYXBcIjogXCLiiKlcIixcblx0XCJDYXBcIjogXCLii5JcIixcblx0XCJjYXBjdXBcIjogXCLiqYdcIixcblx0XCJjYXBkb3RcIjogXCLiqYBcIixcblx0XCJDYXBpdGFsRGlmZmVyZW50aWFsRFwiOiBcIuKFhVwiLFxuXHRcImNhcHNcIjogXCLiiKnvuIBcIixcblx0XCJjYXJldFwiOiBcIuKBgVwiLFxuXHRcImNhcm9uXCI6IFwiy4dcIixcblx0XCJDYXlsZXlzXCI6IFwi4oStXCIsXG5cdFwiY2NhcHNcIjogXCLiqY1cIixcblx0XCJDY2Fyb25cIjogXCLEjFwiLFxuXHRcImNjYXJvblwiOiBcIsSNXCIsXG5cdFwiQ2NlZGlsXCI6IFwiw4dcIixcblx0XCJjY2VkaWxcIjogXCLDp1wiLFxuXHRcIkNjaXJjXCI6IFwixIhcIixcblx0XCJjY2lyY1wiOiBcIsSJXCIsXG5cdFwiQ2NvbmludFwiOiBcIuKIsFwiLFxuXHRcImNjdXBzXCI6IFwi4qmMXCIsXG5cdFwiY2N1cHNzbVwiOiBcIuKpkFwiLFxuXHRcIkNkb3RcIjogXCLEilwiLFxuXHRcImNkb3RcIjogXCLEi1wiLFxuXHRcImNlZGlsXCI6IFwiwrhcIixcblx0XCJDZWRpbGxhXCI6IFwiwrhcIixcblx0XCJjZW1wdHl2XCI6IFwi4qayXCIsXG5cdFwiY2VudFwiOiBcIsKiXCIsXG5cdFwiY2VudGVyZG90XCI6IFwiwrdcIixcblx0XCJDZW50ZXJEb3RcIjogXCLCt1wiLFxuXHRcImNmclwiOiBcIvCdlKBcIixcblx0XCJDZnJcIjogXCLihK1cIixcblx0XCJDSGN5XCI6IFwi0KdcIixcblx0XCJjaGN5XCI6IFwi0YdcIixcblx0XCJjaGVja1wiOiBcIuKck1wiLFxuXHRcImNoZWNrbWFya1wiOiBcIuKck1wiLFxuXHRcIkNoaVwiOiBcIs6nXCIsXG5cdFwiY2hpXCI6IFwiz4dcIixcblx0XCJjaXJjXCI6IFwiy4ZcIixcblx0XCJjaXJjZXFcIjogXCLiiZdcIixcblx0XCJjaXJjbGVhcnJvd2xlZnRcIjogXCLihrpcIixcblx0XCJjaXJjbGVhcnJvd3JpZ2h0XCI6IFwi4oa7XCIsXG5cdFwiY2lyY2xlZGFzdFwiOiBcIuKKm1wiLFxuXHRcImNpcmNsZWRjaXJjXCI6IFwi4oqaXCIsXG5cdFwiY2lyY2xlZGRhc2hcIjogXCLiip1cIixcblx0XCJDaXJjbGVEb3RcIjogXCLiiplcIixcblx0XCJjaXJjbGVkUlwiOiBcIsKuXCIsXG5cdFwiY2lyY2xlZFNcIjogXCLik4hcIixcblx0XCJDaXJjbGVNaW51c1wiOiBcIuKKllwiLFxuXHRcIkNpcmNsZVBsdXNcIjogXCLiipVcIixcblx0XCJDaXJjbGVUaW1lc1wiOiBcIuKKl1wiLFxuXHRcImNpclwiOiBcIuKXi1wiLFxuXHRcImNpckVcIjogXCLip4NcIixcblx0XCJjaXJlXCI6IFwi4omXXCIsXG5cdFwiY2lyZm5pbnRcIjogXCLiqJBcIixcblx0XCJjaXJtaWRcIjogXCLiq69cIixcblx0XCJjaXJzY2lyXCI6IFwi4qeCXCIsXG5cdFwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6IFwi4oiyXCIsXG5cdFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6IFwi4oCdXCIsXG5cdFwiQ2xvc2VDdXJseVF1b3RlXCI6IFwi4oCZXCIsXG5cdFwiY2x1YnNcIjogXCLimaNcIixcblx0XCJjbHVic3VpdFwiOiBcIuKZo1wiLFxuXHRcImNvbG9uXCI6IFwiOlwiLFxuXHRcIkNvbG9uXCI6IFwi4oi3XCIsXG5cdFwiQ29sb25lXCI6IFwi4qm0XCIsXG5cdFwiY29sb25lXCI6IFwi4omUXCIsXG5cdFwiY29sb25lcVwiOiBcIuKJlFwiLFxuXHRcImNvbW1hXCI6IFwiLFwiLFxuXHRcImNvbW1hdFwiOiBcIkBcIixcblx0XCJjb21wXCI6IFwi4oiBXCIsXG5cdFwiY29tcGZuXCI6IFwi4oiYXCIsXG5cdFwiY29tcGxlbWVudFwiOiBcIuKIgVwiLFxuXHRcImNvbXBsZXhlc1wiOiBcIuKEglwiLFxuXHRcImNvbmdcIjogXCLiiYVcIixcblx0XCJjb25nZG90XCI6IFwi4qmtXCIsXG5cdFwiQ29uZ3J1ZW50XCI6IFwi4omhXCIsXG5cdFwiY29uaW50XCI6IFwi4oiuXCIsXG5cdFwiQ29uaW50XCI6IFwi4oivXCIsXG5cdFwiQ29udG91ckludGVncmFsXCI6IFwi4oiuXCIsXG5cdFwiY29wZlwiOiBcIvCdlZRcIixcblx0XCJDb3BmXCI6IFwi4oSCXCIsXG5cdFwiY29wcm9kXCI6IFwi4oiQXCIsXG5cdFwiQ29wcm9kdWN0XCI6IFwi4oiQXCIsXG5cdFwiY29weVwiOiBcIsKpXCIsXG5cdFwiQ09QWVwiOiBcIsKpXCIsXG5cdFwiY29weXNyXCI6IFwi4oSXXCIsXG5cdFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOiBcIuKIs1wiLFxuXHRcImNyYXJyXCI6IFwi4oa1XCIsXG5cdFwiY3Jvc3NcIjogXCLinJdcIixcblx0XCJDcm9zc1wiOiBcIuKor1wiLFxuXHRcIkNzY3JcIjogXCLwnZKeXCIsXG5cdFwiY3NjclwiOiBcIvCdkrhcIixcblx0XCJjc3ViXCI6IFwi4quPXCIsXG5cdFwiY3N1YmVcIjogXCLiq5FcIixcblx0XCJjc3VwXCI6IFwi4quQXCIsXG5cdFwiY3N1cGVcIjogXCLiq5JcIixcblx0XCJjdGRvdFwiOiBcIuKLr1wiLFxuXHRcImN1ZGFycmxcIjogXCLipLhcIixcblx0XCJjdWRhcnJyXCI6IFwi4qS1XCIsXG5cdFwiY3VlcHJcIjogXCLii55cIixcblx0XCJjdWVzY1wiOiBcIuKLn1wiLFxuXHRcImN1bGFyclwiOiBcIuKGtlwiLFxuXHRcImN1bGFycnBcIjogXCLipL1cIixcblx0XCJjdXBicmNhcFwiOiBcIuKpiFwiLFxuXHRcImN1cGNhcFwiOiBcIuKphlwiLFxuXHRcIkN1cENhcFwiOiBcIuKJjVwiLFxuXHRcImN1cFwiOiBcIuKIqlwiLFxuXHRcIkN1cFwiOiBcIuKLk1wiLFxuXHRcImN1cGN1cFwiOiBcIuKpilwiLFxuXHRcImN1cGRvdFwiOiBcIuKKjVwiLFxuXHRcImN1cG9yXCI6IFwi4qmFXCIsXG5cdFwiY3Vwc1wiOiBcIuKIqu+4gFwiLFxuXHRcImN1cmFyclwiOiBcIuKGt1wiLFxuXHRcImN1cmFycm1cIjogXCLipLxcIixcblx0XCJjdXJseWVxcHJlY1wiOiBcIuKLnlwiLFxuXHRcImN1cmx5ZXFzdWNjXCI6IFwi4oufXCIsXG5cdFwiY3VybHl2ZWVcIjogXCLii45cIixcblx0XCJjdXJseXdlZGdlXCI6IFwi4ouPXCIsXG5cdFwiY3VycmVuXCI6IFwiwqRcIixcblx0XCJjdXJ2ZWFycm93bGVmdFwiOiBcIuKGtlwiLFxuXHRcImN1cnZlYXJyb3dyaWdodFwiOiBcIuKGt1wiLFxuXHRcImN1dmVlXCI6IFwi4ouOXCIsXG5cdFwiY3V3ZWRcIjogXCLii49cIixcblx0XCJjd2NvbmludFwiOiBcIuKIslwiLFxuXHRcImN3aW50XCI6IFwi4oixXCIsXG5cdFwiY3lsY3R5XCI6IFwi4oytXCIsXG5cdFwiZGFnZ2VyXCI6IFwi4oCgXCIsXG5cdFwiRGFnZ2VyXCI6IFwi4oChXCIsXG5cdFwiZGFsZXRoXCI6IFwi4oS4XCIsXG5cdFwiZGFyclwiOiBcIuKGk1wiLFxuXHRcIkRhcnJcIjogXCLihqFcIixcblx0XCJkQXJyXCI6IFwi4oeTXCIsXG5cdFwiZGFzaFwiOiBcIuKAkFwiLFxuXHRcIkRhc2h2XCI6IFwi4qukXCIsXG5cdFwiZGFzaHZcIjogXCLiiqNcIixcblx0XCJkYmthcm93XCI6IFwi4qSPXCIsXG5cdFwiZGJsYWNcIjogXCLLnVwiLFxuXHRcIkRjYXJvblwiOiBcIsSOXCIsXG5cdFwiZGNhcm9uXCI6IFwixI9cIixcblx0XCJEY3lcIjogXCLQlFwiLFxuXHRcImRjeVwiOiBcItC0XCIsXG5cdFwiZGRhZ2dlclwiOiBcIuKAoVwiLFxuXHRcImRkYXJyXCI6IFwi4oeKXCIsXG5cdFwiRERcIjogXCLihYVcIixcblx0XCJkZFwiOiBcIuKFhlwiLFxuXHRcIkREb3RyYWhkXCI6IFwi4qSRXCIsXG5cdFwiZGRvdHNlcVwiOiBcIuKpt1wiLFxuXHRcImRlZ1wiOiBcIsKwXCIsXG5cdFwiRGVsXCI6IFwi4oiHXCIsXG5cdFwiRGVsdGFcIjogXCLOlFwiLFxuXHRcImRlbHRhXCI6IFwizrRcIixcblx0XCJkZW1wdHl2XCI6IFwi4qaxXCIsXG5cdFwiZGZpc2h0XCI6IFwi4qW/XCIsXG5cdFwiRGZyXCI6IFwi8J2Uh1wiLFxuXHRcImRmclwiOiBcIvCdlKFcIixcblx0XCJkSGFyXCI6IFwi4qWlXCIsXG5cdFwiZGhhcmxcIjogXCLih4NcIixcblx0XCJkaGFyclwiOiBcIuKHglwiLFxuXHRcIkRpYWNyaXRpY2FsQWN1dGVcIjogXCLCtFwiLFxuXHRcIkRpYWNyaXRpY2FsRG90XCI6IFwiy5lcIixcblx0XCJEaWFjcml0aWNhbERvdWJsZUFjdXRlXCI6IFwiy51cIixcblx0XCJEaWFjcml0aWNhbEdyYXZlXCI6IFwiYFwiLFxuXHRcIkRpYWNyaXRpY2FsVGlsZGVcIjogXCLLnFwiLFxuXHRcImRpYW1cIjogXCLii4RcIixcblx0XCJkaWFtb25kXCI6IFwi4ouEXCIsXG5cdFwiRGlhbW9uZFwiOiBcIuKLhFwiLFxuXHRcImRpYW1vbmRzdWl0XCI6IFwi4pmmXCIsXG5cdFwiZGlhbXNcIjogXCLimaZcIixcblx0XCJkaWVcIjogXCLCqFwiLFxuXHRcIkRpZmZlcmVudGlhbERcIjogXCLihYZcIixcblx0XCJkaWdhbW1hXCI6IFwiz51cIixcblx0XCJkaXNpblwiOiBcIuKLslwiLFxuXHRcImRpdlwiOiBcIsO3XCIsXG5cdFwiZGl2aWRlXCI6IFwiw7dcIixcblx0XCJkaXZpZGVvbnRpbWVzXCI6IFwi4ouHXCIsXG5cdFwiZGl2b254XCI6IFwi4ouHXCIsXG5cdFwiREpjeVwiOiBcItCCXCIsXG5cdFwiZGpjeVwiOiBcItGSXCIsXG5cdFwiZGxjb3JuXCI6IFwi4oyeXCIsXG5cdFwiZGxjcm9wXCI6IFwi4oyNXCIsXG5cdFwiZG9sbGFyXCI6IFwiJFwiLFxuXHRcIkRvcGZcIjogXCLwnZS7XCIsXG5cdFwiZG9wZlwiOiBcIvCdlZVcIixcblx0XCJEb3RcIjogXCLCqFwiLFxuXHRcImRvdFwiOiBcIsuZXCIsXG5cdFwiRG90RG90XCI6IFwi4oOcXCIsXG5cdFwiZG90ZXFcIjogXCLiiZBcIixcblx0XCJkb3RlcWRvdFwiOiBcIuKJkVwiLFxuXHRcIkRvdEVxdWFsXCI6IFwi4omQXCIsXG5cdFwiZG90bWludXNcIjogXCLiiLhcIixcblx0XCJkb3RwbHVzXCI6IFwi4oiUXCIsXG5cdFwiZG90c3F1YXJlXCI6IFwi4oqhXCIsXG5cdFwiZG91YmxlYmFyd2VkZ2VcIjogXCLijIZcIixcblx0XCJEb3VibGVDb250b3VySW50ZWdyYWxcIjogXCLiiK9cIixcblx0XCJEb3VibGVEb3RcIjogXCLCqFwiLFxuXHRcIkRvdWJsZURvd25BcnJvd1wiOiBcIuKHk1wiLFxuXHRcIkRvdWJsZUxlZnRBcnJvd1wiOiBcIuKHkFwiLFxuXHRcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6IFwi4oeUXCIsXG5cdFwiRG91YmxlTGVmdFRlZVwiOiBcIuKrpFwiLFxuXHRcIkRvdWJsZUxvbmdMZWZ0QXJyb3dcIjogXCLin7hcIixcblx0XCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjogXCLin7pcIixcblx0XCJEb3VibGVMb25nUmlnaHRBcnJvd1wiOiBcIuKfuVwiLFxuXHRcIkRvdWJsZVJpZ2h0QXJyb3dcIjogXCLih5JcIixcblx0XCJEb3VibGVSaWdodFRlZVwiOiBcIuKKqFwiLFxuXHRcIkRvdWJsZVVwQXJyb3dcIjogXCLih5FcIixcblx0XCJEb3VibGVVcERvd25BcnJvd1wiOiBcIuKHlVwiLFxuXHRcIkRvdWJsZVZlcnRpY2FsQmFyXCI6IFwi4oilXCIsXG5cdFwiRG93bkFycm93QmFyXCI6IFwi4qSTXCIsXG5cdFwiZG93bmFycm93XCI6IFwi4oaTXCIsXG5cdFwiRG93bkFycm93XCI6IFwi4oaTXCIsXG5cdFwiRG93bmFycm93XCI6IFwi4oeTXCIsXG5cdFwiRG93bkFycm93VXBBcnJvd1wiOiBcIuKHtVwiLFxuXHRcIkRvd25CcmV2ZVwiOiBcIsyRXCIsXG5cdFwiZG93bmRvd25hcnJvd3NcIjogXCLih4pcIixcblx0XCJkb3duaGFycG9vbmxlZnRcIjogXCLih4NcIixcblx0XCJkb3duaGFycG9vbnJpZ2h0XCI6IFwi4oeCXCIsXG5cdFwiRG93bkxlZnRSaWdodFZlY3RvclwiOiBcIuKlkFwiLFxuXHRcIkRvd25MZWZ0VGVlVmVjdG9yXCI6IFwi4qWeXCIsXG5cdFwiRG93bkxlZnRWZWN0b3JCYXJcIjogXCLipZZcIixcblx0XCJEb3duTGVmdFZlY3RvclwiOiBcIuKGvVwiLFxuXHRcIkRvd25SaWdodFRlZVZlY3RvclwiOiBcIuKln1wiLFxuXHRcIkRvd25SaWdodFZlY3RvckJhclwiOiBcIuKll1wiLFxuXHRcIkRvd25SaWdodFZlY3RvclwiOiBcIuKHgVwiLFxuXHRcIkRvd25UZWVBcnJvd1wiOiBcIuKGp1wiLFxuXHRcIkRvd25UZWVcIjogXCLiiqRcIixcblx0XCJkcmJrYXJvd1wiOiBcIuKkkFwiLFxuXHRcImRyY29yblwiOiBcIuKMn1wiLFxuXHRcImRyY3JvcFwiOiBcIuKMjFwiLFxuXHRcIkRzY3JcIjogXCLwnZKfXCIsXG5cdFwiZHNjclwiOiBcIvCdkrlcIixcblx0XCJEU2N5XCI6IFwi0IVcIixcblx0XCJkc2N5XCI6IFwi0ZVcIixcblx0XCJkc29sXCI6IFwi4qe2XCIsXG5cdFwiRHN0cm9rXCI6IFwixJBcIixcblx0XCJkc3Ryb2tcIjogXCLEkVwiLFxuXHRcImR0ZG90XCI6IFwi4ouxXCIsXG5cdFwiZHRyaVwiOiBcIuKWv1wiLFxuXHRcImR0cmlmXCI6IFwi4pa+XCIsXG5cdFwiZHVhcnJcIjogXCLih7VcIixcblx0XCJkdWhhclwiOiBcIuKlr1wiLFxuXHRcImR3YW5nbGVcIjogXCLipqZcIixcblx0XCJEWmN5XCI6IFwi0I9cIixcblx0XCJkemN5XCI6IFwi0Z9cIixcblx0XCJkemlncmFyclwiOiBcIuKfv1wiLFxuXHRcIkVhY3V0ZVwiOiBcIsOJXCIsXG5cdFwiZWFjdXRlXCI6IFwiw6lcIixcblx0XCJlYXN0ZXJcIjogXCLiqa5cIixcblx0XCJFY2Fyb25cIjogXCLEmlwiLFxuXHRcImVjYXJvblwiOiBcIsSbXCIsXG5cdFwiRWNpcmNcIjogXCLDilwiLFxuXHRcImVjaXJjXCI6IFwiw6pcIixcblx0XCJlY2lyXCI6IFwi4omWXCIsXG5cdFwiZWNvbG9uXCI6IFwi4omVXCIsXG5cdFwiRWN5XCI6IFwi0K1cIixcblx0XCJlY3lcIjogXCLRjVwiLFxuXHRcImVERG90XCI6IFwi4qm3XCIsXG5cdFwiRWRvdFwiOiBcIsSWXCIsXG5cdFwiZWRvdFwiOiBcIsSXXCIsXG5cdFwiZURvdFwiOiBcIuKJkVwiLFxuXHRcImVlXCI6IFwi4oWHXCIsXG5cdFwiZWZEb3RcIjogXCLiiZJcIixcblx0XCJFZnJcIjogXCLwnZSIXCIsXG5cdFwiZWZyXCI6IFwi8J2UolwiLFxuXHRcImVnXCI6IFwi4qqaXCIsXG5cdFwiRWdyYXZlXCI6IFwiw4hcIixcblx0XCJlZ3JhdmVcIjogXCLDqFwiLFxuXHRcImVnc1wiOiBcIuKqllwiLFxuXHRcImVnc2RvdFwiOiBcIuKqmFwiLFxuXHRcImVsXCI6IFwi4qqZXCIsXG5cdFwiRWxlbWVudFwiOiBcIuKIiFwiLFxuXHRcImVsaW50ZXJzXCI6IFwi4o+nXCIsXG5cdFwiZWxsXCI6IFwi4oSTXCIsXG5cdFwiZWxzXCI6IFwi4qqVXCIsXG5cdFwiZWxzZG90XCI6IFwi4qqXXCIsXG5cdFwiRW1hY3JcIjogXCLEklwiLFxuXHRcImVtYWNyXCI6IFwixJNcIixcblx0XCJlbXB0eVwiOiBcIuKIhVwiLFxuXHRcImVtcHR5c2V0XCI6IFwi4oiFXCIsXG5cdFwiRW1wdHlTbWFsbFNxdWFyZVwiOiBcIuKXu1wiLFxuXHRcImVtcHR5dlwiOiBcIuKIhVwiLFxuXHRcIkVtcHR5VmVyeVNtYWxsU3F1YXJlXCI6IFwi4parXCIsXG5cdFwiZW1zcDEzXCI6IFwi4oCEXCIsXG5cdFwiZW1zcDE0XCI6IFwi4oCFXCIsXG5cdFwiZW1zcFwiOiBcIuKAg1wiLFxuXHRcIkVOR1wiOiBcIsWKXCIsXG5cdFwiZW5nXCI6IFwixYtcIixcblx0XCJlbnNwXCI6IFwi4oCCXCIsXG5cdFwiRW9nb25cIjogXCLEmFwiLFxuXHRcImVvZ29uXCI6IFwixJlcIixcblx0XCJFb3BmXCI6IFwi8J2UvFwiLFxuXHRcImVvcGZcIjogXCLwnZWWXCIsXG5cdFwiZXBhclwiOiBcIuKLlVwiLFxuXHRcImVwYXJzbFwiOiBcIuKno1wiLFxuXHRcImVwbHVzXCI6IFwi4qmxXCIsXG5cdFwiZXBzaVwiOiBcIs61XCIsXG5cdFwiRXBzaWxvblwiOiBcIs6VXCIsXG5cdFwiZXBzaWxvblwiOiBcIs61XCIsXG5cdFwiZXBzaXZcIjogXCLPtVwiLFxuXHRcImVxY2lyY1wiOiBcIuKJllwiLFxuXHRcImVxY29sb25cIjogXCLiiZVcIixcblx0XCJlcXNpbVwiOiBcIuKJglwiLFxuXHRcImVxc2xhbnRndHJcIjogXCLiqpZcIixcblx0XCJlcXNsYW50bGVzc1wiOiBcIuKqlVwiLFxuXHRcIkVxdWFsXCI6IFwi4qm1XCIsXG5cdFwiZXF1YWxzXCI6IFwiPVwiLFxuXHRcIkVxdWFsVGlsZGVcIjogXCLiiYJcIixcblx0XCJlcXVlc3RcIjogXCLiiZ9cIixcblx0XCJFcXVpbGlicml1bVwiOiBcIuKHjFwiLFxuXHRcImVxdWl2XCI6IFwi4omhXCIsXG5cdFwiZXF1aXZERFwiOiBcIuKpuFwiLFxuXHRcImVxdnBhcnNsXCI6IFwi4qelXCIsXG5cdFwiZXJhcnJcIjogXCLipbFcIixcblx0XCJlckRvdFwiOiBcIuKJk1wiLFxuXHRcImVzY3JcIjogXCLihK9cIixcblx0XCJFc2NyXCI6IFwi4oSwXCIsXG5cdFwiZXNkb3RcIjogXCLiiZBcIixcblx0XCJFc2ltXCI6IFwi4qmzXCIsXG5cdFwiZXNpbVwiOiBcIuKJglwiLFxuXHRcIkV0YVwiOiBcIs6XXCIsXG5cdFwiZXRhXCI6IFwizrdcIixcblx0XCJFVEhcIjogXCLDkFwiLFxuXHRcImV0aFwiOiBcIsOwXCIsXG5cdFwiRXVtbFwiOiBcIsOLXCIsXG5cdFwiZXVtbFwiOiBcIsOrXCIsXG5cdFwiZXVyb1wiOiBcIuKCrFwiLFxuXHRcImV4Y2xcIjogXCIhXCIsXG5cdFwiZXhpc3RcIjogXCLiiINcIixcblx0XCJFeGlzdHNcIjogXCLiiINcIixcblx0XCJleHBlY3RhdGlvblwiOiBcIuKEsFwiLFxuXHRcImV4cG9uZW50aWFsZVwiOiBcIuKFh1wiLFxuXHRcIkV4cG9uZW50aWFsRVwiOiBcIuKFh1wiLFxuXHRcImZhbGxpbmdkb3RzZXFcIjogXCLiiZJcIixcblx0XCJGY3lcIjogXCLQpFwiLFxuXHRcImZjeVwiOiBcItGEXCIsXG5cdFwiZmVtYWxlXCI6IFwi4pmAXCIsXG5cdFwiZmZpbGlnXCI6IFwi76yDXCIsXG5cdFwiZmZsaWdcIjogXCLvrIBcIixcblx0XCJmZmxsaWdcIjogXCLvrIRcIixcblx0XCJGZnJcIjogXCLwnZSJXCIsXG5cdFwiZmZyXCI6IFwi8J2Uo1wiLFxuXHRcImZpbGlnXCI6IFwi76yBXCIsXG5cdFwiRmlsbGVkU21hbGxTcXVhcmVcIjogXCLil7xcIixcblx0XCJGaWxsZWRWZXJ5U21hbGxTcXVhcmVcIjogXCLilqpcIixcblx0XCJmamxpZ1wiOiBcImZqXCIsXG5cdFwiZmxhdFwiOiBcIuKZrVwiLFxuXHRcImZsbGlnXCI6IFwi76yCXCIsXG5cdFwiZmx0bnNcIjogXCLilrFcIixcblx0XCJmbm9mXCI6IFwixpJcIixcblx0XCJGb3BmXCI6IFwi8J2UvVwiLFxuXHRcImZvcGZcIjogXCLwnZWXXCIsXG5cdFwiZm9yYWxsXCI6IFwi4oiAXCIsXG5cdFwiRm9yQWxsXCI6IFwi4oiAXCIsXG5cdFwiZm9ya1wiOiBcIuKLlFwiLFxuXHRcImZvcmt2XCI6IFwi4quZXCIsXG5cdFwiRm91cmllcnRyZlwiOiBcIuKEsVwiLFxuXHRcImZwYXJ0aW50XCI6IFwi4qiNXCIsXG5cdFwiZnJhYzEyXCI6IFwiwr1cIixcblx0XCJmcmFjMTNcIjogXCLihZNcIixcblx0XCJmcmFjMTRcIjogXCLCvFwiLFxuXHRcImZyYWMxNVwiOiBcIuKFlVwiLFxuXHRcImZyYWMxNlwiOiBcIuKFmVwiLFxuXHRcImZyYWMxOFwiOiBcIuKFm1wiLFxuXHRcImZyYWMyM1wiOiBcIuKFlFwiLFxuXHRcImZyYWMyNVwiOiBcIuKFllwiLFxuXHRcImZyYWMzNFwiOiBcIsK+XCIsXG5cdFwiZnJhYzM1XCI6IFwi4oWXXCIsXG5cdFwiZnJhYzM4XCI6IFwi4oWcXCIsXG5cdFwiZnJhYzQ1XCI6IFwi4oWYXCIsXG5cdFwiZnJhYzU2XCI6IFwi4oWaXCIsXG5cdFwiZnJhYzU4XCI6IFwi4oWdXCIsXG5cdFwiZnJhYzc4XCI6IFwi4oWeXCIsXG5cdFwiZnJhc2xcIjogXCLigYRcIixcblx0XCJmcm93blwiOiBcIuKMolwiLFxuXHRcImZzY3JcIjogXCLwnZK7XCIsXG5cdFwiRnNjclwiOiBcIuKEsVwiLFxuXHRcImdhY3V0ZVwiOiBcIse1XCIsXG5cdFwiR2FtbWFcIjogXCLOk1wiLFxuXHRcImdhbW1hXCI6IFwizrNcIixcblx0XCJHYW1tYWRcIjogXCLPnFwiLFxuXHRcImdhbW1hZFwiOiBcIs+dXCIsXG5cdFwiZ2FwXCI6IFwi4qqGXCIsXG5cdFwiR2JyZXZlXCI6IFwixJ5cIixcblx0XCJnYnJldmVcIjogXCLEn1wiLFxuXHRcIkdjZWRpbFwiOiBcIsSiXCIsXG5cdFwiR2NpcmNcIjogXCLEnFwiLFxuXHRcImdjaXJjXCI6IFwixJ1cIixcblx0XCJHY3lcIjogXCLQk1wiLFxuXHRcImdjeVwiOiBcItCzXCIsXG5cdFwiR2RvdFwiOiBcIsSgXCIsXG5cdFwiZ2RvdFwiOiBcIsShXCIsXG5cdFwiZ2VcIjogXCLiiaVcIixcblx0XCJnRVwiOiBcIuKJp1wiLFxuXHRcImdFbFwiOiBcIuKqjFwiLFxuXHRcImdlbFwiOiBcIuKLm1wiLFxuXHRcImdlcVwiOiBcIuKJpVwiLFxuXHRcImdlcXFcIjogXCLiiadcIixcblx0XCJnZXFzbGFudFwiOiBcIuKpvlwiLFxuXHRcImdlc2NjXCI6IFwi4qqpXCIsXG5cdFwiZ2VzXCI6IFwi4qm+XCIsXG5cdFwiZ2VzZG90XCI6IFwi4qqAXCIsXG5cdFwiZ2VzZG90b1wiOiBcIuKqglwiLFxuXHRcImdlc2RvdG9sXCI6IFwi4qqEXCIsXG5cdFwiZ2VzbFwiOiBcIuKLm++4gFwiLFxuXHRcImdlc2xlc1wiOiBcIuKqlFwiLFxuXHRcIkdmclwiOiBcIvCdlIpcIixcblx0XCJnZnJcIjogXCLwnZSkXCIsXG5cdFwiZ2dcIjogXCLiiatcIixcblx0XCJHZ1wiOiBcIuKLmVwiLFxuXHRcImdnZ1wiOiBcIuKLmVwiLFxuXHRcImdpbWVsXCI6IFwi4oS3XCIsXG5cdFwiR0pjeVwiOiBcItCDXCIsXG5cdFwiZ2pjeVwiOiBcItGTXCIsXG5cdFwiZ2xhXCI6IFwi4qqlXCIsXG5cdFwiZ2xcIjogXCLiibdcIixcblx0XCJnbEVcIjogXCLiqpJcIixcblx0XCJnbGpcIjogXCLiqqRcIixcblx0XCJnbmFwXCI6IFwi4qqKXCIsXG5cdFwiZ25hcHByb3hcIjogXCLiqopcIixcblx0XCJnbmVcIjogXCLiqohcIixcblx0XCJnbkVcIjogXCLiialcIixcblx0XCJnbmVxXCI6IFwi4qqIXCIsXG5cdFwiZ25lcXFcIjogXCLiialcIixcblx0XCJnbnNpbVwiOiBcIuKLp1wiLFxuXHRcIkdvcGZcIjogXCLwnZS+XCIsXG5cdFwiZ29wZlwiOiBcIvCdlZhcIixcblx0XCJncmF2ZVwiOiBcImBcIixcblx0XCJHcmVhdGVyRXF1YWxcIjogXCLiiaVcIixcblx0XCJHcmVhdGVyRXF1YWxMZXNzXCI6IFwi4oubXCIsXG5cdFwiR3JlYXRlckZ1bGxFcXVhbFwiOiBcIuKJp1wiLFxuXHRcIkdyZWF0ZXJHcmVhdGVyXCI6IFwi4qqiXCIsXG5cdFwiR3JlYXRlckxlc3NcIjogXCLiibdcIixcblx0XCJHcmVhdGVyU2xhbnRFcXVhbFwiOiBcIuKpvlwiLFxuXHRcIkdyZWF0ZXJUaWxkZVwiOiBcIuKJs1wiLFxuXHRcIkdzY3JcIjogXCLwnZKiXCIsXG5cdFwiZ3NjclwiOiBcIuKEilwiLFxuXHRcImdzaW1cIjogXCLiibNcIixcblx0XCJnc2ltZVwiOiBcIuKqjlwiLFxuXHRcImdzaW1sXCI6IFwi4qqQXCIsXG5cdFwiZ3RjY1wiOiBcIuKqp1wiLFxuXHRcImd0Y2lyXCI6IFwi4qm6XCIsXG5cdFwiZ3RcIjogXCI+XCIsXG5cdFwiR1RcIjogXCI+XCIsXG5cdFwiR3RcIjogXCLiiatcIixcblx0XCJndGRvdFwiOiBcIuKLl1wiLFxuXHRcImd0bFBhclwiOiBcIuKmlVwiLFxuXHRcImd0cXVlc3RcIjogXCLiqbxcIixcblx0XCJndHJhcHByb3hcIjogXCLiqoZcIixcblx0XCJndHJhcnJcIjogXCLipbhcIixcblx0XCJndHJkb3RcIjogXCLii5dcIixcblx0XCJndHJlcWxlc3NcIjogXCLii5tcIixcblx0XCJndHJlcXFsZXNzXCI6IFwi4qqMXCIsXG5cdFwiZ3RybGVzc1wiOiBcIuKJt1wiLFxuXHRcImd0cnNpbVwiOiBcIuKJs1wiLFxuXHRcImd2ZXJ0bmVxcVwiOiBcIuKJqe+4gFwiLFxuXHRcImd2bkVcIjogXCLiianvuIBcIixcblx0XCJIYWNla1wiOiBcIsuHXCIsXG5cdFwiaGFpcnNwXCI6IFwi4oCKXCIsXG5cdFwiaGFsZlwiOiBcIsK9XCIsXG5cdFwiaGFtaWx0XCI6IFwi4oSLXCIsXG5cdFwiSEFSRGN5XCI6IFwi0KpcIixcblx0XCJoYXJkY3lcIjogXCLRilwiLFxuXHRcImhhcnJjaXJcIjogXCLipYhcIixcblx0XCJoYXJyXCI6IFwi4oaUXCIsXG5cdFwiaEFyclwiOiBcIuKHlFwiLFxuXHRcImhhcnJ3XCI6IFwi4oatXCIsXG5cdFwiSGF0XCI6IFwiXlwiLFxuXHRcImhiYXJcIjogXCLihI9cIixcblx0XCJIY2lyY1wiOiBcIsSkXCIsXG5cdFwiaGNpcmNcIjogXCLEpVwiLFxuXHRcImhlYXJ0c1wiOiBcIuKZpVwiLFxuXHRcImhlYXJ0c3VpdFwiOiBcIuKZpVwiLFxuXHRcImhlbGxpcFwiOiBcIuKAplwiLFxuXHRcImhlcmNvblwiOiBcIuKKuVwiLFxuXHRcImhmclwiOiBcIvCdlKVcIixcblx0XCJIZnJcIjogXCLihIxcIixcblx0XCJIaWxiZXJ0U3BhY2VcIjogXCLihItcIixcblx0XCJoa3NlYXJvd1wiOiBcIuKkpVwiLFxuXHRcImhrc3dhcm93XCI6IFwi4qSmXCIsXG5cdFwiaG9hcnJcIjogXCLih79cIixcblx0XCJob210aHRcIjogXCLiiLtcIixcblx0XCJob29rbGVmdGFycm93XCI6IFwi4oapXCIsXG5cdFwiaG9va3JpZ2h0YXJyb3dcIjogXCLihqpcIixcblx0XCJob3BmXCI6IFwi8J2VmVwiLFxuXHRcIkhvcGZcIjogXCLihI1cIixcblx0XCJob3JiYXJcIjogXCLigJVcIixcblx0XCJIb3Jpem9udGFsTGluZVwiOiBcIuKUgFwiLFxuXHRcImhzY3JcIjogXCLwnZK9XCIsXG5cdFwiSHNjclwiOiBcIuKEi1wiLFxuXHRcImhzbGFzaFwiOiBcIuKEj1wiLFxuXHRcIkhzdHJva1wiOiBcIsSmXCIsXG5cdFwiaHN0cm9rXCI6IFwixKdcIixcblx0XCJIdW1wRG93bkh1bXBcIjogXCLiiY5cIixcblx0XCJIdW1wRXF1YWxcIjogXCLiiY9cIixcblx0XCJoeWJ1bGxcIjogXCLigYNcIixcblx0XCJoeXBoZW5cIjogXCLigJBcIixcblx0XCJJYWN1dGVcIjogXCLDjVwiLFxuXHRcImlhY3V0ZVwiOiBcIsOtXCIsXG5cdFwiaWNcIjogXCLigaNcIixcblx0XCJJY2lyY1wiOiBcIsOOXCIsXG5cdFwiaWNpcmNcIjogXCLDrlwiLFxuXHRcIkljeVwiOiBcItCYXCIsXG5cdFwiaWN5XCI6IFwi0LhcIixcblx0XCJJZG90XCI6IFwixLBcIixcblx0XCJJRWN5XCI6IFwi0JVcIixcblx0XCJpZWN5XCI6IFwi0LVcIixcblx0XCJpZXhjbFwiOiBcIsKhXCIsXG5cdFwiaWZmXCI6IFwi4oeUXCIsXG5cdFwiaWZyXCI6IFwi8J2UplwiLFxuXHRcIklmclwiOiBcIuKEkVwiLFxuXHRcIklncmF2ZVwiOiBcIsOMXCIsXG5cdFwiaWdyYXZlXCI6IFwiw6xcIixcblx0XCJpaVwiOiBcIuKFiFwiLFxuXHRcImlpaWludFwiOiBcIuKojFwiLFxuXHRcImlpaW50XCI6IFwi4oitXCIsXG5cdFwiaWluZmluXCI6IFwi4qecXCIsXG5cdFwiaWlvdGFcIjogXCLihKlcIixcblx0XCJJSmxpZ1wiOiBcIsSyXCIsXG5cdFwiaWpsaWdcIjogXCLEs1wiLFxuXHRcIkltYWNyXCI6IFwixKpcIixcblx0XCJpbWFjclwiOiBcIsSrXCIsXG5cdFwiaW1hZ2VcIjogXCLihJFcIixcblx0XCJJbWFnaW5hcnlJXCI6IFwi4oWIXCIsXG5cdFwiaW1hZ2xpbmVcIjogXCLihJBcIixcblx0XCJpbWFncGFydFwiOiBcIuKEkVwiLFxuXHRcImltYXRoXCI6IFwixLFcIixcblx0XCJJbVwiOiBcIuKEkVwiLFxuXHRcImltb2ZcIjogXCLiirdcIixcblx0XCJpbXBlZFwiOiBcIsa1XCIsXG5cdFwiSW1wbGllc1wiOiBcIuKHklwiLFxuXHRcImluY2FyZVwiOiBcIuKEhVwiLFxuXHRcImluXCI6IFwi4oiIXCIsXG5cdFwiaW5maW5cIjogXCLiiJ5cIixcblx0XCJpbmZpbnRpZVwiOiBcIuKnnVwiLFxuXHRcImlub2RvdFwiOiBcIsSxXCIsXG5cdFwiaW50Y2FsXCI6IFwi4oq6XCIsXG5cdFwiaW50XCI6IFwi4oirXCIsXG5cdFwiSW50XCI6IFwi4oisXCIsXG5cdFwiaW50ZWdlcnNcIjogXCLihKRcIixcblx0XCJJbnRlZ3JhbFwiOiBcIuKIq1wiLFxuXHRcImludGVyY2FsXCI6IFwi4oq6XCIsXG5cdFwiSW50ZXJzZWN0aW9uXCI6IFwi4ouCXCIsXG5cdFwiaW50bGFyaGtcIjogXCLiqJdcIixcblx0XCJpbnRwcm9kXCI6IFwi4qi8XCIsXG5cdFwiSW52aXNpYmxlQ29tbWFcIjogXCLigaNcIixcblx0XCJJbnZpc2libGVUaW1lc1wiOiBcIuKBolwiLFxuXHRcIklPY3lcIjogXCLQgVwiLFxuXHRcImlvY3lcIjogXCLRkVwiLFxuXHRcIklvZ29uXCI6IFwixK5cIixcblx0XCJpb2dvblwiOiBcIsSvXCIsXG5cdFwiSW9wZlwiOiBcIvCdlYBcIixcblx0XCJpb3BmXCI6IFwi8J2VmlwiLFxuXHRcIklvdGFcIjogXCLOmVwiLFxuXHRcImlvdGFcIjogXCLOuVwiLFxuXHRcImlwcm9kXCI6IFwi4qi8XCIsXG5cdFwiaXF1ZXN0XCI6IFwiwr9cIixcblx0XCJpc2NyXCI6IFwi8J2SvlwiLFxuXHRcIklzY3JcIjogXCLihJBcIixcblx0XCJpc2luXCI6IFwi4oiIXCIsXG5cdFwiaXNpbmRvdFwiOiBcIuKLtVwiLFxuXHRcImlzaW5FXCI6IFwi4ou5XCIsXG5cdFwiaXNpbnNcIjogXCLii7RcIixcblx0XCJpc2luc3ZcIjogXCLii7NcIixcblx0XCJpc2ludlwiOiBcIuKIiFwiLFxuXHRcIml0XCI6IFwi4oGiXCIsXG5cdFwiSXRpbGRlXCI6IFwixKhcIixcblx0XCJpdGlsZGVcIjogXCLEqVwiLFxuXHRcIkl1a2N5XCI6IFwi0IZcIixcblx0XCJpdWtjeVwiOiBcItGWXCIsXG5cdFwiSXVtbFwiOiBcIsOPXCIsXG5cdFwiaXVtbFwiOiBcIsOvXCIsXG5cdFwiSmNpcmNcIjogXCLEtFwiLFxuXHRcImpjaXJjXCI6IFwixLVcIixcblx0XCJKY3lcIjogXCLQmVwiLFxuXHRcImpjeVwiOiBcItC5XCIsXG5cdFwiSmZyXCI6IFwi8J2UjVwiLFxuXHRcImpmclwiOiBcIvCdlKdcIixcblx0XCJqbWF0aFwiOiBcIsi3XCIsXG5cdFwiSm9wZlwiOiBcIvCdlYFcIixcblx0XCJqb3BmXCI6IFwi8J2Vm1wiLFxuXHRcIkpzY3JcIjogXCLwnZKlXCIsXG5cdFwianNjclwiOiBcIvCdkr9cIixcblx0XCJKc2VyY3lcIjogXCLQiFwiLFxuXHRcImpzZXJjeVwiOiBcItGYXCIsXG5cdFwiSnVrY3lcIjogXCLQhFwiLFxuXHRcImp1a2N5XCI6IFwi0ZRcIixcblx0XCJLYXBwYVwiOiBcIs6aXCIsXG5cdFwia2FwcGFcIjogXCLOulwiLFxuXHRcImthcHBhdlwiOiBcIs+wXCIsXG5cdFwiS2NlZGlsXCI6IFwixLZcIixcblx0XCJrY2VkaWxcIjogXCLEt1wiLFxuXHRcIktjeVwiOiBcItCaXCIsXG5cdFwia2N5XCI6IFwi0LpcIixcblx0XCJLZnJcIjogXCLwnZSOXCIsXG5cdFwia2ZyXCI6IFwi8J2UqFwiLFxuXHRcImtncmVlblwiOiBcIsS4XCIsXG5cdFwiS0hjeVwiOiBcItClXCIsXG5cdFwia2hjeVwiOiBcItGFXCIsXG5cdFwiS0pjeVwiOiBcItCMXCIsXG5cdFwia2pjeVwiOiBcItGcXCIsXG5cdFwiS29wZlwiOiBcIvCdlYJcIixcblx0XCJrb3BmXCI6IFwi8J2VnFwiLFxuXHRcIktzY3JcIjogXCLwnZKmXCIsXG5cdFwia3NjclwiOiBcIvCdk4BcIixcblx0XCJsQWFyclwiOiBcIuKHmlwiLFxuXHRcIkxhY3V0ZVwiOiBcIsS5XCIsXG5cdFwibGFjdXRlXCI6IFwixLpcIixcblx0XCJsYWVtcHR5dlwiOiBcIuKmtFwiLFxuXHRcImxhZ3JhblwiOiBcIuKEklwiLFxuXHRcIkxhbWJkYVwiOiBcIs6bXCIsXG5cdFwibGFtYmRhXCI6IFwizrtcIixcblx0XCJsYW5nXCI6IFwi4p+oXCIsXG5cdFwiTGFuZ1wiOiBcIuKfqlwiLFxuXHRcImxhbmdkXCI6IFwi4qaRXCIsXG5cdFwibGFuZ2xlXCI6IFwi4p+oXCIsXG5cdFwibGFwXCI6IFwi4qqFXCIsXG5cdFwiTGFwbGFjZXRyZlwiOiBcIuKEklwiLFxuXHRcImxhcXVvXCI6IFwiwqtcIixcblx0XCJsYXJyYlwiOiBcIuKHpFwiLFxuXHRcImxhcnJiZnNcIjogXCLipJ9cIixcblx0XCJsYXJyXCI6IFwi4oaQXCIsXG5cdFwiTGFyclwiOiBcIuKGnlwiLFxuXHRcImxBcnJcIjogXCLih5BcIixcblx0XCJsYXJyZnNcIjogXCLipJ1cIixcblx0XCJsYXJyaGtcIjogXCLihqlcIixcblx0XCJsYXJybHBcIjogXCLihqtcIixcblx0XCJsYXJycGxcIjogXCLipLlcIixcblx0XCJsYXJyc2ltXCI6IFwi4qWzXCIsXG5cdFwibGFycnRsXCI6IFwi4oaiXCIsXG5cdFwibGF0YWlsXCI6IFwi4qSZXCIsXG5cdFwibEF0YWlsXCI6IFwi4qSbXCIsXG5cdFwibGF0XCI6IFwi4qqrXCIsXG5cdFwibGF0ZVwiOiBcIuKqrVwiLFxuXHRcImxhdGVzXCI6IFwi4qqt77iAXCIsXG5cdFwibGJhcnJcIjogXCLipIxcIixcblx0XCJsQmFyclwiOiBcIuKkjlwiLFxuXHRcImxiYnJrXCI6IFwi4p2yXCIsXG5cdFwibGJyYWNlXCI6IFwie1wiLFxuXHRcImxicmFja1wiOiBcIltcIixcblx0XCJsYnJrZVwiOiBcIuKmi1wiLFxuXHRcImxicmtzbGRcIjogXCLipo9cIixcblx0XCJsYnJrc2x1XCI6IFwi4qaNXCIsXG5cdFwiTGNhcm9uXCI6IFwixL1cIixcblx0XCJsY2Fyb25cIjogXCLEvlwiLFxuXHRcIkxjZWRpbFwiOiBcIsS7XCIsXG5cdFwibGNlZGlsXCI6IFwixLxcIixcblx0XCJsY2VpbFwiOiBcIuKMiFwiLFxuXHRcImxjdWJcIjogXCJ7XCIsXG5cdFwiTGN5XCI6IFwi0JtcIixcblx0XCJsY3lcIjogXCLQu1wiLFxuXHRcImxkY2FcIjogXCLipLZcIixcblx0XCJsZHF1b1wiOiBcIuKAnFwiLFxuXHRcImxkcXVvclwiOiBcIuKAnlwiLFxuXHRcImxkcmRoYXJcIjogXCLipadcIixcblx0XCJsZHJ1c2hhclwiOiBcIuKli1wiLFxuXHRcImxkc2hcIjogXCLihrJcIixcblx0XCJsZVwiOiBcIuKJpFwiLFxuXHRcImxFXCI6IFwi4ommXCIsXG5cdFwiTGVmdEFuZ2xlQnJhY2tldFwiOiBcIuKfqFwiLFxuXHRcIkxlZnRBcnJvd0JhclwiOiBcIuKHpFwiLFxuXHRcImxlZnRhcnJvd1wiOiBcIuKGkFwiLFxuXHRcIkxlZnRBcnJvd1wiOiBcIuKGkFwiLFxuXHRcIkxlZnRhcnJvd1wiOiBcIuKHkFwiLFxuXHRcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjogXCLih4ZcIixcblx0XCJsZWZ0YXJyb3d0YWlsXCI6IFwi4oaiXCIsXG5cdFwiTGVmdENlaWxpbmdcIjogXCLijIhcIixcblx0XCJMZWZ0RG91YmxlQnJhY2tldFwiOiBcIuKfplwiLFxuXHRcIkxlZnREb3duVGVlVmVjdG9yXCI6IFwi4qWhXCIsXG5cdFwiTGVmdERvd25WZWN0b3JCYXJcIjogXCLipZlcIixcblx0XCJMZWZ0RG93blZlY3RvclwiOiBcIuKHg1wiLFxuXHRcIkxlZnRGbG9vclwiOiBcIuKMilwiLFxuXHRcImxlZnRoYXJwb29uZG93blwiOiBcIuKGvVwiLFxuXHRcImxlZnRoYXJwb29udXBcIjogXCLihrxcIixcblx0XCJsZWZ0bGVmdGFycm93c1wiOiBcIuKHh1wiLFxuXHRcImxlZnRyaWdodGFycm93XCI6IFwi4oaUXCIsXG5cdFwiTGVmdFJpZ2h0QXJyb3dcIjogXCLihpRcIixcblx0XCJMZWZ0cmlnaHRhcnJvd1wiOiBcIuKHlFwiLFxuXHRcImxlZnRyaWdodGFycm93c1wiOiBcIuKHhlwiLFxuXHRcImxlZnRyaWdodGhhcnBvb25zXCI6IFwi4oeLXCIsXG5cdFwibGVmdHJpZ2h0c3F1aWdhcnJvd1wiOiBcIuKGrVwiLFxuXHRcIkxlZnRSaWdodFZlY3RvclwiOiBcIuKljlwiLFxuXHRcIkxlZnRUZWVBcnJvd1wiOiBcIuKGpFwiLFxuXHRcIkxlZnRUZWVcIjogXCLiiqNcIixcblx0XCJMZWZ0VGVlVmVjdG9yXCI6IFwi4qWaXCIsXG5cdFwibGVmdHRocmVldGltZXNcIjogXCLii4tcIixcblx0XCJMZWZ0VHJpYW5nbGVCYXJcIjogXCLip49cIixcblx0XCJMZWZ0VHJpYW5nbGVcIjogXCLiirJcIixcblx0XCJMZWZ0VHJpYW5nbGVFcXVhbFwiOiBcIuKKtFwiLFxuXHRcIkxlZnRVcERvd25WZWN0b3JcIjogXCLipZFcIixcblx0XCJMZWZ0VXBUZWVWZWN0b3JcIjogXCLipaBcIixcblx0XCJMZWZ0VXBWZWN0b3JCYXJcIjogXCLipZhcIixcblx0XCJMZWZ0VXBWZWN0b3JcIjogXCLihr9cIixcblx0XCJMZWZ0VmVjdG9yQmFyXCI6IFwi4qWSXCIsXG5cdFwiTGVmdFZlY3RvclwiOiBcIuKGvFwiLFxuXHRcImxFZ1wiOiBcIuKqi1wiLFxuXHRcImxlZ1wiOiBcIuKLmlwiLFxuXHRcImxlcVwiOiBcIuKJpFwiLFxuXHRcImxlcXFcIjogXCLiiaZcIixcblx0XCJsZXFzbGFudFwiOiBcIuKpvVwiLFxuXHRcImxlc2NjXCI6IFwi4qqoXCIsXG5cdFwibGVzXCI6IFwi4qm9XCIsXG5cdFwibGVzZG90XCI6IFwi4qm/XCIsXG5cdFwibGVzZG90b1wiOiBcIuKqgVwiLFxuXHRcImxlc2RvdG9yXCI6IFwi4qqDXCIsXG5cdFwibGVzZ1wiOiBcIuKLmu+4gFwiLFxuXHRcImxlc2dlc1wiOiBcIuKqk1wiLFxuXHRcImxlc3NhcHByb3hcIjogXCLiqoVcIixcblx0XCJsZXNzZG90XCI6IFwi4ouWXCIsXG5cdFwibGVzc2VxZ3RyXCI6IFwi4ouaXCIsXG5cdFwibGVzc2VxcWd0clwiOiBcIuKqi1wiLFxuXHRcIkxlc3NFcXVhbEdyZWF0ZXJcIjogXCLii5pcIixcblx0XCJMZXNzRnVsbEVxdWFsXCI6IFwi4ommXCIsXG5cdFwiTGVzc0dyZWF0ZXJcIjogXCLiibZcIixcblx0XCJsZXNzZ3RyXCI6IFwi4om2XCIsXG5cdFwiTGVzc0xlc3NcIjogXCLiqqFcIixcblx0XCJsZXNzc2ltXCI6IFwi4omyXCIsXG5cdFwiTGVzc1NsYW50RXF1YWxcIjogXCLiqb1cIixcblx0XCJMZXNzVGlsZGVcIjogXCLiibJcIixcblx0XCJsZmlzaHRcIjogXCLipbxcIixcblx0XCJsZmxvb3JcIjogXCLijIpcIixcblx0XCJMZnJcIjogXCLwnZSPXCIsXG5cdFwibGZyXCI6IFwi8J2UqVwiLFxuXHRcImxnXCI6IFwi4om2XCIsXG5cdFwibGdFXCI6IFwi4qqRXCIsXG5cdFwibEhhclwiOiBcIuKlolwiLFxuXHRcImxoYXJkXCI6IFwi4oa9XCIsXG5cdFwibGhhcnVcIjogXCLihrxcIixcblx0XCJsaGFydWxcIjogXCLipapcIixcblx0XCJsaGJsa1wiOiBcIuKWhFwiLFxuXHRcIkxKY3lcIjogXCLQiVwiLFxuXHRcImxqY3lcIjogXCLRmVwiLFxuXHRcImxsYXJyXCI6IFwi4oeHXCIsXG5cdFwibGxcIjogXCLiiapcIixcblx0XCJMbFwiOiBcIuKLmFwiLFxuXHRcImxsY29ybmVyXCI6IFwi4oyeXCIsXG5cdFwiTGxlZnRhcnJvd1wiOiBcIuKHmlwiLFxuXHRcImxsaGFyZFwiOiBcIuKlq1wiLFxuXHRcImxsdHJpXCI6IFwi4pe6XCIsXG5cdFwiTG1pZG90XCI6IFwixL9cIixcblx0XCJsbWlkb3RcIjogXCLFgFwiLFxuXHRcImxtb3VzdGFjaGVcIjogXCLijrBcIixcblx0XCJsbW91c3RcIjogXCLijrBcIixcblx0XCJsbmFwXCI6IFwi4qqJXCIsXG5cdFwibG5hcHByb3hcIjogXCLiqolcIixcblx0XCJsbmVcIjogXCLiqodcIixcblx0XCJsbkVcIjogXCLiiahcIixcblx0XCJsbmVxXCI6IFwi4qqHXCIsXG5cdFwibG5lcXFcIjogXCLiiahcIixcblx0XCJsbnNpbVwiOiBcIuKLplwiLFxuXHRcImxvYW5nXCI6IFwi4p+sXCIsXG5cdFwibG9hcnJcIjogXCLih71cIixcblx0XCJsb2Jya1wiOiBcIuKfplwiLFxuXHRcImxvbmdsZWZ0YXJyb3dcIjogXCLin7VcIixcblx0XCJMb25nTGVmdEFycm93XCI6IFwi4p+1XCIsXG5cdFwiTG9uZ2xlZnRhcnJvd1wiOiBcIuKfuFwiLFxuXHRcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOiBcIuKft1wiLFxuXHRcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOiBcIuKft1wiLFxuXHRcIkxvbmdsZWZ0cmlnaHRhcnJvd1wiOiBcIuKfulwiLFxuXHRcImxvbmdtYXBzdG9cIjogXCLin7xcIixcblx0XCJsb25ncmlnaHRhcnJvd1wiOiBcIuKftlwiLFxuXHRcIkxvbmdSaWdodEFycm93XCI6IFwi4p+2XCIsXG5cdFwiTG9uZ3JpZ2h0YXJyb3dcIjogXCLin7lcIixcblx0XCJsb29wYXJyb3dsZWZ0XCI6IFwi4oarXCIsXG5cdFwibG9vcGFycm93cmlnaHRcIjogXCLihqxcIixcblx0XCJsb3BhclwiOiBcIuKmhVwiLFxuXHRcIkxvcGZcIjogXCLwnZWDXCIsXG5cdFwibG9wZlwiOiBcIvCdlZ1cIixcblx0XCJsb3BsdXNcIjogXCLiqK1cIixcblx0XCJsb3RpbWVzXCI6IFwi4qi0XCIsXG5cdFwibG93YXN0XCI6IFwi4oiXXCIsXG5cdFwibG93YmFyXCI6IFwiX1wiLFxuXHRcIkxvd2VyTGVmdEFycm93XCI6IFwi4oaZXCIsXG5cdFwiTG93ZXJSaWdodEFycm93XCI6IFwi4oaYXCIsXG5cdFwibG96XCI6IFwi4peKXCIsXG5cdFwibG96ZW5nZVwiOiBcIuKXilwiLFxuXHRcImxvemZcIjogXCLip6tcIixcblx0XCJscGFyXCI6IFwiKFwiLFxuXHRcImxwYXJsdFwiOiBcIuKmk1wiLFxuXHRcImxyYXJyXCI6IFwi4oeGXCIsXG5cdFwibHJjb3JuZXJcIjogXCLijJ9cIixcblx0XCJscmhhclwiOiBcIuKHi1wiLFxuXHRcImxyaGFyZFwiOiBcIuKlrVwiLFxuXHRcImxybVwiOiBcIuKAjlwiLFxuXHRcImxydHJpXCI6IFwi4oq/XCIsXG5cdFwibHNhcXVvXCI6IFwi4oC5XCIsXG5cdFwibHNjclwiOiBcIvCdk4FcIixcblx0XCJMc2NyXCI6IFwi4oSSXCIsXG5cdFwibHNoXCI6IFwi4oawXCIsXG5cdFwiTHNoXCI6IFwi4oawXCIsXG5cdFwibHNpbVwiOiBcIuKJslwiLFxuXHRcImxzaW1lXCI6IFwi4qqNXCIsXG5cdFwibHNpbWdcIjogXCLiqo9cIixcblx0XCJsc3FiXCI6IFwiW1wiLFxuXHRcImxzcXVvXCI6IFwi4oCYXCIsXG5cdFwibHNxdW9yXCI6IFwi4oCaXCIsXG5cdFwiTHN0cm9rXCI6IFwixYFcIixcblx0XCJsc3Ryb2tcIjogXCLFglwiLFxuXHRcImx0Y2NcIjogXCLiqqZcIixcblx0XCJsdGNpclwiOiBcIuKpuVwiLFxuXHRcImx0XCI6IFwiPFwiLFxuXHRcIkxUXCI6IFwiPFwiLFxuXHRcIkx0XCI6IFwi4omqXCIsXG5cdFwibHRkb3RcIjogXCLii5ZcIixcblx0XCJsdGhyZWVcIjogXCLii4tcIixcblx0XCJsdGltZXNcIjogXCLii4lcIixcblx0XCJsdGxhcnJcIjogXCLipbZcIixcblx0XCJsdHF1ZXN0XCI6IFwi4qm7XCIsXG5cdFwibHRyaVwiOiBcIuKXg1wiLFxuXHRcImx0cmllXCI6IFwi4oq0XCIsXG5cdFwibHRyaWZcIjogXCLil4JcIixcblx0XCJsdHJQYXJcIjogXCLippZcIixcblx0XCJsdXJkc2hhclwiOiBcIuKlilwiLFxuXHRcImx1cnVoYXJcIjogXCLipaZcIixcblx0XCJsdmVydG5lcXFcIjogXCLiiajvuIBcIixcblx0XCJsdm5FXCI6IFwi4omo77iAXCIsXG5cdFwibWFjclwiOiBcIsKvXCIsXG5cdFwibWFsZVwiOiBcIuKZglwiLFxuXHRcIm1hbHRcIjogXCLinKBcIixcblx0XCJtYWx0ZXNlXCI6IFwi4pygXCIsXG5cdFwiTWFwXCI6IFwi4qSFXCIsXG5cdFwibWFwXCI6IFwi4oamXCIsXG5cdFwibWFwc3RvXCI6IFwi4oamXCIsXG5cdFwibWFwc3RvZG93blwiOiBcIuKGp1wiLFxuXHRcIm1hcHN0b2xlZnRcIjogXCLihqRcIixcblx0XCJtYXBzdG91cFwiOiBcIuKGpVwiLFxuXHRcIm1hcmtlclwiOiBcIuKWrlwiLFxuXHRcIm1jb21tYVwiOiBcIuKoqVwiLFxuXHRcIk1jeVwiOiBcItCcXCIsXG5cdFwibWN5XCI6IFwi0LxcIixcblx0XCJtZGFzaFwiOiBcIuKAlFwiLFxuXHRcIm1ERG90XCI6IFwi4oi6XCIsXG5cdFwibWVhc3VyZWRhbmdsZVwiOiBcIuKIoVwiLFxuXHRcIk1lZGl1bVNwYWNlXCI6IFwi4oGfXCIsXG5cdFwiTWVsbGludHJmXCI6IFwi4oSzXCIsXG5cdFwiTWZyXCI6IFwi8J2UkFwiLFxuXHRcIm1mclwiOiBcIvCdlKpcIixcblx0XCJtaG9cIjogXCLihKdcIixcblx0XCJtaWNyb1wiOiBcIsK1XCIsXG5cdFwibWlkYXN0XCI6IFwiKlwiLFxuXHRcIm1pZGNpclwiOiBcIuKrsFwiLFxuXHRcIm1pZFwiOiBcIuKIo1wiLFxuXHRcIm1pZGRvdFwiOiBcIsK3XCIsXG5cdFwibWludXNiXCI6IFwi4oqfXCIsXG5cdFwibWludXNcIjogXCLiiJJcIixcblx0XCJtaW51c2RcIjogXCLiiLhcIixcblx0XCJtaW51c2R1XCI6IFwi4qiqXCIsXG5cdFwiTWludXNQbHVzXCI6IFwi4oiTXCIsXG5cdFwibWxjcFwiOiBcIuKrm1wiLFxuXHRcIm1sZHJcIjogXCLigKZcIixcblx0XCJtbnBsdXNcIjogXCLiiJNcIixcblx0XCJtb2RlbHNcIjogXCLiiqdcIixcblx0XCJNb3BmXCI6IFwi8J2VhFwiLFxuXHRcIm1vcGZcIjogXCLwnZWeXCIsXG5cdFwibXBcIjogXCLiiJNcIixcblx0XCJtc2NyXCI6IFwi8J2TglwiLFxuXHRcIk1zY3JcIjogXCLihLNcIixcblx0XCJtc3Rwb3NcIjogXCLiiL5cIixcblx0XCJNdVwiOiBcIs6cXCIsXG5cdFwibXVcIjogXCLOvFwiLFxuXHRcIm11bHRpbWFwXCI6IFwi4oq4XCIsXG5cdFwibXVtYXBcIjogXCLiirhcIixcblx0XCJuYWJsYVwiOiBcIuKIh1wiLFxuXHRcIk5hY3V0ZVwiOiBcIsWDXCIsXG5cdFwibmFjdXRlXCI6IFwixYRcIixcblx0XCJuYW5nXCI6IFwi4oig4oOSXCIsXG5cdFwibmFwXCI6IFwi4omJXCIsXG5cdFwibmFwRVwiOiBcIuKpsMy4XCIsXG5cdFwibmFwaWRcIjogXCLiiYvMuFwiLFxuXHRcIm5hcG9zXCI6IFwixYlcIixcblx0XCJuYXBwcm94XCI6IFwi4omJXCIsXG5cdFwibmF0dXJhbFwiOiBcIuKZrlwiLFxuXHRcIm5hdHVyYWxzXCI6IFwi4oSVXCIsXG5cdFwibmF0dXJcIjogXCLima5cIixcblx0XCJuYnNwXCI6IFwiwqBcIixcblx0XCJuYnVtcFwiOiBcIuKJjsy4XCIsXG5cdFwibmJ1bXBlXCI6IFwi4omPzLhcIixcblx0XCJuY2FwXCI6IFwi4qmDXCIsXG5cdFwiTmNhcm9uXCI6IFwixYdcIixcblx0XCJuY2Fyb25cIjogXCLFiFwiLFxuXHRcIk5jZWRpbFwiOiBcIsWFXCIsXG5cdFwibmNlZGlsXCI6IFwixYZcIixcblx0XCJuY29uZ1wiOiBcIuKJh1wiLFxuXHRcIm5jb25nZG90XCI6IFwi4qmtzLhcIixcblx0XCJuY3VwXCI6IFwi4qmCXCIsXG5cdFwiTmN5XCI6IFwi0J1cIixcblx0XCJuY3lcIjogXCLQvVwiLFxuXHRcIm5kYXNoXCI6IFwi4oCTXCIsXG5cdFwibmVhcmhrXCI6IFwi4qSkXCIsXG5cdFwibmVhcnJcIjogXCLihpdcIixcblx0XCJuZUFyclwiOiBcIuKHl1wiLFxuXHRcIm5lYXJyb3dcIjogXCLihpdcIixcblx0XCJuZVwiOiBcIuKJoFwiLFxuXHRcIm5lZG90XCI6IFwi4omQzLhcIixcblx0XCJOZWdhdGl2ZU1lZGl1bVNwYWNlXCI6IFwi4oCLXCIsXG5cdFwiTmVnYXRpdmVUaGlja1NwYWNlXCI6IFwi4oCLXCIsXG5cdFwiTmVnYXRpdmVUaGluU3BhY2VcIjogXCLigItcIixcblx0XCJOZWdhdGl2ZVZlcnlUaGluU3BhY2VcIjogXCLigItcIixcblx0XCJuZXF1aXZcIjogXCLiiaJcIixcblx0XCJuZXNlYXJcIjogXCLipKhcIixcblx0XCJuZXNpbVwiOiBcIuKJgsy4XCIsXG5cdFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjogXCLiiatcIixcblx0XCJOZXN0ZWRMZXNzTGVzc1wiOiBcIuKJqlwiLFxuXHRcIk5ld0xpbmVcIjogXCJcXG5cIixcblx0XCJuZXhpc3RcIjogXCLiiIRcIixcblx0XCJuZXhpc3RzXCI6IFwi4oiEXCIsXG5cdFwiTmZyXCI6IFwi8J2UkVwiLFxuXHRcIm5mclwiOiBcIvCdlKtcIixcblx0XCJuZ0VcIjogXCLiiafMuFwiLFxuXHRcIm5nZVwiOiBcIuKJsVwiLFxuXHRcIm5nZXFcIjogXCLiibFcIixcblx0XCJuZ2VxcVwiOiBcIuKJp8y4XCIsXG5cdFwibmdlcXNsYW50XCI6IFwi4qm+zLhcIixcblx0XCJuZ2VzXCI6IFwi4qm+zLhcIixcblx0XCJuR2dcIjogXCLii5nMuFwiLFxuXHRcIm5nc2ltXCI6IFwi4om1XCIsXG5cdFwibkd0XCI6IFwi4omr4oOSXCIsXG5cdFwibmd0XCI6IFwi4omvXCIsXG5cdFwibmd0clwiOiBcIuKJr1wiLFxuXHRcIm5HdHZcIjogXCLiiavMuFwiLFxuXHRcIm5oYXJyXCI6IFwi4oauXCIsXG5cdFwibmhBcnJcIjogXCLih45cIixcblx0XCJuaHBhclwiOiBcIuKrslwiLFxuXHRcIm5pXCI6IFwi4oiLXCIsXG5cdFwibmlzXCI6IFwi4ou8XCIsXG5cdFwibmlzZFwiOiBcIuKLulwiLFxuXHRcIm5pdlwiOiBcIuKIi1wiLFxuXHRcIk5KY3lcIjogXCLQilwiLFxuXHRcIm5qY3lcIjogXCLRmlwiLFxuXHRcIm5sYXJyXCI6IFwi4oaaXCIsXG5cdFwibmxBcnJcIjogXCLih41cIixcblx0XCJubGRyXCI6IFwi4oClXCIsXG5cdFwibmxFXCI6IFwi4ommzLhcIixcblx0XCJubGVcIjogXCLiibBcIixcblx0XCJubGVmdGFycm93XCI6IFwi4oaaXCIsXG5cdFwibkxlZnRhcnJvd1wiOiBcIuKHjVwiLFxuXHRcIm5sZWZ0cmlnaHRhcnJvd1wiOiBcIuKGrlwiLFxuXHRcIm5MZWZ0cmlnaHRhcnJvd1wiOiBcIuKHjlwiLFxuXHRcIm5sZXFcIjogXCLiibBcIixcblx0XCJubGVxcVwiOiBcIuKJpsy4XCIsXG5cdFwibmxlcXNsYW50XCI6IFwi4qm9zLhcIixcblx0XCJubGVzXCI6IFwi4qm9zLhcIixcblx0XCJubGVzc1wiOiBcIuKJrlwiLFxuXHRcIm5MbFwiOiBcIuKLmMy4XCIsXG5cdFwibmxzaW1cIjogXCLiibRcIixcblx0XCJuTHRcIjogXCLiiarig5JcIixcblx0XCJubHRcIjogXCLiia5cIixcblx0XCJubHRyaVwiOiBcIuKLqlwiLFxuXHRcIm5sdHJpZVwiOiBcIuKLrFwiLFxuXHRcIm5MdHZcIjogXCLiiarMuFwiLFxuXHRcIm5taWRcIjogXCLiiKRcIixcblx0XCJOb0JyZWFrXCI6IFwi4oGgXCIsXG5cdFwiTm9uQnJlYWtpbmdTcGFjZVwiOiBcIsKgXCIsXG5cdFwibm9wZlwiOiBcIvCdlZ9cIixcblx0XCJOb3BmXCI6IFwi4oSVXCIsXG5cdFwiTm90XCI6IFwi4qusXCIsXG5cdFwibm90XCI6IFwiwqxcIixcblx0XCJOb3RDb25ncnVlbnRcIjogXCLiiaJcIixcblx0XCJOb3RDdXBDYXBcIjogXCLiia1cIixcblx0XCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOiBcIuKIplwiLFxuXHRcIk5vdEVsZW1lbnRcIjogXCLiiIlcIixcblx0XCJOb3RFcXVhbFwiOiBcIuKJoFwiLFxuXHRcIk5vdEVxdWFsVGlsZGVcIjogXCLiiYLMuFwiLFxuXHRcIk5vdEV4aXN0c1wiOiBcIuKIhFwiLFxuXHRcIk5vdEdyZWF0ZXJcIjogXCLiia9cIixcblx0XCJOb3RHcmVhdGVyRXF1YWxcIjogXCLiibFcIixcblx0XCJOb3RHcmVhdGVyRnVsbEVxdWFsXCI6IFwi4omnzLhcIixcblx0XCJOb3RHcmVhdGVyR3JlYXRlclwiOiBcIuKJq8y4XCIsXG5cdFwiTm90R3JlYXRlckxlc3NcIjogXCLiiblcIixcblx0XCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOiBcIuKpvsy4XCIsXG5cdFwiTm90R3JlYXRlclRpbGRlXCI6IFwi4om1XCIsXG5cdFwiTm90SHVtcERvd25IdW1wXCI6IFwi4omOzLhcIixcblx0XCJOb3RIdW1wRXF1YWxcIjogXCLiiY/MuFwiLFxuXHRcIm5vdGluXCI6IFwi4oiJXCIsXG5cdFwibm90aW5kb3RcIjogXCLii7XMuFwiLFxuXHRcIm5vdGluRVwiOiBcIuKLucy4XCIsXG5cdFwibm90aW52YVwiOiBcIuKIiVwiLFxuXHRcIm5vdGludmJcIjogXCLii7dcIixcblx0XCJub3RpbnZjXCI6IFwi4ou2XCIsXG5cdFwiTm90TGVmdFRyaWFuZ2xlQmFyXCI6IFwi4qePzLhcIixcblx0XCJOb3RMZWZ0VHJpYW5nbGVcIjogXCLii6pcIixcblx0XCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOiBcIuKLrFwiLFxuXHRcIk5vdExlc3NcIjogXCLiia5cIixcblx0XCJOb3RMZXNzRXF1YWxcIjogXCLiibBcIixcblx0XCJOb3RMZXNzR3JlYXRlclwiOiBcIuKJuFwiLFxuXHRcIk5vdExlc3NMZXNzXCI6IFwi4omqzLhcIixcblx0XCJOb3RMZXNzU2xhbnRFcXVhbFwiOiBcIuKpvcy4XCIsXG5cdFwiTm90TGVzc1RpbGRlXCI6IFwi4om0XCIsXG5cdFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXJcIjogXCLiqqLMuFwiLFxuXHRcIk5vdE5lc3RlZExlc3NMZXNzXCI6IFwi4qqhzLhcIixcblx0XCJub3RuaVwiOiBcIuKIjFwiLFxuXHRcIm5vdG5pdmFcIjogXCLiiIxcIixcblx0XCJub3RuaXZiXCI6IFwi4ou+XCIsXG5cdFwibm90bml2Y1wiOiBcIuKLvVwiLFxuXHRcIk5vdFByZWNlZGVzXCI6IFwi4oqAXCIsXG5cdFwiTm90UHJlY2VkZXNFcXVhbFwiOiBcIuKqr8y4XCIsXG5cdFwiTm90UHJlY2VkZXNTbGFudEVxdWFsXCI6IFwi4ougXCIsXG5cdFwiTm90UmV2ZXJzZUVsZW1lbnRcIjogXCLiiIxcIixcblx0XCJOb3RSaWdodFRyaWFuZ2xlQmFyXCI6IFwi4qeQzLhcIixcblx0XCJOb3RSaWdodFRyaWFuZ2xlXCI6IFwi4ourXCIsXG5cdFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsXCI6IFwi4outXCIsXG5cdFwiTm90U3F1YXJlU3Vic2V0XCI6IFwi4oqPzLhcIixcblx0XCJOb3RTcXVhcmVTdWJzZXRFcXVhbFwiOiBcIuKLolwiLFxuXHRcIk5vdFNxdWFyZVN1cGVyc2V0XCI6IFwi4oqQzLhcIixcblx0XCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsXCI6IFwi4oujXCIsXG5cdFwiTm90U3Vic2V0XCI6IFwi4oqC4oOSXCIsXG5cdFwiTm90U3Vic2V0RXF1YWxcIjogXCLiiohcIixcblx0XCJOb3RTdWNjZWVkc1wiOiBcIuKKgVwiLFxuXHRcIk5vdFN1Y2NlZWRzRXF1YWxcIjogXCLiqrDMuFwiLFxuXHRcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbFwiOiBcIuKLoVwiLFxuXHRcIk5vdFN1Y2NlZWRzVGlsZGVcIjogXCLiib/MuFwiLFxuXHRcIk5vdFN1cGVyc2V0XCI6IFwi4oqD4oOSXCIsXG5cdFwiTm90U3VwZXJzZXRFcXVhbFwiOiBcIuKKiVwiLFxuXHRcIk5vdFRpbGRlXCI6IFwi4omBXCIsXG5cdFwiTm90VGlsZGVFcXVhbFwiOiBcIuKJhFwiLFxuXHRcIk5vdFRpbGRlRnVsbEVxdWFsXCI6IFwi4omHXCIsXG5cdFwiTm90VGlsZGVUaWxkZVwiOiBcIuKJiVwiLFxuXHRcIk5vdFZlcnRpY2FsQmFyXCI6IFwi4oikXCIsXG5cdFwibnBhcmFsbGVsXCI6IFwi4oimXCIsXG5cdFwibnBhclwiOiBcIuKIplwiLFxuXHRcIm5wYXJzbFwiOiBcIuKrveKDpVwiLFxuXHRcIm5wYXJ0XCI6IFwi4oiCzLhcIixcblx0XCJucG9saW50XCI6IFwi4qiUXCIsXG5cdFwibnByXCI6IFwi4oqAXCIsXG5cdFwibnByY3VlXCI6IFwi4ougXCIsXG5cdFwibnByZWNcIjogXCLiioBcIixcblx0XCJucHJlY2VxXCI6IFwi4qqvzLhcIixcblx0XCJucHJlXCI6IFwi4qqvzLhcIixcblx0XCJucmFycmNcIjogXCLipLPMuFwiLFxuXHRcIm5yYXJyXCI6IFwi4oabXCIsXG5cdFwibnJBcnJcIjogXCLih49cIixcblx0XCJucmFycndcIjogXCLihp3MuFwiLFxuXHRcIm5yaWdodGFycm93XCI6IFwi4oabXCIsXG5cdFwiblJpZ2h0YXJyb3dcIjogXCLih49cIixcblx0XCJucnRyaVwiOiBcIuKLq1wiLFxuXHRcIm5ydHJpZVwiOiBcIuKLrVwiLFxuXHRcIm5zY1wiOiBcIuKKgVwiLFxuXHRcIm5zY2N1ZVwiOiBcIuKLoVwiLFxuXHRcIm5zY2VcIjogXCLiqrDMuFwiLFxuXHRcIk5zY3JcIjogXCLwnZKpXCIsXG5cdFwibnNjclwiOiBcIvCdk4NcIixcblx0XCJuc2hvcnRtaWRcIjogXCLiiKRcIixcblx0XCJuc2hvcnRwYXJhbGxlbFwiOiBcIuKIplwiLFxuXHRcIm5zaW1cIjogXCLiiYFcIixcblx0XCJuc2ltZVwiOiBcIuKJhFwiLFxuXHRcIm5zaW1lcVwiOiBcIuKJhFwiLFxuXHRcIm5zbWlkXCI6IFwi4oikXCIsXG5cdFwibnNwYXJcIjogXCLiiKZcIixcblx0XCJuc3FzdWJlXCI6IFwi4ouiXCIsXG5cdFwibnNxc3VwZVwiOiBcIuKLo1wiLFxuXHRcIm5zdWJcIjogXCLiioRcIixcblx0XCJuc3ViRVwiOiBcIuKrhcy4XCIsXG5cdFwibnN1YmVcIjogXCLiiohcIixcblx0XCJuc3Vic2V0XCI6IFwi4oqC4oOSXCIsXG5cdFwibnN1YnNldGVxXCI6IFwi4oqIXCIsXG5cdFwibnN1YnNldGVxcVwiOiBcIuKrhcy4XCIsXG5cdFwibnN1Y2NcIjogXCLiioFcIixcblx0XCJuc3VjY2VxXCI6IFwi4qqwzLhcIixcblx0XCJuc3VwXCI6IFwi4oqFXCIsXG5cdFwibnN1cEVcIjogXCLiq4bMuFwiLFxuXHRcIm5zdXBlXCI6IFwi4oqJXCIsXG5cdFwibnN1cHNldFwiOiBcIuKKg+KDklwiLFxuXHRcIm5zdXBzZXRlcVwiOiBcIuKKiVwiLFxuXHRcIm5zdXBzZXRlcXFcIjogXCLiq4bMuFwiLFxuXHRcIm50Z2xcIjogXCLiiblcIixcblx0XCJOdGlsZGVcIjogXCLDkVwiLFxuXHRcIm50aWxkZVwiOiBcIsOxXCIsXG5cdFwibnRsZ1wiOiBcIuKJuFwiLFxuXHRcIm50cmlhbmdsZWxlZnRcIjogXCLii6pcIixcblx0XCJudHJpYW5nbGVsZWZ0ZXFcIjogXCLii6xcIixcblx0XCJudHJpYW5nbGVyaWdodFwiOiBcIuKLq1wiLFxuXHRcIm50cmlhbmdsZXJpZ2h0ZXFcIjogXCLii61cIixcblx0XCJOdVwiOiBcIs6dXCIsXG5cdFwibnVcIjogXCLOvVwiLFxuXHRcIm51bVwiOiBcIiNcIixcblx0XCJudW1lcm9cIjogXCLihJZcIixcblx0XCJudW1zcFwiOiBcIuKAh1wiLFxuXHRcIm52YXBcIjogXCLiiY3ig5JcIixcblx0XCJudmRhc2hcIjogXCLiiqxcIixcblx0XCJudkRhc2hcIjogXCLiiq1cIixcblx0XCJuVmRhc2hcIjogXCLiiq5cIixcblx0XCJuVkRhc2hcIjogXCLiiq9cIixcblx0XCJudmdlXCI6IFwi4oml4oOSXCIsXG5cdFwibnZndFwiOiBcIj7ig5JcIixcblx0XCJudkhhcnJcIjogXCLipIRcIixcblx0XCJudmluZmluXCI6IFwi4qeeXCIsXG5cdFwibnZsQXJyXCI6IFwi4qSCXCIsXG5cdFwibnZsZVwiOiBcIuKJpOKDklwiLFxuXHRcIm52bHRcIjogXCI84oOSXCIsXG5cdFwibnZsdHJpZVwiOiBcIuKKtOKDklwiLFxuXHRcIm52ckFyclwiOiBcIuKkg1wiLFxuXHRcIm52cnRyaWVcIjogXCLiirXig5JcIixcblx0XCJudnNpbVwiOiBcIuKIvOKDklwiLFxuXHRcIm53YXJoa1wiOiBcIuKko1wiLFxuXHRcIm53YXJyXCI6IFwi4oaWXCIsXG5cdFwibndBcnJcIjogXCLih5ZcIixcblx0XCJud2Fycm93XCI6IFwi4oaWXCIsXG5cdFwibnduZWFyXCI6IFwi4qSnXCIsXG5cdFwiT2FjdXRlXCI6IFwiw5NcIixcblx0XCJvYWN1dGVcIjogXCLDs1wiLFxuXHRcIm9hc3RcIjogXCLiiptcIixcblx0XCJPY2lyY1wiOiBcIsOUXCIsXG5cdFwib2NpcmNcIjogXCLDtFwiLFxuXHRcIm9jaXJcIjogXCLiippcIixcblx0XCJPY3lcIjogXCLQnlwiLFxuXHRcIm9jeVwiOiBcItC+XCIsXG5cdFwib2Rhc2hcIjogXCLiip1cIixcblx0XCJPZGJsYWNcIjogXCLFkFwiLFxuXHRcIm9kYmxhY1wiOiBcIsWRXCIsXG5cdFwib2RpdlwiOiBcIuKouFwiLFxuXHRcIm9kb3RcIjogXCLiiplcIixcblx0XCJvZHNvbGRcIjogXCLiprxcIixcblx0XCJPRWxpZ1wiOiBcIsWSXCIsXG5cdFwib2VsaWdcIjogXCLFk1wiLFxuXHRcIm9mY2lyXCI6IFwi4qa/XCIsXG5cdFwiT2ZyXCI6IFwi8J2UklwiLFxuXHRcIm9mclwiOiBcIvCdlKxcIixcblx0XCJvZ29uXCI6IFwiy5tcIixcblx0XCJPZ3JhdmVcIjogXCLDklwiLFxuXHRcIm9ncmF2ZVwiOiBcIsOyXCIsXG5cdFwib2d0XCI6IFwi4qeBXCIsXG5cdFwib2hiYXJcIjogXCLiprVcIixcblx0XCJvaG1cIjogXCLOqVwiLFxuXHRcIm9pbnRcIjogXCLiiK5cIixcblx0XCJvbGFyclwiOiBcIuKGulwiLFxuXHRcIm9sY2lyXCI6IFwi4qa+XCIsXG5cdFwib2xjcm9zc1wiOiBcIuKmu1wiLFxuXHRcIm9saW5lXCI6IFwi4oC+XCIsXG5cdFwib2x0XCI6IFwi4qeAXCIsXG5cdFwiT21hY3JcIjogXCLFjFwiLFxuXHRcIm9tYWNyXCI6IFwixY1cIixcblx0XCJPbWVnYVwiOiBcIs6pXCIsXG5cdFwib21lZ2FcIjogXCLPiVwiLFxuXHRcIk9taWNyb25cIjogXCLOn1wiLFxuXHRcIm9taWNyb25cIjogXCLOv1wiLFxuXHRcIm9taWRcIjogXCLiprZcIixcblx0XCJvbWludXNcIjogXCLiipZcIixcblx0XCJPb3BmXCI6IFwi8J2VhlwiLFxuXHRcIm9vcGZcIjogXCLwnZWgXCIsXG5cdFwib3BhclwiOiBcIuKmt1wiLFxuXHRcIk9wZW5DdXJseURvdWJsZVF1b3RlXCI6IFwi4oCcXCIsXG5cdFwiT3BlbkN1cmx5UXVvdGVcIjogXCLigJhcIixcblx0XCJvcGVycFwiOiBcIuKmuVwiLFxuXHRcIm9wbHVzXCI6IFwi4oqVXCIsXG5cdFwib3JhcnJcIjogXCLihrtcIixcblx0XCJPclwiOiBcIuKplFwiLFxuXHRcIm9yXCI6IFwi4oioXCIsXG5cdFwib3JkXCI6IFwi4qmdXCIsXG5cdFwib3JkZXJcIjogXCLihLRcIixcblx0XCJvcmRlcm9mXCI6IFwi4oS0XCIsXG5cdFwib3JkZlwiOiBcIsKqXCIsXG5cdFwib3JkbVwiOiBcIsK6XCIsXG5cdFwib3JpZ29mXCI6IFwi4oq2XCIsXG5cdFwib3JvclwiOiBcIuKpllwiLFxuXHRcIm9yc2xvcGVcIjogXCLiqZdcIixcblx0XCJvcnZcIjogXCLiqZtcIixcblx0XCJvU1wiOiBcIuKTiFwiLFxuXHRcIk9zY3JcIjogXCLwnZKqXCIsXG5cdFwib3NjclwiOiBcIuKEtFwiLFxuXHRcIk9zbGFzaFwiOiBcIsOYXCIsXG5cdFwib3NsYXNoXCI6IFwiw7hcIixcblx0XCJvc29sXCI6IFwi4oqYXCIsXG5cdFwiT3RpbGRlXCI6IFwiw5VcIixcblx0XCJvdGlsZGVcIjogXCLDtVwiLFxuXHRcIm90aW1lc2FzXCI6IFwi4qi2XCIsXG5cdFwiT3RpbWVzXCI6IFwi4qi3XCIsXG5cdFwib3RpbWVzXCI6IFwi4oqXXCIsXG5cdFwiT3VtbFwiOiBcIsOWXCIsXG5cdFwib3VtbFwiOiBcIsO2XCIsXG5cdFwib3ZiYXJcIjogXCLijL1cIixcblx0XCJPdmVyQmFyXCI6IFwi4oC+XCIsXG5cdFwiT3ZlckJyYWNlXCI6IFwi4o+eXCIsXG5cdFwiT3ZlckJyYWNrZXRcIjogXCLijrRcIixcblx0XCJPdmVyUGFyZW50aGVzaXNcIjogXCLij5xcIixcblx0XCJwYXJhXCI6IFwiwrZcIixcblx0XCJwYXJhbGxlbFwiOiBcIuKIpVwiLFxuXHRcInBhclwiOiBcIuKIpVwiLFxuXHRcInBhcnNpbVwiOiBcIuKrs1wiLFxuXHRcInBhcnNsXCI6IFwi4qu9XCIsXG5cdFwicGFydFwiOiBcIuKIglwiLFxuXHRcIlBhcnRpYWxEXCI6IFwi4oiCXCIsXG5cdFwiUGN5XCI6IFwi0J9cIixcblx0XCJwY3lcIjogXCLQv1wiLFxuXHRcInBlcmNudFwiOiBcIiVcIixcblx0XCJwZXJpb2RcIjogXCIuXCIsXG5cdFwicGVybWlsXCI6IFwi4oCwXCIsXG5cdFwicGVycFwiOiBcIuKKpVwiLFxuXHRcInBlcnRlbmtcIjogXCLigLFcIixcblx0XCJQZnJcIjogXCLwnZSTXCIsXG5cdFwicGZyXCI6IFwi8J2UrVwiLFxuXHRcIlBoaVwiOiBcIs6mXCIsXG5cdFwicGhpXCI6IFwiz4ZcIixcblx0XCJwaGl2XCI6IFwiz5VcIixcblx0XCJwaG1tYXRcIjogXCLihLNcIixcblx0XCJwaG9uZVwiOiBcIuKYjlwiLFxuXHRcIlBpXCI6IFwizqBcIixcblx0XCJwaVwiOiBcIs+AXCIsXG5cdFwicGl0Y2hmb3JrXCI6IFwi4ouUXCIsXG5cdFwicGl2XCI6IFwiz5ZcIixcblx0XCJwbGFuY2tcIjogXCLihI9cIixcblx0XCJwbGFuY2toXCI6IFwi4oSOXCIsXG5cdFwicGxhbmt2XCI6IFwi4oSPXCIsXG5cdFwicGx1c2FjaXJcIjogXCLiqKNcIixcblx0XCJwbHVzYlwiOiBcIuKKnlwiLFxuXHRcInBsdXNjaXJcIjogXCLiqKJcIixcblx0XCJwbHVzXCI6IFwiK1wiLFxuXHRcInBsdXNkb1wiOiBcIuKIlFwiLFxuXHRcInBsdXNkdVwiOiBcIuKopVwiLFxuXHRcInBsdXNlXCI6IFwi4qmyXCIsXG5cdFwiUGx1c01pbnVzXCI6IFwiwrFcIixcblx0XCJwbHVzbW5cIjogXCLCsVwiLFxuXHRcInBsdXNzaW1cIjogXCLiqKZcIixcblx0XCJwbHVzdHdvXCI6IFwi4qinXCIsXG5cdFwicG1cIjogXCLCsVwiLFxuXHRcIlBvaW5jYXJlcGxhbmVcIjogXCLihIxcIixcblx0XCJwb2ludGludFwiOiBcIuKolVwiLFxuXHRcInBvcGZcIjogXCLwnZWhXCIsXG5cdFwiUG9wZlwiOiBcIuKEmVwiLFxuXHRcInBvdW5kXCI6IFwiwqNcIixcblx0XCJwcmFwXCI6IFwi4qq3XCIsXG5cdFwiUHJcIjogXCLiqrtcIixcblx0XCJwclwiOiBcIuKJulwiLFxuXHRcInByY3VlXCI6IFwi4om8XCIsXG5cdFwicHJlY2FwcHJveFwiOiBcIuKqt1wiLFxuXHRcInByZWNcIjogXCLiibpcIixcblx0XCJwcmVjY3VybHllcVwiOiBcIuKJvFwiLFxuXHRcIlByZWNlZGVzXCI6IFwi4om6XCIsXG5cdFwiUHJlY2VkZXNFcXVhbFwiOiBcIuKqr1wiLFxuXHRcIlByZWNlZGVzU2xhbnRFcXVhbFwiOiBcIuKJvFwiLFxuXHRcIlByZWNlZGVzVGlsZGVcIjogXCLiib5cIixcblx0XCJwcmVjZXFcIjogXCLiqq9cIixcblx0XCJwcmVjbmFwcHJveFwiOiBcIuKquVwiLFxuXHRcInByZWNuZXFxXCI6IFwi4qq1XCIsXG5cdFwicHJlY25zaW1cIjogXCLii6hcIixcblx0XCJwcmVcIjogXCLiqq9cIixcblx0XCJwckVcIjogXCLiqrNcIixcblx0XCJwcmVjc2ltXCI6IFwi4om+XCIsXG5cdFwicHJpbWVcIjogXCLigLJcIixcblx0XCJQcmltZVwiOiBcIuKAs1wiLFxuXHRcInByaW1lc1wiOiBcIuKEmVwiLFxuXHRcInBybmFwXCI6IFwi4qq5XCIsXG5cdFwicHJuRVwiOiBcIuKqtVwiLFxuXHRcInBybnNpbVwiOiBcIuKLqFwiLFxuXHRcInByb2RcIjogXCLiiI9cIixcblx0XCJQcm9kdWN0XCI6IFwi4oiPXCIsXG5cdFwicHJvZmFsYXJcIjogXCLijK5cIixcblx0XCJwcm9mbGluZVwiOiBcIuKMklwiLFxuXHRcInByb2ZzdXJmXCI6IFwi4oyTXCIsXG5cdFwicHJvcFwiOiBcIuKInVwiLFxuXHRcIlByb3BvcnRpb25hbFwiOiBcIuKInVwiLFxuXHRcIlByb3BvcnRpb25cIjogXCLiiLdcIixcblx0XCJwcm9wdG9cIjogXCLiiJ1cIixcblx0XCJwcnNpbVwiOiBcIuKJvlwiLFxuXHRcInBydXJlbFwiOiBcIuKKsFwiLFxuXHRcIlBzY3JcIjogXCLwnZKrXCIsXG5cdFwicHNjclwiOiBcIvCdk4VcIixcblx0XCJQc2lcIjogXCLOqFwiLFxuXHRcInBzaVwiOiBcIs+IXCIsXG5cdFwicHVuY3NwXCI6IFwi4oCIXCIsXG5cdFwiUWZyXCI6IFwi8J2UlFwiLFxuXHRcInFmclwiOiBcIvCdlK5cIixcblx0XCJxaW50XCI6IFwi4qiMXCIsXG5cdFwicW9wZlwiOiBcIvCdlaJcIixcblx0XCJRb3BmXCI6IFwi4oSaXCIsXG5cdFwicXByaW1lXCI6IFwi4oGXXCIsXG5cdFwiUXNjclwiOiBcIvCdkqxcIixcblx0XCJxc2NyXCI6IFwi8J2ThlwiLFxuXHRcInF1YXRlcm5pb25zXCI6IFwi4oSNXCIsXG5cdFwicXVhdGludFwiOiBcIuKollwiLFxuXHRcInF1ZXN0XCI6IFwiP1wiLFxuXHRcInF1ZXN0ZXFcIjogXCLiiZ9cIixcblx0XCJxdW90XCI6IFwiXFxcIlwiLFxuXHRcIlFVT1RcIjogXCJcXFwiXCIsXG5cdFwickFhcnJcIjogXCLih5tcIixcblx0XCJyYWNlXCI6IFwi4oi9zLFcIixcblx0XCJSYWN1dGVcIjogXCLFlFwiLFxuXHRcInJhY3V0ZVwiOiBcIsWVXCIsXG5cdFwicmFkaWNcIjogXCLiiJpcIixcblx0XCJyYWVtcHR5dlwiOiBcIuKms1wiLFxuXHRcInJhbmdcIjogXCLin6lcIixcblx0XCJSYW5nXCI6IFwi4p+rXCIsXG5cdFwicmFuZ2RcIjogXCLippJcIixcblx0XCJyYW5nZVwiOiBcIuKmpVwiLFxuXHRcInJhbmdsZVwiOiBcIuKfqVwiLFxuXHRcInJhcXVvXCI6IFwiwrtcIixcblx0XCJyYXJyYXBcIjogXCLipbVcIixcblx0XCJyYXJyYlwiOiBcIuKHpVwiLFxuXHRcInJhcnJiZnNcIjogXCLipKBcIixcblx0XCJyYXJyY1wiOiBcIuKks1wiLFxuXHRcInJhcnJcIjogXCLihpJcIixcblx0XCJSYXJyXCI6IFwi4oagXCIsXG5cdFwickFyclwiOiBcIuKHklwiLFxuXHRcInJhcnJmc1wiOiBcIuKknlwiLFxuXHRcInJhcnJoa1wiOiBcIuKGqlwiLFxuXHRcInJhcnJscFwiOiBcIuKGrFwiLFxuXHRcInJhcnJwbFwiOiBcIuKlhVwiLFxuXHRcInJhcnJzaW1cIjogXCLipbRcIixcblx0XCJSYXJydGxcIjogXCLipJZcIixcblx0XCJyYXJydGxcIjogXCLihqNcIixcblx0XCJyYXJyd1wiOiBcIuKGnVwiLFxuXHRcInJhdGFpbFwiOiBcIuKkmlwiLFxuXHRcInJBdGFpbFwiOiBcIuKknFwiLFxuXHRcInJhdGlvXCI6IFwi4oi2XCIsXG5cdFwicmF0aW9uYWxzXCI6IFwi4oSaXCIsXG5cdFwicmJhcnJcIjogXCLipI1cIixcblx0XCJyQmFyclwiOiBcIuKkj1wiLFxuXHRcIlJCYXJyXCI6IFwi4qSQXCIsXG5cdFwicmJicmtcIjogXCLinbNcIixcblx0XCJyYnJhY2VcIjogXCJ9XCIsXG5cdFwicmJyYWNrXCI6IFwiXVwiLFxuXHRcInJicmtlXCI6IFwi4qaMXCIsXG5cdFwicmJya3NsZFwiOiBcIuKmjlwiLFxuXHRcInJicmtzbHVcIjogXCLippBcIixcblx0XCJSY2Fyb25cIjogXCLFmFwiLFxuXHRcInJjYXJvblwiOiBcIsWZXCIsXG5cdFwiUmNlZGlsXCI6IFwixZZcIixcblx0XCJyY2VkaWxcIjogXCLFl1wiLFxuXHRcInJjZWlsXCI6IFwi4oyJXCIsXG5cdFwicmN1YlwiOiBcIn1cIixcblx0XCJSY3lcIjogXCLQoFwiLFxuXHRcInJjeVwiOiBcItGAXCIsXG5cdFwicmRjYVwiOiBcIuKkt1wiLFxuXHRcInJkbGRoYXJcIjogXCLipalcIixcblx0XCJyZHF1b1wiOiBcIuKAnVwiLFxuXHRcInJkcXVvclwiOiBcIuKAnVwiLFxuXHRcInJkc2hcIjogXCLihrNcIixcblx0XCJyZWFsXCI6IFwi4oScXCIsXG5cdFwicmVhbGluZVwiOiBcIuKEm1wiLFxuXHRcInJlYWxwYXJ0XCI6IFwi4oScXCIsXG5cdFwicmVhbHNcIjogXCLihJ1cIixcblx0XCJSZVwiOiBcIuKEnFwiLFxuXHRcInJlY3RcIjogXCLilq1cIixcblx0XCJyZWdcIjogXCLCrlwiLFxuXHRcIlJFR1wiOiBcIsKuXCIsXG5cdFwiUmV2ZXJzZUVsZW1lbnRcIjogXCLiiItcIixcblx0XCJSZXZlcnNlRXF1aWxpYnJpdW1cIjogXCLih4tcIixcblx0XCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOiBcIuKlr1wiLFxuXHRcInJmaXNodFwiOiBcIuKlvVwiLFxuXHRcInJmbG9vclwiOiBcIuKMi1wiLFxuXHRcInJmclwiOiBcIvCdlK9cIixcblx0XCJSZnJcIjogXCLihJxcIixcblx0XCJySGFyXCI6IFwi4qWkXCIsXG5cdFwicmhhcmRcIjogXCLih4FcIixcblx0XCJyaGFydVwiOiBcIuKHgFwiLFxuXHRcInJoYXJ1bFwiOiBcIuKlrFwiLFxuXHRcIlJob1wiOiBcIs6hXCIsXG5cdFwicmhvXCI6IFwiz4FcIixcblx0XCJyaG92XCI6IFwiz7FcIixcblx0XCJSaWdodEFuZ2xlQnJhY2tldFwiOiBcIuKfqVwiLFxuXHRcIlJpZ2h0QXJyb3dCYXJcIjogXCLih6VcIixcblx0XCJyaWdodGFycm93XCI6IFwi4oaSXCIsXG5cdFwiUmlnaHRBcnJvd1wiOiBcIuKGklwiLFxuXHRcIlJpZ2h0YXJyb3dcIjogXCLih5JcIixcblx0XCJSaWdodEFycm93TGVmdEFycm93XCI6IFwi4oeEXCIsXG5cdFwicmlnaHRhcnJvd3RhaWxcIjogXCLihqNcIixcblx0XCJSaWdodENlaWxpbmdcIjogXCLijIlcIixcblx0XCJSaWdodERvdWJsZUJyYWNrZXRcIjogXCLin6dcIixcblx0XCJSaWdodERvd25UZWVWZWN0b3JcIjogXCLipZ1cIixcblx0XCJSaWdodERvd25WZWN0b3JCYXJcIjogXCLipZVcIixcblx0XCJSaWdodERvd25WZWN0b3JcIjogXCLih4JcIixcblx0XCJSaWdodEZsb29yXCI6IFwi4oyLXCIsXG5cdFwicmlnaHRoYXJwb29uZG93blwiOiBcIuKHgVwiLFxuXHRcInJpZ2h0aGFycG9vbnVwXCI6IFwi4oeAXCIsXG5cdFwicmlnaHRsZWZ0YXJyb3dzXCI6IFwi4oeEXCIsXG5cdFwicmlnaHRsZWZ0aGFycG9vbnNcIjogXCLih4xcIixcblx0XCJyaWdodHJpZ2h0YXJyb3dzXCI6IFwi4oeJXCIsXG5cdFwicmlnaHRzcXVpZ2Fycm93XCI6IFwi4oadXCIsXG5cdFwiUmlnaHRUZWVBcnJvd1wiOiBcIuKGplwiLFxuXHRcIlJpZ2h0VGVlXCI6IFwi4oqiXCIsXG5cdFwiUmlnaHRUZWVWZWN0b3JcIjogXCLipZtcIixcblx0XCJyaWdodHRocmVldGltZXNcIjogXCLii4xcIixcblx0XCJSaWdodFRyaWFuZ2xlQmFyXCI6IFwi4qeQXCIsXG5cdFwiUmlnaHRUcmlhbmdsZVwiOiBcIuKKs1wiLFxuXHRcIlJpZ2h0VHJpYW5nbGVFcXVhbFwiOiBcIuKKtVwiLFxuXHRcIlJpZ2h0VXBEb3duVmVjdG9yXCI6IFwi4qWPXCIsXG5cdFwiUmlnaHRVcFRlZVZlY3RvclwiOiBcIuKlnFwiLFxuXHRcIlJpZ2h0VXBWZWN0b3JCYXJcIjogXCLipZRcIixcblx0XCJSaWdodFVwVmVjdG9yXCI6IFwi4oa+XCIsXG5cdFwiUmlnaHRWZWN0b3JCYXJcIjogXCLipZNcIixcblx0XCJSaWdodFZlY3RvclwiOiBcIuKHgFwiLFxuXHRcInJpbmdcIjogXCLLmlwiLFxuXHRcInJpc2luZ2RvdHNlcVwiOiBcIuKJk1wiLFxuXHRcInJsYXJyXCI6IFwi4oeEXCIsXG5cdFwicmxoYXJcIjogXCLih4xcIixcblx0XCJybG1cIjogXCLigI9cIixcblx0XCJybW91c3RhY2hlXCI6IFwi4o6xXCIsXG5cdFwicm1vdXN0XCI6IFwi4o6xXCIsXG5cdFwicm5taWRcIjogXCLiq65cIixcblx0XCJyb2FuZ1wiOiBcIuKfrVwiLFxuXHRcInJvYXJyXCI6IFwi4oe+XCIsXG5cdFwicm9icmtcIjogXCLin6dcIixcblx0XCJyb3BhclwiOiBcIuKmhlwiLFxuXHRcInJvcGZcIjogXCLwnZWjXCIsXG5cdFwiUm9wZlwiOiBcIuKEnVwiLFxuXHRcInJvcGx1c1wiOiBcIuKorlwiLFxuXHRcInJvdGltZXNcIjogXCLiqLVcIixcblx0XCJSb3VuZEltcGxpZXNcIjogXCLipbBcIixcblx0XCJycGFyXCI6IFwiKVwiLFxuXHRcInJwYXJndFwiOiBcIuKmlFwiLFxuXHRcInJwcG9saW50XCI6IFwi4qiSXCIsXG5cdFwicnJhcnJcIjogXCLih4lcIixcblx0XCJScmlnaHRhcnJvd1wiOiBcIuKHm1wiLFxuXHRcInJzYXF1b1wiOiBcIuKAulwiLFxuXHRcInJzY3JcIjogXCLwnZOHXCIsXG5cdFwiUnNjclwiOiBcIuKEm1wiLFxuXHRcInJzaFwiOiBcIuKGsVwiLFxuXHRcIlJzaFwiOiBcIuKGsVwiLFxuXHRcInJzcWJcIjogXCJdXCIsXG5cdFwicnNxdW9cIjogXCLigJlcIixcblx0XCJyc3F1b3JcIjogXCLigJlcIixcblx0XCJydGhyZWVcIjogXCLii4xcIixcblx0XCJydGltZXNcIjogXCLii4pcIixcblx0XCJydHJpXCI6IFwi4pa5XCIsXG5cdFwicnRyaWVcIjogXCLiirVcIixcblx0XCJydHJpZlwiOiBcIuKWuFwiLFxuXHRcInJ0cmlsdHJpXCI6IFwi4qeOXCIsXG5cdFwiUnVsZURlbGF5ZWRcIjogXCLip7RcIixcblx0XCJydWx1aGFyXCI6IFwi4qWoXCIsXG5cdFwicnhcIjogXCLihJ5cIixcblx0XCJTYWN1dGVcIjogXCLFmlwiLFxuXHRcInNhY3V0ZVwiOiBcIsWbXCIsXG5cdFwic2JxdW9cIjogXCLigJpcIixcblx0XCJzY2FwXCI6IFwi4qq4XCIsXG5cdFwiU2Nhcm9uXCI6IFwixaBcIixcblx0XCJzY2Fyb25cIjogXCLFoVwiLFxuXHRcIlNjXCI6IFwi4qq8XCIsXG5cdFwic2NcIjogXCLiibtcIixcblx0XCJzY2N1ZVwiOiBcIuKJvVwiLFxuXHRcInNjZVwiOiBcIuKqsFwiLFxuXHRcInNjRVwiOiBcIuKqtFwiLFxuXHRcIlNjZWRpbFwiOiBcIsWeXCIsXG5cdFwic2NlZGlsXCI6IFwixZ9cIixcblx0XCJTY2lyY1wiOiBcIsWcXCIsXG5cdFwic2NpcmNcIjogXCLFnVwiLFxuXHRcInNjbmFwXCI6IFwi4qq6XCIsXG5cdFwic2NuRVwiOiBcIuKqtlwiLFxuXHRcInNjbnNpbVwiOiBcIuKLqVwiLFxuXHRcInNjcG9saW50XCI6IFwi4qiTXCIsXG5cdFwic2NzaW1cIjogXCLiib9cIixcblx0XCJTY3lcIjogXCLQoVwiLFxuXHRcInNjeVwiOiBcItGBXCIsXG5cdFwic2RvdGJcIjogXCLiiqFcIixcblx0XCJzZG90XCI6IFwi4ouFXCIsXG5cdFwic2RvdGVcIjogXCLiqaZcIixcblx0XCJzZWFyaGtcIjogXCLipKVcIixcblx0XCJzZWFyclwiOiBcIuKGmFwiLFxuXHRcInNlQXJyXCI6IFwi4oeYXCIsXG5cdFwic2VhcnJvd1wiOiBcIuKGmFwiLFxuXHRcInNlY3RcIjogXCLCp1wiLFxuXHRcInNlbWlcIjogXCI7XCIsXG5cdFwic2Vzd2FyXCI6IFwi4qSpXCIsXG5cdFwic2V0bWludXNcIjogXCLiiJZcIixcblx0XCJzZXRtblwiOiBcIuKIllwiLFxuXHRcInNleHRcIjogXCLinLZcIixcblx0XCJTZnJcIjogXCLwnZSWXCIsXG5cdFwic2ZyXCI6IFwi8J2UsFwiLFxuXHRcInNmcm93blwiOiBcIuKMolwiLFxuXHRcInNoYXJwXCI6IFwi4pmvXCIsXG5cdFwiU0hDSGN5XCI6IFwi0KlcIixcblx0XCJzaGNoY3lcIjogXCLRiVwiLFxuXHRcIlNIY3lcIjogXCLQqFwiLFxuXHRcInNoY3lcIjogXCLRiFwiLFxuXHRcIlNob3J0RG93bkFycm93XCI6IFwi4oaTXCIsXG5cdFwiU2hvcnRMZWZ0QXJyb3dcIjogXCLihpBcIixcblx0XCJzaG9ydG1pZFwiOiBcIuKIo1wiLFxuXHRcInNob3J0cGFyYWxsZWxcIjogXCLiiKVcIixcblx0XCJTaG9ydFJpZ2h0QXJyb3dcIjogXCLihpJcIixcblx0XCJTaG9ydFVwQXJyb3dcIjogXCLihpFcIixcblx0XCJzaHlcIjogXCLCrVwiLFxuXHRcIlNpZ21hXCI6IFwizqNcIixcblx0XCJzaWdtYVwiOiBcIs+DXCIsXG5cdFwic2lnbWFmXCI6IFwiz4JcIixcblx0XCJzaWdtYXZcIjogXCLPglwiLFxuXHRcInNpbVwiOiBcIuKIvFwiLFxuXHRcInNpbWRvdFwiOiBcIuKpqlwiLFxuXHRcInNpbWVcIjogXCLiiYNcIixcblx0XCJzaW1lcVwiOiBcIuKJg1wiLFxuXHRcInNpbWdcIjogXCLiqp5cIixcblx0XCJzaW1nRVwiOiBcIuKqoFwiLFxuXHRcInNpbWxcIjogXCLiqp1cIixcblx0XCJzaW1sRVwiOiBcIuKqn1wiLFxuXHRcInNpbW5lXCI6IFwi4omGXCIsXG5cdFwic2ltcGx1c1wiOiBcIuKopFwiLFxuXHRcInNpbXJhcnJcIjogXCLipbJcIixcblx0XCJzbGFyclwiOiBcIuKGkFwiLFxuXHRcIlNtYWxsQ2lyY2xlXCI6IFwi4oiYXCIsXG5cdFwic21hbGxzZXRtaW51c1wiOiBcIuKIllwiLFxuXHRcInNtYXNocFwiOiBcIuKos1wiLFxuXHRcInNtZXBhcnNsXCI6IFwi4qekXCIsXG5cdFwic21pZFwiOiBcIuKIo1wiLFxuXHRcInNtaWxlXCI6IFwi4oyjXCIsXG5cdFwic210XCI6IFwi4qqqXCIsXG5cdFwic210ZVwiOiBcIuKqrFwiLFxuXHRcInNtdGVzXCI6IFwi4qqs77iAXCIsXG5cdFwiU09GVGN5XCI6IFwi0KxcIixcblx0XCJzb2Z0Y3lcIjogXCLRjFwiLFxuXHRcInNvbGJhclwiOiBcIuKMv1wiLFxuXHRcInNvbGJcIjogXCLip4RcIixcblx0XCJzb2xcIjogXCIvXCIsXG5cdFwiU29wZlwiOiBcIvCdlYpcIixcblx0XCJzb3BmXCI6IFwi8J2VpFwiLFxuXHRcInNwYWRlc1wiOiBcIuKZoFwiLFxuXHRcInNwYWRlc3VpdFwiOiBcIuKZoFwiLFxuXHRcInNwYXJcIjogXCLiiKVcIixcblx0XCJzcWNhcFwiOiBcIuKKk1wiLFxuXHRcInNxY2Fwc1wiOiBcIuKKk++4gFwiLFxuXHRcInNxY3VwXCI6IFwi4oqUXCIsXG5cdFwic3FjdXBzXCI6IFwi4oqU77iAXCIsXG5cdFwiU3FydFwiOiBcIuKImlwiLFxuXHRcInNxc3ViXCI6IFwi4oqPXCIsXG5cdFwic3FzdWJlXCI6IFwi4oqRXCIsXG5cdFwic3FzdWJzZXRcIjogXCLiio9cIixcblx0XCJzcXN1YnNldGVxXCI6IFwi4oqRXCIsXG5cdFwic3FzdXBcIjogXCLiipBcIixcblx0XCJzcXN1cGVcIjogXCLiipJcIixcblx0XCJzcXN1cHNldFwiOiBcIuKKkFwiLFxuXHRcInNxc3Vwc2V0ZXFcIjogXCLiipJcIixcblx0XCJzcXVhcmVcIjogXCLilqFcIixcblx0XCJTcXVhcmVcIjogXCLilqFcIixcblx0XCJTcXVhcmVJbnRlcnNlY3Rpb25cIjogXCLiipNcIixcblx0XCJTcXVhcmVTdWJzZXRcIjogXCLiio9cIixcblx0XCJTcXVhcmVTdWJzZXRFcXVhbFwiOiBcIuKKkVwiLFxuXHRcIlNxdWFyZVN1cGVyc2V0XCI6IFwi4oqQXCIsXG5cdFwiU3F1YXJlU3VwZXJzZXRFcXVhbFwiOiBcIuKKklwiLFxuXHRcIlNxdWFyZVVuaW9uXCI6IFwi4oqUXCIsXG5cdFwic3F1YXJmXCI6IFwi4paqXCIsXG5cdFwic3F1XCI6IFwi4pahXCIsXG5cdFwic3F1ZlwiOiBcIuKWqlwiLFxuXHRcInNyYXJyXCI6IFwi4oaSXCIsXG5cdFwiU3NjclwiOiBcIvCdkq5cIixcblx0XCJzc2NyXCI6IFwi8J2TiFwiLFxuXHRcInNzZXRtblwiOiBcIuKIllwiLFxuXHRcInNzbWlsZVwiOiBcIuKMo1wiLFxuXHRcInNzdGFyZlwiOiBcIuKLhlwiLFxuXHRcIlN0YXJcIjogXCLii4ZcIixcblx0XCJzdGFyXCI6IFwi4piGXCIsXG5cdFwic3RhcmZcIjogXCLimIVcIixcblx0XCJzdHJhaWdodGVwc2lsb25cIjogXCLPtVwiLFxuXHRcInN0cmFpZ2h0cGhpXCI6IFwiz5VcIixcblx0XCJzdHJuc1wiOiBcIsKvXCIsXG5cdFwic3ViXCI6IFwi4oqCXCIsXG5cdFwiU3ViXCI6IFwi4ouQXCIsXG5cdFwic3ViZG90XCI6IFwi4qq9XCIsXG5cdFwic3ViRVwiOiBcIuKrhVwiLFxuXHRcInN1YmVcIjogXCLiioZcIixcblx0XCJzdWJlZG90XCI6IFwi4quDXCIsXG5cdFwic3VibXVsdFwiOiBcIuKrgVwiLFxuXHRcInN1Ym5FXCI6IFwi4quLXCIsXG5cdFwic3VibmVcIjogXCLiiopcIixcblx0XCJzdWJwbHVzXCI6IFwi4qq/XCIsXG5cdFwic3VicmFyclwiOiBcIuKluVwiLFxuXHRcInN1YnNldFwiOiBcIuKKglwiLFxuXHRcIlN1YnNldFwiOiBcIuKLkFwiLFxuXHRcInN1YnNldGVxXCI6IFwi4oqGXCIsXG5cdFwic3Vic2V0ZXFxXCI6IFwi4quFXCIsXG5cdFwiU3Vic2V0RXF1YWxcIjogXCLiioZcIixcblx0XCJzdWJzZXRuZXFcIjogXCLiiopcIixcblx0XCJzdWJzZXRuZXFxXCI6IFwi4quLXCIsXG5cdFwic3Vic2ltXCI6IFwi4quHXCIsXG5cdFwic3Vic3ViXCI6IFwi4quVXCIsXG5cdFwic3Vic3VwXCI6IFwi4quTXCIsXG5cdFwic3VjY2FwcHJveFwiOiBcIuKquFwiLFxuXHRcInN1Y2NcIjogXCLiibtcIixcblx0XCJzdWNjY3VybHllcVwiOiBcIuKJvVwiLFxuXHRcIlN1Y2NlZWRzXCI6IFwi4om7XCIsXG5cdFwiU3VjY2VlZHNFcXVhbFwiOiBcIuKqsFwiLFxuXHRcIlN1Y2NlZWRzU2xhbnRFcXVhbFwiOiBcIuKJvVwiLFxuXHRcIlN1Y2NlZWRzVGlsZGVcIjogXCLiib9cIixcblx0XCJzdWNjZXFcIjogXCLiqrBcIixcblx0XCJzdWNjbmFwcHJveFwiOiBcIuKqulwiLFxuXHRcInN1Y2NuZXFxXCI6IFwi4qq2XCIsXG5cdFwic3VjY25zaW1cIjogXCLii6lcIixcblx0XCJzdWNjc2ltXCI6IFwi4om/XCIsXG5cdFwiU3VjaFRoYXRcIjogXCLiiItcIixcblx0XCJzdW1cIjogXCLiiJFcIixcblx0XCJTdW1cIjogXCLiiJFcIixcblx0XCJzdW5nXCI6IFwi4pmqXCIsXG5cdFwic3VwMVwiOiBcIsK5XCIsXG5cdFwic3VwMlwiOiBcIsKyXCIsXG5cdFwic3VwM1wiOiBcIsKzXCIsXG5cdFwic3VwXCI6IFwi4oqDXCIsXG5cdFwiU3VwXCI6IFwi4ouRXCIsXG5cdFwic3VwZG90XCI6IFwi4qq+XCIsXG5cdFwic3VwZHN1YlwiOiBcIuKrmFwiLFxuXHRcInN1cEVcIjogXCLiq4ZcIixcblx0XCJzdXBlXCI6IFwi4oqHXCIsXG5cdFwic3VwZWRvdFwiOiBcIuKrhFwiLFxuXHRcIlN1cGVyc2V0XCI6IFwi4oqDXCIsXG5cdFwiU3VwZXJzZXRFcXVhbFwiOiBcIuKKh1wiLFxuXHRcInN1cGhzb2xcIjogXCLin4lcIixcblx0XCJzdXBoc3ViXCI6IFwi4quXXCIsXG5cdFwic3VwbGFyclwiOiBcIuKlu1wiLFxuXHRcInN1cG11bHRcIjogXCLiq4JcIixcblx0XCJzdXBuRVwiOiBcIuKrjFwiLFxuXHRcInN1cG5lXCI6IFwi4oqLXCIsXG5cdFwic3VwcGx1c1wiOiBcIuKrgFwiLFxuXHRcInN1cHNldFwiOiBcIuKKg1wiLFxuXHRcIlN1cHNldFwiOiBcIuKLkVwiLFxuXHRcInN1cHNldGVxXCI6IFwi4oqHXCIsXG5cdFwic3Vwc2V0ZXFxXCI6IFwi4quGXCIsXG5cdFwic3Vwc2V0bmVxXCI6IFwi4oqLXCIsXG5cdFwic3Vwc2V0bmVxcVwiOiBcIuKrjFwiLFxuXHRcInN1cHNpbVwiOiBcIuKriFwiLFxuXHRcInN1cHN1YlwiOiBcIuKrlFwiLFxuXHRcInN1cHN1cFwiOiBcIuKrllwiLFxuXHRcInN3YXJoa1wiOiBcIuKkplwiLFxuXHRcInN3YXJyXCI6IFwi4oaZXCIsXG5cdFwic3dBcnJcIjogXCLih5lcIixcblx0XCJzd2Fycm93XCI6IFwi4oaZXCIsXG5cdFwic3dud2FyXCI6IFwi4qSqXCIsXG5cdFwic3psaWdcIjogXCLDn1wiLFxuXHRcIlRhYlwiOiBcIlxcdFwiLFxuXHRcInRhcmdldFwiOiBcIuKMllwiLFxuXHRcIlRhdVwiOiBcIs6kXCIsXG5cdFwidGF1XCI6IFwiz4RcIixcblx0XCJ0YnJrXCI6IFwi4o60XCIsXG5cdFwiVGNhcm9uXCI6IFwixaRcIixcblx0XCJ0Y2Fyb25cIjogXCLFpVwiLFxuXHRcIlRjZWRpbFwiOiBcIsWiXCIsXG5cdFwidGNlZGlsXCI6IFwixaNcIixcblx0XCJUY3lcIjogXCLQolwiLFxuXHRcInRjeVwiOiBcItGCXCIsXG5cdFwidGRvdFwiOiBcIuKDm1wiLFxuXHRcInRlbHJlY1wiOiBcIuKMlVwiLFxuXHRcIlRmclwiOiBcIvCdlJdcIixcblx0XCJ0ZnJcIjogXCLwnZSxXCIsXG5cdFwidGhlcmU0XCI6IFwi4oi0XCIsXG5cdFwidGhlcmVmb3JlXCI6IFwi4oi0XCIsXG5cdFwiVGhlcmVmb3JlXCI6IFwi4oi0XCIsXG5cdFwiVGhldGFcIjogXCLOmFwiLFxuXHRcInRoZXRhXCI6IFwizrhcIixcblx0XCJ0aGV0YXN5bVwiOiBcIs+RXCIsXG5cdFwidGhldGF2XCI6IFwiz5FcIixcblx0XCJ0aGlja2FwcHJveFwiOiBcIuKJiFwiLFxuXHRcInRoaWNrc2ltXCI6IFwi4oi8XCIsXG5cdFwiVGhpY2tTcGFjZVwiOiBcIuKBn+KAilwiLFxuXHRcIlRoaW5TcGFjZVwiOiBcIuKAiVwiLFxuXHRcInRoaW5zcFwiOiBcIuKAiVwiLFxuXHRcInRoa2FwXCI6IFwi4omIXCIsXG5cdFwidGhrc2ltXCI6IFwi4oi8XCIsXG5cdFwiVEhPUk5cIjogXCLDnlwiLFxuXHRcInRob3JuXCI6IFwiw75cIixcblx0XCJ0aWxkZVwiOiBcIsucXCIsXG5cdFwiVGlsZGVcIjogXCLiiLxcIixcblx0XCJUaWxkZUVxdWFsXCI6IFwi4omDXCIsXG5cdFwiVGlsZGVGdWxsRXF1YWxcIjogXCLiiYVcIixcblx0XCJUaWxkZVRpbGRlXCI6IFwi4omIXCIsXG5cdFwidGltZXNiYXJcIjogXCLiqLFcIixcblx0XCJ0aW1lc2JcIjogXCLiiqBcIixcblx0XCJ0aW1lc1wiOiBcIsOXXCIsXG5cdFwidGltZXNkXCI6IFwi4qiwXCIsXG5cdFwidGludFwiOiBcIuKIrVwiLFxuXHRcInRvZWFcIjogXCLipKhcIixcblx0XCJ0b3Bib3RcIjogXCLijLZcIixcblx0XCJ0b3BjaXJcIjogXCLiq7FcIixcblx0XCJ0b3BcIjogXCLiiqRcIixcblx0XCJUb3BmXCI6IFwi8J2Vi1wiLFxuXHRcInRvcGZcIjogXCLwnZWlXCIsXG5cdFwidG9wZm9ya1wiOiBcIuKrmlwiLFxuXHRcInRvc2FcIjogXCLipKlcIixcblx0XCJ0cHJpbWVcIjogXCLigLRcIixcblx0XCJ0cmFkZVwiOiBcIuKEolwiLFxuXHRcIlRSQURFXCI6IFwi4oSiXCIsXG5cdFwidHJpYW5nbGVcIjogXCLilrVcIixcblx0XCJ0cmlhbmdsZWRvd25cIjogXCLilr9cIixcblx0XCJ0cmlhbmdsZWxlZnRcIjogXCLil4NcIixcblx0XCJ0cmlhbmdsZWxlZnRlcVwiOiBcIuKKtFwiLFxuXHRcInRyaWFuZ2xlcVwiOiBcIuKJnFwiLFxuXHRcInRyaWFuZ2xlcmlnaHRcIjogXCLilrlcIixcblx0XCJ0cmlhbmdsZXJpZ2h0ZXFcIjogXCLiirVcIixcblx0XCJ0cmlkb3RcIjogXCLil6xcIixcblx0XCJ0cmllXCI6IFwi4omcXCIsXG5cdFwidHJpbWludXNcIjogXCLiqLpcIixcblx0XCJUcmlwbGVEb3RcIjogXCLig5tcIixcblx0XCJ0cmlwbHVzXCI6IFwi4qi5XCIsXG5cdFwidHJpc2JcIjogXCLip41cIixcblx0XCJ0cml0aW1lXCI6IFwi4qi7XCIsXG5cdFwidHJwZXppdW1cIjogXCLij6JcIixcblx0XCJUc2NyXCI6IFwi8J2Sr1wiLFxuXHRcInRzY3JcIjogXCLwnZOJXCIsXG5cdFwiVFNjeVwiOiBcItCmXCIsXG5cdFwidHNjeVwiOiBcItGGXCIsXG5cdFwiVFNIY3lcIjogXCLQi1wiLFxuXHRcInRzaGN5XCI6IFwi0ZtcIixcblx0XCJUc3Ryb2tcIjogXCLFplwiLFxuXHRcInRzdHJva1wiOiBcIsWnXCIsXG5cdFwidHdpeHRcIjogXCLiiaxcIixcblx0XCJ0d29oZWFkbGVmdGFycm93XCI6IFwi4oaeXCIsXG5cdFwidHdvaGVhZHJpZ2h0YXJyb3dcIjogXCLihqBcIixcblx0XCJVYWN1dGVcIjogXCLDmlwiLFxuXHRcInVhY3V0ZVwiOiBcIsO6XCIsXG5cdFwidWFyclwiOiBcIuKGkVwiLFxuXHRcIlVhcnJcIjogXCLihp9cIixcblx0XCJ1QXJyXCI6IFwi4oeRXCIsXG5cdFwiVWFycm9jaXJcIjogXCLipYlcIixcblx0XCJVYnJjeVwiOiBcItCOXCIsXG5cdFwidWJyY3lcIjogXCLRnlwiLFxuXHRcIlVicmV2ZVwiOiBcIsWsXCIsXG5cdFwidWJyZXZlXCI6IFwixa1cIixcblx0XCJVY2lyY1wiOiBcIsObXCIsXG5cdFwidWNpcmNcIjogXCLDu1wiLFxuXHRcIlVjeVwiOiBcItCjXCIsXG5cdFwidWN5XCI6IFwi0YNcIixcblx0XCJ1ZGFyclwiOiBcIuKHhVwiLFxuXHRcIlVkYmxhY1wiOiBcIsWwXCIsXG5cdFwidWRibGFjXCI6IFwixbFcIixcblx0XCJ1ZGhhclwiOiBcIuKlrlwiLFxuXHRcInVmaXNodFwiOiBcIuKlvlwiLFxuXHRcIlVmclwiOiBcIvCdlJhcIixcblx0XCJ1ZnJcIjogXCLwnZSyXCIsXG5cdFwiVWdyYXZlXCI6IFwiw5lcIixcblx0XCJ1Z3JhdmVcIjogXCLDuVwiLFxuXHRcInVIYXJcIjogXCLipaNcIixcblx0XCJ1aGFybFwiOiBcIuKGv1wiLFxuXHRcInVoYXJyXCI6IFwi4oa+XCIsXG5cdFwidWhibGtcIjogXCLiloBcIixcblx0XCJ1bGNvcm5cIjogXCLijJxcIixcblx0XCJ1bGNvcm5lclwiOiBcIuKMnFwiLFxuXHRcInVsY3JvcFwiOiBcIuKMj1wiLFxuXHRcInVsdHJpXCI6IFwi4pe4XCIsXG5cdFwiVW1hY3JcIjogXCLFqlwiLFxuXHRcInVtYWNyXCI6IFwixatcIixcblx0XCJ1bWxcIjogXCLCqFwiLFxuXHRcIlVuZGVyQmFyXCI6IFwiX1wiLFxuXHRcIlVuZGVyQnJhY2VcIjogXCLij59cIixcblx0XCJVbmRlckJyYWNrZXRcIjogXCLijrVcIixcblx0XCJVbmRlclBhcmVudGhlc2lzXCI6IFwi4o+dXCIsXG5cdFwiVW5pb25cIjogXCLii4NcIixcblx0XCJVbmlvblBsdXNcIjogXCLiio5cIixcblx0XCJVb2dvblwiOiBcIsWyXCIsXG5cdFwidW9nb25cIjogXCLFs1wiLFxuXHRcIlVvcGZcIjogXCLwnZWMXCIsXG5cdFwidW9wZlwiOiBcIvCdlaZcIixcblx0XCJVcEFycm93QmFyXCI6IFwi4qSSXCIsXG5cdFwidXBhcnJvd1wiOiBcIuKGkVwiLFxuXHRcIlVwQXJyb3dcIjogXCLihpFcIixcblx0XCJVcGFycm93XCI6IFwi4oeRXCIsXG5cdFwiVXBBcnJvd0Rvd25BcnJvd1wiOiBcIuKHhVwiLFxuXHRcInVwZG93bmFycm93XCI6IFwi4oaVXCIsXG5cdFwiVXBEb3duQXJyb3dcIjogXCLihpVcIixcblx0XCJVcGRvd25hcnJvd1wiOiBcIuKHlVwiLFxuXHRcIlVwRXF1aWxpYnJpdW1cIjogXCLipa5cIixcblx0XCJ1cGhhcnBvb25sZWZ0XCI6IFwi4oa/XCIsXG5cdFwidXBoYXJwb29ucmlnaHRcIjogXCLihr5cIixcblx0XCJ1cGx1c1wiOiBcIuKKjlwiLFxuXHRcIlVwcGVyTGVmdEFycm93XCI6IFwi4oaWXCIsXG5cdFwiVXBwZXJSaWdodEFycm93XCI6IFwi4oaXXCIsXG5cdFwidXBzaVwiOiBcIs+FXCIsXG5cdFwiVXBzaVwiOiBcIs+SXCIsXG5cdFwidXBzaWhcIjogXCLPklwiLFxuXHRcIlVwc2lsb25cIjogXCLOpVwiLFxuXHRcInVwc2lsb25cIjogXCLPhVwiLFxuXHRcIlVwVGVlQXJyb3dcIjogXCLihqVcIixcblx0XCJVcFRlZVwiOiBcIuKKpVwiLFxuXHRcInVwdXBhcnJvd3NcIjogXCLih4hcIixcblx0XCJ1cmNvcm5cIjogXCLijJ1cIixcblx0XCJ1cmNvcm5lclwiOiBcIuKMnVwiLFxuXHRcInVyY3JvcFwiOiBcIuKMjlwiLFxuXHRcIlVyaW5nXCI6IFwixa5cIixcblx0XCJ1cmluZ1wiOiBcIsWvXCIsXG5cdFwidXJ0cmlcIjogXCLil7lcIixcblx0XCJVc2NyXCI6IFwi8J2SsFwiLFxuXHRcInVzY3JcIjogXCLwnZOKXCIsXG5cdFwidXRkb3RcIjogXCLii7BcIixcblx0XCJVdGlsZGVcIjogXCLFqFwiLFxuXHRcInV0aWxkZVwiOiBcIsWpXCIsXG5cdFwidXRyaVwiOiBcIuKWtVwiLFxuXHRcInV0cmlmXCI6IFwi4pa0XCIsXG5cdFwidXVhcnJcIjogXCLih4hcIixcblx0XCJVdW1sXCI6IFwiw5xcIixcblx0XCJ1dW1sXCI6IFwiw7xcIixcblx0XCJ1d2FuZ2xlXCI6IFwi4qanXCIsXG5cdFwidmFuZ3J0XCI6IFwi4qacXCIsXG5cdFwidmFyZXBzaWxvblwiOiBcIs+1XCIsXG5cdFwidmFya2FwcGFcIjogXCLPsFwiLFxuXHRcInZhcm5vdGhpbmdcIjogXCLiiIVcIixcblx0XCJ2YXJwaGlcIjogXCLPlVwiLFxuXHRcInZhcnBpXCI6IFwiz5ZcIixcblx0XCJ2YXJwcm9wdG9cIjogXCLiiJ1cIixcblx0XCJ2YXJyXCI6IFwi4oaVXCIsXG5cdFwidkFyclwiOiBcIuKHlVwiLFxuXHRcInZhcnJob1wiOiBcIs+xXCIsXG5cdFwidmFyc2lnbWFcIjogXCLPglwiLFxuXHRcInZhcnN1YnNldG5lcVwiOiBcIuKKiu+4gFwiLFxuXHRcInZhcnN1YnNldG5lcXFcIjogXCLiq4vvuIBcIixcblx0XCJ2YXJzdXBzZXRuZXFcIjogXCLiiovvuIBcIixcblx0XCJ2YXJzdXBzZXRuZXFxXCI6IFwi4quM77iAXCIsXG5cdFwidmFydGhldGFcIjogXCLPkVwiLFxuXHRcInZhcnRyaWFuZ2xlbGVmdFwiOiBcIuKKslwiLFxuXHRcInZhcnRyaWFuZ2xlcmlnaHRcIjogXCLiirNcIixcblx0XCJ2QmFyXCI6IFwi4quoXCIsXG5cdFwiVmJhclwiOiBcIuKrq1wiLFxuXHRcInZCYXJ2XCI6IFwi4qupXCIsXG5cdFwiVmN5XCI6IFwi0JJcIixcblx0XCJ2Y3lcIjogXCLQslwiLFxuXHRcInZkYXNoXCI6IFwi4oqiXCIsXG5cdFwidkRhc2hcIjogXCLiiqhcIixcblx0XCJWZGFzaFwiOiBcIuKKqVwiLFxuXHRcIlZEYXNoXCI6IFwi4oqrXCIsXG5cdFwiVmRhc2hsXCI6IFwi4qumXCIsXG5cdFwidmVlYmFyXCI6IFwi4oq7XCIsXG5cdFwidmVlXCI6IFwi4oioXCIsXG5cdFwiVmVlXCI6IFwi4ouBXCIsXG5cdFwidmVlZXFcIjogXCLiiZpcIixcblx0XCJ2ZWxsaXBcIjogXCLii65cIixcblx0XCJ2ZXJiYXJcIjogXCJ8XCIsXG5cdFwiVmVyYmFyXCI6IFwi4oCWXCIsXG5cdFwidmVydFwiOiBcInxcIixcblx0XCJWZXJ0XCI6IFwi4oCWXCIsXG5cdFwiVmVydGljYWxCYXJcIjogXCLiiKNcIixcblx0XCJWZXJ0aWNhbExpbmVcIjogXCJ8XCIsXG5cdFwiVmVydGljYWxTZXBhcmF0b3JcIjogXCLinZhcIixcblx0XCJWZXJ0aWNhbFRpbGRlXCI6IFwi4omAXCIsXG5cdFwiVmVyeVRoaW5TcGFjZVwiOiBcIuKAilwiLFxuXHRcIlZmclwiOiBcIvCdlJlcIixcblx0XCJ2ZnJcIjogXCLwnZSzXCIsXG5cdFwidmx0cmlcIjogXCLiirJcIixcblx0XCJ2bnN1YlwiOiBcIuKKguKDklwiLFxuXHRcInZuc3VwXCI6IFwi4oqD4oOSXCIsXG5cdFwiVm9wZlwiOiBcIvCdlY1cIixcblx0XCJ2b3BmXCI6IFwi8J2Vp1wiLFxuXHRcInZwcm9wXCI6IFwi4oidXCIsXG5cdFwidnJ0cmlcIjogXCLiirNcIixcblx0XCJWc2NyXCI6IFwi8J2SsVwiLFxuXHRcInZzY3JcIjogXCLwnZOLXCIsXG5cdFwidnN1Ym5FXCI6IFwi4quL77iAXCIsXG5cdFwidnN1Ym5lXCI6IFwi4oqK77iAXCIsXG5cdFwidnN1cG5FXCI6IFwi4quM77iAXCIsXG5cdFwidnN1cG5lXCI6IFwi4oqL77iAXCIsXG5cdFwiVnZkYXNoXCI6IFwi4oqqXCIsXG5cdFwidnppZ3phZ1wiOiBcIuKmmlwiLFxuXHRcIldjaXJjXCI6IFwixbRcIixcblx0XCJ3Y2lyY1wiOiBcIsW1XCIsXG5cdFwid2VkYmFyXCI6IFwi4qmfXCIsXG5cdFwid2VkZ2VcIjogXCLiiKdcIixcblx0XCJXZWRnZVwiOiBcIuKLgFwiLFxuXHRcIndlZGdlcVwiOiBcIuKJmVwiLFxuXHRcIndlaWVycFwiOiBcIuKEmFwiLFxuXHRcIldmclwiOiBcIvCdlJpcIixcblx0XCJ3ZnJcIjogXCLwnZS0XCIsXG5cdFwiV29wZlwiOiBcIvCdlY5cIixcblx0XCJ3b3BmXCI6IFwi8J2VqFwiLFxuXHRcIndwXCI6IFwi4oSYXCIsXG5cdFwid3JcIjogXCLiiYBcIixcblx0XCJ3cmVhdGhcIjogXCLiiYBcIixcblx0XCJXc2NyXCI6IFwi8J2SslwiLFxuXHRcIndzY3JcIjogXCLwnZOMXCIsXG5cdFwieGNhcFwiOiBcIuKLglwiLFxuXHRcInhjaXJjXCI6IFwi4pevXCIsXG5cdFwieGN1cFwiOiBcIuKLg1wiLFxuXHRcInhkdHJpXCI6IFwi4pa9XCIsXG5cdFwiWGZyXCI6IFwi8J2Um1wiLFxuXHRcInhmclwiOiBcIvCdlLVcIixcblx0XCJ4aGFyclwiOiBcIuKft1wiLFxuXHRcInhoQXJyXCI6IFwi4p+6XCIsXG5cdFwiWGlcIjogXCLOnlwiLFxuXHRcInhpXCI6IFwizr5cIixcblx0XCJ4bGFyclwiOiBcIuKftVwiLFxuXHRcInhsQXJyXCI6IFwi4p+4XCIsXG5cdFwieG1hcFwiOiBcIuKfvFwiLFxuXHRcInhuaXNcIjogXCLii7tcIixcblx0XCJ4b2RvdFwiOiBcIuKogFwiLFxuXHRcIlhvcGZcIjogXCLwnZWPXCIsXG5cdFwieG9wZlwiOiBcIvCdlalcIixcblx0XCJ4b3BsdXNcIjogXCLiqIFcIixcblx0XCJ4b3RpbWVcIjogXCLiqIJcIixcblx0XCJ4cmFyclwiOiBcIuKftlwiLFxuXHRcInhyQXJyXCI6IFwi4p+5XCIsXG5cdFwiWHNjclwiOiBcIvCdkrNcIixcblx0XCJ4c2NyXCI6IFwi8J2TjVwiLFxuXHRcInhzcWN1cFwiOiBcIuKohlwiLFxuXHRcInh1cGx1c1wiOiBcIuKohFwiLFxuXHRcInh1dHJpXCI6IFwi4pazXCIsXG5cdFwieHZlZVwiOiBcIuKLgVwiLFxuXHRcInh3ZWRnZVwiOiBcIuKLgFwiLFxuXHRcIllhY3V0ZVwiOiBcIsOdXCIsXG5cdFwieWFjdXRlXCI6IFwiw71cIixcblx0XCJZQWN5XCI6IFwi0K9cIixcblx0XCJ5YWN5XCI6IFwi0Y9cIixcblx0XCJZY2lyY1wiOiBcIsW2XCIsXG5cdFwieWNpcmNcIjogXCLFt1wiLFxuXHRcIlljeVwiOiBcItCrXCIsXG5cdFwieWN5XCI6IFwi0YtcIixcblx0XCJ5ZW5cIjogXCLCpVwiLFxuXHRcIllmclwiOiBcIvCdlJxcIixcblx0XCJ5ZnJcIjogXCLwnZS2XCIsXG5cdFwiWUljeVwiOiBcItCHXCIsXG5cdFwieWljeVwiOiBcItGXXCIsXG5cdFwiWW9wZlwiOiBcIvCdlZBcIixcblx0XCJ5b3BmXCI6IFwi8J2VqlwiLFxuXHRcIllzY3JcIjogXCLwnZK0XCIsXG5cdFwieXNjclwiOiBcIvCdk45cIixcblx0XCJZVWN5XCI6IFwi0K5cIixcblx0XCJ5dWN5XCI6IFwi0Y5cIixcblx0XCJ5dW1sXCI6IFwiw79cIixcblx0XCJZdW1sXCI6IFwixbhcIixcblx0XCJaYWN1dGVcIjogXCLFuVwiLFxuXHRcInphY3V0ZVwiOiBcIsW6XCIsXG5cdFwiWmNhcm9uXCI6IFwixb1cIixcblx0XCJ6Y2Fyb25cIjogXCLFvlwiLFxuXHRcIlpjeVwiOiBcItCXXCIsXG5cdFwiemN5XCI6IFwi0LdcIixcblx0XCJaZG90XCI6IFwixbtcIixcblx0XCJ6ZG90XCI6IFwixbxcIixcblx0XCJ6ZWV0cmZcIjogXCLihKhcIixcblx0XCJaZXJvV2lkdGhTcGFjZVwiOiBcIuKAi1wiLFxuXHRcIlpldGFcIjogXCLOllwiLFxuXHRcInpldGFcIjogXCLOtlwiLFxuXHRcInpmclwiOiBcIvCdlLdcIixcblx0XCJaZnJcIjogXCLihKhcIixcblx0XCJaSGN5XCI6IFwi0JZcIixcblx0XCJ6aGN5XCI6IFwi0LZcIixcblx0XCJ6aWdyYXJyXCI6IFwi4oedXCIsXG5cdFwiem9wZlwiOiBcIvCdlatcIixcblx0XCJab3BmXCI6IFwi4oSkXCIsXG5cdFwiWnNjclwiOiBcIvCdkrVcIixcblx0XCJ6c2NyXCI6IFwi8J2Tj1wiLFxuXHRcInp3alwiOiBcIuKAjVwiLFxuXHRcInp3bmpcIjogXCLigIxcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS9ib2t1L3dvcmsvbXR3dGttYW4uZ2l0aHViLmlvL2Jsb2dfbWFuYWdlci9ibG9nX21hbmFnZXIvc3RhdGljcy9qcy9+L2VudGl0aWVzL21hcHMvZW50aXRpZXMuanNvblxuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEtMSEuL3N0eWxlcy5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4vc3R5bGVzLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHlsZXMuY3NzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBDZWxsIGZyb20gJy4vY2VsbC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0OiB2bm9kZSA9PiB7XG4gICAgdm5vZGUuc3RhdGUubW9kZWwgPSB2bm9kZS5hdHRycy5tb2RlbDtcbiAgICB2bm9kZS5zdGF0ZS5vbmNoYW5nZSA9IHYgPT4ge1xuICAgICAgdm5vZGUuc3RhdGUubW9kZWwuZGF0YS5zbHVnID0gdjtcbiAgICB9O1xuICB9LFxuICB2aWV3OiB2bm9kZSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSA8bGFiZWw+XG4gICAgICBVUkxcbiAgICAgIDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzc05hbWU9e3N0eWxlcy5zbHVnfVxuICAgICAgICBvbmNoYW5nZT17bS53aXRoQXR0cigndmFsdWUnLCB2bm9kZS5zdGF0ZS5vbmNoYW5nZSl9XG4gICAgICAgIHZhbHVlPXt2bm9kZS5zdGF0ZS5tb2RlbC5kYXRhLnNsdWd9XG4gICAgICAvPlxuICAgIDwvbGFiZWw+XG4gICAgcmV0dXJuIDxDZWxsIHNwYW49ezEyfSBpbm5lcj17aW5uZXJ9IC8+XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbGlicy9jb21wb25lbnRzL3NsdWcuanMiXSwic291cmNlUm9vdCI6IiJ9