title: mithriljsのコードを読む(2)
slug: reading-mithriljs-2
utime: 1472042534
date: 2016/08/24 21:42:14
tags:
  - javascript
  - mithril
publish: true
body: |-
  さて、前回は`m.mount`の内容を見たところ、描画についてはわからなかった。

  `endComputation`内で呼んでいる`m.redraw`の正体を暴こう。

  [ここ](https://github.com/lhorie/mithril.js/blob/0159cd667ad85cd82d92fcb31a33f75be6539f6d/mithril.js#L1522)
  ```javascript
  m.redraw = function (force) {
    if (redrawing) return
    redrawing = true
    if (force) forcing = true
    try {
      // lastRedrawId is a positive number if a second redraw is requested
      // before the next animation frame
      // lastRedrawId is null if it's the first redraw and not an event
      // handler
      // 超意訳: lastRedrawIdはフレームの更新が必要な時に正の数値を持つ。
      if (lastRedrawId && !force) {
        // when setTimeout: only reschedule redraw if time between now
        // and previous redraw is bigger than a frame, otherwise keep
        // currently scheduled timeout
        // when rAF: always reschedule redraw
        // 超意訳: フレームの更新時間が規定を超えていれば更新する
        if ($requestAnimationFrame === global.requestAnimationFrame ||
            new Date() - lastRedrawCallTime > FRAME_BUDGET) {
          if (lastRedrawId > 0) $cancelAnimationFrame(lastRedrawId)
          lastRedrawId = $requestAnimationFrame(redraw, FRAME_BUDGET)
        }
      } else {
        redraw()
        lastRedrawId = $requestAnimationFrame(function () {
          lastRedrawId = null
        }, FRAME_BUDGET)
      }
    } finally {
      redrawing = forcing = false
    }
  }
  ```
  ここではフレームの更新有無を判定している。再描画処理の本体は`redraw`という内部関数のようだ。

  [ここ](https://github.com/lhorie/mithril.js/blob/0159cd667ad85cd82d92fcb31a33f75be6539f6d/mithril.js#L1554)
  ```javascript
  function redraw() {
    if (computePreRedrawHook) {
      computePreRedrawHook()
      computePreRedrawHook = null
    }
    forEach(roots, function (root, i) {
      var component = components[i]
      if (controllers[i]) {
        var args = [controllers[i]]
        m.render(root,
          component.view ? component.view(controllers[i], args) : "")
      }
    })
    // after rendering within a routed context, we need to scroll back to
    // the top, and fetch the document title for history.pushState
    // 訳: routeされているコンテキスト(うまく訳せない)内での描画後、ドキュメントのトップにスクロールする必要がある。
    //     後history.pushStateするためのドキュメントのタイトルを取得する
    if (computePostRedrawHook) {
      computePostRedrawHook()
      computePostRedrawHook = null
    }
    lastRedrawId = null
    lastRedrawCallTime = new Date()
    m.redraw.strategy("diff")
  }
  ```
  溜め込まれた`roots`のviewを`m.render`に渡している。いよいよ核心に迫ってきた感出てきた。

  `computePreRedrawHook`と`computePostRedrawHook`は訳に書いてある処理をやっているだけ。描画が終われば`m.redraw.strategy`がdiffに更新されて、差分だけの更新になるわけだ。

  `m.render`を見てみよう。

  [ここ](https://github.com/lhorie/mithril.js/blob/0159cd667ad85cd82d92fcb31a33f75be6539f6d/mithril.js#L1316)
  ```javascript
  m.render = function (root, cell, forceRecreation) {
    if (!root) {
      throw new Error("Ensure the DOM element being passed to " +
        "m.route/m.mount/m.render is not undefined.")
    }
    var configs = []
    var id = getCellCacheKey(root)
    var isDocumentRoot = root === $document
    var node

    if (isDocumentRoot || root === $document.documentElement) {
      node = documentNode
    } else {
      node = root
    }

    if (isDocumentRoot && cell.tag !== "html") {
      cell = {tag: "html", attrs: {}, children: cell}
    }

    if (cellCache[id] === undefined) clear(node.childNodes)
    if (forceRecreation === true) reset(root)

    cellCache[id] = build(
      node,
      null,
      undefined,
      undefined,
      cell,
      cellCache[id],
      false,
      0,
      null,
      undefined,
      configs)

    forEach(configs, function (config) { config() })
  }
  ```

  mithrilでは仮想DOMをcellと呼んでいるようで、`getCellCacheKey`はキャッシュされているrootの仮想DOMのidを取得している。

  で、nodeはまさにDOMのノードの事(まさに本当の意味でのDOMオブジェクト)で、キャッシュされていないDOMの場合、`clear`を呼び出している。

  ```javascript
  function clear(nodes, cached) {
    for (var i = nodes.length - 1; i > -1; i--) {
      if (nodes[i] && nodes[i].parentNode) {
        try {
          nodes[i].parentNode.removeChild(nodes[i])
        } catch (e) {
          /* eslint-disable max-len */
          // ignore if this fails due to order of events (see
          // http://stackoverflow.com/questions/21926083/failed-to-execute-removechild-on-node)
          /* eslint-enable max-len */
        }
        cached = [].concat(cached)
        if (cached[i]) unload(cached[i])
      }
    }
    // release memory if nodes is an array. This check should fail if nodes
    // is a NodeList (see loop above)
    if (nodes.length) {
      nodes.length = 0
    }
  }
  ```

  `clear`は一番後ろの子ノードを親から削除している。ループ処理の対象の長さを変えてしまう倫理観は別の問題として、要するにこれは子ノードを一掃するだけの関数だ。

  `m.render`に戻ろう。

  ようやくたどり着いた`build`がDOM作成の本体だ。

  これがまたしんどそうなので次回
