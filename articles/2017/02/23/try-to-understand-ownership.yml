title: Rust の所有権を理解する
slug: try-to-understand-ownership
utime: 1487856435
date: 2017/02/23 22:27:15
tags:
  - rust
publish: true
body: |-
  [Rustの公式ドキュメント](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/ownership.html)をじっくり咀嚼して、Rustコードを読み書きするしかないけどまずは概念をある程度理解していないと難しいので、できるだけ仲良くなろう。

  そのためにも静的型付けのコンパイル言語という未経験なパラダイムということもあるので語学のためにも一言一句レベルで馬鹿丁寧にドキュメントを読み砕く。

  特に、所有権、借用、参照は必ず理解しておきたいのでここでみておく。

  # 所有権
  > Rustでは 変数束縛 はある特性を持ちます。それは、束縛されているものの「所有権を持つ」ということです。 これは束縛がスコープから外れるとき、Rustは束縛されているリソースを解放するだろうということを意味します。

  とある。これはつまりこういうことだ。

  ```rust
  {
    let hoge = "var";  // 束縛
    println!("{}", hoge);
  }
  // スコープから外れたのでリソースを解放している。
  // そのため、hoge を参照しようとするとエラーが発生。
  println!("{}", hoge);
  // error[E0425]: unresolved name `hoge`
  //  --> src/main.rs:6:20
  //    |
  //  6 |     println!("{}", hoge);
  //    |                    ^^^^ unresolved name
  // error: aborting due to previous error
  ```

  言い換えると、`letを用いた変数束縛は、束縛されたスコープ内でのみ生存可能なリソースの所有権を持つ`という特性を持つと言えそうだ。

  # ムーブセマンティクス

  > しかし、ここではもっと微妙なことがあります。それは、Rustは与えられたリソースに対する束縛が 1つだけ あるということを保証するということです。

  ここではリソースに対する束縛、つまり所有権が1つだけであることを保証するRustについて微妙だと言っている。そして以下のような例が挙げられている。

  ```rust
  let v = vec![1, 2, 3];
  let v2 = v;
  println!("{}", v[0]);
  // error[E0382]: use of moved value: `v`
  //  --> src/main.rs:4:20
  //    |
  //  3 |     let v2 = v;
  //    |         -- value moved here
  //  4 |     println!("{}", v[0]);
  //    |                    ^ value used here after move
  //    |
  //    = note: move occurs because `v` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
  // error: aborting due to previous error
  ```
  ここで発生したエラーの内容はムーブされた変数`v`を使うなということである。

  > 所有権を何か別のものに転送するとき、参照するものを「ムーブした」と言います。

  これは別に微妙でもなんでもなくて、リソースを所有できるのは常に唯一なんらかのオブジェクトであることがわかる。だから`v`が所有していたリソースの`v2`への転送(ムーブ)と表現しているわけだ。

  この動作の詳細についての解説がされている。

  > ベクタオブジェクトは スタック に保存され、 ヒープ に保存された内容（ [1, 2, 3] ）へのポインタを含みます。v を v2 にムーブするとき、それは v2 のためにそのポインタのコピーを作ります。 それは、ヒープ上のベクタの内容へのポインタが2つあることを意味します。

  とのことで、確かにこれで`v`と`v2`からデータ競合が起きる可能性があるためRustがそれを排除するのは自然だ。それよりも重要なのはムーブにはポインタのコピーを伴うということだ。これは`v`が所有するリソースが保存されているアドレスと異なるアドレスに`v2`のオブジェクトが格納され、それに伴ってポインタのコピーが発生するということだろう。

  だとしたらムーブというのは厳密には転送ではなくてコピーということなのではないだろうか。これはコンパイラの実装を見て理解できるのかどうかも怪しいがなんとも言えない。

  # Copy型
  `Copy`とは
  > 所有権が他の束縛に転送されるとき、元の束縛を使うことができないということを証明しました。 しかし、この挙動を変更する トレイト があります。

  と言っているトレイトである。上のコード例でも`Copy`トレイトが実装されていない`Vec<i32>`型の`v`のムーブだったため`v2`にムーブした後に`v`を使うことができずにエラーが出ていた。つまり`Copy`が実装されている型であれば万事解決というわけだ。

  ```rust
  let v = 1;
  let v2 = v;
  println!("{}", v);
  ```

  これは実際成功する。なぜなら`i32`は`Copy`を実装しているからだ。でもムーブが発生しているし、データの競合は起きるのでは？という疑問がある。それについては

  > これはちょうどムーブと同じように、 v を v2 に割り当てるとき、データのコピーが作られるということを意味します。 しかし、ムーブと違って後でまだ v を使うことができます。 これは i32 がどこか別の場所へのポインタを持たず、コピーが完全コピーだからです。

  ということらしい。`Copy`の実装がされていればムーブは実質的に完全コピー、見かけは同じでもメモリ上は全く別物のリソースとなるため所有権は完全に独立している。そのためRustのルールから逸脱していないわけだ。

  > 全てのプリミティブ型は Copy トレイトを実装しているので、推測どおりそれらの所有権は「所有権ルール」に従ってはムーブしません。

  とある。`「所有権ルール」に従っては`という表現は何か行間がありそうだが、単純にコピーをしていると読み替えても問題はなさそうだ。なぜなら上で推察した通り、それは1つのリソースが複数所有されているわけではないからだ。

  # 所有権を越えて
  関数への実引数として束縛した変数を渡すとムーブが起きる。そのため、関数の呼び出し元は関数がその所有権を返すようにしてもらわねばならない。

  ```rust
  fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // `Copy`を実装しない`Vec`であるため`v`についてはムーブが起きる　
    // そのため、持ち主に対して所有権を返す必要がある
    (v1, v2, 42)
  }

  let v1 = vec![1, 2, 3];
  let v2 = vec![1, 2, 3];

  let (v1, v2, n) = foo(v1, v2);
  ```

  これはなんとも手間だ。しかしこれはRustがもともと提供する借用という機能を使うことで簡単に解決できる。

  # 借用
  借用を用いたコードはこのようになる

  ```rust
  fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> Vec<i32> {
    42
  }

  let v1 = vec![1, 2, 3];
  let v2 = vec![1, 2, 3];

  let n = foo(&v1, &v2);
  // コンパイルが通る
  println!("{}, {}", v1[0], v2[0]);
  ```

  > 引数として Vec<i32> を使う代わりに、参照、つまり &Vec<i32> を使います。 そして、 v1 と v2 を直接渡す代わりに、 &v1 と &v2 を渡します。

  `&Vec<i32`を「参照」であるといい、`&v1`とすることで`v1`を直接渡さなくて済むという。つまり参照を渡すと所有権の転送であるムーブは起きないということだろう。実際にこう解説されている。

  > &T 型は「参照」と呼ばれ、それは、リソースを所有するのではなく、所有権を借用します。

  参照をムーブが起きうる箇所で渡すことを所有権の借用という。

  > 何かを借用した束縛はそれがスコープから外れるときにリソースを割当解除しません。 これは foo() の呼出しの後に元の束縛を再び使うことができることを意味します。

  所有権の項で見た通り、束縛は本来「所有権を持つ」ことを言うが、その所有権が借用だった場合はリソースが解放されずに済む。当然のことだがとても大切だ。

  > 参照は束縛とちょうど同じようにイミュータブルです。 これは foo() の中ではベクタは全く変更できないことを意味します。

  これは安全にリソースを扱うRustの心意気という感じだが、普通に`&T`はイミュータブルなものとして扱われる。

  ここまでの事実を整理すると借用とは

  - `&T`の形式で表すリソースの参照を使う
  - 所有権のムーブを回避し、束縛のスコープが終わってもリソースの解放をしない
  - 特に指定がない限りはイミュータブル

  ということが明らかになった。

  # &mut参照
  ミュータブルな束縛があるように、参照にもミュータブルなものがある。
  > 参照には2つ目の種類、 &mut T があります。 「ミュータブルな参照」によって借用しているリソースを変更することができるようになります。

  ```rust
  let mut x = 5;
  {
    let y = &mut x;
    *y += 1;
  }
  println!("{}", x);
  ```

  > y を x へのミュータブルな参照にして、それから y の指示先に1を足します。 x も mut とマークしなければならないことに気付くでしょう。 そうしないと、イミュータブルな値へのミュータブルな借用ということになってしまい、使うことができなくなってしまいます。

  これは今まで得た知識で理解できることだ。ミュータブルな参照を借用した束縛は当然値を変更できる。

  >   アスタリスク（ * ）を y の前に追加して、それを *y にしたことにも気付くでしょう。これは、 y が &mut 参照だからです。

  アスタリスクを追加する理由として`y`が&mut参照であることが述べられている。値を変更するということはその実体にアクセスして書き換えねばならない。参照の内容にアクセするにはアスタリスクを使用する必要があるということだ。

  > それ以外は、 &mut 参照は普通の参照と全く同じです。 しかし、2つの間には、そしてそれらがどのように相互作用するかには大きな違いが あります 。前の例で何かが怪しいと思ったかもしれません。なぜなら、 { と } を使って追加のスコープを必要とするからです。 もしそれらを削除すれば、次のようなエラーが出ます。

  この理由として借用についてのルールが挙げられている。

  - 借用は全て所有者のスコープより長く存続してはいけない
  - 借用は`リソースに対する1つ以上の参照(&T)`または`ただ1つのミュータブルな参照(&mut T)`のどちらかを持つことがありうるが、両方同時に持つことはない

  1つ目の借用がスコープが終わってもなお存在してしまった場合、本来の所有者と借用しているものが同スコープに並存してしまうことになる。これはRust的にはおかしいことだ。

  2つ目はこれもリソースに対して所有権が1つしかあり得ないこととほぼ同じ制約だろう。

  いずれにせよ、Rustはデータ競合を排除している。

  # スコープの考え方
  ドキュメントでは借用のルールを踏まえてスコープの考え方に立ち返っている。

  このコードはエラーを出す。
  ```rust
  let mut x = 5;
  // x をミュータブルな借用をしている。
  let y = &mut x;

  // x と同じスコープで借用しているリソースを更新
  *y += 1;

  // 2つ目のルールに違反。また、このエラーは所有者のイミュータブルな参照をしようとしているため発生している。
  println!("{}", x);
  // error: cannot borrow `x` as immutable because it is also borrowed as mutable
  //     println!("{}", x);
  //                    ^
  ```

  > 必要なものは、 println! を呼び出し、イミュータブルな借用を作ろうとする 前に 終わるミュータブルな借用です。 Rustでは借用はその有効なスコープと結び付けられます。 そしてスコープはこのように見えます。

  ```rust
  let mut x = 5;

  let y = &mut x;    // -+ xの&mut借用がここから始まる
                     //  |
  *y += 1;           //  |
                     //  |
  println!("{}", x); // -+ - ここでxを借用しようとする
                     // -+ xの&mut借用がここで終わる
  ```

  `pintln!`で`x`を渡すのはムーブが起きるのではないのかという疑問は起きつつもこれはどうやら借用であるらしい。それによって起きるルール違反でコンパイルエラーが出るというわけだ。

  ここからわかることは借用をする場合は所有者とのスコープの衝突を避けることを知っておかなければならない。

  # 借用が回避する問題
  > なぜこのような厳格なルールがあるのでしょうか。 そう、前述したように、それらのルールはデータ競合を回避します。

  借用の存在意義はデータ競合の回避だと言っている。例えば

  ## イテレータの無効
  > 一例は「イテレータの無効」です。それは繰返しを行っているコレクションを変更しようとするときに起こります。 Rustの借用チェッカはこれの発生を回避します。

  ```rust
  let mut v = vec![1, 2, 3];

  for i in &v {
      println!("{}", i);
  }
  ```

  `Vec<i32>`のミュータブルな束縛である`v`をイミュータブルな借用でイテレートしている。この借用は`for`のスコープのみ有効である。

  ```rust
  let mut v = vec![1, 2, 3];

  for i in &v {
      println!("{}", i);
          v.push(34);
  }
  //  error: cannot borrow `v` as mutable because it is also borrowed as immutable
  //     v.push(34);
  //     ^
  // note: previous borrow of `v` occurs here; the immutable borrow prevents
  // subsequent moves or mutable borrows of `v` until the borrow ends
  // for i in &v {
  //           ^
  // note: previous borrow ends here
  // for i in &v {
  //     println!(“{}”, i);
  //     v.push(34);
  // }
  // ^
  ```

  ミュータブルな束縛であっても借用の仕方によって不意な変更を避けることができることがわかった。　

  ## 解放後の使用
  > 参照はそれらの指示するリソースよりも長く生存することはできません。 Rustはこれが真であることを保証するために、参照のスコープをチェックするでしょう。

  これも前述のルール通りだ。

  ```rust
  let y: &i32;
  {
      let x = 5;
      y = &x;
  }

  println!("{}", y);
  // error: `x` does not live long enough
  //     y = &x;
  //          ^
  // note: reference must be valid for the block suffix following statement 0 at
  // 2:16...
  // let y: &i32;
  // {
  //     let x = 5;
  //     y = &x;
  // }
  //
  // note: ...but borrowed value is only valid for the block suffix following
  // statement 0 at 4:18
  //     let x = 5;
  //     y = &x;
  // }
  ```

  これは少し分かりづらい。まず、外側のスコープで`i32`の参照を束縛するために`y`を宣言した。内側のスコープでは`i32`である5を`x`に束縛し、その参照を`y`に束縛しようとした。コンパイラはそこでエラーを出している。
  なぜなら、内側のスコープを抜けた瞬間に`x`のリソースは解放されてメモリ上から存在をなくしているため、存在しない`x`の参照を持つ`y`が外側のスコープで生きているからである。

  > 言い換えると、 y は x が存在するスコープの中でだけ有効だということです。 x がなくなるとすぐに、それを指示することは不正になります。 そのように、エラーは借用が「十分長く生存していない」ことを示します。なぜなら、それが正しい期間有効ではないからです。

  これはすごく安全という印象を受ける。

  また

  > 参照がそれの参照する変数より 前に 宣言されたとき、同じ問題が起こります。 これは同じスコープにあるリソースはそれらの宣言された順番と逆に解放されるからです。

  ```rust
  let y: &i32;
  let x = 5;
  y = &x;

  println!("{}", y);
  // error: `x` does not live long enough
  // y = &x;
  //      ^
  // note: reference must be valid for the block suffix following statement 0 at
  // 2:16...
  //     let y: &i32;
  //     let x = 5;
  //     y = &x;
  //
  //     println!("{}", y);
  // }
  //
  // note: ...but borrowed value is only valid for the block suffix following
  // statement 1 at 3:14
  //     let x = 5;
  //     y = &x;
  //
  //     println!("{}", y);
  // }
  ```

  参照(`&x`)がそれの参照する変数(`y`)と読み替えられる。つまり`x`より先に宣言した`y`は`x`より寿命が長いためにエラーが出ているということだ。

  > 前の例では、 y は x より前に宣言されています。それは、 y が x より長く生存することを意味し、それは許されません。

  そう、自分より寿命の短い変数の参照はどうあがいても取得できないためである。


  なんかあとライフタイムが続くぽいが長くなったので分割。
