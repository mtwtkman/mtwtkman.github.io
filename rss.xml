<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>mtwtkman.github.io</title><link>http://mtwtkman.github.io</link><description>mtwtkman's site.</description><lastBuildDate>Sun, 20 Mar 2016 06:07:55 GMT</lastBuildDate><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>V8で最適化されないjavascript</title><link>http://mtwtkman.github.io/#/blog/article/2016/03/19/v8-optimization</link><description>[mithril](https://github.com/lhorie/mithril.js)のコードを読んでいて`for`文で`argumets`の要素をぐるぐる回しながらインデクスアクセスをして配列にデータを詰め込んでる処理が気持ち悪かったので`map`にしてプルリクしたところ、
パフォーマンスを理由にリジェクトされました。

で、そのプルリクでもらった返答にV8の最適化についてのリンクを併記してもらっていたので読むことにしました。

ちなみに[プルリクで修正した内容](https://github.com/lhorie/mithril.js/pull/993/commits/f384054947681d10696fcfeb2fab71f2a40dde1d)はクソ単純で
Arraylikeな`arguments`を`slice`で回すというものです。

[Optimization killersのリンク](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers)

# Unsupported syntax
2016/3/19現在、V8で最適化できない構文がいくつかある。

- Generator functions
- Functions that contain a for-of statement
- Functions that contain a try-catch statement
- Functions that contain a try-finally statement
- Functions that contain a compound let assignment
- Functions that contain a compound const assignment
- Functions that contain object literals that contain __proto__, or get or set declarations.

`try`文ダメってキツそう。あと`for-of`が最適化されないのもつらい。まあ`for-of`が最適化されるならそっち使うよな。

generatorもダメとは…こう見ると単純にES2015以降に対応しきれていないだけという感じか。

あとは↓の場合もダメっぽい

- Functions that contain a debugger statement
- Functions that call literally eval()
- Functions that contain a with statement

VBAみたいで悔しい思いをしそうな`with`を使うことはない気がするけど、`eval`や`with`を最適化ができない理由はスコープの判定ができないからとのことらしい。(曖昧)

で、プロダクトコードで例外処理を避けるわけにもいかんということでワークアラウンドなコード例が書いてあったのでそのまま引用。

```javascript
var errorObject = {value: null};
function tryCatch(fn, ctx, args) {
    try {
        return fn.apply(ctx, args);
    }
    catch(e) {
        errorObject.value = e;
        return errorObject;
    }
}

var result = tryCatch(mightThrow, void 0, [1,2,3]);
//Unambiguously tells whether the call threw
if(result === errorObject) {
    var error = errorObject.value;
}
else {
    //result is the returned value
}
```

エラーハンドリングは独立した最小限の関数に切り出すのが良いらしい。
そうすれば最適化されない範囲が最小限になるということだ。


# Managing `arguments`
`arguments`は最適化を阻害する多数の原因になりうるやつだそうだ。

## 1. sloppyモード(=strictモードじゃないやつ)で`arguments`を評価しながら定義済みの引数に再代入する場合
何言ってんだ？？？？例を見てみよう

```javascript
function defaultArgsReassign(a, b) {
  if (arguments.length &lt; 2) b = 5;
}
```

とにかくこれがダメということらしい。じゃあどうしたらいいのかというと引数の値を新しい変数に保存しましょうとのこと

```javascript
function reAssignParam(a, b_) {
  var b = b_;
  //unlike b_, b can safely be reassigned
  if (arguments.length &lt; 2) b = 5;
}
```

ただし、今回の場合だとただ引数が与えられているのかをチェックしているだけなので下記のように書くのがいいっぽい。

```javascript
function reAssignParam(a, b) {
  if (b === void 0) b = 5;
}
```

まあでもおとなしく端からstrictモードにしておけば考える必要のない問題ですね。

## 2. `arguments`漏れ
```javascript
function leaksArguments1() {
  return arguments;
}

function leaksArguments2() {
  var args = [].slice.call(arguments);
}

function leaksArguments3() {
  var a = arguments;
  return function() {
      return a;
  };
}
```

今回のプルリクで指摘されたのが`leaksArguments2`と同じケースだった。`arguments`はどこにも漏らしたり渡したりしてはいけないらしい。

つまり`slice.call`や`map`の引数に渡すのはご法度いうわけだ。対処法は以下(mithrilの`m()`でまさに下の実装になっていた)

```javascript
function doesntLeakArguments() {
                  //.length is just an integer, this doesn't leak
                  //the arguments object itself
  var args = new Array(arguments.length);
  for(var i = 0; i &lt; args.length; ++i) {
              //i is always valid index in the arguments object
      args[i] = arguments[i];
  }
  return args;
}
```

## 3. `arguments`への代入
こんなことする必要性がないと思うけど、これも例によってsloppyモードの時だけ。

```javascript
function assignToArguments() {
  arguments = 3;
  return arguments;
}
```

## 結局のところ`arguments`はどうやったら安全に扱えるのか
以下を厳守すればok

- `arguments.length`使おう。
- 適切なインデクスアクセスで`arguments`の要素を取得する。で、そいつは外に出さない。
- `argumets`を**絶対に**直接扱わない。`.length`やインデクスアクセスは`arguments`そのものじゃないからおk。
- **厳密に言えば**`fn.apply(y, arguments)`はおk。他はいかなる場合もダメ。例えば`.slice`とか。 `Function#apply`だけが特別。
- `Function#apply`を使って関数のプロパティを追加するときと`Function#bind`で隠れクラスができてしまうような場合に気をつける。


# Switch-case
`switch`文は`case`の節が128を超えると最適化がされなくなる。なので`if-else`使おう。

# For-in
幾つかの場合で最適化を妨げることになる。

## 1. キーがローカル変数でない場合
```javascript
function nonLocalKey1() {
  var obj = {}
  for(var key in obj);
  return function() {
      return key;
  };
}

var key;
function nonLocalKey2() {
  var obj = {}
  for(key in obj);
}
```

そもそもオブジェクトのキーは上のスコープから参照できない。純粋にローカルスコープの変数でないとダメ。

## 2. イテレートできるようなオブジェクトは'simple enumerable'ではない
### `hash table mode`(あるいは`normalized objects`, `dictionary mode`)のオブジェクトは'simple enumerable'ではない。

```javascript
function hashTableIteration() {
  var hashTable = {"-": 3};
  for(var key in hashTable);
}
```

これわかりづらいのだけど、コンストラクタ外で動的に`hash table mode`のオブジェクトを作るのがよくないらしい。

オブジェクトが`hash table mode`になっているかはコード内に`console.log(%HasFastProperties(obj))`を仕込んでnodeのオプションに`--allow-natives-syntax`を指定してやればいいらしい。


### プロトタイプチェインで定義されたオブジェクトがenumerableなプロパティを持っている

```javascript
Object.prototype.fn = function() {};
```

プロトタイプチェインで追加した値は`for-in`文を含んでしまうらしい。

`Object.defineProperty`を使えばそれは避けられるらしい。慣れていないと難しい話だ。

### 配列のインデクスを持っている
これは結構やりがちかもしれない

```javascript
function iteratesOverArray() {
  var arr = [1, 2, 3];
  for (var index in arr) {

  }
}
```

そもそも`for-in`は`for`より遅いらしい。なおかつ`for-in`を含む関数は含んでいるというそれだけで関数全体の最適化がなされない。

これらの問題に対する処置としてキー名のリストを作ってしまえということだ。

```javascript
function inheritedKeys(obj) {
  var ret = [];
  for(var key in obj) {
      ret.push(key);
  }
  return ret;
}
```

まじかよ


# 無限ループと曖昧な脱出の条件
必ず一回はループを通るなら`do-while`使おう。あとはまあロジックを踏まえて適切にexit仕掛けようね。ということらしい。

現場からは以上です。</description><author>mtwtkman</author><pubDate>Sat, 19 Mar 2016 21:52:40 GMT</pubDate></item><item><title>Gyazo APIのクライアントを雑に作った</title><link>http://mtwtkman.github.io/#/blog/article/2016/03/13/pyazo</link><description>Gyazo APIが非常にシンプルなため本当にシンプルな面白みのない実装になりました。

[pypi](https://pypi.python.org/pypi/pyazo)

[github](https://github.com/mtwtkman/pyazo)

pyazoって名前は別言語でかぶってたりしてアレ感ある。

ところでこういう外部のAPIのテストってどうしたらいいんじゃろ</description><author>mtwtkman</author><pubDate>Sun, 13 Mar 2016 09:19:21 GMT</pubDate></item><item><title>pythonの__new__とかtypeなど</title><link>http://mtwtkman.github.io/#/blog/article/2016/02/26/expert-python-chapter3</link><description>pythonコードの読み書き練習のために便利ツールの[percol](https://github.com/mooz/percol)のリファクタリングを始めました。

`percol.finder`という文字列検索処理をしてるっぽいモジュールでメタクラスが使われていたのでメタクラスについてエキパイを読み直しました。

つっても、`percol.finder.Finder`クラスは[ただの抽象基底クラスというだけっぽい。](https://github.com/mooz/percol/blob/master/percol/finder.py#L11-L37)

メタプログラミングなんて高度なことをする場面は中々ないと思うけど、とりあえず`__new__`と`type()`について忘れたくないのでメモ。

```
$ python -V
Python 3.5.0
```

# \_\_new\_\_
`__new__`はインスタンスを作成しようとする時に毎回実行される。エキパイ的には`meta-constructor`と説明されている。

```python
class C(object):
  def __new__(cls, *args, **kwargs):
      print('args: {}'.format(args))
      print('kargs: {}'.format(kwargs))
      print('__new__ called.')
      ins = object.__new__(cls)
      print('created instance')
      ins.hoge = 'hoge'
      return ins

  def __init__(self, arg):
      print('__init__ called.')
      self._fuga = arg

  @property
  def fuga(self):
      return self._fuga + self.hoge


print(C('fuga').fuga)
# args: ('fuga',)
# kargs: {}
# __new__ called.
# created instance
# __init__ called.
# fugahoge
```

`__new__`はクラスオブジェクトを引数にとって必ずインスタンスを返さなくてはいけない。つまり、インスタンスを作成する前にクラスオブジェクトを煮るなる焼くなり自由にいじり倒すことができるわけだ。

で、この`C`クラスを継承した場合、子クラスから親クラスの`__init__()`を呼び出すには`super()`をしないといけない。

```pytyhon
class C(object):
    def __new__(cls, *args, **kwargs):
        print('C.__new__ called.')
        return object.__new__(cls)

    def __init__(self):
        print('C.__init__ called.')


class D(C):
    def __init__(self):
        print('D.__init__() called')


class E(C):
    def __init__(self):
        super().__init__()
        print('E.__init__() called')


print(D())
# C.__new__ called.
# D.__init__() called
# &lt;__main__.D object at 0x104616f28&gt;

print(E())
# C.__new__ called.
# C.__init__ called.
# E.__init__() called
# &lt;__main__.E object at 0x104616f98&gt;
```

なるほど。

# metaclassとtype
`metaclass`はクラスのコンストラクタに渡すキーワード引数になる。python2では`__metaclass__`というクラス属性。

`metaclass`は`type()`と同じ形式の引数を取る関数が指定する。

```python
def mymetaclass(cls, base, _dict):
  if '__cat__' in _dict:
      _dict['__cat__'] = \
          'oh! my {}'.format(_dict.get('__cat__', ''))
  return type(cls, base, _dict)


class A(object, metaclass=mymetaclass):
    __cat__ = 'neko'


print(a.__cat__)
# oh! my neko
```

全く実用的な例ではないけど、クラスの属性を自由に操作できる。というか、`type()`に渡す基底クラスを変えてしまえば自由にクラスオブジェクトを変更できてしまう。

エキパイにも

&gt;For changing the read-write attributes or adding new ones, metaclasses can be avoided for simpler solutions, based on dynamic changes over the class instance.

というふうに書いてあるし、そう気軽に使っていいものではないことがわかる。(というか、使えないだろう。)

で、エキパイのこのチャプタの最後にクラスを拡張するパッチの実装があるのでほぼ丸コピ。

```python
def enhancer_1(cls):
  cls.contracted_name = ''.join(
      l for l in cls.__name__ if l.isupper()
  )


def enhancer_2(cls):
    def logger(func):
        def wrapper(*args, **kwargs):
            print('logging!')
            return func(*args, **kwargs)
        return wrapper
    for el in dir(cls):
        if el.startswith('_'):
            continue
        v = getattr(cls, el)
        if not hasattr(v, '__func__'):
            continue
        setattr(cls, el, logger(v))


def enhance(cls, *enhancers):
    for e in enhancers:
        e(cls)


class ThisIsMyClass(object):
    def hi(self):
        return 'hi'


enhance(ThisIsMyClass, enhancer_1, enhancer_2)
ins = ThisIsMyClass()
assert ins.hi() == 'hi'
assert ins.__class__.contracted_name == 'TIMC'
```

なお、メタプログラミングを使うべき時が来、適切に使える時が来るのかガチ不明。</description><author>mtwtkman</author><pubDate>Fri, 26 Feb 2016 12:32:48 GMT</pubDate></item><item><title>github pagesの構成を変えた</title><link>http://mtwtkman.github.io/#/blog/article/2016/02/21/mithrilify</link><description>引越しをした時は、pythonで記事データになるyamlファイルをビルドしてhtmlをした後にindex.htmlにリンクを載せるという方法を取っていました。

このやり方でも問題はないんですが、yamlとhtmlが重複してしまいなんともいけてない感じがしたので、yamlをjsで読み取る方法にしました。

どうせgithubがストレージなんだし記事の目録を作ってやってjsでyamlファイルをパースしてやればええがなという動機です。SPAの利です。

jsのフレームワークはなんとなく好きなmithrilを使って組んでいます。ブログみたいな単純なものならちょろっと書けるので最高。

でも結局は、目録を作るというのに変わっただけで記事を新規作成ないし削除をしたら目録を更新しないといけません。circleciとか使ってうまくできないか調べよう。

ところで、webpackのloaderは本当に最高で何も考えずにただただ`yaml-loader`を使えば全てが丸く収まるのでもうwebpackから抜け出せなくなりました。

ガンガン使っていきましょう。</description><author>mtwtkman</author><pubDate>Sun, 21 Feb 2016 18:38:37 GMT</pubDate></item><item><title>github pagesに引越し</title><link>http://mtwtkman.github.io/#/blog/article/2016/02/14/moved-to-gh-page</link><description>jekyllとか色々覚えることが多そうなのでpythonで必要最低限のhtmlのジェネレータを作ってgithub pagesにお引越ししてみました。

記事の情報はyamlで管理して、そいつをパースしてhtmlに吐き出すという感じにしてるのですが、自分しか使わないしかなり雑。

記事の情報管理をyamlでやるのはすごくいいということがわかってきました。

yamlは
```yaml
title: github pagesに引越し
slug: moved_to_gh_page
utime: 1455438723
date: 2016/02/14 17:32:03
tags:
  - タグ
active: true
body: |-
  ほにゃらら
```

という構成にしていて、こいつをpythonのPyYamlで読み込んだ結果をjinja2で書いたテンプレートにrenderしてやるようにしています。

面倒なのが、リポジトリのトップにあるindex.htmlへ記事の追加を反映しなくてはいけないので都度ビルドコマンドを叩くようにしています。

この辺はいちいちコマンドを叩かずに変更を監視して自動でビルドするようにしたいなぁと。

まあとにかくブログに特化するというのであればgithub pagesでもイケそうな気がする。</description><author>mtwtkman</author><pubDate>Sun, 14 Feb 2016 17:32:03 GMT</pubDate></item></channel></rss>